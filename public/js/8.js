(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "./node_modules/@material-ui/core/esm/Fab/Fab.js":
/*!*******************************************************!*\
  !*** ./node_modules/@material-ui/core/esm/Fab/Fab.js ***!
  \*******************************************************/
/*! exports provided: styles, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "styles", function() { return styles; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutProperties */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _styles_withStyles__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/withStyles */ "./node_modules/@material-ui/core/esm/styles/withStyles.js");
/* harmony import */ var _ButtonBase__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../ButtonBase */ "./node_modules/@material-ui/core/esm/ButtonBase/index.js");
/* harmony import */ var _utils_capitalize__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/capitalize */ "./node_modules/@material-ui/core/esm/utils/capitalize.js");








var styles = function styles(theme) {
  return {
    /* Styles applied to the root element. */
    root: Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, theme.typography.button, {
      boxSizing: 'border-box',
      minHeight: 36,
      transition: theme.transitions.create(['background-color', 'box-shadow', 'border'], {
        duration: theme.transitions.duration.short
      }),
      borderRadius: '50%',
      padding: 0,
      minWidth: 0,
      width: 56,
      height: 56,
      boxShadow: theme.shadows[6],
      '&:active': {
        boxShadow: theme.shadows[12]
      },
      color: theme.palette.getContrastText(theme.palette.grey[300]),
      backgroundColor: theme.palette.grey[300],
      '&:hover': {
        backgroundColor: theme.palette.grey.A100,
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: theme.palette.grey[300]
        },
        '&$disabled': {
          backgroundColor: theme.palette.action.disabledBackground
        },
        textDecoration: 'none'
      },
      '&$focusVisible': {
        boxShadow: theme.shadows[6]
      },
      '&$disabled': {
        color: theme.palette.action.disabled,
        boxShadow: theme.shadows[0],
        backgroundColor: theme.palette.action.disabledBackground
      }
    }),

    /* Styles applied to the span element that wraps the children. */
    label: {
      width: '100%',
      // assure the correct width for iOS Safari
      display: 'inherit',
      alignItems: 'inherit',
      justifyContent: 'inherit'
    },

    /* Styles applied to the root element if `color="primary"`. */
    primary: {
      color: theme.palette.primary.contrastText,
      backgroundColor: theme.palette.primary.main,
      '&:hover': {
        backgroundColor: theme.palette.primary.dark,
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: theme.palette.primary.main
        }
      }
    },

    /* Styles applied to the root element if `color="secondary"`. */
    secondary: {
      color: theme.palette.secondary.contrastText,
      backgroundColor: theme.palette.secondary.main,
      '&:hover': {
        backgroundColor: theme.palette.secondary.dark,
        // Reset on touch devices, it doesn't add specificity
        '@media (hover: none)': {
          backgroundColor: theme.palette.secondary.main
        }
      }
    },

    /* Styles applied to the root element if `variant="extended"`. */
    extended: {
      borderRadius: 48 / 2,
      padding: '0 16px',
      width: 'auto',
      minHeight: 'auto',
      minWidth: 48,
      height: 48,
      '&$sizeSmall': {
        width: 'auto',
        padding: '0 8px',
        borderRadius: 34 / 2,
        minWidth: 34,
        height: 34
      },
      '&$sizeMedium': {
        width: 'auto',
        padding: '0 16px',
        borderRadius: 40 / 2,
        minWidth: 40,
        height: 40
      }
    },

    /* Pseudo-class applied to the ButtonBase root element if the button is keyboard focused. */
    focusVisible: {},

    /* Pseudo-class applied to the root element if `disabled={true}`. */
    disabled: {},

    /* Styles applied to the root element if `color="inherit"`. */
    colorInherit: {
      color: 'inherit'
    },

    /* Styles applied to the root element if `size="small"``. */
    sizeSmall: {
      width: 40,
      height: 40
    },

    /* Styles applied to the root element if `size="medium"``. */
    sizeMedium: {
      width: 48,
      height: 48
    }
  };
};
var Fab = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__["forwardRef"](function Fab(props, ref) {
  var children = props.children,
      classes = props.classes,
      className = props.className,
      _props$color = props.color,
      color = _props$color === void 0 ? 'default' : _props$color,
      _props$component = props.component,
      component = _props$component === void 0 ? 'button' : _props$component,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$disableFocusRi = props.disableFocusRipple,
      disableFocusRipple = _props$disableFocusRi === void 0 ? false : _props$disableFocusRi,
      focusVisibleClassName = props.focusVisibleClassName,
      _props$size = props.size,
      size = _props$size === void 0 ? 'large' : _props$size,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? 'round' : _props$variant,
      other = Object(_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__["default"])(props, ["children", "classes", "className", "color", "component", "disabled", "disableFocusRipple", "focusVisibleClassName", "size", "variant"]);

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__["createElement"](_ButtonBase__WEBPACK_IMPORTED_MODULE_6__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    className: Object(clsx__WEBPACK_IMPORTED_MODULE_4__["default"])(classes.root, className, variant !== "round" && classes.extended, size !== 'large' && classes["size".concat(Object(_utils_capitalize__WEBPACK_IMPORTED_MODULE_7__["default"])(size))], disabled && classes.disabled, {
      'primary': classes.primary,
      'secondary': classes.secondary,
      'inherit': classes.colorInherit
    }[color]),
    component: component,
    disabled: disabled,
    focusRipple: !disableFocusRipple,
    focusVisibleClassName: Object(clsx__WEBPACK_IMPORTED_MODULE_4__["default"])(classes.focusVisible, focusVisibleClassName),
    ref: ref
  }, other), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__["createElement"]("span", {
    className: classes.label
  }, children));
});
 true ? Fab.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------

  /**
   * The content of the button.
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a
  /* @typescript-to-proptypes-ignore */
  .node.isRequired,

  /**
   * Override or extend the styles applied to the component.
   * See [CSS API](#css) below for more details.
   */
  classes: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,

  /**
   * @ignore
   */
  className: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

  /**
   * The color of the component. It supports those theme colors that make sense for this component.
   */
  color: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(['default', 'inherit', 'primary', 'secondary']),

  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a
  /* @typescript-to-proptypes-ignore */
  .elementType,

  /**
   * If `true`, the button will be disabled.
   */
  disabled: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

  /**
   * If `true`, the  keyboard focus ripple will be disabled.
   */
  disableFocusRipple: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

  /**
   * If `true`, the ripple effect will be disabled.
   */
  disableRipple: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,

  /**
   * @ignore
   */
  focusVisibleClassName: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

  /**
   * The URL to link to when the button is clicked.
   * If defined, an `a` element will be used as the root node.
   */
  href: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,

  /**
   * The size of the button.
   * `small` is equivalent to the dense button styling.
   */
  size: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(['large', 'medium', 'small']),

  /**
   * The variant to use.
   */
  variant: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf(['extended', 'round'])
} : undefined;
/* harmony default export */ __webpack_exports__["default"] = (Object(_styles_withStyles__WEBPACK_IMPORTED_MODULE_5__["default"])(styles, {
  name: 'MuiFab'
})(Fab));

/***/ }),

/***/ "./node_modules/@material-ui/core/esm/Fab/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@material-ui/core/esm/Fab/index.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Fab__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fab */ "./node_modules/@material-ui/core/esm/Fab/Fab.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _Fab__WEBPACK_IMPORTED_MODULE_0__["default"]; });



/***/ }),

/***/ "./node_modules/@material-ui/icons/AccountBalanceOutlined.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@material-ui/icons/AccountBalanceOutlined.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var React = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _createSvgIcon = _interopRequireDefault(__webpack_require__(/*! ./utils/createSvgIcon */ "./node_modules/@material-ui/icons/utils/createSvgIcon.js"));

var _default = (0, _createSvgIcon.default)( /*#__PURE__*/React.createElement("path", {
  d: "M6.5 10h-2v7h2v-7zm6 0h-2v7h2v-7zm8.5 9H2v2h19v-2zm-2.5-9h-2v7h2v-7zm-7-6.74L16.71 6H6.29l5.21-2.74m0-2.26L2 6v2h19V6l-9.5-5z"
}), 'AccountBalanceOutlined');

exports.default = _default;

/***/ }),

/***/ "./node_modules/bizcharts/umd/BizCharts.js":
/*!*************************************************!*\
  !*** ./node_modules/bizcharts/umd/BizCharts.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! react */ "./node_modules/react/index.js"), __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));
	else {}
})(window, function(__WEBPACK_EXTERNAL_MODULE__3__, __WEBPACK_EXTERNAL_MODULE__594__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 613);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "contains", {
  enumerable: true,
  get: function get() {
    return _contains.default;
  }
});
Object.defineProperty(exports, "includes", {
  enumerable: true,
  get: function get() {
    return _contains.default;
  }
});
Object.defineProperty(exports, "difference", {
  enumerable: true,
  get: function get() {
    return _difference.default;
  }
});
Object.defineProperty(exports, "find", {
  enumerable: true,
  get: function get() {
    return _find.default;
  }
});
Object.defineProperty(exports, "findIndex", {
  enumerable: true,
  get: function get() {
    return _findIndex.default;
  }
});
Object.defineProperty(exports, "firstValue", {
  enumerable: true,
  get: function get() {
    return _firstValue.default;
  }
});
Object.defineProperty(exports, "flatten", {
  enumerable: true,
  get: function get() {
    return _flatten.default;
  }
});
Object.defineProperty(exports, "flattenDeep", {
  enumerable: true,
  get: function get() {
    return _flattenDeep.default;
  }
});
Object.defineProperty(exports, "getRange", {
  enumerable: true,
  get: function get() {
    return _getRange.default;
  }
});
Object.defineProperty(exports, "pull", {
  enumerable: true,
  get: function get() {
    return _pull.default;
  }
});
Object.defineProperty(exports, "pullAt", {
  enumerable: true,
  get: function get() {
    return _pullAt.default;
  }
});
Object.defineProperty(exports, "reduce", {
  enumerable: true,
  get: function get() {
    return _reduce.default;
  }
});
Object.defineProperty(exports, "remove", {
  enumerable: true,
  get: function get() {
    return _remove.default;
  }
});
Object.defineProperty(exports, "sortBy", {
  enumerable: true,
  get: function get() {
    return _sortBy.default;
  }
});
Object.defineProperty(exports, "union", {
  enumerable: true,
  get: function get() {
    return _union.default;
  }
});
Object.defineProperty(exports, "uniq", {
  enumerable: true,
  get: function get() {
    return _uniq.default;
  }
});
Object.defineProperty(exports, "valuesOfKey", {
  enumerable: true,
  get: function get() {
    return _valuesOfKey.default;
  }
});
Object.defineProperty(exports, "head", {
  enumerable: true,
  get: function get() {
    return _head.default;
  }
});
Object.defineProperty(exports, "last", {
  enumerable: true,
  get: function get() {
    return _last.default;
  }
});
Object.defineProperty(exports, "startsWith", {
  enumerable: true,
  get: function get() {
    return _startsWith.default;
  }
});
Object.defineProperty(exports, "endsWith", {
  enumerable: true,
  get: function get() {
    return _endsWith.default;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function get() {
    return _filter.default;
  }
});
Object.defineProperty(exports, "every", {
  enumerable: true,
  get: function get() {
    return _every.default;
  }
});
Object.defineProperty(exports, "some", {
  enumerable: true,
  get: function get() {
    return _some.default;
  }
});
Object.defineProperty(exports, "group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "groupBy", {
  enumerable: true,
  get: function get() {
    return _groupBy.default;
  }
});
Object.defineProperty(exports, "groupToMap", {
  enumerable: true,
  get: function get() {
    return _groupToMap.default;
  }
});
Object.defineProperty(exports, "getWrapBehavior", {
  enumerable: true,
  get: function get() {
    return _getWrapBehavior.default;
  }
});
Object.defineProperty(exports, "wrapBehavior", {
  enumerable: true,
  get: function get() {
    return _wrapBehavior.default;
  }
});
Object.defineProperty(exports, "number2color", {
  enumerable: true,
  get: function get() {
    return _number2color.default;
  }
});
Object.defineProperty(exports, "parseRadius", {
  enumerable: true,
  get: function get() {
    return _parseRadius.default;
  }
});
Object.defineProperty(exports, "clamp", {
  enumerable: true,
  get: function get() {
    return _clamp.default;
  }
});
Object.defineProperty(exports, "fixedBase", {
  enumerable: true,
  get: function get() {
    return _fixedBase.default;
  }
});
Object.defineProperty(exports, "isDecimal", {
  enumerable: true,
  get: function get() {
    return _isDecimal.default;
  }
});
Object.defineProperty(exports, "isEven", {
  enumerable: true,
  get: function get() {
    return _isEven.default;
  }
});
Object.defineProperty(exports, "isInteger", {
  enumerable: true,
  get: function get() {
    return _isInteger.default;
  }
});
Object.defineProperty(exports, "isNegative", {
  enumerable: true,
  get: function get() {
    return _isNegative.default;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return _isNumberEqual.default;
  }
});
Object.defineProperty(exports, "isOdd", {
  enumerable: true,
  get: function get() {
    return _isOdd.default;
  }
});
Object.defineProperty(exports, "isPositive", {
  enumerable: true,
  get: function get() {
    return _isPositive.default;
  }
});
Object.defineProperty(exports, "maxBy", {
  enumerable: true,
  get: function get() {
    return _maxBy.default;
  }
});
Object.defineProperty(exports, "minBy", {
  enumerable: true,
  get: function get() {
    return _minBy.default;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return _mod.default;
  }
});
Object.defineProperty(exports, "toDegree", {
  enumerable: true,
  get: function get() {
    return _toDegree.default;
  }
});
Object.defineProperty(exports, "toInteger", {
  enumerable: true,
  get: function get() {
    return _toInteger.default;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return _toRadian.default;
  }
});
Object.defineProperty(exports, "forIn", {
  enumerable: true,
  get: function get() {
    return _forIn.default;
  }
});
Object.defineProperty(exports, "has", {
  enumerable: true,
  get: function get() {
    return _has.default;
  }
});
Object.defineProperty(exports, "hasKey", {
  enumerable: true,
  get: function get() {
    return _hasKey.default;
  }
});
Object.defineProperty(exports, "hasValue", {
  enumerable: true,
  get: function get() {
    return _hasValue.default;
  }
});
Object.defineProperty(exports, "keys", {
  enumerable: true,
  get: function get() {
    return _keys.default;
  }
});
Object.defineProperty(exports, "isMatch", {
  enumerable: true,
  get: function get() {
    return _isMatch.default;
  }
});
Object.defineProperty(exports, "values", {
  enumerable: true,
  get: function get() {
    return _values.default;
  }
});
Object.defineProperty(exports, "lowerCase", {
  enumerable: true,
  get: function get() {
    return _lowerCase.default;
  }
});
Object.defineProperty(exports, "lowerFirst", {
  enumerable: true,
  get: function get() {
    return _lowerFirst.default;
  }
});
Object.defineProperty(exports, "substitute", {
  enumerable: true,
  get: function get() {
    return _substitute.default;
  }
});
Object.defineProperty(exports, "upperCase", {
  enumerable: true,
  get: function get() {
    return _upperCase.default;
  }
});
Object.defineProperty(exports, "upperFirst", {
  enumerable: true,
  get: function get() {
    return _upperFirst.default;
  }
});
Object.defineProperty(exports, "getType", {
  enumerable: true,
  get: function get() {
    return _getType.default;
  }
});
Object.defineProperty(exports, "isArguments", {
  enumerable: true,
  get: function get() {
    return _isArguments.default;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _isArray.default;
  }
});
Object.defineProperty(exports, "isArrayLike", {
  enumerable: true,
  get: function get() {
    return _isArrayLike.default;
  }
});
Object.defineProperty(exports, "isBoolean", {
  enumerable: true,
  get: function get() {
    return _isBoolean.default;
  }
});
Object.defineProperty(exports, "isDate", {
  enumerable: true,
  get: function get() {
    return _isDate.default;
  }
});
Object.defineProperty(exports, "isError", {
  enumerable: true,
  get: function get() {
    return _isError.default;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _isFunction.default;
  }
});
Object.defineProperty(exports, "isFinite", {
  enumerable: true,
  get: function get() {
    return _isFinite.default;
  }
});
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _isNil.default;
  }
});
Object.defineProperty(exports, "isNull", {
  enumerable: true,
  get: function get() {
    return _isNull.default;
  }
});
Object.defineProperty(exports, "isNumber", {
  enumerable: true,
  get: function get() {
    return _isNumber.default;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function get() {
    return _isObject.default;
  }
});
Object.defineProperty(exports, "isObjectLike", {
  enumerable: true,
  get: function get() {
    return _isObjectLike.default;
  }
});
Object.defineProperty(exports, "isPlainObject", {
  enumerable: true,
  get: function get() {
    return _isPlainObject.default;
  }
});
Object.defineProperty(exports, "isPrototype", {
  enumerable: true,
  get: function get() {
    return _isPrototype.default;
  }
});
Object.defineProperty(exports, "isRegExp", {
  enumerable: true,
  get: function get() {
    return _isRegExp.default;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _isString.default;
  }
});
Object.defineProperty(exports, "isType", {
  enumerable: true,
  get: function get() {
    return _isType.default;
  }
});
Object.defineProperty(exports, "isUndefined", {
  enumerable: true,
  get: function get() {
    return _isUndefined.default;
  }
});
Object.defineProperty(exports, "isElement", {
  enumerable: true,
  get: function get() {
    return _isElement.default;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _requestAnimationFrame.default;
  }
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _clearAnimationFrame.default;
  }
});
Object.defineProperty(exports, "augment", {
  enumerable: true,
  get: function get() {
    return _augment.default;
  }
});
Object.defineProperty(exports, "clone", {
  enumerable: true,
  get: function get() {
    return _clone.default;
  }
});
Object.defineProperty(exports, "debounce", {
  enumerable: true,
  get: function get() {
    return _debounce.default;
  }
});
Object.defineProperty(exports, "memoize", {
  enumerable: true,
  get: function get() {
    return _memoize.default;
  }
});
Object.defineProperty(exports, "deepMix", {
  enumerable: true,
  get: function get() {
    return _deepMix.default;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _each.default;
  }
});
Object.defineProperty(exports, "extend", {
  enumerable: true,
  get: function get() {
    return _extend.default;
  }
});
Object.defineProperty(exports, "indexOf", {
  enumerable: true,
  get: function get() {
    return _indexOf.default;
  }
});
Object.defineProperty(exports, "isEmpty", {
  enumerable: true,
  get: function get() {
    return _isEmpty.default;
  }
});
Object.defineProperty(exports, "isEqual", {
  enumerable: true,
  get: function get() {
    return _isEqual.default;
  }
});
Object.defineProperty(exports, "isEqualWith", {
  enumerable: true,
  get: function get() {
    return _isEqualWith.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function get() {
    return _map.default;
  }
});
Object.defineProperty(exports, "mapValues", {
  enumerable: true,
  get: function get() {
    return _mapValues.default;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function get() {
    return _mix.default;
  }
});
Object.defineProperty(exports, "assign", {
  enumerable: true,
  get: function get() {
    return _mix.default;
  }
});
Object.defineProperty(exports, "get", {
  enumerable: true,
  get: function get() {
    return _get.default;
  }
});
Object.defineProperty(exports, "set", {
  enumerable: true,
  get: function get() {
    return _set.default;
  }
});
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return _pick.default;
  }
});
Object.defineProperty(exports, "throttle", {
  enumerable: true,
  get: function get() {
    return _throttle.default;
  }
});
Object.defineProperty(exports, "toArray", {
  enumerable: true,
  get: function get() {
    return _toArray.default;
  }
});
Object.defineProperty(exports, "toString", {
  enumerable: true,
  get: function get() {
    return _toString.default;
  }
});
Object.defineProperty(exports, "uniqueId", {
  enumerable: true,
  get: function get() {
    return _uniqueId.default;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function get() {
    return _noop.default;
  }
});
Object.defineProperty(exports, "identity", {
  enumerable: true,
  get: function get() {
    return _identity.default;
  }
});
Object.defineProperty(exports, "size", {
  enumerable: true,
  get: function get() {
    return _size.default;
  }
});
Object.defineProperty(exports, "Cache", {
  enumerable: true,
  get: function get() {
    return _cache.default;
  }
});

var _contains = _interopRequireDefault(__webpack_require__(174));

var _difference = _interopRequireDefault(__webpack_require__(621));

var _find = _interopRequireDefault(__webpack_require__(622));

var _findIndex = _interopRequireDefault(__webpack_require__(623));

var _firstValue = _interopRequireDefault(__webpack_require__(624));

var _flatten = _interopRequireDefault(__webpack_require__(625));

var _flattenDeep = _interopRequireDefault(__webpack_require__(626));

var _getRange = _interopRequireDefault(__webpack_require__(627));

var _pull = _interopRequireDefault(__webpack_require__(628));

var _pullAt = _interopRequireDefault(__webpack_require__(366));

var _reduce = _interopRequireDefault(__webpack_require__(629));

var _remove = _interopRequireDefault(__webpack_require__(630));

var _sortBy = _interopRequireDefault(__webpack_require__(631));

var _union = _interopRequireDefault(__webpack_require__(632));

var _uniq = _interopRequireDefault(__webpack_require__(367));

var _valuesOfKey = _interopRequireDefault(__webpack_require__(633));

var _head = _interopRequireDefault(__webpack_require__(634));

var _last = _interopRequireDefault(__webpack_require__(635));

var _startsWith = _interopRequireDefault(__webpack_require__(636));

var _endsWith = _interopRequireDefault(__webpack_require__(637));

var _filter = _interopRequireDefault(__webpack_require__(363));

var _every = _interopRequireDefault(__webpack_require__(638));

var _some = _interopRequireDefault(__webpack_require__(639));

var _group = _interopRequireDefault(__webpack_require__(640));

var _groupBy = _interopRequireDefault(__webpack_require__(369));

var _groupToMap = _interopRequireDefault(__webpack_require__(368));

var _getWrapBehavior = _interopRequireDefault(__webpack_require__(641));

var _wrapBehavior = _interopRequireDefault(__webpack_require__(642));

var _number2color = _interopRequireDefault(__webpack_require__(643));

var _parseRadius = _interopRequireDefault(__webpack_require__(644));

var _clamp = _interopRequireDefault(__webpack_require__(645));

var _fixedBase = _interopRequireDefault(__webpack_require__(646));

var _isDecimal = _interopRequireDefault(__webpack_require__(647));

var _isEven = _interopRequireDefault(__webpack_require__(648));

var _isInteger = _interopRequireDefault(__webpack_require__(649));

var _isNegative = _interopRequireDefault(__webpack_require__(650));

var _isNumberEqual = _interopRequireDefault(__webpack_require__(651));

var _isOdd = _interopRequireDefault(__webpack_require__(652));

var _isPositive = _interopRequireDefault(__webpack_require__(653));

var _maxBy = _interopRequireDefault(__webpack_require__(654));

var _minBy = _interopRequireDefault(__webpack_require__(655));

var _mod = _interopRequireDefault(__webpack_require__(656));

var _toDegree = _interopRequireDefault(__webpack_require__(657));

var _toInteger = _interopRequireDefault(__webpack_require__(658));

var _toRadian = _interopRequireDefault(__webpack_require__(659));

var _forIn = _interopRequireDefault(__webpack_require__(660));

var _has = _interopRequireDefault(__webpack_require__(370));

var _hasKey = _interopRequireDefault(__webpack_require__(661));

var _hasValue = _interopRequireDefault(__webpack_require__(662));

var _keys = _interopRequireDefault(__webpack_require__(365));

var _isMatch = _interopRequireDefault(__webpack_require__(364));

var _values = _interopRequireDefault(__webpack_require__(371));

var _lowerCase = _interopRequireDefault(__webpack_require__(663));

var _lowerFirst = _interopRequireDefault(__webpack_require__(664));

var _substitute = _interopRequireDefault(__webpack_require__(665));

var _upperCase = _interopRequireDefault(__webpack_require__(666));

var _upperFirst = _interopRequireDefault(__webpack_require__(667));

var _getType = _interopRequireDefault(__webpack_require__(372));

var _isArguments = _interopRequireDefault(__webpack_require__(668));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var _isBoolean = _interopRequireDefault(__webpack_require__(669));

var _isDate = _interopRequireDefault(__webpack_require__(670));

var _isError = _interopRequireDefault(__webpack_require__(671));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var _isFinite = _interopRequireDefault(__webpack_require__(672));

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _isNull = _interopRequireDefault(__webpack_require__(673));

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var _isObject = _interopRequireDefault(__webpack_require__(175));

var _isObjectLike = _interopRequireDefault(__webpack_require__(236));

var _isPlainObject = _interopRequireDefault(__webpack_require__(137));

var _isPrototype = _interopRequireDefault(__webpack_require__(373));

var _isRegExp = _interopRequireDefault(__webpack_require__(674));

var _isString = _interopRequireDefault(__webpack_require__(101));

var _isType = _interopRequireDefault(__webpack_require__(67));

var _isUndefined = _interopRequireDefault(__webpack_require__(675));

var _isElement = _interopRequireDefault(__webpack_require__(676));

var _requestAnimationFrame = _interopRequireDefault(__webpack_require__(677));

var _clearAnimationFrame = _interopRequireDefault(__webpack_require__(678));

var _augment = _interopRequireDefault(__webpack_require__(679));

var _clone = _interopRequireDefault(__webpack_require__(680));

var _debounce = _interopRequireDefault(__webpack_require__(681));

var _memoize = _interopRequireDefault(__webpack_require__(682));

var _deepMix = _interopRequireDefault(__webpack_require__(683));

var _each = _interopRequireDefault(__webpack_require__(84));

var _extend = _interopRequireDefault(__webpack_require__(684));

var _indexOf = _interopRequireDefault(__webpack_require__(685));

var _isEmpty = _interopRequireDefault(__webpack_require__(686));

var _isEqual = _interopRequireDefault(__webpack_require__(374));

var _isEqualWith = _interopRequireDefault(__webpack_require__(687));

var _map = _interopRequireDefault(__webpack_require__(688));

var _mapValues = _interopRequireDefault(__webpack_require__(689));

var _mix = _interopRequireDefault(__webpack_require__(237));

var _get = _interopRequireDefault(__webpack_require__(690));

var _set = _interopRequireDefault(__webpack_require__(691));

var _pick = _interopRequireDefault(__webpack_require__(692));

var _throttle = _interopRequireDefault(__webpack_require__(693));

var _toArray = _interopRequireDefault(__webpack_require__(694));

var _toString = _interopRequireDefault(__webpack_require__(138));

var _uniqueId = _interopRequireDefault(__webpack_require__(695));

var _noop = _interopRequireDefault(__webpack_require__(696));

var _identity = _interopRequireDefault(__webpack_require__(697));

var _size = _interopRequireDefault(__webpack_require__(698));

var _cache = _interopRequireDefault(__webpack_require__(699));

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__spreadArray = __spreadArray;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__createBinding = exports.__assign = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  exports.__assign = _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};

exports.__assign = _assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

var __createBinding = Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
};

exports.__createBinding = __createBinding;

function __exportStar(m, o) {
  for (var p in m) {
    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
/** @deprecated */


function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
}
/** @deprecated */


function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
}

function __spreadArray(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) {
    to[j] = from[i];
  }

  return to;
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

var __setModuleDefault = Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defineProperties = __webpack_require__(354);

var callBind = __webpack_require__(357);

var implementation = __webpack_require__(361);

var getPolyfill = __webpack_require__(362);

var shim = __webpack_require__(620);

var polyfill = callBind.apply(getPolyfill()); // eslint-disable-next-line no-unused-vars

var bound = function assign(target, source1) {
  return polyfill(Object, arguments);
};

defineProperties(bound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = bound;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony import */ var _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/* harmony import */ var _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(590);
/* harmony import */ var _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _extend_scale_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1278);
/* harmony import */ var _animations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(906);
/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(445);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createThemeByStyleSheet", function() { return _theme__WEBPACK_IMPORTED_MODULE_5__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "antvLight", function() { return _theme__WEBPACK_IMPORTED_MODULE_5__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "antvDark", function() { return _theme__WEBPACK_IMPORTED_MODULE_5__["a"]; });

/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__) if(["default","VERSION","setDefaultErrorFallback","createThemeByStyleSheet","antvLight","antvDark"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _boundary_ErrorBoundary__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(65);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDefaultErrorFallback", function() { return _boundary_ErrorBoundary__WEBPACK_IMPORTED_MODULE_6__["c"]; });

//  G 



 // 

 // 


Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerEngine"])('canvas', _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerEngine"])('svg', _antv_g_svg_lib__WEBPACK_IMPORTED_MODULE_1__); // @ts-ignore


var VERSION = '4.1.6'; // fixme: supportCSSTransform g2@4.1.0 
// 

var rawGetPointByClient = _antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__["Canvas"].prototype.getPointByClient;

_antv_g_canvas_lib__WEBPACK_IMPORTED_MODULE_0__["Canvas"].prototype.getPointByClient = function (clientX, clientY) {
  // 
  var raw = rawGetPointByClient.call(this, clientX, clientY); // 
  // getBoundingClientRect

  var el = this.get('el');
  var bbox = el.getBoundingClientRect();
  var setWidth = this.get('width');
  var setHeight = this.get('height');
  var realWidth = bbox.width,
      realHeight = bbox.height; //  / 

  return {
    x: raw.x / (realWidth / setWidth),
    y: raw.y / (realHeight / setHeight)
  };
}; // error fallback




/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(238);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(19);

var assertThisInitialized = __webpack_require__(375);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/slicedToArray.js
var slicedToArray = __webpack_require__(41);
var slicedToArray_default = /*#__PURE__*/__webpack_require__.n(slicedToArray);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(46);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js
var unique_id = __webpack_require__(92);
var unique_id_default = /*#__PURE__*/__webpack_require__.n(unique_id);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal.js
var is_equal = __webpack_require__(230);
var is_equal_default = /*#__PURE__*/__webpack_require__.n(is_equal);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./src/boundary/withContainer.tsx
var withContainer = __webpack_require__(132);

// EXTERNAL MODULE: ./src/boundary/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(65);

// EXTERNAL MODULE: ./src/context/root.tsx
var root = __webpack_require__(73);

// EXTERNAL MODULE: ./src/context/view.tsx
var view = __webpack_require__(49);

// EXTERNAL MODULE: ./src/utils/plotTools.ts
var plotTools = __webpack_require__(170);

// EXTERNAL MODULE: ./src/utils/shallowEqual.ts
var shallowEqual = __webpack_require__(81);

// EXTERNAL MODULE: ./src/utils/pickWithout.ts
var pickWithout = __webpack_require__(66);

// EXTERNAL MODULE: ./src/utils/cloneDeep.ts
var cloneDeep = __webpack_require__(80);

// EXTERNAL MODULE: ./src/utils/constant.ts
var constant = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/_resize-observer-polyfill@1.5.1@resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(229);
var ResizeObserver_es_default = /*#__PURE__*/__webpack_require__.n(ResizeObserver_es);

// CONCATENATED MODULE: ./src/utils/getElementSize.ts
function getElementSize(ele) {
  return {
    width: ele.clientWidth,
    height: ele.clientHeight
  };
}
// EXTERNAL MODULE: ./src/plots/core/polyfill.ts
var polyfill = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/esm/index.js
var esm = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// CONCATENATED MODULE: ./src/createPlot.tsx









function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



















var DEFAULT_PLACEHOLDER = /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
  style: {
    position: 'absolute',
    top: '48%',
    left: '50%',
    color: '#aaa',
    textAlign: 'center'
  }
}, "\u6682\u65E0\u6570\u636E");
var DESCRIPTION_STYLE = {
  padding: '8px 24px 10px 10px',
  fontFamily: 'PingFang SC',
  fontSize: 12,
  color: 'grey',
  textAlign: 'left',
  lineHeight: '16px'
};
var TITLE_STYLE = {
  padding: '10px 0 0 10px',
  fontFamily: 'PingFang SC',
  fontSize: 18,
  color: 'black',
  textAlign: 'left',
  lineHeight: '20px'
};

var createPlot_BasePlot = /*#__PURE__*/function (_React$Component) {
  inherits_default()(BasePlot, _React$Component);

  var _super = _createSuper(BasePlot);

  function BasePlot() {
    var _this;

    classCallCheck_default()(this, BasePlot);

    _this = _super.apply(this, arguments);
    _this._context = {
      chart: null
    };
    return _this;
  }

  createClass_default()(BasePlot, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.children && this.g2Instance.chart) {
        this.g2Instance.chart.render();
      }

      Object(polyfill["b" /* polyfillEvents */])(this.g2Instance, {}, this.props);
      this.g2Instance.data = this.props.data;
      this.preConfig = Object(pickWithout["a" /* default */])(this.props, [].concat(toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]), ['container', 'PlotClass', 'onGetG2Instance', 'data']));
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (this.props.children && this.g2Instance.chart) {
        this.g2Instance.chart.render();
      } // 1.0 events


      Object(polyfill["b" /* polyfillEvents */])(this.g2Instance, prevProps, this.props);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this2 = this;

      if (this.g2Instance) {
        setTimeout(function () {
          _this2.g2Instance.destroy();

          _this2.g2Instance = null;
          _this2._context.chart = null;
        }, 0);
      }
    }
  }, {
    key: "getG2Instance",
    value: function getG2Instance() {
      return this.g2Instance;
    }
  }, {
    key: "getChartView",
    value: function getChartView() {
      return this.g2Instance.chart;
    }
  }, {
    key: "checkInstanceReady",
    value: function checkInstanceReady() {
      if (!this.g2Instance) {
        this.initInstance();
        this.g2Instance.render();
      } else if (this.shouldReCreate()) {
        // 
        this.g2Instance.destroy();
        this.initInstance();
        this.g2Instance.render();
      } else if (this.diffConfig()) {
        var options = Object(pickWithout["a" /* default */])(this.props, ['container', 'PlotClass', 'onGetG2Instance', 'children']);
        this.g2Instance.update(options);
      } else if (this.diffData()) {
        this.g2Instance.changeData(this.props.data);
      } // 


      var currentConfig = Object(pickWithout["a" /* default */])(this.props, [].concat(toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]), ['container', 'PlotClass', 'onGetG2Instance', 'data']));
      this.preConfig = Object(cloneDeep["a" /* default */])(currentConfig);
      this.g2Instance.data = this.props.data;
    }
  }, {
    key: "initInstance",
    value: function initInstance() {
      var _a = this.props,
          container = _a.container,
          PlotClass = _a.PlotClass,
          onGetG2Instance = _a.onGetG2Instance,
          children = _a.children,
          options = __rest(_a, ["container", "PlotClass", "onGetG2Instance", "children"]);

      this.g2Instance = new PlotClass(container, options);
      this._context.chart = this.g2Instance;

      if (is_function_default()(onGetG2Instance)) {
        onGetG2Instance(this.g2Instance);
      }
    }
  }, {
    key: "diffConfig",
    value: function diffConfig() {
      // 
      var preConfig = this.preConfig || {};
      var currentConfig = Object(pickWithout["a" /* default */])(this.props, [].concat(toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]), ['container', 'PlotClass', 'onGetG2Instance', 'data']));
      return !is_equal_default()(preConfig, currentConfig);
    }
  }, {
    key: "diffData",
    value: function diffData() {
      // 
      var preData = this.g2Instance.data;
      var data = this.props.data;

      if (!Object(esm["isArray"])(preData) || !Object(esm["isArray"])(data)) {
        // 
        return !preData === data;
      }

      if (preData.length !== data.length) {
        return true;
      }

      var isEqual = true;
      preData.forEach(function (element, index) {
        if (!Object(shallowEqual["a" /* default */])(element, data[index])) {
          isEqual = false;
        }
      });
      return !isEqual;
    }
  }, {
    key: "shouldReCreate",
    value: function shouldReCreate() {
      var forceUpdate = this.props.forceUpdate;

      if (forceUpdate) {
        return true;
      }

      return false;
    }
  }, {
    key: "render",
    value: function render() {
      this.checkInstanceReady();
      var chartView = this.getChartView();
      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(root["a" /* default */].Provider, {
        value: this._context
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(view["a" /* default */].Provider, {
        value: chartView
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
        key: unique_id_default()('plot-chart')
      }, this.props.children)));
    }
  }]);

  return BasePlot;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

var BxPlot = Object(withContainer["a" /* default */])(createPlot_BasePlot);

function createPlot(Plot, name) {
  var transCfg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (cfg) {
    return cfg;
  };
  var Com = /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.forwardRef(function (props, ref) {
    var title = props.title,
        description = props.description,
        _props$autoFit = props.autoFit,
        autoFit = _props$autoFit === void 0 ? true : _props$autoFit,
        forceFit = props.forceFit,
        _props$errorContent = props.errorContent,
        errorContent = _props$errorContent === void 0 ? ErrorBoundary["a" /* ErrorFallback */] : _props$errorContent,
        placeholder = props.placeholder,
        ErrorBoundaryProps = props.ErrorBoundaryProps,
        cfg = __rest(props, ["title", "description", "autoFit", "forceFit", "errorContent", "placeholder", "ErrorBoundaryProps"]);

    var realCfg = transCfg(cfg);
    var container = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var titleDom = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var descDom = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();

    var _useState = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useState"])(0),
        _useState2 = slicedToArray_default()(_useState, 2),
        chartHeight = _useState2[0],
        setChartHeight = _useState2[1];

    var resizeObserver = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])();
    var resizeFn = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(function () {
      if (!container.current) {
        return;
      }

      var containerSize = getElementSize(container.current);
      var titleSize = titleDom.current ? getElementSize(titleDom.current) : {
        width: 0,
        height: 0
      };
      var descSize = descDom.current ? getElementSize(descDom.current) : {
        width: 0,
        height: 0
      };
      var ch = containerSize.height - titleSize.height - descSize.height;

      if (ch === 0) {
        // 0 
        ch = 350;
      }

      if (ch < 20) {
        // 
        ch = 20;
      } // 1


      if (Math.abs(chartHeight - ch) > 1) {
        setChartHeight(ch);
      }
    }, [container.current, titleDom.current, chartHeight, descDom.current]);
    var resize = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(Object(esm["debounce"])(resizeFn, 500), [resizeFn]);
    var FallbackComponent = /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.isValidElement(errorContent) ? function () {
      return errorContent;
    } : errorContent; // showPlaceholder value

    if (placeholder && !realCfg.data) {
      var pl = placeholder === true ? DEFAULT_PLACEHOLDER : placeholder; // plot 400px

      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" /* default */], _object_assign_4_1_2_object_assign_default()({
        FallbackComponent: FallbackComponent
      }, ErrorBoundaryProps), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
        style: {
          width: props.width || '100%',
          height: props.height || 400,
          textAlign: 'center',
          position: 'relative'
        }
      }, pl));
    }

    var titleCfg = Object(plotTools["a" /* visibleHelper */])(title, false);
    var descriptionCfg = Object(plotTools["a" /* visibleHelper */])(description, false);

    var titleStyle = _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, TITLE_STYLE), titleCfg.style);

    var descStyle = _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, DESCRIPTION_STYLE), descriptionCfg.style), {
      top: titleStyle.height
    });

    var isAutoFit = forceFit !== undefined ? forceFit : autoFit;

    if (!Object(esm["isNil"])(forceFit)) {
      warning_default()(false, 'autoFitforceFit');
    }

    ;
    Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useEffect"])(function () {
      if (!isAutoFit) {
        if (container.current) {
          resizeFn();
        }

        resizeObserver.current && resizeObserver.current.unobserve(container.current);
      } else {
        if (container.current) {
          resizeFn();
          resizeObserver.current = new ResizeObserver_es_default.a(resize);
          resizeObserver.current.observe(container.current);
        } else {
          setChartHeight(0);
        }
      }

      return function () {
        resizeObserver.current && resizeObserver.current.unobserve(container.current);
      };
    }, [container.current, isAutoFit]);
    return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" /* default */], _object_assign_4_1_2_object_assign_default()({
      FallbackComponent: FallbackComponent
    }, ErrorBoundaryProps), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
      ref: container,
      className: "bizcharts-plot",
      style: {
        position: 'relative',
        height: props.height || '100%',
        width: props.width || '100%'
      }
    }, titleCfg.visible && /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", _object_assign_4_1_2_object_assign_default()({
      ref: titleDom
    }, Object(polyfill["d" /* polyfillTitleEvent */])(realCfg), {
      className: "bizcharts-plot-title",
      style: titleStyle
    }), titleCfg.text), descriptionCfg.visible && /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", _object_assign_4_1_2_object_assign_default()({
      ref: descDom
    }, Object(polyfill["a" /* polyfillDescriptionEvent */])(realCfg), {
      className: "bizcharts-plot-description",
      style: descStyle
    }), descriptionCfg.text), !!chartHeight && /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(BxPlot // API 
    , _object_assign_4_1_2_object_assign_default()({
      // API 
      appendPadding: [10, 5, 10, 10],
      autoFit: isAutoFit,
      ref: ref
    }, realCfg, {
      PlotClass: Plot,
      containerStyle: {
        // 
        height: chartHeight
      }
    }))));
  });
  Com.displayName = name || Plot.name;
  return Com;
}

/* harmony default export */ var src_createPlot = __webpack_exports__["a"] = (createPlot);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return replaceApi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return replaceAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return polyfillVisible; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return polyfillOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return polyfillEvents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return polyfillTitleEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return polyfillDescriptionEvent; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_data_transform_sum__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(228);
/* harmony import */ var _components_Chart_events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(136);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};




 // api

var replaceApi = function replaceApi(replaceApiList, options) {
  replaceApiList.forEach(function (item) {
    var sourceKey = item.sourceKey,
        targetKey = item.targetKey,
        notice = item.notice;
    var value = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, sourceKey);

    if (value) {
      warning__WEBPACK_IMPORTED_MODULE_1___default()(false, notice);
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(options, targetKey, value);
    }
  });
};
/**
 * sourceKeytargetKey
 * angleAxisxAxis
 * @param options object 
 * @param sourceKey string
 * @param targetKey  string
 */

var replaceAxis = function replaceAxis(options) {
  var sourceKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'angleAxis';
  var targetKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'xAxis';

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(options[sourceKey])) {
    return;
  }

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".visible")) === false) {
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(options, targetKey, false);
    return;
  }

  var config = object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, options[sourceKey]);

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".line.visible")) === false) {
    config.line = null;
  }

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".grid.visible")) === false) {
    config.grid = null;
  }

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".label.visible")) === false) {
    config.label = false;
  } else {
    var label = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".label"), {});

    if (label) {
      var suffix = object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, label.suffix);

      if (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(suffix) || suffix) {
        // undefined null  suffix
        label = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, label), {
          formatter: function formatter(val) {
            return "".concat(val).concat(suffix);
          }
        });
      }

      var _label = label,
          offsetX = _label.offsetX,
          offsetY = _label.offsetY,
          offset = _label.offset,
          labelCfg = __rest(label, ["offsetX", "offsetY", "offset"]);

      if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offset) && (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetX) || !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetY))) {
        if (targetKey === 'xAxis') {
          label = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, labelCfg), {
            offset: !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetX) ? offsetX : offsetY
          });
        }

        if (targetKey === 'yAxis') {
          label = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, labelCfg), {
            offset: !Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(offsetY) ? offsetY : offsetX
          });
        }
      }

      config.label = label;
    }
  }

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".tickLine.visible")) === false) {
    config.tickLine = false;
  }

  if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, "".concat(sourceKey, ".title.visible")) === false) {
    config.title = false;
  }

  Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(options, targetKey, config);
}; // visible

var polyfillVisible = function polyfillVisible(polyfillOpt, path) {
  var vis = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, "".concat(path, ".visible"));

  if (vis === false || vis === null) {
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, path, false);
  }

  return vis;
};
var polyfillOptions = function polyfillOptions(opt) {
  var polyfillOpt = object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, opt); // tooltip


  polyfillVisible(polyfillOpt, 'tooltip'); // legend

  var legendVis = polyfillVisible(polyfillOpt, 'legend');

  if (legendVis) {
    if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.title.visible') === false) {
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.title', false);
    }
  }

  var formatter = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.formatter');

  if (formatter) {
    var itemName = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.itemName', {});
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.itemName', object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, itemName), {
      formatter: formatter
    }));
  }

  var textConfig = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'legend.text');

  if (textConfig) {
    Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'legend.itemName', textConfig);
  } // label


  polyfillVisible(polyfillOpt, 'label'); // 

  var guideLine = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'guideLine', []);
  var data = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'data', []);
  var yField = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'yField', 'y');
  guideLine.forEach(function (element) {
    if (data.length > 0) {
      var y = 'median';

      switch (element.type) {
        case 'max':
          y = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["maxBy"])(data, function (d) {
            return d[yField];
          })[yField];
          break;

        case 'mean':
          y = Object(_utils_data_transform_sum__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(data.map(function (d) {
            return d[yField];
          })) / data.length;
          break;

        default:
          // min
          y = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["minBy"])(data, function (d) {
            return d[yField];
          })[yField];
          break;
      }

      var line = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        start: ['min', y],
        end: ['max', y],
        style: element.lineStyle,
        text: {
          content: y
        }
      }, element), {
        type: 'line'
      });

      if (!Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'annotations')) {
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'annotations', []);
      }

      polyfillOpt.annotations.push(line);
      Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["set"])(polyfillOpt, 'point', false);
    }
  }); // slider

  var interactions = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(polyfillOpt, 'interactions', []);
  var slider = interactions.find(function (it) {
    return it.type === 'slider';
  });

  if (slider && Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["isNil"])(polyfillOpt.slider)) {
    polyfillOpt.slider = slider.cfg;
  }

  return polyfillOpt;
};
var polyfillEvents = function polyfillEvents(chart, preOptions, newOptions) {
  // 
  var eventNames = Object(_components_Chart_events__WEBPACK_IMPORTED_MODULE_4__[/* pickEventName */ "a"])(Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(preOptions, 'events', []));
  var newEventNames = Object(_components_Chart_events__WEBPACK_IMPORTED_MODULE_4__[/* pickEventName */ "a"])(Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(newOptions, 'events', [])); // 

  eventNames.forEach(function (ev) {
    chart.off(ev[1], preOptions.events[ev[0]]);
  }); // 

  newEventNames.forEach(function (ev) {
    chart.on(ev[1], newOptions.events[ev[0]]);
  });
};
var polyfillTitleEvent = function polyfillTitleEvent(options) {
  var events = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, 'events', {});
  var titleEvents = {};
  ['onTitleClick', 'onTitleDblClick', 'onTitleMouseleave', 'onTitleMousemove', 'onTitleMousedown', 'onTitleMouseup', 'onTitleMouseenter'].forEach(function (e) {
    if (events[e]) {
      titleEvents[e.replace('Title', '')] = events[e];
    }
  });
  return titleEvents;
};
var polyfillDescriptionEvent = function polyfillDescriptionEvent(options) {
  var events = Object(_antv_util__WEBPACK_IMPORTED_MODULE_2__["get"])(options, 'events', {});
  var titleEvents = {};
  ['onDescriptionClick', 'onDescriptionDblClick', 'onDescriptionMouseleave', 'onDescriptionMousemove', 'onDescriptionMousedown', 'onDescriptionMouseup', 'onDescriptionMouseenter'].forEach(function (e) {
    if (events[e]) {
      titleEvents[e.replace('Description', '')] = events[e];
    }
  });
  return titleEvents;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "flow", {
  enumerable: true,
  get: function get() {
    return _flow.flow;
  }
});
Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return _pick.pick;
  }
});
Object.defineProperty(exports, "template", {
  enumerable: true,
  get: function get() {
    return _template.template;
  }
});
Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return _invariant.log;
  }
});
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function get() {
    return _invariant.invariant;
  }
});
Object.defineProperty(exports, "LEVEL", {
  enumerable: true,
  get: function get() {
    return _invariant.LEVEL;
  }
});
Object.defineProperty(exports, "getContainerSize", {
  enumerable: true,
  get: function get() {
    return _dom.getContainerSize;
  }
});
Object.defineProperty(exports, "findGeometry", {
  enumerable: true,
  get: function get() {
    return _geometry.findGeometry;
  }
});
Object.defineProperty(exports, "getAllElements", {
  enumerable: true,
  get: function get() {
    return _geometry.getAllElements;
  }
});
Object.defineProperty(exports, "findViewById", {
  enumerable: true,
  get: function get() {
    return _view.findViewById;
  }
});
Object.defineProperty(exports, "transformLabel", {
  enumerable: true,
  get: function get() {
    return _label.transformLabel;
  }
});
Object.defineProperty(exports, "getSplinePath", {
  enumerable: true,
  get: function get() {
    return _path.getSplinePath;
  }
});
Object.defineProperty(exports, "deepAssign", {
  enumerable: true,
  get: function get() {
    return _deepAssign.deepAssign;
  }
});
Object.defineProperty(exports, "kebabCase", {
  enumerable: true,
  get: function get() {
    return _kebabCase.kebabCase;
  }
});
Object.defineProperty(exports, "renderStatistic", {
  enumerable: true,
  get: function get() {
    return _statistic.renderStatistic;
  }
});
Object.defineProperty(exports, "renderGaugeStatistic", {
  enumerable: true,
  get: function get() {
    return _statistic.renderGaugeStatistic;
  }
});
Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return _measureText.measureTextWidth;
  }
});

var _flow = __webpack_require__(1087);

var _pick = __webpack_require__(1088);

var _template = __webpack_require__(1089);

var _invariant = __webpack_require__(1090);

var _dom = __webpack_require__(1091);

var _geometry = __webpack_require__(1092);

var _view = __webpack_require__(514);

var _label = __webpack_require__(1093);

var _path = __webpack_require__(1094);

var _deepAssign = __webpack_require__(1095);

var _kebabCase = __webpack_require__(1096);

var _statistic = __webpack_require__(515);

var _measureText = __webpack_require__(1097);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = "production" !== 'production';

var warning = function warning() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);

    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);

    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

module.exports = warning;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = __webpack_require__(19);

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_string_1 = __webpack_require__(50);
/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param key
 * @param defaultValue
 */


exports.default = function (obj, key, defaultValue) {
  var p = 0;
  var keyArr = is_string_1.default(key) ? key.split('.') : key;

  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }

  return obj === undefined || p < keyArr.length ? defaultValue : obj;
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var flow_1 = __webpack_require__(996);

Object.defineProperty(exports, "flow", {
  enumerable: true,
  get: function get() {
    return flow_1.flow;
  }
});

var pick_1 = __webpack_require__(997);

Object.defineProperty(exports, "pick", {
  enumerable: true,
  get: function get() {
    return pick_1.pick;
  }
});

var template_1 = __webpack_require__(998);

Object.defineProperty(exports, "template", {
  enumerable: true,
  get: function get() {
    return template_1.template;
  }
});

var invariant_1 = __webpack_require__(999);

Object.defineProperty(exports, "log", {
  enumerable: true,
  get: function get() {
    return invariant_1.log;
  }
});
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function get() {
    return invariant_1.invariant;
  }
});
Object.defineProperty(exports, "LEVEL", {
  enumerable: true,
  get: function get() {
    return invariant_1.LEVEL;
  }
});

var dom_1 = __webpack_require__(1000);

Object.defineProperty(exports, "getContainerSize", {
  enumerable: true,
  get: function get() {
    return dom_1.getContainerSize;
  }
});

var geometry_1 = __webpack_require__(1001);

Object.defineProperty(exports, "findGeometry", {
  enumerable: true,
  get: function get() {
    return geometry_1.findGeometry;
  }
});
Object.defineProperty(exports, "getAllElements", {
  enumerable: true,
  get: function get() {
    return geometry_1.getAllElements;
  }
});

var view_1 = __webpack_require__(1002);

Object.defineProperty(exports, "findViewById", {
  enumerable: true,
  get: function get() {
    return view_1.findViewById;
  }
});

var label_1 = __webpack_require__(1003);

Object.defineProperty(exports, "transformLabel", {
  enumerable: true,
  get: function get() {
    return label_1.transformLabel;
  }
});

var path_1 = __webpack_require__(1004);

Object.defineProperty(exports, "getSplinePath", {
  enumerable: true,
  get: function get() {
    return path_1.getSplinePath;
  }
});

var deep_assign_1 = __webpack_require__(1005);

Object.defineProperty(exports, "deepAssign", {
  enumerable: true,
  get: function get() {
    return deep_assign_1.deepAssign;
  }
});

var kebab_case_1 = __webpack_require__(1006);

Object.defineProperty(exports, "kebabCase", {
  enumerable: true,
  get: function get() {
    return kebab_case_1.kebabCase;
  }
});

var statistic_1 = __webpack_require__(486);

Object.defineProperty(exports, "renderStatistic", {
  enumerable: true,
  get: function get() {
    return statistic_1.renderStatistic;
  }
});
Object.defineProperty(exports, "renderGaugeStatistic", {
  enumerable: true,
  get: function get() {
    return statistic_1.renderGaugeStatistic;
  }
});

var measure_text_1 = __webpack_require__(1007);

Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return measure_text_1.measureTextWidth;
  }
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1); // 


var core_1 = __webpack_require__(24);

var dark_1 = __webpack_require__(167);

var create_by_style_sheet_1 = __webpack_require__(109);

core_1.registerTheme('dark', create_by_style_sheet_1.createThemeByStyleSheet(dark_1.antvDark)); //  G 

var CanvasEngine = tslib_1.__importStar(__webpack_require__(204));

var SVGEngine = tslib_1.__importStar(__webpack_require__(315));

var core_2 = __webpack_require__(24);

core_2.registerEngine('canvas', CanvasEngine);
core_2.registerEngine('svg', SVGEngine); //  G2  geometry

var core_3 = __webpack_require__(24);

var area_1 = tslib_1.__importDefault(__webpack_require__(316));

var edge_1 = tslib_1.__importDefault(__webpack_require__(317));

var heatmap_1 = tslib_1.__importDefault(__webpack_require__(318));

var interval_1 = tslib_1.__importDefault(__webpack_require__(319));

var line_1 = tslib_1.__importDefault(__webpack_require__(320));

var path_1 = tslib_1.__importDefault(__webpack_require__(164));

var point_1 = tslib_1.__importDefault(__webpack_require__(321));

var polygon_1 = tslib_1.__importDefault(__webpack_require__(322));

var schema_1 = tslib_1.__importDefault(__webpack_require__(323));

core_3.registerGeometry('Polygon', polygon_1.default);
core_3.registerGeometry('Interval', interval_1.default);
core_3.registerGeometry('Schema', schema_1.default);
core_3.registerGeometry('Path', path_1.default);
core_3.registerGeometry('Point', point_1.default);
core_3.registerGeometry('Line', line_1.default);
core_3.registerGeometry('Area', area_1.default);
core_3.registerGeometry('Edge', edge_1.default);
core_3.registerGeometry('Heatmap', heatmap_1.default); //  shapes

__webpack_require__(945);

__webpack_require__(946);

__webpack_require__(947);

__webpack_require__(948);

__webpack_require__(949);

__webpack_require__(950);

__webpack_require__(452);

__webpack_require__(453);

__webpack_require__(454);

__webpack_require__(455);

__webpack_require__(456);

__webpack_require__(281);

__webpack_require__(457);

__webpack_require__(458);

__webpack_require__(459);

__webpack_require__(460);

__webpack_require__(461);

__webpack_require__(462); //  Geometry  label


var core_4 = __webpack_require__(24);

var base_1 = tslib_1.__importDefault(__webpack_require__(99));

var interval_2 = tslib_1.__importDefault(__webpack_require__(168));

var pie_1 = tslib_1.__importDefault(__webpack_require__(169));

var polar_1 = tslib_1.__importDefault(__webpack_require__(212));

core_4.registerGeometryLabel('base', base_1.default);
core_4.registerGeometryLabel('interval', interval_2.default);
core_4.registerGeometryLabel('pie', pie_1.default);
core_4.registerGeometryLabel('polar', polar_1.default); //  Geometry label 

var core_5 = __webpack_require__(24);

var distribute_1 = __webpack_require__(324);

var outer_1 = __webpack_require__(951);

var spider_1 = __webpack_require__(952);

var limit_in_canvas_1 = __webpack_require__(325);

var limit_in_shape_1 = __webpack_require__(326);

var overlap_1 = __webpack_require__(223);

var hide_overlap_1 = __webpack_require__(953);

var adjust_color_1 = __webpack_require__(955);

var adjust_position_1 = __webpack_require__(957);

var hide_overlap_2 = __webpack_require__(958);

var adjust_position_2 = __webpack_require__(959);

var adjust_position_3 = __webpack_require__(960);

var limit_in_plot_1 = __webpack_require__(961);

core_5.registerGeometryLabelLayout('overlap', overlap_1.overlap);
core_5.registerGeometryLabelLayout('distribute', distribute_1.distribute);
core_5.registerGeometryLabelLayout('fixed-overlap', overlap_1.fixedOverlap);
core_5.registerGeometryLabelLayout('hide-overlap', hide_overlap_1.hideOverlap);
core_5.registerGeometryLabelLayout('limit-in-shape', limit_in_shape_1.limitInShape);
core_5.registerGeometryLabelLayout('limit-in-canvas', limit_in_canvas_1.limitInCanvas);
core_5.registerGeometryLabelLayout('limit-in-plot', limit_in_plot_1.limitInPlot);
core_5.registerGeometryLabelLayout('pie-outer', outer_1.pieOuterLabelLayout);
core_5.registerGeometryLabelLayout('adjust-color', adjust_color_1.adjustColor);
core_5.registerGeometryLabelLayout('interval-adjust-position', adjust_position_1.intervalAdjustPosition);
core_5.registerGeometryLabelLayout('interval-hide-overlap', hide_overlap_2.intervalHideOverlap);
core_5.registerGeometryLabelLayout('point-adjust-position', adjust_position_2.pointAdjustPosition);
core_5.registerGeometryLabelLayout('pie-spider', spider_1.pieSpiderLabelLayout);
core_5.registerGeometryLabelLayout('path-adjust-position', adjust_position_3.pathAdjustPosition); // 

var fade_1 = __webpack_require__(220);

var grow_in_1 = __webpack_require__(172);

var path_in_1 = __webpack_require__(166);

var position_update_1 = __webpack_require__(310);

var scale_in_1 = __webpack_require__(221);

var sector_path_update_1 = __webpack_require__(311);

var wave_in_1 = __webpack_require__(312);

var zoom_1 = __webpack_require__(222);

var core_6 = __webpack_require__(24);

core_6.registerAnimation('fade-in', fade_1.fadeIn);
core_6.registerAnimation('fade-out', fade_1.fadeOut);
core_6.registerAnimation('grow-in-x', grow_in_1.growInX);
core_6.registerAnimation('grow-in-xy', grow_in_1.growInXY);
core_6.registerAnimation('grow-in-y', grow_in_1.growInY);
core_6.registerAnimation('scale-in-x', scale_in_1.scaleInX);
core_6.registerAnimation('scale-in-y', scale_in_1.scaleInY);
core_6.registerAnimation('wave-in', wave_in_1.waveIn);
core_6.registerAnimation('zoom-in', zoom_1.zoomIn);
core_6.registerAnimation('zoom-out', zoom_1.zoomOut);
core_6.registerAnimation('position-update', position_update_1.positionUpdate);
core_6.registerAnimation('sector-path-update', sector_path_update_1.sectorPathUpdate);
core_6.registerAnimation('path-in', path_in_1.pathIn); //  Facet

var core_7 = __webpack_require__(24);

var circle_1 = tslib_1.__importDefault(__webpack_require__(327));

var list_1 = tslib_1.__importDefault(__webpack_require__(328));

var matrix_1 = tslib_1.__importDefault(__webpack_require__(329));

var mirror_1 = tslib_1.__importDefault(__webpack_require__(330));

var rect_1 = tslib_1.__importDefault(__webpack_require__(331));

var tree_1 = tslib_1.__importDefault(__webpack_require__(332));

core_7.registerFacet('rect', rect_1.default);
core_7.registerFacet('mirror', mirror_1.default);
core_7.registerFacet('list', list_1.default);
core_7.registerFacet('matrix', matrix_1.default);
core_7.registerFacet('circle', circle_1.default);
core_7.registerFacet('tree', tree_1.default); //  Component

var core_8 = __webpack_require__(24);

var annotation_1 = tslib_1.__importDefault(__webpack_require__(308));

var axis_1 = tslib_1.__importDefault(__webpack_require__(333));

var legend_1 = tslib_1.__importDefault(__webpack_require__(334));

var slider_1 = tslib_1.__importDefault(__webpack_require__(335));

var tooltip_1 = tslib_1.__importDefault(__webpack_require__(203));

var scrollbar_1 = tslib_1.__importDefault(__webpack_require__(965)); // register build-in components


core_8.registerComponentController('axis', axis_1.default);
core_8.registerComponentController('legend', legend_1.default);
core_8.registerComponentController('tooltip', tooltip_1.default);
core_8.registerComponentController('annotation', annotation_1.default);
core_8.registerComponentController('slider', slider_1.default);
core_8.registerComponentController('scrollbar', scrollbar_1.default); //  Interaction Action

var core_9 = __webpack_require__(24);

var active_region_1 = tslib_1.__importDefault(__webpack_require__(336));

var sibling_1 = tslib_1.__importDefault(__webpack_require__(337));

var geometry_1 = tslib_1.__importDefault(__webpack_require__(127));

var ellipsis_text_1 = tslib_1.__importDefault(__webpack_require__(338));

var active_1 = tslib_1.__importDefault(__webpack_require__(339));

var link_by_color_1 = tslib_1.__importDefault(__webpack_require__(340));

var range_active_1 = tslib_1.__importDefault(__webpack_require__(341));

var single_active_1 = tslib_1.__importDefault(__webpack_require__(342));

var highlight_1 = tslib_1.__importDefault(__webpack_require__(165));

var highlight_by_color_1 = tslib_1.__importDefault(__webpack_require__(343));

var highlight_by_x_1 = tslib_1.__importDefault(__webpack_require__(344));

var range_highlight_1 = tslib_1.__importDefault(__webpack_require__(224));

var single_highlight_1 = tslib_1.__importDefault(__webpack_require__(345));

var range_selected_1 = tslib_1.__importDefault(__webpack_require__(346));

var selected_1 = tslib_1.__importDefault(__webpack_require__(347));

var single_selected_1 = tslib_1.__importDefault(__webpack_require__(348));

var list_active_1 = tslib_1.__importDefault(__webpack_require__(349));

var list_highlight_1 = tslib_1.__importDefault(__webpack_require__(225));

var list_selected_1 = tslib_1.__importDefault(__webpack_require__(350));

var list_unchecked_1 = tslib_1.__importDefault(__webpack_require__(351));

var circle_2 = tslib_1.__importDefault(__webpack_require__(967));

var dim_rect_1 = tslib_1.__importDefault(__webpack_require__(968));

var path_2 = tslib_1.__importDefault(__webpack_require__(465));

var rect_2 = tslib_1.__importDefault(__webpack_require__(464));

var smooth_path_1 = tslib_1.__importDefault(__webpack_require__(969));

var cursor_1 = tslib_1.__importDefault(__webpack_require__(352));

var filter_1 = tslib_1.__importDefault(__webpack_require__(353));

var range_filter_1 = tslib_1.__importDefault(__webpack_require__(466));

var sibling_filter_1 = tslib_1.__importDefault(__webpack_require__(970));

var filter_2 = tslib_1.__importDefault(__webpack_require__(971));

var sibling_filter_2 = tslib_1.__importDefault(__webpack_require__(972));

var button_1 = tslib_1.__importDefault(__webpack_require__(973));

var drag_1 = tslib_1.__importDefault(__webpack_require__(974));

var move_1 = tslib_1.__importDefault(__webpack_require__(975));

var scale_translate_1 = tslib_1.__importDefault(__webpack_require__(976));

var scale_zoom_1 = tslib_1.__importDefault(__webpack_require__(977));

core_9.registerAction('tooltip', geometry_1.default);
core_9.registerAction('sibling-tooltip', sibling_1.default);
core_9.registerAction('ellipsis-text', ellipsis_text_1.default);
core_9.registerAction('element-active', active_1.default);
core_9.registerAction('element-single-active', single_active_1.default);
core_9.registerAction('element-range-active', range_active_1.default);
core_9.registerAction('element-highlight', highlight_1.default);
core_9.registerAction('element-highlight-by-x', highlight_by_x_1.default);
core_9.registerAction('element-highlight-by-color', highlight_by_color_1.default);
core_9.registerAction('element-single-highlight', single_highlight_1.default);
core_9.registerAction('element-range-highlight', range_highlight_1.default);
core_9.registerAction('element-sibling-highlight', range_highlight_1.default, {
  effectSiblings: true,
  effectByRecord: true
});
core_9.registerAction('element-selected', selected_1.default);
core_9.registerAction('element-single-selected', single_selected_1.default);
core_9.registerAction('element-range-selected', range_selected_1.default);
core_9.registerAction('element-link-by-color', link_by_color_1.default);
core_9.registerAction('active-region', active_region_1.default);
core_9.registerAction('list-active', list_active_1.default);
core_9.registerAction('list-selected', list_selected_1.default);
core_9.registerAction('list-highlight', list_highlight_1.default);
core_9.registerAction('list-unchecked', list_unchecked_1.default);
core_9.registerAction('legend-item-highlight', list_highlight_1.default, {
  componentNames: ['legend']
});
core_9.registerAction('axis-label-highlight', list_highlight_1.default, {
  componentNames: ['axis']
});
core_9.registerAction('rect-mask', rect_2.default);
core_9.registerAction('x-rect-mask', dim_rect_1.default, {
  dim: 'x'
});
core_9.registerAction('y-rect-mask', dim_rect_1.default, {
  dim: 'y'
});
core_9.registerAction('circle-mask', circle_2.default);
core_9.registerAction('path-mask', path_2.default);
core_9.registerAction('smooth-path-mask', smooth_path_1.default);
core_9.registerAction('cursor', cursor_1.default);
core_9.registerAction('data-filter', filter_1.default);
core_9.registerAction('brush', range_filter_1.default);
core_9.registerAction('brush-x', range_filter_1.default, {
  dims: ['x']
});
core_9.registerAction('brush-y', range_filter_1.default, {
  dims: ['y']
});
core_9.registerAction('sibling-filter', sibling_filter_1.default);
core_9.registerAction('sibling-x-filter', sibling_filter_1.default);
core_9.registerAction('sibling-y-filter', sibling_filter_1.default);
core_9.registerAction('element-filter', filter_2.default);
core_9.registerAction('element-sibling-filter', sibling_filter_2.default);
core_9.registerAction('element-sibling-filter-record', sibling_filter_2.default, {
  byRecord: true
});
core_9.registerAction('view-drag', drag_1.default);
core_9.registerAction('view-move', move_1.default);
core_9.registerAction('scale-translate', scale_translate_1.default);
core_9.registerAction('scale-zoom', scale_zoom_1.default);
core_9.registerAction('reset-button', button_1.default, {
  name: 'reset-button',
  text: 'reset'
}); //  Interaction 

var core_10 = __webpack_require__(24);

function isPointInView(context) {
  return context.isInPlot();
} //  tooltip  interaction


core_10.registerInteraction('tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:touchmove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:leave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:touchend',
    action: 'tooltip:hide'
  }]
});
core_10.registerInteraction('ellipsis-text', {
  start: [{
    trigger: 'legend-item-name:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'legend-item-name:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'legend-item-name:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'legend-item-name:touchend',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:touchend',
    action: 'ellipsis-text:hide'
  }]
}); //  element  active

core_10.registerInteraction('element-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-active:active'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-active:reset'
  }]
}); // 

core_10.registerInteraction('element-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-selected:toggle'
  }]
}); // hover highlight

core_10.registerInteraction('element-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight:reset'
  }]
}); // hover highlight by x

core_10.registerInteraction('element-highlight-by-x', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-x:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-x:reset'
  }]
}); // hover highlight by y

core_10.registerInteraction('element-highlight-by-color', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-color:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-color:reset'
  }]
}); // legend hoverelement active

core_10.registerInteraction('legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['list-active:active', 'element-active:active']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['list-active:reset', 'element-active:reset']
  }]
}); // legend hoverelement active

core_10.registerInteraction('legend-highlight', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['legend-item-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['legend-item-highlight:reset', 'element-highlight:reset']
  }]
}); // legend hoverelement active

core_10.registerInteraction('axis-label-highlight', {
  start: [{
    trigger: 'axis-label:mouseenter',
    action: ['axis-label-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'axis-label:mouseleave',
    action: ['axis-label-highlight:reset', 'element-highlight:reset']
  }]
}); // legend hoverelement active

core_10.registerInteraction('element-list-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: ['list-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: ['list-highlight:reset', 'element-highlight:reset']
  }]
}); // 

core_10.registerInteraction('element-range-highlight', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'mask:mouseenter',
    action: 'cursor:move'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }, {
    trigger: 'mask:mouseleave',
    action: 'cursor:crosshair'
  }],
  start: [{
    trigger: 'plot:mousedown',
    isEnable: function isEnable(context) {
      //  mask 
      return !context.isInShape('mask');
    },
    action: ['rect-mask:start', 'rect-mask:show']
  }, {
    trigger: 'mask:dragstart',
    action: ['rect-mask:moveStart']
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: ['rect-mask:resize']
  }, {
    trigger: 'mask:drag',
    action: ['rect-mask:move']
  }, {
    trigger: 'mask:change',
    action: ['element-range-highlight:highlight']
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: ['rect-mask:end']
  }, {
    trigger: 'mask:dragend',
    action: ['rect-mask:moveEnd']
  }, {
    trigger: 'document:mouseup',
    isEnable: function isEnable(context) {
      return !context.isInPlot();
    },
    action: ['element-range-highlight:clear', 'rect-mask:end', 'rect-mask:hide']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['element-range-highlight:clear', 'rect-mask:hide']
  }]
});
core_10.registerInteraction('brush', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: ['brush:start', 'rect-mask:start', 'rect-mask:show']
  }],
  processing: [{
    trigger: 'mousemove',
    isEnable: isPointInView,
    action: ['rect-mask:resize']
  }],
  end: [{
    trigger: 'mouseup',
    isEnable: isPointInView,
    action: ['brush:filter', 'brush:end', 'rect-mask:end', 'rect-mask:hide', 'reset-button:show']
  }],
  rollback: [{
    trigger: 'reset-button:click',
    action: ['brush:reset', 'reset-button:hide', 'cursor:crosshair']
  }]
});
core_10.registerInteraction('brush-visible', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'plot:mousedown',
    action: ['rect-mask:start', 'rect-mask:show']
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: ['rect-mask:resize']
  }, {
    trigger: 'mask:change',
    action: ['element-range-highlight:highlight']
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: ['rect-mask:end', 'rect-mask:hide', 'element-filter:filter', 'element-range-highlight:clear']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['element-filter:clear']
  }]
});
core_10.registerInteraction('brush-x', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: ['brush-x:start', 'x-rect-mask:start', 'x-rect-mask:show']
  }],
  processing: [{
    trigger: 'mousemove',
    isEnable: isPointInView,
    action: ['x-rect-mask:resize']
  }],
  end: [{
    trigger: 'mouseup',
    isEnable: isPointInView,
    action: ['brush-x:filter', 'brush-x:end', 'x-rect-mask:end', 'x-rect-mask:hide']
  }],
  rollback: [{
    trigger: 'dblclick',
    action: ['brush-x:reset']
  }]
});
core_10.registerInteraction('element-path-highlight', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:crosshair'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: 'path-mask:start'
  }, {
    trigger: 'mousedown',
    isEnable: isPointInView,
    action: 'path-mask:show'
  }],
  processing: [{
    trigger: 'mousemove',
    action: 'path-mask:addPoint'
  }],
  end: [{
    trigger: 'mouseup',
    action: 'path-mask:end'
  }],
  rollback: [{
    trigger: 'dblclick',
    action: 'path-mask:hide'
  }]
}); // 

core_10.registerInteraction('element-single-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-single-selected:toggle'
  }]
}); // 

core_10.registerInteraction('legend-filter', {
  showEnable: [{
    trigger: 'legend-item:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'legend-item:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'legend-item:click',
    action: ['list-unchecked:toggle', 'data-filter:filter']
  }]
}); // 

core_10.registerInteraction('continuous-filter', {
  start: [{
    trigger: 'legend:valuechanged',
    action: 'data-filter:filter'
  }]
}); // 

core_10.registerInteraction('continuous-visible-filter', {
  start: [{
    trigger: 'legend:valuechanged',
    action: 'element-filter:filter'
  }]
}); // 

core_10.registerInteraction('legend-visible-filter', {
  showEnable: [{
    trigger: 'legend-item:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'legend-item:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'legend-item:click',
    action: ['list-unchecked:toggle', 'element-filter:filter']
  }]
}); // 

core_10.registerInteraction('active-region', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'active-region:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'active-region:hide'
  }]
});

function isWheelDown(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}

core_10.registerInteraction('view-zoom', {
  start: [{
    trigger: 'plot:mousewheel',
    isEnable: function isEnable(context) {
      return isWheelDown(context.event);
    },
    action: 'scale-zoom:zoomOut',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:mousewheel',
    isEnable: function isEnable(context) {
      return !isWheelDown(context.event);
    },
    action: 'scale-zoom:zoomIn',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }]
});
core_10.registerInteraction('sibling-tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'sibling-tooltip:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'sibling-tooltip:hide'
  }]
});

tslib_1.__exportStar(__webpack_require__(24), exports);

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_object_1 = __webpack_require__(62);

var is_string_1 = __webpack_require__(50);

var is_number_1 = __webpack_require__(990);
/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param path
 * @param value
 */


exports.default = function (obj, path, value) {
  var o = obj;
  var keyArr = is_string_1.default(path) ? path.split('.') : path;
  keyArr.forEach(function (key, idx) {
    // 
    if (idx < keyArr.length - 1) {
      if (!is_object_1.default(o[key])) {
        o[key] = is_number_1.default(keyArr[idx + 1]) ? [] : {};
      }

      o = o[key];
    } else {
      o[key] = value;
    }
  });
  return obj;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COMPONENT_MAX_VIEW_PERCENTAGE = exports.MIN_CHART_HEIGHT = exports.MIN_CHART_WIDTH = exports.FIELD_ORIGIN = exports.GROUP_ATTRS = exports.ELEMENT_STATE = exports.PLOT_EVENTS = exports.GEOMETRY_LIFE_CIRCLE = exports.VIEW_LIFE_CIRCLE = exports.GROUP_Z_INDEX = exports.COMPONENT_TYPE = exports.DIRECTION = exports.LAYER = void 0;
/**
 * view  group  key
 */

var LAYER;

(function (LAYER) {
  /**  */
  LAYER["FORE"] = "fore";
  /**  */

  LAYER["MID"] = "mid";
  /**  */

  LAYER["BG"] = "bg";
})(LAYER = exports.LAYER || (exports.LAYER = {}));
/**
 *  12 
 */


var DIRECTION;

(function (DIRECTION) {
  DIRECTION["TOP"] = "top";
  DIRECTION["TOP_LEFT"] = "top-left";
  DIRECTION["TOP_RIGHT"] = "top-right";
  DIRECTION["RIGHT"] = "right";
  DIRECTION["RIGHT_TOP"] = "right-top";
  DIRECTION["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION["LEFT"] = "left";
  DIRECTION["LEFT_TOP"] = "left-top";
  DIRECTION["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION["BOTTOM"] = "bottom";
  DIRECTION["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION["RADIUS"] = "radius";
  DIRECTION["CIRCLE"] = "circle"; // no direction information

  DIRECTION["NONE"] = "none";
})(DIRECTION = exports.DIRECTION || (exports.DIRECTION = {}));
/**
 * 
 */


var COMPONENT_TYPE;

(function (COMPONENT_TYPE) {
  /** axis  */
  COMPONENT_TYPE["AXIS"] = "axis";
  /** grid  */

  COMPONENT_TYPE["GRID"] = "grid";
  /** legend  */

  COMPONENT_TYPE["LEGEND"] = "legend";
  /** tooltip  */

  COMPONENT_TYPE["TOOLTIP"] = "tooltip";
  /** annotation  */

  COMPONENT_TYPE["ANNOTATION"] = "annotation";
  /**  */

  COMPONENT_TYPE["SLIDER"] = "slider";
  /**  */

  COMPONENT_TYPE["SCROLLBAR"] = "scrollbar";
  /**  */

  COMPONENT_TYPE["OTHER"] = "other";
})(COMPONENT_TYPE = exports.COMPONENT_TYPE || (exports.COMPONENT_TYPE = {}));
/**
 *  group  z index
 */


exports.GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
/**
 * View  3.x 
 * 
 */

var VIEW_LIFE_CIRCLE;

(function (VIEW_LIFE_CIRCLE) {
  VIEW_LIFE_CIRCLE["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE = exports.VIEW_LIFE_CIRCLE || (exports.VIEW_LIFE_CIRCLE = {}));
/**
 * geometry 
 */


var GEOMETRY_LIFE_CIRCLE;

(function (GEOMETRY_LIFE_CIRCLE) {
  GEOMETRY_LIFE_CIRCLE["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE["AFTER_DRAW_ANIMATE"] = "afteranimate";
})(GEOMETRY_LIFE_CIRCLE = exports.GEOMETRY_LIFE_CIRCLE || (exports.GEOMETRY_LIFE_CIRCLE = {}));
/**
 * 
 */


var PLOT_EVENTS;

(function (PLOT_EVENTS) {
  // mouse 
  PLOT_EVENTS["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS["MOUSE_LEAVE"] = "plot:mouseleave"; // 

  PLOT_EVENTS["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS["TOUCH_CANCEL"] = "plot:touchcancel"; // click 

  PLOT_EVENTS["CLICK"] = "plot:click";
  PLOT_EVENTS["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS["LEAVE"] = "plot:leave";
  PLOT_EVENTS["ENTER"] = "plot:enter";
})(PLOT_EVENTS = exports.PLOT_EVENTS || (exports.PLOT_EVENTS = {}));
/**
 * Element 
 */


var ELEMENT_STATE;

(function (ELEMENT_STATE) {
  ELEMENT_STATE["ACTIVE"] = "active";
  ELEMENT_STATE["INACTIVE"] = "inactive";
  ELEMENT_STATE["SELECTED"] = "selected";
  ELEMENT_STATE["DEFAULT"] = "default";
})(ELEMENT_STATE = exports.ELEMENT_STATE || (exports.ELEMENT_STATE = {}));
/**  */


exports.GROUP_ATTRS = ['color', 'shape', 'size'];
/**  */

exports.FIELD_ORIGIN = '_origin';
/**  */

exports.MIN_CHART_WIDTH = 1;
/**  */

exports.MIN_CHART_HEIGHT = 1;
/** 25% */

exports.COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = void 0;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _eventEmitter = _interopRequireDefault(__webpack_require__(125));

var _sizeSensor = __webpack_require__(483);

var _utils = __webpack_require__(12);

var SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';
/**
 *  plot 
 */

var Plot =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Plot, _super);

  function Plot(container, options) {
    var _this = _super.call(this) || this;
    /** plot  */


    _this.type = 'base';
    _this.container = typeof container === 'string' ? document.getElementById(container) : container;
    _this.options = (0, _utils.deepAssign)({}, _this.getDefaultOptions(), options);

    _this.createG2();

    _this.bindEvents();

    return _this;
  }
  /**
   *  options 
   * 
   */


  Plot.getDefaultOptions = function () {
    return {
      renderer: 'canvas',
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: {
            type: 'equidistance',
            cfg: {
              minGap: 6
            }
          }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
  /**
   *  G2 
   */


  Plot.prototype.createG2 = function () {
    var _a = this.options,
        width = _a.width,
        height = _a.height,
        padding = _a.padding,
        appendPadding = _a.appendPadding,
        renderer = _a.renderer,
        pixelRatio = _a.pixelRatio,
        syncViewPadding = _a.syncViewPadding,
        supportCSSTransform = _a.supportCSSTransform,
        limitInPlot = _a.limitInPlot;
    this.chart = new _g.Chart((0, _tslib.__assign)((0, _tslib.__assign)({
      container: this.container,
      autoFit: false
    }, this.getChartSize(width, height)), {
      padding: padding,
      appendPadding: appendPadding,
      renderer: renderer,
      pixelRatio: pixelRatio,
      localRefresh: false,
      //  G 
      syncViewPadding: syncViewPadding,
      supportCSSTransform: supportCSSTransform,
      limitInPlot: limitInPlot
    })); //  G2

    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');
  };
  /**
   *  chart  width  height
   * @param width
   * @param height
   */


  Plot.prototype.getChartSize = function (width, height) {
    var chartSize = (0, _utils.getContainerSize)(this.container);
    return {
      width: width || chartSize.width || 400,
      height: height || chartSize.height || 400
    };
  };
  /**
   *  G2 
   */


  Plot.prototype.bindEvents = function () {
    var _this = this;

    if (this.chart) {
      this.chart.on('*', function (e) {
        if (e === null || e === void 0 ? void 0 : e.type) {
          _this.emit(e.type, e);
        }
      });
    }
  };
  /**
   *  options 
   * 
   */


  Plot.prototype.getDefaultOptions = function () {
    return Plot.getDefaultOptions();
  };
  /**
   * 
   */


  Plot.prototype.render = function () {
    //  G2 
    this.chart.clear(); //  view  view  options  legend legend 
    //  chart  options 
    //  G2 view.clear  options  resetOptions
    // #1684  view  custom legend
    // @ts-ignore

    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = []; //  views
    //  adaptor

    this.execAdaptor(); // 

    this.chart.render(); // 

    this.bindSizeSensor();
  };
  /**
   * : 
   * @param options
   */


  Plot.prototype.update = function (options) {
    this.updateOption(options);
    this.render();
  };
  /**
   * 
   * @param options
   */


  Plot.prototype.updateOption = function (options) {
    this.options = (0, _utils.deepAssign)({}, this.options, options);
  };
  /**
   * 
   * @param type  'active' | 'inactive' | 'selected' 
   * @param conditions 
   * @param status  true
   */


  Plot.prototype.setState = function (type, condition, status) {
    if (status === void 0) {
      status = true;
    }

    var elements = (0, _utils.getAllElements)(this.chart);
    (0, _util.each)(elements, function (ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
  /**
   * 
   */


  Plot.prototype.getStates = function () {
    var elements = (0, _utils.getAllElements)(this.chart);
    var stateObjects = [];
    (0, _util.each)(elements, function (element) {
      var data = element.getData();
      var states = element.getStates();
      (0, _util.each)(states, function (state) {
        stateObjects.push({
          data: data,
          state: state,
          geometry: element.geometry,
          element: element
        });
      });
    });
    return stateObjects;
  };
  /**
   * 
   * @override
   * @param options
   */


  Plot.prototype.changeData = function (data) {
    // @ts-ignore
    this.update({
      data: data
    }); // TODO: 
    // this.chart.changeData(data);
  };
  /**
   * 
   * @param width
   * @param height
   */


  Plot.prototype.changeSize = function (width, height) {
    this.chart.changeSize(width, height);
  };
  /**
   * 
   */


  Plot.prototype.destroy = function () {
    //  size-sensor 
    this.unbindSizeSensor(); // G2 

    this.chart.destroy(); // 

    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
  /**
   *  adaptor 
   */


  Plot.prototype.execAdaptor = function () {
    var adaptor = this.getSchemaAdaptor();
    var _a = this.options,
        padding = _a.padding,
        appendPadding = _a.appendPadding; //  padding

    this.chart.padding = padding; //  appendPadding

    this.chart.appendPadding = appendPadding; //  G2 API

    adaptor({
      chart: this.chart,
      options: this.options
    });
  };
  /**
   * 
   */


  Plot.prototype.triggerResize = function () {
    this.chart.forceFit();
  };
  /**
   *  dom 
   */


  Plot.prototype.bindSizeSensor = function () {
    var _this = this;

    if (this.unbind) {
      return;
    }

    var _a = this.options.autoFit,
        autoFit = _a === void 0 ? true : _a;

    if (autoFit) {
      this.unbind = (0, _sizeSensor.bind)(this.container, function () {
        // 
        var _a = (0, _utils.getContainerSize)(_this.container),
            width = _a.width,
            height = _a.height; //  resize 


        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
  /**
   * 
   */


  Plot.prototype.unbindSizeSensor = function () {
    if (this.unbind) {
      this.unbind();
      this.unbind = undefined;
    }
  };

  return Plot;
}(_eventEmitter.default);

exports.Plot = Plot;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_type_1 = __webpack_require__(117);

exports.default = function (value) {
  return Array.isArray ? Array.isArray(value) : is_type_1.default(value, 'Array');
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* G2  Geometry */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Util = exports.Types = exports.VERSION = void 0;

var tslib_1 = __webpack_require__(1);

exports.VERSION = '4.1.8'; // 

var chart_1 = __webpack_require__(113); // Chart, View 


Object.defineProperty(exports, "Chart", {
  enumerable: true,
  get: function get() {
    return chart_1.Chart;
  }
});
Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function get() {
    return chart_1.View;
  }
});
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return chart_1.Event;
  }
});

var base_1 = __webpack_require__(104); // G2 


Object.defineProperty(exports, "ComponentController", {
  enumerable: true,
  get: function get() {
    return base_1.Controller;
  }
});

var tooltip_1 = __webpack_require__(203); // G2 tooltip 


Object.defineProperty(exports, "TooltipController", {
  enumerable: true,
  get: function get() {
    return tooltip_1.default;
  }
});

var base_2 = __webpack_require__(97); // Geometry 


Object.defineProperty(exports, "Geometry", {
  enumerable: true,
  get: function get() {
    return base_2.default;
  }
});

var element_1 = __webpack_require__(269); // Element 


Object.defineProperty(exports, "Element", {
  enumerable: true,
  get: function get() {
    return element_1.default;
  }
});

var base_3 = __webpack_require__(99); // Geometry Label 


Object.defineProperty(exports, "GeometryLabel", {
  enumerable: true,
  get: function get() {
    return base_3.default;
  }
});

var interaction_1 = __webpack_require__(264); // Interaction, Action 


Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function get() {
    return interaction_1.Interaction;
  }
});
Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return interaction_1.Action;
  }
});

var facet_1 = __webpack_require__(262); // Facet 


Object.defineProperty(exports, "Facet", {
  enumerable: true,
  get: function get() {
    return facet_1.Facet;
  }
});

var base_4 = __webpack_require__(47); // Interaction Action 


Object.defineProperty(exports, "InteractionAction", {
  enumerable: true,
  get: function get() {
    return base_4.default;
  }
}); //  ComponentController

var chart_2 = __webpack_require__(113);

Object.defineProperty(exports, "registerComponentController", {
  enumerable: true,
  get: function get() {
    return chart_2.registerComponentController;
  }
}); //  Geometry

var chart_3 = __webpack_require__(113);

Object.defineProperty(exports, "registerGeometry", {
  enumerable: true,
  get: function get() {
    return chart_3.registerGeometry;
  }
}); //  Geometry Shape

var base_5 = __webpack_require__(29);

Object.defineProperty(exports, "registerShape", {
  enumerable: true,
  get: function get() {
    return base_5.registerShape;
  }
});
Object.defineProperty(exports, "registerShapeFactory", {
  enumerable: true,
  get: function get() {
    return base_5.registerShapeFactory;
  }
});
Object.defineProperty(exports, "getShapeFactory", {
  enumerable: true,
  get: function get() {
    return base_5.getShapeFactory;
  }
}); //  Geometry label  Geometry Label 

var label_1 = __webpack_require__(271);

Object.defineProperty(exports, "registerGeometryLabel", {
  enumerable: true,
  get: function get() {
    return label_1.registerGeometryLabel;
  }
});
Object.defineProperty(exports, "registerGeometryLabelLayout", {
  enumerable: true,
  get: function get() {
    return label_1.registerGeometryLabelLayout;
  }
});
Object.defineProperty(exports, "getGeometryLabel", {
  enumerable: true,
  get: function get() {
    return label_1.getGeometryLabel;
  }
});
Object.defineProperty(exports, "getGeometryLabelLayout", {
  enumerable: true,
  get: function get() {
    return label_1.getGeometryLabelLayout;
  }
}); //  interaction

var interaction_2 = __webpack_require__(264);

Object.defineProperty(exports, "getInteraction", {
  enumerable: true,
  get: function get() {
    return interaction_2.getInteraction;
  }
});
Object.defineProperty(exports, "registerInteraction", {
  enumerable: true,
  get: function get() {
    return interaction_2.registerInteraction;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return interaction_2.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return interaction_2.getActionClass;
  }
}); //  facet

var facet_2 = __webpack_require__(262);

Object.defineProperty(exports, "getFacet", {
  enumerable: true,
  get: function get() {
    return facet_2.getFacet;
  }
});
Object.defineProperty(exports, "registerFacet", {
  enumerable: true,
  get: function get() {
    return facet_2.registerFacet;
  }
}); // 

var theme_1 = __webpack_require__(91);

Object.defineProperty(exports, "getTheme", {
  enumerable: true,
  get: function get() {
    return theme_1.getTheme;
  }
});
Object.defineProperty(exports, "registerTheme", {
  enumerable: true,
  get: function get() {
    return theme_1.registerTheme;
  }
}); // G engine 

var engine_1 = __webpack_require__(431);

Object.defineProperty(exports, "registerEngine", {
  enumerable: true,
  get: function get() {
    return engine_1.registerEngine;
  }
});
Object.defineProperty(exports, "getEngine", {
  enumerable: true,
  get: function get() {
    return engine_1.getEngine;
  }
}); // 

var animation_1 = __webpack_require__(424);

Object.defineProperty(exports, "registerAnimation", {
  enumerable: true,
  get: function get() {
    return animation_1.registerAnimation;
  }
});
Object.defineProperty(exports, "getAnimation", {
  enumerable: true,
  get: function get() {
    return animation_1.getAnimation;
  }
});

var constant_1 = __webpack_require__(20);

Object.defineProperty(exports, "LAYER", {
  enumerable: true,
  get: function get() {
    return constant_1.LAYER;
  }
});
Object.defineProperty(exports, "DIRECTION", {
  enumerable: true,
  get: function get() {
    return constant_1.DIRECTION;
  }
}); //  typescript  export * as 

var Types = tslib_1.__importStar(__webpack_require__(272));

exports.Types = Types;

var dependents_1 = __webpack_require__(68);

Object.defineProperty(exports, "Coordinate", {
  enumerable: true,
  get: function get() {
    return dependents_1.Coordinate;
  }
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return dependents_1.Scale;
  }
}); // 

var legend_1 = __webpack_require__(438);

var graphics_1 = __webpack_require__(45);

var transform_1 = __webpack_require__(115);

var tooltip_2 = __webpack_require__(266);

var util_1 = __webpack_require__(30);

exports.Util = {
  getLegendItems: legend_1.getLegendItems,
  translate: transform_1.translate,
  rotate: transform_1.rotate,
  zoom: transform_1.zoom,
  transform: transform_1.transform,
  getAngle: graphics_1.getAngle,
  getSectorPath: graphics_1.getSectorPath,
  polarToCartesian: graphics_1.polarToCartesian,
  getDelegationObject: util_1.getDelegationObject,
  getTooltipItems: tooltip_2.getTooltipItems
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.legend = legend;
exports.tooltip = tooltip;
exports.interaction = interaction;
exports.animation = animation;
exports.theme = theme;
exports.state = state;
exports.slider = slider;
exports.scrollbar = scrollbar;
exports.scale = scale;
exports.annotation = annotation;
exports.limitInPlot = limitInPlot;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(121);

var _utils = __webpack_require__(12);

/**
 *  legend ,  colorField  seriesField 
 * @param params
 */
function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField,
      seriesField = options.seriesField;

  if (legend === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend);
  }

  return params;
}
/**
 *  tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;

  if (tooltip !== undefined) {
    chart.tooltip(tooltip);
  }

  return params;
}
/**
 * Interaction 
 * @param params
 */


function interaction(params) {
  var chart = params.chart,
      options = params.options;
  var interactions = options.interactions;
  (0, _util.each)(interactions, function (i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
/**
 * 
 * @param params
 */


function animation(params) {
  var chart = params.chart,
      options = params.options;
  var animation = options.animation; //  view 

  if (typeof animation === 'boolean') {
    chart.animate(animation);
  } else {
    chart.animate(true);
  } //  Geometry 


  (0, _util.each)(chart.geometries, function (g) {
    g.animate(animation);
  });
  return params;
}
/**
 * 
 * @param params
 */


function theme(params) {
  var chart = params.chart,
      options = params.options;
  var theme = options.theme; // 

  if (theme) {
    chart.theme(theme);
  }

  return params;
}
/**
 *  state 
 * @param params
 */


function state(params) {
  var chart = params.chart,
      options = params.options;
  var state = options.state;

  if (state) {
    (0, _util.each)(chart.geometries, function (geometry) {
      geometry.state(state);
    });
  }

  return params;
}
/**
 *  adaptor
 * @param params
 */


function slider(params) {
  var chart = params.chart,
      options = params.options;
  var slider = options.slider;
  chart.option('slider', slider);
  return params;
}
/**
 *  adaptor
 * @param params
 */


function scrollbar(params) {
  var chart = params.chart,
      options = params.options;
  var scrollbar = options.scrollbar;
  chart.option('scrollbar', scrollbar);
  return params;
}
/**
 * scale  adaptor
 * @param axes
 */


function scale(axes, meta) {
  return function (params) {
    var chart = params.chart,
        options = params.options; // 1.  scale 

    var scales = {};
    (0, _util.each)(axes, function (axis, field) {
      scales[field] = (0, _utils.pick)(axis, _constant.AXIS_META_CONFIG_KEYS);
    }); // 2. meta  scale 

    scales = (0, _utils.deepAssign)({}, meta, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
/**
 * annotation 
 * @param params
 */


function annotation(annotationOptions) {
  return function (params) {
    var chart = params.chart,
        options = params.options;
    var annotationController = chart.getController('annotation');
    /**  annotation */

    (0, _util.each)((0, _tslib.__spreadArrays)(options.annotations || [], annotationOptions || []), function (annotationOption) {
      // @ts-ignore
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
/**
 *  limitInPlot
 * @param params
 */


function limitInPlot(params) {
  var chart = params.chart,
      options = params.options;
  var yAxis = options.yAxis,
      limitInPlot = options.limitInPlot;
  var value = limitInPlot; //  limitInPlot yAxis  min/max  limitInPlot

  if ((0, _util.isObject)(yAxis) && (0, _util.isNil)(limitInPlot)) {
    if (Object.values((0, _utils.pick)(yAxis, ['min', 'max', 'minLimit', 'maxLimit'])).some(function (value) {
      return !(0, _util.isNil)(value);
    })) {
      value = true;
    } else {
      value = false;
    }
  }

  chart.limitInPlot = value;
  return params;
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 
 * @param  {*} fn 
 * @return {Boolean}  
 */

var is_type_1 = __webpack_require__(117);

exports.default = function (value) {
  return is_type_1.default(value, 'Function');
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  PathUtil: true,
  Event: true,
  Base: true,
  AbstractCanvas: true,
  AbstractGroup: true,
  AbstractShape: true,
  getBBoxMethod: true,
  getTextHeight: true,
  assembleFont: true,
  isAllowCapture: true,
  multiplyVec2: true,
  invert: true,
  getOffScreenContext: true
};
Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return _graphEvent.default;
  }
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "AbstractCanvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "AbstractGroup", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "AbstractShape", {
  enumerable: true,
  get: function get() {
    return _shape.default;
  }
});
Object.defineProperty(exports, "getBBoxMethod", {
  enumerable: true,
  get: function get() {
    return _bbox.getBBoxMethod;
  }
});
Object.defineProperty(exports, "getTextHeight", {
  enumerable: true,
  get: function get() {
    return _text.getTextHeight;
  }
});
Object.defineProperty(exports, "assembleFont", {
  enumerable: true,
  get: function get() {
    return _text.assembleFont;
  }
});
Object.defineProperty(exports, "isAllowCapture", {
  enumerable: true,
  get: function get() {
    return _util.isAllowCapture;
  }
});
Object.defineProperty(exports, "multiplyVec2", {
  enumerable: true,
  get: function get() {
    return _matrix.multiplyVec2;
  }
});
Object.defineProperty(exports, "invert", {
  enumerable: true,
  get: function get() {
    return _matrix.invert;
  }
});
Object.defineProperty(exports, "getOffScreenContext", {
  enumerable: true,
  get: function get() {
    return _offscreen.getOffScreenContext;
  }
});
exports.PathUtil = exports.version = void 0;

var PathUtil = _interopRequireWildcard(__webpack_require__(376));

exports.PathUtil = PathUtil;

var _types = __webpack_require__(700);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _interfaces = __webpack_require__(701);

Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interfaces[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interfaces[key];
    }
  });
});

var _graphEvent = _interopRequireDefault(__webpack_require__(377));

var _base = _interopRequireDefault(__webpack_require__(378));

var _canvas = _interopRequireDefault(__webpack_require__(702));

var _group = _interopRequireDefault(__webpack_require__(741));

var _shape = _interopRequireDefault(__webpack_require__(742));

var _bbox = __webpack_require__(743);

var _text = __webpack_require__(399);

var _util = __webpack_require__(102);

var _matrix = __webpack_require__(240);

var _offscreen = __webpack_require__(400);

/**
 * @fileoverview G 
 * @author dxq613@gmail.com
 */
var version = '0.5.4';
exports.version = version;

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return withGroupContext; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);

 // Group 

var GroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
GroupContext.displayName = 'GroupContext';
function withGroupContext(Component) {
  var Com = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.forwardRef(function (props, ref) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(GroupContext.Consumer, null, function (ctx) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: ref,
        group: ctx
      }, props));
    });
  });
  Com.displayName = Component.name;
  return Com;
}
;
/* harmony default export */ __webpack_exports__["a"] = (GroupContext);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShapeFactory = exports.registerShape = exports.registerShapeFactory = void 0;

var tslib_1 = __webpack_require__(1);

var path_util_1 = __webpack_require__(95);

var util_1 = __webpack_require__(0);

var path_1 = __webpack_require__(146);
/** ShapeFactory  */


var ShapeFactoryBase = {
  /**  */
  coordinate: null,

  /**  Shape  */
  defaultShapeType: null,

  /**  */
  theme: null,

  /**
   *  shape 
   * @param shapeType shape 
   * @param shapePoint  size 
   * @returns 
   */
  getShapePoints: function getShapePoints(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);

    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }

    return this.getDefaultPoints(shapePoint);
  },

  /**
   *  shape  shape 
   * @param shapeType string shape 
   * @returns
   */
  getShape: function getShape(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },

  /**
   *  shape 
   * @override
   */
  getDefaultPoints: function getDefaultPoints() {
    return [];
  },

  /**
   *  shape  ( shapeFactory )
   */
  getDefaultStyle: function getDefaultStyle(geometryTheme) {
    return util_1.get(geometryTheme, [this.defaultShapeType, 'default', 'style'], {});
  },

  /**
   *  shape 
   * @param shapeType shape 
   * @param color 
   * @param isInPolar 
   * @returns  marker 
   */
  getMarker: function getMarker(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);

    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }

    var theme = this.theme;
    var shapeStyle = util_1.get(theme, [shapeType, 'default'], {});
    var markerStyle = shape.getMarker(markerCfg);
    return util_1.deepMix({}, shapeStyle, markerStyle);
  },

  /**
   *  shape
   * @override
   * @param shapeType  shape 
   * @param cfg  shape 
   * @param element Element 
   * @returns
   */
  drawShape: function drawShape(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
/** Shape  */

var ShapeBase = {
  /**  */
  coordinate: null,

  /**
   *  path  path
   * @param path 
   * @returns
   */
  parsePath: function parsePath(path) {
    var coordinate = this.coordinate;
    var parsedPath = path_util_1.parsePathString(path);

    if (coordinate.isPolar) {
      parsedPath = path_1.convertPolarPath(coordinate, parsedPath);
    } else {
      parsedPath = path_1.convertNormalPath(coordinate, parsedPath);
    }

    return parsedPath;
  },

  /**
   * 
   * @param point 
   * @returns
   */
  parsePoint: function parsePoint(point) {
    var coordinate = this.coordinate;
    return coordinate.convert(point);
  },

  /**
   * 01 points   points
   * @param points 
   * @returns
   */
  parsePoints: function parsePoints(points) {
    var coordinate = this.coordinate;
    return points.map(function (point) {
      return coordinate.convert(point);
    });
  },

  /**
   *  shape
   * @override
   */
  draw: function draw(cfg, container) {}
};
var ShapeFactoryMap = {};
/**
 *  ShapeFactory
 * @param factoryName  ShapeFactory  Geometry 
 * @param cfg  ShapeFactory 
 * @returns  ShapeFactory 
 */

function registerShapeFactory(factoryName, cfg) {
  var className = util_1.upperFirst(factoryName);

  var geomObj = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, ShapeFactoryBase), cfg), {
    geometryType: factoryName
  });

  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}

exports.registerShapeFactory = registerShapeFactory;
/**
 *  Shape
 * @param factoryName  ShapeFactory 
 * @param shapeType  shape 
 * @param cfg  Shape 
 * @returns shape  shape 
 */

function registerShape(factoryName, shapeType, cfg) {
  var className = util_1.upperFirst(factoryName);
  var factory = ShapeFactoryMap[className];

  var shapeObj = tslib_1.__assign(tslib_1.__assign({}, ShapeBase), cfg);

  factory[shapeType] = shapeObj;
  return shapeObj;
}

exports.registerShape = registerShape;
/**
 *  factoryName  shapeFactory
 * @param factoryName
 * @returns shape factory
 */

function getShapeFactory(factoryName) {
  var className = util_1.upperFirst(factoryName);
  return ShapeFactoryMap[className];
}

exports.getShapeFactory = getShapeFactory;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScaleByField = exports.isInRecords = exports.getSiblingPoint = exports.getSilbings = exports.isInBox = exports.getSpline = exports.distance = exports.getComponents = exports.getElementsByPath = exports.getIntersectElements = exports.intersectRect = exports.getElementValue = exports.getElementsByState = exports.getElementsByField = exports.getElements = exports.getSiblingMaskElements = exports.getMaskedElements = exports.isMask = exports.isSlider = exports.isList = exports.isElementChange = exports.getDelegationObject = exports.getCurrentElement = void 0;

var util_1 = __webpack_require__(0);

var path_1 = __webpack_require__(146);

var bbox_1 = __webpack_require__(77);

var path_util_1 = __webpack_require__(95);

function getMaskBBox(context, tolerance) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox(); //  bbox 

  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {
    return null;
  }

  return maskBBox;
}

function getMaskPath(context, tolerance) {
  var event = context.event;
  var maskShape = event.target;
  var maskBBox = maskShape.getCanvasBBox(); //  bbox 

  if (!(maskBBox.width >= tolerance || maskBBox.height >= tolerance)) {
    return null;
  }

  return maskShape.attr('path');
}
/**
 * 
 * @param context 
 * @ignore
 */


function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target = event.target;

  if (target) {
    element = target.get('element');
  }

  return element;
}

exports.getCurrentElement = getCurrentElement;
/**
 * 
 * @param context 
 * @ignore
 */

function getDelegationObject(context) {
  var event = context.event;
  var target = event.target;
  var delegateObject;

  if (target) {
    delegateObject = target.get('delegateObject');
  }

  return delegateObject;
}

exports.getDelegationObject = getDelegationObject;

function isElementChange(context) {
  var event = context.event.gEvent; //  element label  shape 

  if (event && event.fromShape && event.toShape && event.fromShape.get('element') === event.toShape.get('element')) {
    return false;
  }

  return true;
}

exports.isElementChange = isElementChange;
/**
 * 
 * @param delegateObject 
 * @ignore
 */

function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}

exports.isList = isList;
/**
 * 
 * @param delegateObject 
 * @ignore
 */

function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}

exports.isSlider = isSlider;
/**
 *  mask 
 * @param context 
 * @ignore
 */

function isMask(context) {
  var event = context.event;
  var target = event.target;
  return target && target.get('name') === 'mask';
}

exports.isMask = isMask;
/**
 *  elements
 * @param context 
 * @ignore
 */

function getMaskedElements(context, tolerance) {
  var target = context.event.target;

  if (target.get('type') === 'path') {
    var maskPath = getMaskPath(context, tolerance);

    if (!maskPath) {
      return;
    }

    return getElementsByPath(context.view, maskPath);
  }

  var maskBBox = getMaskBBox(context, tolerance); //  bbox 

  if (!maskBBox) {
    return null;
  }

  return getIntersectElements(context.view, maskBBox);
}

exports.getMaskedElements = getMaskedElements;
/**
 * @ignore
 */

function getSiblingMaskElements(context, sibling, tolerance) {
  var maskBBox = getMaskBBox(context, tolerance); //  bbox 

  if (!maskBBox) {
    return null;
  }

  var view = context.view;
  var start = getSiblingPoint(view, sibling, {
    x: maskBBox.x,
    y: maskBBox.y
  });
  var end = getSiblingPoint(view, sibling, {
    x: maskBBox.maxX,
    y: maskBBox.maxY
  });
  var box = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box);
}

exports.getSiblingMaskElements = getSiblingMaskElements;
/**
 * 
 * @param view View/Chart
 * @ignore
 */

function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  util_1.each(geometries, function (geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });

  if (view.views && view.views.length) {
    util_1.each(view.views, function (subView) {
      rst = rst.concat(getElements(subView));
    });
  }

  return rst;
}

exports.getElements = getElements;
/**
 * 
 * @param view View/Chart
 * @param field 
 * @param value 
 * @ignore
 */

function getElementsByField(view, field, value) {
  var elements = getElements(view);
  return elements.filter(function (el) {
    return getElementValue(el, field) === value;
  });
}

exports.getElementsByField = getElementsByField;
/**
 * 
 * @param view View/Chart
 * @param stateName 
 * @ignore
 */

function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  util_1.each(geometries, function (geom) {
    var elements = geom.getElementsBy(function (el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}

exports.getElementsByState = getElementsByState;
/**
 * 
 * @param element 
 * @param field 
 * @ignore
 */

function getElementValue(element, field) {
  var model = element.getModel();
  var record = model.data;
  var value;

  if (util_1.isArray(record)) {
    value = record[0][field];
  } else {
    value = record[field];
  }

  return value;
}

exports.getElementValue = getElementValue;
/**
 * 
 * @param box1 1
 * @param box2 2
 * @ignore
 */

function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}

exports.intersectRect = intersectRect;
/**
 * 
 * @param view View/Chart
 * @param box 
 * @ignore
 */

function getIntersectElements(view, box) {
  var elements = getElements(view);
  var rst = [];
  util_1.each(elements, function (el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();

    if (intersectRect(box, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}

exports.getIntersectElements = getIntersectElements;

function pathToPoints(path) {
  var points = [];
  util_1.each(path, function (seg) {
    var command = seg[0];

    if (command !== 'A') {
      for (var i = 1; i < seg.length; i = i + 2) {
        points.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
}
/**
 * 
 * @param view View/Chart
 * @param path 
 * @ignore
 */


function getElementsByPath(view, path) {
  var elements = getElements(view);
  var points = pathToPoints(path);
  var rst = elements.filter(function (el) {
    var shape = el.shape;
    var shapePoints;

    if (shape.get('type') === 'path') {
      shapePoints = pathToPoints(shape.attr('path'));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = bbox_1.toPoints(shapeBBox);
    }

    return path_util_1.isPolygonsIntersect(points, shapePoints);
  });
  return rst;
}

exports.getElementsByPath = getElementsByPath;
/**
 *  View 
 * @param view View/Chart
 * @ignore
 */

function getComponents(view) {
  return view.getComponents().map(function (co) {
    return co.component;
  });
}

exports.getComponents = getComponents;
/** @ignore */

function distance(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

exports.distance = distance;
/** @ignore */

function getSpline(points, z) {
  if (points.length <= 2) {
    return path_1.getLinePath(points, false);
  }

  var first = points[0];
  var arr = [];
  util_1.each(points, function (point) {
    arr.push(point.x);
    arr.push(point.y);
  });
  var path = path_1.catmullRom2bezier(arr, z, null);
  path.unshift(['M', first.x, first.y]);
  return path;
}

exports.getSpline = getSpline;
/**
 * 
 * @param box 
 * @param point 
 * @ignore
 */

function isInBox(box, point) {
  return box.x <= point.x && box.maxX >= point.x && box.y <= point.y && box.maxY > point.y;
}

exports.isInBox = isInBox;
/**
 *  view  views
 * @param view  view
 * @returns  views
 * @ignore
 */

function getSilbings(view) {
  var parent = view.parent;
  var siblings = null;

  if (parent) {
    siblings = parent.views.filter(function (sub) {
      return sub !== view;
    });
  }

  return siblings;
}

exports.getSilbings = getSilbings;

function point2Normalize(view, point) {
  var coord = view.getCoordinate();
  return coord.invert(point);
}
/**
 *  view  view 
 * @param view  view
 * @param sibling  view
 * @param point 
 * @ignore
 */


function getSiblingPoint(view, sibling, point) {
  var normalPoint = point2Normalize(view, point);
  return sibling.getCoordinate().convert(normalPoint);
}

exports.getSiblingPoint = getSiblingPoint;
/**
 *  view 
 *  view  includes
 *  x, y  isEqual 
 * 
 * @param records
 * @param record
 * @param xFiled
 * @param yField
 * @returns
 * @ignore
 */

function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  util_1.each(records, function (r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}

exports.isInRecords = isInRecords; //  field  scale view  view

function getScaleByField(view, field) {
  var scale = view.getScaleByField(field);

  if (!scale && view.views) {
    util_1.each(view.views, function (subView) {
      scale = getScaleByField(subView, field);

      if (scale) {
        return false; // 
      }
    });
  }

  return scale;
}

exports.getScaleByField = getScaleByField;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Plot = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var event_emitter_1 = tslib_1.__importDefault(__webpack_require__(125));

var size_sensor_1 = __webpack_require__(483);

var utils_1 = __webpack_require__(16);

var SOURCE_ATTRIBUTE_NAME = 'data-chart-source-type';
/**
 *  plot 
 */

var Plot =
/** @class */
function (_super) {
  tslib_1.__extends(Plot, _super);

  function Plot(container, options) {
    var _this = _super.call(this) || this;
    /** plot  */


    _this.type = 'base';
    _this.container = typeof container === 'string' ? document.getElementById(container) : container;
    _this.options = utils_1.deepAssign({}, _this.getDefaultOptions(), options);

    _this.createG2();

    _this.bindEvents();

    return _this;
  }
  /**
   *  options 
   * 
   */


  Plot.getDefaultOptions = function () {
    return {
      renderer: 'canvas',
      xAxis: {
        nice: true,
        label: {
          autoRotate: false,
          autoHide: {
            type: 'equidistance',
            cfg: {
              minGap: 6
            }
          }
        }
      },
      yAxis: {
        nice: true,
        label: {
          autoHide: true,
          autoRotate: false
        }
      },
      animation: true
    };
  };
  /**
   *  G2 
   */


  Plot.prototype.createG2 = function () {
    var _a = this.options,
        width = _a.width,
        height = _a.height,
        padding = _a.padding,
        appendPadding = _a.appendPadding,
        renderer = _a.renderer,
        pixelRatio = _a.pixelRatio,
        syncViewPadding = _a.syncViewPadding,
        supportCSSTransform = _a.supportCSSTransform,
        limitInPlot = _a.limitInPlot;
    this.chart = new g2_1.Chart(tslib_1.__assign(tslib_1.__assign({
      container: this.container,
      autoFit: false
    }, this.getChartSize(width, height)), {
      padding: padding,
      appendPadding: appendPadding,
      renderer: renderer,
      pixelRatio: pixelRatio,
      localRefresh: false,
      //  G 
      syncViewPadding: syncViewPadding,
      supportCSSTransform: supportCSSTransform,
      limitInPlot: limitInPlot
    })); //  G2

    this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, 'G2Plot');
  };
  /**
   *  chart  width  height
   * @param width
   * @param height
   */


  Plot.prototype.getChartSize = function (width, height) {
    var chartSize = utils_1.getContainerSize(this.container);
    return {
      width: width || chartSize.width || 400,
      height: height || chartSize.height || 400
    };
  };
  /**
   *  G2 
   */


  Plot.prototype.bindEvents = function () {
    var _this = this;

    if (this.chart) {
      this.chart.on('*', function (e) {
        if (e === null || e === void 0 ? void 0 : e.type) {
          _this.emit(e.type, e);
        }
      });
    }
  };
  /**
   *  options 
   * 
   */


  Plot.prototype.getDefaultOptions = function () {
    return Plot.getDefaultOptions();
  };
  /**
   * 
   */


  Plot.prototype.render = function () {
    //  G2 
    this.chart.clear(); //  view  view  options  legend legend 
    //  chart  options 
    //  G2 view.clear  options  resetOptions
    // #1684  view  custom legend
    // @ts-ignore

    this.chart.options = {
      data: [],
      animate: true
    };
    this.chart.views = []; //  views
    //  adaptor

    this.execAdaptor(); // 

    this.chart.render(); // 

    this.bindSizeSensor();
  };
  /**
   * : 
   * @param options
   */


  Plot.prototype.update = function (options) {
    this.updateOption(options);
    this.render();
  };
  /**
   * 
   * @param options
   */


  Plot.prototype.updateOption = function (options) {
    this.options = utils_1.deepAssign({}, this.options, options);
  };
  /**
   * 
   * @param type  'active' | 'inactive' | 'selected' 
   * @param conditions 
   * @param status  true
   */


  Plot.prototype.setState = function (type, condition, status) {
    if (status === void 0) {
      status = true;
    }

    var elements = utils_1.getAllElements(this.chart);
    util_1.each(elements, function (ele) {
      if (condition(ele.getData())) {
        ele.setState(type, status);
      }
    });
  };
  /**
   * 
   */


  Plot.prototype.getStates = function () {
    var elements = utils_1.getAllElements(this.chart);
    var stateObjects = [];
    util_1.each(elements, function (element) {
      var data = element.getData();
      var states = element.getStates();
      util_1.each(states, function (state) {
        stateObjects.push({
          data: data,
          state: state,
          geometry: element.geometry,
          element: element
        });
      });
    });
    return stateObjects;
  };
  /**
   * 
   * @override
   * @param options
   */


  Plot.prototype.changeData = function (data) {
    // @ts-ignore
    this.update({
      data: data
    }); // TODO: 
    // this.chart.changeData(data);
  };
  /**
   * 
   * @param width
   * @param height
   */


  Plot.prototype.changeSize = function (width, height) {
    this.chart.changeSize(width, height);
  };
  /**
   * 
   */


  Plot.prototype.destroy = function () {
    //  size-sensor 
    this.unbindSizeSensor(); // G2 

    this.chart.destroy(); // 

    this.off();
    this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
  };
  /**
   *  adaptor 
   */


  Plot.prototype.execAdaptor = function () {
    var adaptor = this.getSchemaAdaptor();
    var _a = this.options,
        padding = _a.padding,
        appendPadding = _a.appendPadding; //  padding

    this.chart.padding = padding; //  appendPadding

    this.chart.appendPadding = appendPadding; //  G2 API

    adaptor({
      chart: this.chart,
      options: this.options
    });
  };
  /**
   * 
   */


  Plot.prototype.triggerResize = function () {
    this.chart.forceFit();
  };
  /**
   *  dom 
   */


  Plot.prototype.bindSizeSensor = function () {
    var _this = this;

    if (this.unbind) {
      return;
    }

    var _a = this.options.autoFit,
        autoFit = _a === void 0 ? true : _a;

    if (autoFit) {
      this.unbind = size_sensor_1.bind(this.container, function () {
        // 
        var _a = utils_1.getContainerSize(_this.container),
            width = _a.width,
            height = _a.height; //  resize 


        if (width !== _this.chart.width || height !== _this.chart.height) {
          _this.triggerResize();
        }
      });
    }
  };
  /**
   * 
   */


  Plot.prototype.unbindSizeSensor = function () {
    if (this.unbind) {
      this.unbind();
      this.unbind = undefined;
    }
  };

  return Plot;
}(event_emitter_1.default);

exports.Plot = Plot;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return _area.area;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return _line.line;
  }
});
Object.defineProperty(exports, "point", {
  enumerable: true,
  get: function get() {
    return _point.point;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return _interval.interval;
  }
});
Object.defineProperty(exports, "polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.polygon;
  }
});
Object.defineProperty(exports, "edge", {
  enumerable: true,
  get: function get() {
    return _edge.edge;
  }
});

var _area = __webpack_require__(1107);

var _line = __webpack_require__(1108);

var _point = __webpack_require__(1109);

var _interval = __webpack_require__(1110);

var _polygon = __webpack_require__(517);

var _edge = __webpack_require__(1111);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "mat3", {
  enumerable: true,
  get: function get() {
    return _glMatrix.mat3;
  }
});
Object.defineProperty(exports, "vec2", {
  enumerable: true,
  get: function get() {
    return _glMatrix.vec2;
  }
});
Object.defineProperty(exports, "vec3", {
  enumerable: true,
  get: function get() {
    return _glMatrix.vec3;
  }
});
exports.ext = void 0;

var _glMatrix = __webpack_require__(381);

var ext = _interopRequireWildcard(__webpack_require__(707));

exports.ext = ext;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInPlot = exports.annotation = exports.scale = exports.scrollbar = exports.slider = exports.state = exports.theme = exports.animation = exports.interaction = exports.tooltip = exports.legend = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(290);

var utils_1 = __webpack_require__(16);
/**
 *  legend ,  colorField  seriesField 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField,
      seriesField = options.seriesField;

  if (legend === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend);
  }

  return params;
}

exports.legend = legend;
/**
 *  tooltip 
 * @param params
 */

function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;

  if (tooltip !== undefined) {
    chart.tooltip(tooltip);
  }

  return params;
}

exports.tooltip = tooltip;
/**
 * Interaction 
 * @param params
 */

function interaction(params) {
  var chart = params.chart,
      options = params.options;
  var interactions = options.interactions;
  util_1.each(interactions, function (i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}

exports.interaction = interaction;
/**
 * 
 * @param params
 */

function animation(params) {
  var chart = params.chart,
      options = params.options;
  var animation = options.animation; //  view 

  if (typeof animation === 'boolean') {
    chart.animate(animation);
  } else {
    chart.animate(true);
  } //  Geometry 


  util_1.each(chart.geometries, function (g) {
    g.animate(animation);
  });
  return params;
}

exports.animation = animation;
/**
 * 
 * @param params
 */

function theme(params) {
  var chart = params.chart,
      options = params.options;
  var theme = options.theme; // 

  if (theme) {
    chart.theme(theme);
  }

  return params;
}

exports.theme = theme;
/**
 *  state 
 * @param params
 */

function state(params) {
  var chart = params.chart,
      options = params.options;
  var state = options.state;

  if (state) {
    util_1.each(chart.geometries, function (geometry) {
      geometry.state(state);
    });
  }

  return params;
}

exports.state = state;
/**
 *  adaptor
 * @param params
 */

function slider(params) {
  var chart = params.chart,
      options = params.options;
  var slider = options.slider;
  chart.option('slider', slider);
  return params;
}

exports.slider = slider;
/**
 *  adaptor
 * @param params
 */

function scrollbar(params) {
  var chart = params.chart,
      options = params.options;
  var scrollbar = options.scrollbar;
  chart.option('scrollbar', scrollbar);
  return params;
}

exports.scrollbar = scrollbar;
/**
 * scale  adaptor
 * @param axes
 */

function scale(axes, meta) {
  return function (params) {
    var chart = params.chart,
        options = params.options; // 1.  scale 

    var scales = {};
    util_1.each(axes, function (axis, field) {
      scales[field] = utils_1.pick(axis, constant_1.AXIS_META_CONFIG_KEYS);
    }); // 2. meta  scale 

    scales = utils_1.deepAssign({}, meta, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}

exports.scale = scale;
/**
 * annotation 
 * @param params
 */

function annotation(annotationOptions) {
  return function (params) {
    var chart = params.chart,
        options = params.options;
    var annotationController = chart.getController('annotation');
    /**  annotation */

    util_1.each(tslib_1.__spreadArrays(options.annotations || [], annotationOptions || []), function (annotationOption) {
      // @ts-ignore
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}

exports.annotation = annotation;
/**
 *  limitInPlot
 * @param params
 */

function limitInPlot(params) {
  var chart = params.chart,
      options = params.options;
  var yAxis = options.yAxis,
      limitInPlot = options.limitInPlot;
  var value = limitInPlot; //  limitInPlot yAxis  min/max  limitInPlot

  if (util_1.isObject(yAxis) && util_1.isNil(limitInPlot)) {
    if (Object.values(utils_1.pick(yAxis, ['min', 'max', 'minLimit', 'maxLimit'])).some(function (value) {
      return !util_1.isNil(value);
    })) {
      value = true;
    } else {
      value = false;
    }
  }

  chart.limitInPlot = value;
  return params;
}

exports.limitInPlot = limitInPlot;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Quad", {
  enumerable: true,
  get: function get() {
    return _quadratic.default;
  }
});
Object.defineProperty(exports, "Cubic", {
  enumerable: true,
  get: function get() {
    return _cubic.default;
  }
});
Object.defineProperty(exports, "Arc", {
  enumerable: true,
  get: function get() {
    return _arc.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
exports.Util = void 0;

var _quadratic = _interopRequireDefault(__webpack_require__(748));

var _cubic = _interopRequireDefault(__webpack_require__(749));

var _arc = _interopRequireDefault(__webpack_require__(750));

var _line = _interopRequireDefault(__webpack_require__(178));

var _polygon = _interopRequireDefault(__webpack_require__(752));

var _polyline = _interopRequireDefault(__webpack_require__(398));

var Util = _interopRequireWildcard(__webpack_require__(86));

exports.Util = Util;

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g2_lib_chart_controller_annotation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(308);
/* harmony import */ var _antv_g2_lib_chart_controller_annotation__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_chart_controller_annotation__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(0);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _context_view__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(49);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_5___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_4___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }






Object(_core__WEBPACK_IMPORTED_MODULE_10__["registerComponentController"])('annotation', _antv_g2_lib_chart_controller_annotation__WEBPACK_IMPORTED_MODULE_7___default.a); // 4.0Annotation

var Annotation = /*#__PURE__*/function (_React$Component) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_3___default()(Annotation, _React$Component);

  var _super = _createSuper(Annotation);

  function Annotation() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_1___default()(this, Annotation);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'line'; // lineguide

    return _this;
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_2___default()(Annotation, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var chartIns = this.getChartIns();
      this.id = _antv_util__WEBPACK_IMPORTED_MODULE_8__["uniqueId"]('annotation');
      this.annotation = chartIns.annotation();
      this.annotation[this.annotationType](this.props);
      this.annotation.option[this.annotation.option.length - 1].__id = this.id;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var _this2 = this;

      var index = null;
      this.annotation.option.forEach(function (item, i) {
        if (item.__id === _this2.id) {
          index = i;
        }
      });
      this.annotation.option[index] = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        type: this.annotationType
      }, this.props), {
        __id: this.id
      }); // fixme: view

      this.getChartIns().render();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var _this3 = this;

      var index = null;

      if (!this.annotation) {
        return;
      }

      this.annotation.option.forEach(function (item, i) {
        if (item.__id === _this3.id) {
          index = i;
        }
      });

      if (index !== null) {
        this.annotation.option.splice(index, 1);
      }

      this.annotation = null;
    }
  }, {
    key: "getChartIns",
    value: function getChartIns() {
      return this.context;
    }
  }, {
    key: "render",
    value: function render() {
      return null;
    }
  }]);

  return Annotation;
}(react__WEBPACK_IMPORTED_MODULE_6___default.a.Component);

Annotation.contextType = _context_view__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"];
/* harmony default export */ __webpack_exports__["a"] = (Annotation);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: IBaseGemoProps

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(46);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js
var is_string = __webpack_require__(50);
var is_string_default = /*#__PURE__*/__webpack_require__.n(is_string);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/geometry/label/base.js
var base = __webpack_require__(99);
var base_default = /*#__PURE__*/__webpack_require__.n(base);

// EXTERNAL MODULE: ./src/interface.ts
var src_interface = __webpack_require__(474);

// EXTERNAL MODULE: ./src/context/view.tsx
var view = __webpack_require__(49);

// EXTERNAL MODULE: ./src/core.ts
var core = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js
var each = __webpack_require__(56);
var each_default = /*#__PURE__*/__webpack_require__.n(each);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./src/utils/shallowEqual.ts
var shallowEqual = __webpack_require__(81);

// CONCATENATED MODULE: ./src/utils/compareProps.ts
/**
 * 
*/



/* harmony default export */ var compareProps = (function (preProps, nextProps, keys, callback) {
  // preProps null 
  if (preProps === null) {
    each_default()(keys, function (key) {
      var value = nextProps[key];

      if (value !== undefined) {
        if (!is_array_default()(value)) {
          value = [value];
        }

        callback(value, key);
      }
    });

    return;
  }

  var value;
  var nextValue;

  each_default()(keys, function (key) {
    value = preProps[key];
    nextValue = nextProps[key];

    if (!Object(shallowEqual["a" /* default */])(nextValue, value)) {
      if (!is_array_default()(nextValue)) {
        nextValue = [nextValue];
      }

      callback(nextValue, key);
    }
  });
});
// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// EXTERNAL MODULE: ./src/geometry/Label.tsx
var Label = __webpack_require__(289);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/active.js
var active = __webpack_require__(339);
var active_default = /*#__PURE__*/__webpack_require__.n(active);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/link-by-color.js
var link_by_color = __webpack_require__(340);
var link_by_color_default = /*#__PURE__*/__webpack_require__.n(link_by_color);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/range-active.js
var range_active = __webpack_require__(341);
var range_active_default = /*#__PURE__*/__webpack_require__.n(range_active);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/single-active.js
var single_active = __webpack_require__(342);
var single_active_default = /*#__PURE__*/__webpack_require__.n(single_active);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/highlight.js
var highlight = __webpack_require__(165);
var highlight_default = /*#__PURE__*/__webpack_require__.n(highlight);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/highlight-by-x.js
var highlight_by_x = __webpack_require__(344);
var highlight_by_x_default = /*#__PURE__*/__webpack_require__.n(highlight_by_x);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/highlight-by-color.js
var highlight_by_color = __webpack_require__(343);
var highlight_by_color_default = /*#__PURE__*/__webpack_require__.n(highlight_by_color);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/single-highlight.js
var single_highlight = __webpack_require__(345);
var single_highlight_default = /*#__PURE__*/__webpack_require__.n(single_highlight);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/range-highlight.js
var range_highlight = __webpack_require__(224);
var range_highlight_default = /*#__PURE__*/__webpack_require__.n(range_highlight);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/selected.js
var selected = __webpack_require__(347);
var selected_default = /*#__PURE__*/__webpack_require__.n(selected);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/single-selected.js
var single_selected = __webpack_require__(348);
var single_selected_default = /*#__PURE__*/__webpack_require__.n(single_selected);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/element/range-selected.js
var range_selected = __webpack_require__(346);
var range_selected_default = /*#__PURE__*/__webpack_require__.n(range_selected);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/cursor.js
var cursor = __webpack_require__(352);
var cursor_default = /*#__PURE__*/__webpack_require__.n(cursor);

// CONCATENATED MODULE: ./src/geometry/actions.ts
// TODO: element 














Object(core["registerAction"])('cursor', cursor_default.a);
Object(core["registerAction"])('element-active', active_default.a);
Object(core["registerAction"])('element-single-active', single_active_default.a);
Object(core["registerAction"])('element-range-active', range_active_default.a);
Object(core["registerAction"])('element-highlight', highlight_default.a);
Object(core["registerAction"])('element-highlight-by-x', highlight_by_x_default.a);
Object(core["registerAction"])('element-highlight-by-color', highlight_by_color_default.a);
Object(core["registerAction"])('element-single-highlight', single_highlight_default.a);
Object(core["registerAction"])('element-range-highlight', range_highlight_default.a);
Object(core["registerAction"])('element-sibling-highlight', range_highlight_default.a, {
  effectSiblings: true,
  effectByRecord: true
});
Object(core["registerAction"])('element-selected', selected_default.a);
Object(core["registerAction"])('element-single-selected', single_selected_default.a);
Object(core["registerAction"])('element-range-selected', range_selected_default.a);
Object(core["registerAction"])('element-link-by-color', link_by_color_default.a); //  elment  active

Object(core["registerInteraction"])('element-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-active:active'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-active:reset'
  }]
}); // 

Object(core["registerInteraction"])('element-selected', {
  start: [{
    trigger: 'element:click',
    action: 'element-selected:toggle'
  }]
}); // hover highlight

Object(core["registerInteraction"])('element-highlight', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight:reset'
  }]
}); // hover highlight by x

Object(core["registerInteraction"])('element-highlight-by-x', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-x:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-x:reset'
  }]
}); // hover highlight by y

Object(core["registerInteraction"])('element-highlight-by-color', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'element-highlight-by-color:highlight'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'element-highlight-by-color:reset'
  }]
});
// EXTERNAL MODULE: ./src/utils/cloneDeep.ts
var cloneDeep = __webpack_require__(80);

// CONCATENATED MODULE: ./src/geometry/Base.tsx







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }










 // 



Object(core["registerGeometryLabel"])('base', base_default.a);

var DEFAULT_SORT_GEOMETRYS = ['line', 'area'];

var Base_GeomHelper = /*#__PURE__*/function () {
  function GeomHelper() {
    classCallCheck_default()(this, GeomHelper);

    this.config = {};
  }

  createClass_default()(GeomHelper, [{
    key: "setView",
    value: function setView(view) {
      this.view = view;
      this.rootChart = view.rootChart || view; // chart
    }
  }, {
    key: "createGeomInstance",
    value: function createGeomInstance(GemoBaseClassName, cfg) {
      this.geom = this.view[GemoBaseClassName](cfg);
      var sortable = cfg.sortable; // 
      // @ts-ignore

      this.geom.__beforeMapping = this.geom.beforeMapping; // @ts-ignore

      this.geom.beforeMapping = function (data) {
        var xScale = this.getXScale();

        if (sortable !== false && data && data[0] && DEFAULT_SORT_GEOMETRYS.includes(GemoBaseClassName) && ['time', 'timeCat'].includes(xScale.type)) {
          this.sort(data);
        }

        return this.__beforeMapping(data);
      };

      this.GemoBaseClassName = GemoBaseClassName;
    }
  }, {
    key: "update",
    value: function update(newConfig, component) {
      var _this = this;

      if (!this.geom) {
        this.setView(component.context);
        var sortable = newConfig.sortable,
            visible = newConfig.visible,
            connectNulls = newConfig.connectNulls;
        var cfg = {
          sortable: sortable,
          visible: visible,
          connectNulls: connectNulls
        }; // 

        this.createGeomInstance(component.GemoBaseClassName, cfg);
        this.interactionTypes = component.interactionTypes;
      }

      compareProps(this.config, newConfig, ['position', 'shape', 'color', 'label', 'style', 'tooltip', 'size', 'animate', 'state'], function (value, key) {
        var _this$geom;

        // value array
        warning_default()(!(key === 'label' && value[0] === true), 'label false | LabelOption | FieldString');

        (_this$geom = _this.geom)[key].apply(_this$geom, toConsumableArray_default()(value));
      });
      compareProps(this.config, newConfig, ['adjust'], function (value, key) {
        if (is_string_default()(value[0])) {
          _this.geom[key](value[0]);
        } else {
          _this.geom[key](value);
        }
      }); // 

      this.geom.state(newConfig.state || {}); // selected  active  interacttion 
      // setElements  selected  active 

      this.rootChart.on('processElemens', function () {
        if (is_function_default()(newConfig.setElements)) {
          newConfig.setElements(_this.geom.elements);
        }
      }); // 
      // interaction 

      compareProps(this.config, newConfig, this.interactionTypes, function (value, key) {
        if (value[0]) {
          _this.rootChart.interaction(key);
        } else {
          _this.rootChart.removeInteraction(key);
        }
      }); // 

      this.config = Object(cloneDeep["a" /* default */])(newConfig);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.geom) {
        this.geom.destroy();
        this.geom = null;
      }

      this.config = {};
    }
  }]);

  return GeomHelper;
}();

var Base_BaseGeom = /*#__PURE__*/function (_React$Component) {
  inherits_default()(BaseGeom, _React$Component);

  var _super = _createSuper(BaseGeom);

  function BaseGeom(props) {
    var _this2;

    classCallCheck_default()(this, BaseGeom);

    _this2 = _super.call(this, props);
    _this2.interactionTypes = [];
    _this2.geomHelper = new Base_GeomHelper();
    return _this2;
  }

  createClass_default()(BaseGeom, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.geomHelper.destroy();
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      this.geomHelper.update(this.props, this);
      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null, external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Children.map(this.props.children, function (ele) {
        return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.isValidElement(ele) ? /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.cloneElement(ele, {
          parentInstance: _this3.geomHelper.geom
        }) : /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null);
      }));
    }
  }]);

  return BaseGeom;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

Base_BaseGeom.contextType = view["a" /* default */];
/* harmony default export */ var Base = __webpack_exports__["a"] = (Base_BaseGeom);

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
}); // isFinite,

var isNil = function isNil(value) {
  /**
   * isNil(null) => true
   * isNil() => true
   */
  return value === null || value === undefined;
};

exports.default = isNil;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

var _default = function _default(value) {
  return Array.isArray ? Array.isArray(value) : (0, _isType.default)(value, 'Array');
};

exports.default = _default;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBackgroundRectStyle = exports.getStyle = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);
/**
 * @ignore
 *  Shape 
 * @param cfg
 * @param isStroke 
 * @param isFill 
 * @param [sizeName] lineWidth  r
 * @returns
 */


function getStyle(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = '';
  }

  var _a = cfg.style,
      style = _a === void 0 ? {} : _a,
      defaultStyle = cfg.defaultStyle,
      color = cfg.color,
      size = cfg.size;

  var attrs = tslib_1.__assign(tslib_1.__assign({}, defaultStyle), style);

  if (color) {
    if (isStroke) {
      if (!style.stroke) {
        //  style()  stroke
        attrs.stroke = color;
      }
    }

    if (isFill) {
      if (!style.fill) {
        //  style()  fill
        attrs.fill = color;
      }
    }
  }

  if (sizeName && util_1.isNil(style[sizeName]) && !util_1.isNil(size)) {
    //  style()  lineWidth  r 
    attrs[sizeName] = size;
  }

  return attrs;
}

exports.getStyle = getStyle;
/**
 *   
 * @param cfg
 */

function getBackgroundRectStyle(cfg) {
  return util_1.deepMix({}, {
    // copy from active-region
    fill: '#CCD6EC',
    fillOpacity: 0.3
  }, util_1.get(cfg, ['background', 'style']));
}

exports.getBackgroundRectStyle = getBackgroundRectStyle;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayWithHoles = __webpack_require__(982);

var iterableToArrayLimit = __webpack_require__(983);

var unsupportedIterableToArray = __webpack_require__(469);

var nonIterableRest = __webpack_require__(984);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return useView; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _context_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);


function useView() {
  // @ts-ignore
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_view__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);
}

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _event = __webpack_require__(419);

var _matrix = __webpack_require__(87);

var _util2 = __webpack_require__(44);

var _component = _interopRequireDefault(__webpack_require__(252));

var STATUS_UPDATE = 'update_status';
var COPY_PROPERTIES = ['visible', 'tip', 'delegateObject']; // 

var COPY_PROPERTIES_EXCLUDES = ['container', 'group', 'shapesMap', 'isRegister', 'isUpdating', 'destroyed']; // 

var GroupComponent =
/** @class */
function (_super) {
  (0, _tslib.__extends)(GroupComponent, _super);

  function GroupComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GroupComponent.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      container: null,

      /**
       * @private
       *  Map
       */
      shapesMap: {},
      group: null,
      capture: true,

      /**
       * @private 
       * @type {false}
       */
      isRegister: false,

      /**
       * @private 
       * @type {false}
       */
      isUpdating: false,

      /**
       * @private
       *  renderupdate  false, clear 
       */
      isInit: true
    });
  };

  GroupComponent.prototype.remove = function () {
    this.clear();
    var group = this.get('group');
    group.remove();
  };

  GroupComponent.prototype.clear = function () {
    var group = this.get('group');
    group.clear();
    this.set('shapesMap', {});
    this.clearOffScreenCache();
    this.set('isInit', true);
  };

  GroupComponent.prototype.getChildComponentById = function (id) {
    var group = this.getElementById(id);
    var inst = group && group.get('component');
    return inst;
  };

  GroupComponent.prototype.getElementById = function (id) {
    return this.get('shapesMap')[id];
  };

  GroupComponent.prototype.getElementByLocalId = function (localId) {
    var id = this.getElementId(localId);
    return this.getElementById(id);
  };

  GroupComponent.prototype.getElementsByName = function (name) {
    var rst = [];
    (0, _util.each)(this.get('shapesMap'), function (elem) {
      if (elem.get('name') === name) {
        rst.push(elem);
      }
    });
    return rst;
  };

  GroupComponent.prototype.getContainer = function () {
    return this.get('container');
  };

  GroupComponent.prototype.updateInner = function (cfg) {
    // this.updateInner();
    // this.set('isUpdating', false);
    this.offScreenRender();

    if (this.get('updateAutoRender')) {
      this.render();
    }
  };

  GroupComponent.prototype.render = function () {
    var offScreenGroup = this.get('offScreenGroup');

    if (!offScreenGroup) {
      offScreenGroup = this.offScreenRender();
    }

    var group = this.get('group');
    this.updateElements(offScreenGroup, group);
    this.deleteElements();
    this.applyOffset();

    if (!this.get('eventInitted')) {
      this.initEvent();
      this.set('eventInitted', true);
    }

    this.set('isInit', false);
  };

  GroupComponent.prototype.show = function () {
    var group = this.get('group');
    group.show();
    this.set('visible', true);
  };

  GroupComponent.prototype.hide = function () {
    var group = this.get('group');
    group.hide();
    this.set('visible', false);
  };

  GroupComponent.prototype.setCapture = function (capture) {
    var group = this.get('group');
    group.set('capture', capture);
    this.set('capture', capture);
  };

  GroupComponent.prototype.destroy = function () {
    this.removeEvent();
    this.remove();

    _super.prototype.destroy.call(this);
  };

  GroupComponent.prototype.getBBox = function () {
    return this.get('group').getCanvasBBox();
  };

  GroupComponent.prototype.getLayoutBBox = function () {
    var group = this.get('group'); //  clear offScreenBBox 

    var bbox = this.getInnerLayoutBBox();
    var matrix = group.getTotalMatrix();

    if (matrix) {
      bbox = (0, _matrix.applyMatrix2BBox)(matrix, bbox);
    }

    return bbox; //  getBBox
  }; //  on, off, emit  group


  GroupComponent.prototype.on = function (evt, callback, once) {
    var group = this.get('group');
    group.on(evt, callback, once);
    return this;
  };

  GroupComponent.prototype.off = function (evt, callback) {
    var group = this.get('group');
    group && group.off(evt, callback);
    return this;
  };

  GroupComponent.prototype.emit = function (eventName, eventObject) {
    var group = this.get('group');
    group.emit(eventName, eventObject);
  };

  GroupComponent.prototype.init = function () {
    _super.prototype.init.call(this);

    if (!this.get('group')) {
      this.initGroup();
    }

    this.offScreenRender(); //  group
  }; // 


  GroupComponent.prototype.getInnerLayoutBBox = function () {
    return this.get('offScreenBBox') || this.get('group').getBBox();
  }; // 


  GroupComponent.prototype.delegateEmit = function (eventName, eventObject) {
    var group = this.get('group');
    eventObject.target = group;
    group.emit(eventName, eventObject);
    (0, _event.propagationDelegate)(group, eventName, eventObject);
  }; //  group , canvas 


  GroupComponent.prototype.createOffScreenGroup = function () {
    var group = this.get('group');
    var GroupClass = group.getGroupBase(); // 

    var newGroup = new GroupClass({
      delegateObject: this.getDelegateObject()
    });
    return newGroup;
  }; //  offset


  GroupComponent.prototype.applyOffset = function () {
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    this.moveElementTo(this.get('group'), {
      x: offsetX,
      y: offsetY
    });
  };

  GroupComponent.prototype.initGroup = function () {
    var container = this.get('container');
    this.set('group', container.addGroup({
      id: this.get('id'),
      name: this.get('name'),
      capture: this.get('capture'),
      visible: this.get('visible'),
      isComponent: true,
      component: this,
      delegateObject: this.getDelegateObject()
    }));
  }; // 


  GroupComponent.prototype.offScreenRender = function () {
    this.clearOffScreenCache();
    var offScreenGroup = this.createOffScreenGroup();
    this.renderInner(offScreenGroup);
    this.set('offScreenGroup', offScreenGroup); //  bbox

    this.set('offScreenBBox', (0, _util2.getBBoxWithClip)(offScreenGroup));
    return offScreenGroup;
  };
  /**
   * @protected
   *  isReigeter 
   * @param {IGroup} parent 
   * @param {object} cfg    
   */


  GroupComponent.prototype.addGroup = function (parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var group = parent.addGroup(cfg);

    if (this.get('isRegister')) {
      this.registerElement(group);
    }

    return group;
  };
  /**
   * @protected
   *  isReigeter 
   * @param {IGroup} parent 
   * @param {object} cfg    
   */


  GroupComponent.prototype.addShape = function (parent, cfg) {
    this.appendDelegateObject(parent, cfg);
    var shape = parent.addShape(cfg);

    if (this.get('isRegister')) {
      this.registerElement(shape);
    }

    return shape;
  };
  /**
   * 
   *
   * @param parent 
   * @param cfg 
   */


  GroupComponent.prototype.addComponent = function (parent, cfg) {
    var id = cfg.id,
        Ctor = cfg.component,
        restCfg = (0, _tslib.__rest)(cfg, ["id", "component"]); // @ts-ignore

    var inst = new Ctor((0, _tslib.__assign)((0, _tslib.__assign)({}, restCfg), {
      id: id,
      container: parent,
      updateAutoRender: this.get('updateAutoRender')
    }));
    inst.init();
    inst.render();

    if (this.get('isRegister')) {
      this.registerElement(inst.get('group'));
    }

    return inst;
  };

  GroupComponent.prototype.initEvent = function () {};

  GroupComponent.prototype.removeEvent = function () {
    var group = this.get('group');
    group.off();
  };

  GroupComponent.prototype.getElementId = function (localId) {
    var id = this.get('id'); //  Id

    var name = this.get('name'); // 

    return id + "-" + name + "-" + localId;
  };

  GroupComponent.prototype.registerElement = function (element) {
    var id = element.get('id');
    this.get('shapesMap')[id] = element;
  };

  GroupComponent.prototype.unregisterElement = function (element) {
    var id = element.get('id');
    delete this.get('shapesMap')[id];
  }; // 


  GroupComponent.prototype.moveElementTo = function (element, point) {
    var matrix = (0, _matrix.getMatrixByTranslate)(point);
    element.attr('matrix', matrix);
  };
  /**
   *  0 
   * @protected
   * @param {string} elmentName 
   * @param {IElement} newElement  
   * @param {object} animateCfg 
   */


  GroupComponent.prototype.addAnimation = function (elmentName, newElement, animateCfg) {
    // 
    var originOpacity = newElement.attr('opacity');

    if ((0, _util.isNil)(originOpacity)) {
      originOpacity = 1;
    }

    newElement.attr('opacity', 0);
    newElement.animate({
      opacity: originOpacity
    }, animateCfg);
  };
  /**
   *  0 
   * @protected
   * @param {string} elmentName 
   * @param {IElement} originElement 
   * @param {object} animateCfg 
   */


  GroupComponent.prototype.removeAnimation = function (elementName, originElement, animateCfg) {
    originElement.animate({
      opacity: 0
    }, animateCfg);
  };
  /**
   * 
   * @param {string} elmentName 
   * @param {IElement} originElement 
   * @param {object} newAttrs  
   * @param {object} animateCfg 
   */


  GroupComponent.prototype.updateAnimation = function (elementName, originElement, newAttrs, animateCfg) {
    originElement.animate(newAttrs, animateCfg);
  }; // 


  GroupComponent.prototype.updateElements = function (newGroup, originGroup) {
    var _this = this;

    var animate = this.get('animate');
    var animateOption = this.get('animateOption');
    var children = newGroup.getChildren().slice(0); //  originGroup  children 

    var preElement; // 

    (0, _util.each)(children, function (element) {
      var elementId = element.get('id');

      var originElement = _this.getElementById(elementId);

      var elementName = element.get('name');

      if (originElement) {
        if (element.get('isComponent')) {
          // 
          var childComponent = element.get('component');
          var origChildComponent = originElement.get('component');
          var newCfg = (0, _util.pick)(childComponent.cfg, (0, _util.difference)((0, _util.keys)(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
          origChildComponent.update(newCfg);
          originElement.set(STATUS_UPDATE, 'update');
        } else {
          var replaceAttrs = _this.getReplaceAttrs(originElement, element); // 


          if (animate && animateOption.update) {
            // 
            _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
          } else {
            // originElement.attrs = replaceAttrs; // 
            originElement.attr(replaceAttrs);
          } // 


          if (element.isGroup()) {
            _this.updateElements(element, originElement);
          } // 


          (0, _util.each)(COPY_PROPERTIES, function (name) {
            originElement.set(name, element.get(name));
          });
          (0, _util2.updateClip)(originElement, element);
          preElement = originElement; // 

          originElement.set(STATUS_UPDATE, 'update');
        }
      } else {
        // 
        originGroup.add(element); //  group  insertAt 

        var siblings = originGroup.getChildren(); // 

        siblings.splice(siblings.length - 1, 1); // 

        if (preElement) {
          // 
          var index = siblings.indexOf(preElement);
          siblings.splice(index + 1, 0, element); // 
        } else {
          siblings.unshift(element);
        }

        _this.registerElement(element); // 


        element.set(STATUS_UPDATE, 'add'); // 

        if (element.get('isComponent')) {
          // container
          var childComponent = element.get('component');
          childComponent.set('container', originGroup);
        } else if (element.isGroup()) {
          // 
          _this.registerNewGroup(element);
        }

        preElement = element;

        if (animate) {
          var animateCfg = _this.get('isInit') ? animateOption.appear : animateOption.enter;

          if (animateCfg) {
            _this.addAnimation(elementName, element, animateCfg);
          }
        }
      }
    });
  };

  GroupComponent.prototype.clearUpdateStatus = function (group) {
    var children = group.getChildren();
    (0, _util.each)(children, function (el) {
      el.set(STATUS_UPDATE, null); // 
    });
  }; // 


  GroupComponent.prototype.clearOffScreenCache = function () {
    var offScreenGroup = this.get('offScreenGroup');

    if (offScreenGroup) {
      //  Group
      offScreenGroup.destroy();
    }

    this.set('offScreenGroup', null);
    this.set('offScreenBBox', null);
  }; // private updateInner() {
  //   const group = this.get('group');
  //   const newGroup = this.createOffScreenGroup();
  //   this.renderInner(newGroup);
  //   this.applyOffset();
  //   this.updateElements(newGroup, group);
  //   this.deleteElements();
  //   newGroup.destroy(); // 
  // }
  // 


  GroupComponent.prototype.getDelegateObject = function () {
    var _a;

    var name = this.get('name');
    var delegateObject = (_a = {}, _a[name] = this, _a.component = this, _a);
    return delegateObject;
  }; // 


  GroupComponent.prototype.appendDelegateObject = function (parent, cfg) {
    var parentObject = parent.get('delegateObject');

    if (!cfg.delegateObject) {
      cfg.delegateObject = {};
    }

    (0, _util.mix)(cfg.delegateObject, parentObject); // 
  }; //  undefined


  GroupComponent.prototype.getReplaceAttrs = function (originElement, newElement) {
    var originAttrs = originElement.attr();
    var newAttrs = newElement.attr();
    (0, _util.each)(originAttrs, function (v, k) {
      if (newAttrs[k] === undefined) {
        newAttrs[k] = undefined;
      }
    });
    return newAttrs;
  };

  GroupComponent.prototype.registerNewGroup = function (group) {
    var _this = this;

    var children = group.getChildren();
    (0, _util.each)(children, function (element) {
      _this.registerElement(element); // 


      element.set(STATUS_UPDATE, 'add'); // 

      if (element.isGroup()) {
        _this.registerNewGroup(element);
      }
    });
  }; // 


  GroupComponent.prototype.deleteElements = function () {
    var _this = this;

    var shapesMap = this.get('shapesMap');
    var deleteArray = []; // 

    (0, _util.each)(shapesMap, function (element, id) {
      if (!element.get(STATUS_UPDATE) || element.destroyed) {
        deleteArray.push([id, element]);
      } else {
        element.set(STATUS_UPDATE, null); // 
      }
    });
    var animate = this.get('animate');
    var animateOption = this.get('animateOption'); // 

    (0, _util.each)(deleteArray, function (item) {
      var id = item[0],
          element = item[1];

      if (!element.destroyed) {
        var elementName = element.get('name');

        if (animate && animateOption.leave) {
          // 
          var callbackAnimCfg = (0, _util.mix)({
            callback: function callback() {
              _this.removeElement(element);
            }
          }, animateOption.leave);

          _this.removeAnimation(elementName, element, callbackAnimCfg);
        } else {
          _this.removeElement(element);
        }
      }

      delete shapesMap[id]; // 
    });
  };

  GroupComponent.prototype.removeElement = function (element) {
    if (element.get('isGroup')) {
      var component = element.get('component');

      if (component) {
        component.destroy();
      }
    }

    element.remove();
  };

  return GroupComponent;
}(_component.default);

var _default = GroupComponent;
exports.default = _default;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatPadding = formatPadding;
exports.clearDom = clearDom;
exports.hasClass = hasClass;
exports.regionToBBox = regionToBBox;
exports.pointsToBBox = pointsToBBox;
exports.createBBox = createBBox;
exports.getValueByPercent = getValueByPercent;
exports.getCirclePoint = getCirclePoint;
exports.distance = distance;
exports.intersectBBox = intersectBBox;
exports.mergeBBox = mergeBBox;
exports.getBBoxWithClip = getBBoxWithClip;
exports.updateClip = updateClip;
exports.toPx = toPx;
exports.getTextPoint = getTextPoint;
exports.near = exports.wait = void 0;

var _util = __webpack_require__(0);

function formatPadding(padding) {
  var top = 0;
  var left = 0;
  var right = 0;
  var bottom = 0;

  if ((0, _util.isNumber)(padding)) {
    top = left = right = bottom = padding;
  } else if ((0, _util.isArray)(padding)) {
    top = padding[0];
    right = !(0, _util.isNil)(padding[1]) ? padding[1] : padding[0];
    bottom = !(0, _util.isNil)(padding[2]) ? padding[2] : padding[0];
    left = !(0, _util.isNil)(padding[3]) ? padding[3] : right;
  }

  return [top, right, bottom, left];
}

function clearDom(container) {
  var children = container.childNodes;
  var length = children.length;

  for (var i = length - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}

function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}

function regionToBBox(region) {
  var start = region.start,
      end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}

function pointsToBBox(points) {
  var xs = points.map(function (point) {
    return point.x;
  });
  var ys = points.map(function (point) {
    return point.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}

function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY = y + height;
  return {
    x: x,
    y: y,
    width: width,
    height: height,
    minX: x,
    minY: y,
    //  js 
    // Infinity + Infinity = Infinity
    // Infinity - Infinity = NaN
    // fixed https://github.com/antvis/G2Plot/issues/1243
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY) ? 0 : maxY
  };
}

function getValueByPercent(min, max, percent) {
  return (1 - percent) * min + max * percent;
}

function getCirclePoint(center, radius, angle) {
  return {
    x: center.x + Math.cos(angle) * radius,
    y: center.y + Math.sin(angle) * radius
  };
}

function distance(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}

var wait = function wait(interval) {
  return new Promise(function (resolve) {
    setTimeout(resolve, interval);
  });
};
/**
 *  
 * -   
 */


exports.wait = wait;

var near = function near(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }

  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};

exports.near = near;

function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}

function mergeBBox(box1, box2) {
  var minX = Math.min(box1.minX, box2.minX);
  var minY = Math.min(box1.minY, box2.minY);
  var maxX = Math.max(box1.maxX, box2.maxX);
  var maxY = Math.max(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY - minY);
}

function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;

  if (!element.isGroup()) {
    // 
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();

    if (children.length > 0) {
      (0, _util.each)(children, function (child) {
        if (child.get('visible')) {
          // 
          if (child.isGroup() && child.get('children').length === 0) {
            return true;
          }

          var box = getBBoxWithClip(child); //  4 

          var leftTop = child.applyToMatrix([box.minX, box.minY, 1]);
          var leftBottom = child.applyToMatrix([box.minX, box.maxY, 1]);
          var rightTop = child.applyToMatrix([box.maxX, box.minY, 1]);
          var rightBottom = child.applyToMatrix([box.maxX, box.maxY, 1]); // 

          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);

          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }

          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }

          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }

          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }

    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }

  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}

function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    //  clip
    return;
  }

  var newClipShape = newElement.getClip();

  if (!newClipShape) {
    //  element  clip
    element.setClip(null); //  clip

    return;
  }

  var clipCfg = {
    type: newClipShape.get('type'),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}

function toPx(number) {
  return number + "px";
}

function getTextPoint(start, end, position, offset) {
  var lineLength = distance(start, end);
  var offsetPercent = offset / lineLength; // 

  var percent = 0;

  if (position === 'start') {
    percent = 0 - offsetPercent;
  } else if (position === 'end') {
    percent = 1 + offsetPercent;
  }

  return {
    x: getValueByPercent(start.x, end.x, percent),
    y: getValueByPercent(start.y, end.y, percent)
  };
}

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getReplaceAttrs = exports.getPolygonCentroid = exports.getAngle = exports.getArcPath = exports.getSectorPath = exports.polarToCartesian = void 0;

var util_1 = __webpack_require__(0); // 


function getPointsBox(points) {
  if (util_1.isEmpty(points)) {
    return null;
  }

  var minX = points[0].x;
  var maxX = points[0].x;
  var minY = points[0].y;
  var maxY = points[0].y;
  util_1.each(points, function (point) {
    minX = minX > point.x ? point.x : minX;
    maxX = maxX < point.x ? point.x : maxX;
    minY = minY > point.y ? point.y : minY;
    maxY = maxY < point.y ? point.y : maxY;
  });
  return {
    minX: minX,
    maxX: maxX,
    minY: minY,
    maxY: maxY,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2
  };
}
/**
 * @ignore
 * 
 * @param centerX
 * @param centerY
 * @param radius
 * @param angleInRadian
 * @returns
 */


function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}

exports.polarToCartesian = polarToCartesian;
/**
 * @ignore
 *  path
 * @param centerX
 * @param centerY
 * @param radius
 * @param startAngleInRadian
 * @param endAngleInRadian
 * @returns
 */

function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }

  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);

  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    // 
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, end.x, end.y], ['M', innerStart.x, innerStart.y]];

    if (innerRadius) {
      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(['A', innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }

    circlePathCommands.push(['M', start.x, start.y]);
    circlePathCommands.push(['Z']);
    return circlePathCommands;
  }

  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y], ['L', innerEnd.x, innerEnd.y]];

  if (innerRadius) {
    sectorPathCommands.push(['A', innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }

  sectorPathCommands.push(['L', start.x, start.y]);
  sectorPathCommands.push(['Z']);
  return sectorPathCommands;
}

exports.getSectorPath = getSectorPath;
/**
 * @ignore
 * Gets arc path
 * @param centerX
 * @param centerY
 * @param radius
 * @param startAngleInRadian
 * @param endAngleInRadian
 * @returns
 */

function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);

  if (util_1.isNumberEqual(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [['M', start.x, start.y], ['A', radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 1, start.x, start.y], ['A', radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y], ['A', radius, radius, 0, 1, 0, start.x, start.y], ['Z']];
  }

  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [['M', start.x, start.y], ['A', radius, radius, 0, arcSweep, 1, end.x, end.y]];
}

exports.getArcPath = getArcPath;
/**
 * @ignore
 *  points 
 * @param shapeModel
 * @param coordinate
 * @returns
 */

function getAngle(shapeModel, coordinate) {
  var points = shapeModel.points;
  var box = getPointsBox(points);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate.startAngle,
      coordEndAngle = coordinate.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;

  if (coordinate.isTransposed) {
    endAngle = box.maxY * diffAngle;
    startAngle = box.minY * diffAngle;
  } else {
    endAngle = box.maxX * diffAngle;
    startAngle = box.minX * diffAngle;
  }

  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle: startAngle,
    endAngle: endAngle
  };
}

exports.getAngle = getAngle;
/**
 * @ignore
 * : https://en.wikipedia.org/wiki/Centroid#Of_a_polygon
 */

function getPolygonCentroid(xs, ys) {
  if (util_1.isNumber(xs) && util_1.isNumber(ys)) {
    // xs  ys 
    return [xs, ys];
  }

  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff;
  var k = 0;

  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff;
    y += (ys[former] + ys[current]) * diff;
  }

  k *= 3;
  return [x / k, y / k];
}

exports.getPolygonCentroid = getPolygonCentroid;
/**
 * @ignore
 *  undefined
 */

function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  util_1.each(originAttrs, function (v, k) {
    if (newAttrs[k] === undefined) {
      newAttrs[k] = undefined;
    }
  });
  return newAttrs;
}

exports.getReplaceAttrs = getReplaceAttrs;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayWithoutHoles = __webpack_require__(985);

var iterableToArray = __webpack_require__(986);

var unsupportedIterableToArray = __webpack_require__(469);

var nonIterableSpread = __webpack_require__(987);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);
/**
 * Action 
 */


var Action =
/** @class */
function () {
  function Action(context, cfg) {
    this.context = context;
    this.cfg = cfg;
    context.addAction(this);
  }
  /**
   * 
   * @param cfg
   */


  Action.prototype.applyCfg = function (cfg) {
    util_1.assign(this, cfg);
  };
  /**
   * Inits action
   */


  Action.prototype.init = function () {
    this.applyCfg(this.cfg);
  };
  /**
   * Destroys action
   */


  Action.prototype.destroy = function () {
    //  action
    this.context.removeAction(this); // 

    this.context = null;
  };

  return Action;
}();

exports.default = Action;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var area_1 = __webpack_require__(1009);

Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return area_1.area;
  }
});

var line_1 = __webpack_require__(1010);

Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return line_1.line;
  }
});

var point_1 = __webpack_require__(1011);

Object.defineProperty(exports, "point", {
  enumerable: true,
  get: function get() {
    return point_1.point;
  }
});

var interval_1 = __webpack_require__(1012);

Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return interval_1.interval;
  }
});

var polygon_1 = __webpack_require__(488);

Object.defineProperty(exports, "polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.polygon;
  }
});

var edge_1 = __webpack_require__(1013);

Object.defineProperty(exports, "edge", {
  enumerable: true,
  get: function get() {
    return edge_1.edge;
  }
});

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return withView; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);

 // chart  view

var ChartViewContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
ChartViewContext.displayName = 'ChartViewContext';
var Consumer = ChartViewContext.Consumer;
function withView(Component) {
  return function (props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Consumer, null, function (ctx) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        chartView: ctx
      }, props));
    });
  };
}
/* harmony default export */ __webpack_exports__["a"] = (ChartViewContext);

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_type_1 = __webpack_require__(117);

exports.default = function (str) {
  return is_type_1.default(str, 'String');
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCoordinateBBox = exports.getCoordinateClipCfg = exports.getAngleByPoint = exports.isPointInCoordinate = exports.getDistanceToCenter = exports.isFullCircle = exports.getXDimensionLength = void 0;

var graphics_1 = __webpack_require__(45);

var helper_1 = __webpack_require__(76);

var bbox_1 = __webpack_require__(77);
/**
 * @ignore
 * Gets x dimension length
 * @param coordinate
 * @returns x dimension length
 */


function getXDimensionLength(coordinate) {
  if (coordinate.isPolar && !coordinate.isTransposed) {
    //  width 
    return (coordinate.endAngle - coordinate.startAngle) * coordinate.getRadius();
  } // 


  var start = coordinate.convert({
    x: 0,
    y: 0
  });
  var end = coordinate.convert({
    x: 1,
    y: 0
  }); //  transpose 

  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}

exports.getXDimensionLength = getXDimensionLength;
/**
 * @ignore
 * Determines whether full circle is
 * @param coordinate
 * @returns true if full circle
 */

function isFullCircle(coordinate) {
  if (coordinate.isPolar) {
    var startAngle = coordinate.startAngle,
        endAngle = coordinate.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }

  return false;
}

exports.isFullCircle = isFullCircle;
/**
 * @ignore
 * 
 * @param coordinate 
 * @param point 
 * @returns distance to center
 */

function getDistanceToCenter(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2));
}

exports.getDistanceToCenter = getDistanceToCenter;
/**
 * @ignore
 * 
 * @param coordinate
 * @param point
 */

function isPointInCoordinate(coordinate, point) {
  var result = false;

  if (coordinate) {
    if (coordinate.type === 'theta') {
      var start = coordinate.start,
          end = coordinate.end;
      result = helper_1.isBetween(point.x, start.x, end.x) && helper_1.isBetween(point.y, start.y, end.y);
    } else {
      var invertPoint = coordinate.invert(point);
      result = helper_1.isBetween(invertPoint.x, 0, 1) && helper_1.isBetween(invertPoint.y, 0, 1);
    }
  }

  return result;
}

exports.isPointInCoordinate = isPointInCoordinate;
/**
 * @ignore
 * 
 */

function getAngleByPoint(coordinate, point) {
  var center = coordinate.getCenter();
  return Math.atan2(point.y - center.y, point.x - center.x);
}

exports.getAngleByPoint = getAngleByPoint;
/**
 * @ignore
 * 
 * @param coordinate
 * @returns
 */

function getCoordinateClipCfg(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  var start = coordinate.start,
      end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();

  if (coordinate.isPolar) {
    var startAngle_1 = coordinate.startAngle,
        endAngle_1 = coordinate.endAngle;
    var center_1 = coordinate.getCenter();
    var radius_1 = coordinate.getRadius();
    return {
      type: 'path',
      startState: {
        path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function endState(ratio) {
        var diff = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path = graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff);
        return {
          path: path
        };
      },
      attrs: {
        path: graphics_1.getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }

  var endState;

  if (coordinate.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }

  return {
    type: 'rect',
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate.isTransposed ? width + margin * 2 : 0,
      height: coordinate.isTransposed ? 0 : height + margin * 2
    },
    endState: endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}

exports.getCoordinateClipCfg = getCoordinateClipCfg;
/**
 *  BBox
 * @param coordinate
 * @param margin
 */

function getCoordinateBBox(coordinate, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  var start = coordinate.start,
      end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return bbox_1.BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}

exports.getCoordinateBBox = getCoordinateBBox;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSamePoint = exports.mergeRegion = exports.intersectRect = exports.inBox = exports.distance = exports.getPixelRatio = void 0;

function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}

exports.getPixelRatio = getPixelRatio;
/**
 * 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */

function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

exports.distance = distance;
/**
 * 
 * @param {number} minX    x
 * @param {number} minY    y
 * @param {number} width  
 * @param {number} height 
 * @param {[type]} x       x
 * @param {[type]} y       y
 */

function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}

exports.inBox = inBox;

function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}

exports.intersectRect = intersectRect; // 

function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }

  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}

exports.mergeRegion = mergeRegion;
/**
 *  [x, y]
 * @param {Array} point1 
 * @param {Array} point2 
 */

function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

exports.isSamePoint = isSamePoint;

var util_1 = __webpack_require__(0);

Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return util_1.isNil;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return util_1.isString;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return util_1.isFunction;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return util_1.isArray;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return util_1.each;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return util_1.toRadian;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return util_1.mod;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return util_1.isNumberEqual;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return util_1.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return util_1.clearAnimationFrame;
  }
});

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EVENTS = exports.SVG_ATTR_MAP = exports.SHAPE_TO_TAGS = void 0;
exports.SHAPE_TO_TAGS = {
  rect: 'path',
  circle: 'circle',
  line: 'line',
  path: 'path',
  marker: 'path',
  text: 'text',
  polyline: 'polyline',
  polygon: 'polygon',
  image: 'image',
  ellipse: 'ellipse',
  dom: 'foreignObject'
};
exports.SVG_ATTR_MAP = {
  opacity: 'opacity',
  fillStyle: 'fill',
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  strokeStyle: 'stroke',
  strokeOpacity: 'stroke-opacity',
  stroke: 'stroke',
  x: 'x',
  y: 'y',
  r: 'r',
  rx: 'rx',
  ry: 'ry',
  width: 'width',
  height: 'height',
  x1: 'x1',
  x2: 'x2',
  y1: 'y1',
  y2: 'y2',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  lineWidth: 'stroke-width',
  lineDash: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset',
  miterLimit: 'stroke-miterlimit',
  font: 'font',
  fontSize: 'font-size',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  fontFamily: 'font-family',
  startArrow: 'marker-start',
  endArrow: 'marker-end',
  path: 'd',
  class: 'class',
  id: 'id',
  style: 'style',
  preserveAspectRatio: 'preserveAspectRatio'
};
exports.EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout', 'mousemove', 'wheel'];

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPixelRatio = getPixelRatio;
exports.distance = distance;
exports.inBox = inBox;
exports.intersectRect = intersectRect;
exports.mergeRegion = mergeRegion;
exports.isSamePoint = isSamePoint;
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _util.isNil;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _util.isString;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _util.isFunction;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _util.isArray;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _util.each;
  }
});
Object.defineProperty(exports, "toRadian", {
  enumerable: true,
  get: function get() {
    return _util.toRadian;
  }
});
Object.defineProperty(exports, "mod", {
  enumerable: true,
  get: function get() {
    return _util.mod;
  }
});
Object.defineProperty(exports, "isNumberEqual", {
  enumerable: true,
  get: function get() {
    return _util.isNumberEqual;
  }
});
Object.defineProperty(exports, "requestAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _util.requestAnimationFrame;
  }
});
Object.defineProperty(exports, "clearAnimationFrame", {
  enumerable: true,
  get: function get() {
    return _util.clearAnimationFrame;
  }
});

var _util = __webpack_require__(0);

function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
/**
 * 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */


function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
/**
 * 
 * @param {number} minX    x
 * @param {number} minY    y
 * @param {number} width  
 * @param {number} height 
 * @param {[type]} x       x
 * @param {[type]} y       y
 */


function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}

function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
} // 


function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }

  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
/**
 *  [x, y]
 * @param {Array} point1 
 * @param {Array} point2 
 */


function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EVENTS = exports.SVG_ATTR_MAP = exports.SHAPE_TO_TAGS = void 0;
var SHAPE_TO_TAGS = {
  rect: 'path',
  circle: 'circle',
  line: 'line',
  path: 'path',
  marker: 'path',
  text: 'text',
  polyline: 'polyline',
  polygon: 'polygon',
  image: 'image',
  ellipse: 'ellipse',
  dom: 'foreignObject'
};
exports.SHAPE_TO_TAGS = SHAPE_TO_TAGS;
var SVG_ATTR_MAP = {
  opacity: 'opacity',
  fillStyle: 'fill',
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  strokeStyle: 'stroke',
  strokeOpacity: 'stroke-opacity',
  stroke: 'stroke',
  x: 'x',
  y: 'y',
  r: 'r',
  rx: 'rx',
  ry: 'ry',
  width: 'width',
  height: 'height',
  x1: 'x1',
  x2: 'x2',
  y1: 'y1',
  y2: 'y2',
  lineCap: 'stroke-linecap',
  lineJoin: 'stroke-linejoin',
  lineWidth: 'stroke-width',
  lineDash: 'stroke-dasharray',
  lineDashOffset: 'stroke-dashoffset',
  miterLimit: 'stroke-miterlimit',
  font: 'font',
  fontSize: 'font-size',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  fontFamily: 'font-family',
  startArrow: 'marker-start',
  endArrow: 'marker-end',
  path: 'd',
  class: 'class',
  id: 'id',
  style: 'style',
  preserveAspectRatio: 'preserveAspectRatio'
};
exports.SVG_ATTR_MAP = SVG_ATTR_MAP;
var EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mouseenter', 'mouseleave', 'mouseover', 'mouseout', 'mousemove', 'wheel'];
exports.EVENTS = EVENTS;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_array_1 = __webpack_require__(22);

var is_object_1 = __webpack_require__(62);

function each(elements, func) {
  if (!elements) {
    return;
  }

  var rst;

  if (is_array_1.default(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);

      if (rst === false) {
        break;
      }
    }
  } else if (is_object_1.default(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);

        if (rst === false) {
          break;
        }
      }
    }
  }
}

exports.default = each;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isArrayLike = function isArrayLike(value) {
  /**
   * isArrayLike([1, 2, 3]) => true
   * isArrayLike(document.body.children) => true
   * isArrayLike('abc') => true
   * isArrayLike(Function) => false
   */
  return value !== null && typeof value !== 'function' && isFinite(value.length);
};

var _default = isArrayLike;
exports.default = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

/**
 * 
 * @param  {*} fn 
 * @return {Boolean}  
 */
var _default = function _default(value) {
  return (0, _isType.default)(value, 'Function');
};

exports.default = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.__extends = __extends;
exports.__rest = __rest;
exports.__decorate = __decorate;
exports.__param = __param;
exports.__metadata = __metadata;
exports.__awaiter = __awaiter;
exports.__generator = __generator;
exports.__createBinding = __createBinding;
exports.__exportStar = __exportStar;
exports.__values = __values;
exports.__read = __read;
exports.__spread = __spread;
exports.__spreadArrays = __spreadArrays;
exports.__await = __await;
exports.__asyncGenerator = __asyncGenerator;
exports.__asyncDelegator = __asyncDelegator;
exports.__asyncValues = __asyncValues;
exports.__makeTemplateObject = __makeTemplateObject;
exports.__importStar = __importStar;
exports.__importDefault = __importDefault;
exports.__classPrivateFieldGet = __classPrivateFieldGet;
exports.__classPrivateFieldSet = __classPrivateFieldSet;
exports.__assign = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  exports.__assign = _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};

exports.__assign = _assign;

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}

function __metadata(metadataKey, metadataValue) {
  if ((typeof Reflect === "undefined" ? "undefined" : (0, _typeof2.default)(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}

function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}

function __exportStar(m, exports) {
  for (var p in m) {
    if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
}

function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
}

;

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}

;

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result.default = mod;
  return result;
}

function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    default: mod
  };
}

function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  fontFamily: "\n  \"-apple-system\", BlinkMacSystemFont, \"Segoe UI\", Roboto,\"Helvetica Neue\",\n  Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\",\n  SimSun, \"sans-serif\"",
  textColor: '#2C3542',
  activeTextColor: '#333333',
  uncheckedColor: '#D8D8D8',
  lineColor: '#416180',
  regionColor: '#CCD7EB',
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4
};
exports.default = _default;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function get() {
    return _color.default;
  }
});
Object.defineProperty(exports, "rgb", {
  enumerable: true,
  get: function get() {
    return _color.rgb;
  }
});
Object.defineProperty(exports, "hsl", {
  enumerable: true,
  get: function get() {
    return _color.hsl;
  }
});
Object.defineProperty(exports, "lab", {
  enumerable: true,
  get: function get() {
    return _lab.default;
  }
});
Object.defineProperty(exports, "hcl", {
  enumerable: true,
  get: function get() {
    return _lab.hcl;
  }
});
Object.defineProperty(exports, "lch", {
  enumerable: true,
  get: function get() {
    return _lab.lch;
  }
});
Object.defineProperty(exports, "gray", {
  enumerable: true,
  get: function get() {
    return _lab.gray;
  }
});
Object.defineProperty(exports, "cubehelix", {
  enumerable: true,
  get: function get() {
    return _cubehelix.default;
  }
});

var _color = _interopRequireWildcard(__webpack_require__(243));

var _lab = _interopRequireWildcard(__webpack_require__(724));

var _cubehelix = _interopRequireDefault(__webpack_require__(725));

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (value) {
  /**
   * isObject({}) => true
   * isObject([1, 2, 3]) => true
   * isObject(Function) => true
   * isObject(null) => false
   */
  var type = (0, _typeof2.default)(value);
  return value !== null && type === 'object' || type === 'function';
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var svg_1 = __webpack_require__(144);

var dom_1 = __webpack_require__(70);

var draw_1 = __webpack_require__(259);

var constant_1 = __webpack_require__(53);

var Shape = __webpack_require__(189);

var group_1 = __webpack_require__(260);

var g_base_2 = __webpack_require__(27);

var ShapeBase =
/** @class */
function (_super) {
  tslib_1.__extends(ShapeBase, _super);

  function ShapeBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'svg';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this); // 


    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  }; //  afterAttrsChange 


  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);

    var canvas = this.get('canvas'); // 

    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.draw(context, targetAttrs);
    }
  };

  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };

  ShapeBase.prototype.getGroupBase = function () {
    return group_1.default;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  ShapeBase.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };

  ShapeBase.prototype.calculateBBox = function () {
    var el = this.get('el');
    var bbox = null; //  Dom  0

    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = g_base_2.getBBoxMethod(this.get('type'));

      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }

    if (bbox) {
      var x = bbox.x,
          y = bbox.y,
          width = bbox.width,
          height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }

    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };

  ShapeBase.prototype.isFill = function () {
    var _a = this.attr(),
        fill = _a.fill,
        fillStyle = _a.fillStyle;

    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };

  ShapeBase.prototype.isStroke = function () {
    var _a = this.attr(),
        stroke = _a.stroke,
        strokeStyle = _a.strokeStyle;

    return (stroke || strokeStyle) && this.canStroke;
  };

  ShapeBase.prototype.draw = function (context, targetAttrs) {
    var el = this.get('el');

    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        dom_1.createDom(this);
      }

      svg_1.setClip(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  /**
   * @protected
   * 
   * @param {Defs} context 
   * @param {ShapeAttrs} targetAttrs 
   */


  ShapeBase.prototype.createPath = function (context, targetAttrs) {}; // stroke and fill


  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill,
        fillStyle = attrs.fillStyle,
        stroke = attrs.stroke,
        strokeStyle = attrs.strokeStyle,
        fillOpacity = attrs.fillOpacity,
        strokeOpacity = attrs.strokeOpacity,
        lineWidth = attrs.lineWidth;
    var el = this.get('el');

    if (this.canFill) {
      // :  none
      if (!targetAttrs) {
        this._setColor(context, 'fill', fill || fillStyle);
      } else if ('fill' in attrs) {
        this._setColor(context, 'fill', fill);
      } else if ('fillStyle' in attrs) {
        // compatible with fillStyle
        this._setColor(context, 'fill', fillStyle);
      }

      if (fillOpacity) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['fillOpacity'], fillOpacity);
      }
    }

    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, 'stroke', stroke || strokeStyle);
      } else if ('stroke' in attrs) {
        this._setColor(context, 'stroke', stroke);
      } else if ('strokeStyle' in attrs) {
        // compatible with strokeStyle
        this._setColor(context, 'stroke', strokeStyle);
      }

      if (strokeOpacity) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);
      }

      if (lineWidth) {
        el.setAttribute(constant_1.SVG_ATTR_MAP['lineWidth'], lineWidth);
      }
    }
  };

  ShapeBase.prototype._setColor = function (context, attr, value) {
    var el = this.get('el');

    if (!value) {
      // need to set `none` to avoid default value
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], 'none');
      return;
    }

    value = value.trim();

    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = context.find('gradient', value);

      if (!id) {
        id = context.addGradient(value);
      }

      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id = context.find('pattern', value);

      if (!id) {
        id = context.addPattern(value);
      }

      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
    }
  };

  ShapeBase.prototype.shadow = function (context, targetAttrs) {
    var attrs = this.attr();

    var _a = targetAttrs || attrs,
        shadowOffsetX = _a.shadowOffsetX,
        shadowOffsetY = _a.shadowOffsetY,
        shadowBlur = _a.shadowBlur,
        shadowColor = _a.shadowColor;

    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      svg_1.setShadow(this, context);
    }
  };

  ShapeBase.prototype.transform = function (targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;

    if (matrix) {
      svg_1.setTransform(this);
    }
  };

  ShapeBase.prototype.isInShape = function (refX, refY) {
    return this.isPointInPath(refX, refY);
  };

  ShapeBase.prototype.isPointInPath = function (refX, refY) {
    var el = this.get('el');
    var canvas = this.get('canvas');
    var bbox = canvas.get('el').getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);

    if (element && element.isEqualNode(el)) {
      return true;
    }

    return false;
  };
  /**
   * 
   * @returns {number} 
   */


  ShapeBase.prototype.getHitLineWidth = function () {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        lineAppendWidth = _a.lineAppendWidth;

    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }

    return 0;
  };

  return ShapeBase;
}(g_base_1.AbstractShape);

exports.default = ShapeBase;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _svg = __webpack_require__(150);

var _dom = __webpack_require__(72);

var _draw = __webpack_require__(274);

var _constant = __webpack_require__(55);

var Shape = _interopRequireWildcard(__webpack_require__(192));

var _group = _interopRequireDefault(__webpack_require__(275));

var ShapeBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ShapeBase, _super);

  function ShapeBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'svg';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this); // 


    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  }; //  afterAttrsChange 


  ShapeBase.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);

    var canvas = this.get('canvas'); // 

    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.draw(context, targetAttrs);
    }
  };

  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };

  ShapeBase.prototype.getGroupBase = function () {
    return _group.default;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  ShapeBase.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };

  ShapeBase.prototype.calculateBBox = function () {
    var el = this.get('el');
    var bbox = null; //  Dom  0

    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = (0, _gBase.getBBoxMethod)(this.get('type'));

      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }

    if (bbox) {
      var x = bbox.x,
          y = bbox.y,
          width = bbox.width,
          height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x - halfWidth;
      var minY = y - halfWidth;
      var maxX = x + width + halfWidth;
      var maxY = y + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }

    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };

  ShapeBase.prototype.isFill = function () {
    var _a = this.attr(),
        fill = _a.fill,
        fillStyle = _a.fillStyle;

    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };

  ShapeBase.prototype.isStroke = function () {
    var _a = this.attr(),
        stroke = _a.stroke,
        strokeStyle = _a.strokeStyle;

    return (stroke || strokeStyle) && this.canStroke;
  };

  ShapeBase.prototype.draw = function (context, targetAttrs) {
    var el = this.get('el');

    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        (0, _dom.createDom)(this);
      }

      (0, _svg.setClip)(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  /**
   * @protected
   * 
   * @param {Defs} context 
   * @param {ShapeAttrs} targetAttrs 
   */


  ShapeBase.prototype.createPath = function (context, targetAttrs) {}; // stroke and fill


  ShapeBase.prototype.strokeAndFill = function (context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill,
        fillStyle = attrs.fillStyle,
        stroke = attrs.stroke,
        strokeStyle = attrs.strokeStyle,
        fillOpacity = attrs.fillOpacity,
        strokeOpacity = attrs.strokeOpacity,
        lineWidth = attrs.lineWidth;
    var el = this.get('el');

    if (this.canFill) {
      // :  none
      if (!targetAttrs) {
        this._setColor(context, 'fill', fill || fillStyle);
      } else if ('fill' in attrs) {
        this._setColor(context, 'fill', fill);
      } else if ('fillStyle' in attrs) {
        // compatible with fillStyle
        this._setColor(context, 'fill', fillStyle);
      }

      if (fillOpacity) {
        el.setAttribute(_constant.SVG_ATTR_MAP['fillOpacity'], fillOpacity);
      }
    }

    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, 'stroke', stroke || strokeStyle);
      } else if ('stroke' in attrs) {
        this._setColor(context, 'stroke', stroke);
      } else if ('strokeStyle' in attrs) {
        // compatible with strokeStyle
        this._setColor(context, 'stroke', strokeStyle);
      }

      if (strokeOpacity) {
        el.setAttribute(_constant.SVG_ATTR_MAP['strokeOpacity'], strokeOpacity);
      }

      if (lineWidth) {
        el.setAttribute(_constant.SVG_ATTR_MAP['lineWidth'], lineWidth);
      }
    }
  };

  ShapeBase.prototype._setColor = function (context, attr, value) {
    var el = this.get('el');

    if (!value) {
      // need to set `none` to avoid default value
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], 'none');
      return;
    }

    value = value.trim();

    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id = context.find('gradient', value);

      if (!id) {
        id = context.addGradient(value);
      }

      el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id = context.find('pattern', value);

      if (!id) {
        id = context.addPattern(value);
      }

      el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
    } else {
      el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
    }
  };

  ShapeBase.prototype.shadow = function (context, targetAttrs) {
    var attrs = this.attr();

    var _a = targetAttrs || attrs,
        shadowOffsetX = _a.shadowOffsetX,
        shadowOffsetY = _a.shadowOffsetY,
        shadowBlur = _a.shadowBlur,
        shadowColor = _a.shadowColor;

    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      (0, _svg.setShadow)(this, context);
    }
  };

  ShapeBase.prototype.transform = function (targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;

    if (matrix) {
      (0, _svg.setTransform)(this);
    }
  };

  ShapeBase.prototype.isInShape = function (refX, refY) {
    return this.isPointInPath(refX, refY);
  };

  ShapeBase.prototype.isPointInPath = function (refX, refY) {
    var el = this.get('el');
    var canvas = this.get('canvas');
    var bbox = canvas.get('el').getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);

    if (element && element.isEqualNode(el)) {
      return true;
    }

    return false;
  };
  /**
   * 
   * @returns {number} 
   */


  ShapeBase.prototype.getHitLineWidth = function () {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        lineAppendWidth = _a.lineAppendWidth;

    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }

    return 0;
  };

  return ShapeBase;
}(_gBase.AbstractShape);

var _default = ShapeBase;
exports.default = _default;

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorFallback; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setDefaultErrorFallback; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_error_boundary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(313);
/* harmony import */ var react_error_boundary__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_error_boundary__WEBPACK_IMPORTED_MODULE_1__);



var DefaultErrorFallback = function DefaultErrorFallback(_ref) {
  var error = _ref.error;
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
    className: "bizcharts-error",
    role: "alert"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("p", null, "BizCharts something went wrong:"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("pre", null, error.message));
};

function ErrorFallback(args) {
  return DefaultErrorFallback(args);
}
var setDefaultErrorFallback = function setDefaultErrorFallback(CustComponents) {
  DefaultErrorFallback = CustComponents;
};

/* harmony default export */ __webpack_exports__["b"] = (react_error_boundary__WEBPACK_IMPORTED_MODULE_1__["ErrorBoundary"]);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);
/* harmony import */ var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1__);

 // 

var pickWithout = function pickWithout(obj, keys) {
  var ret = {};

  _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_0___default()(obj, function (v, k) {
    var match = false;
    keys.forEach(function (itKey) {
      if (_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_1___default()(itKey) && itKey === k) {
        match = true;
      } else if (itKey instanceof RegExp && k.match(itKey)) {
        match = true;
      }
    });

    if (!match) {
      ret[k] = v;
    }
  });

  return ret;
};

/* harmony default export */ __webpack_exports__["a"] = (pickWithout);

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var toString = {}.toString;

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};

var _default = isType;
exports.default = _default;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*  */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scrollbar = exports.Slider = exports.HtmlTooltip = exports.ContinuousLegend = exports.CategoryLegend = exports.CircleGrid = exports.LineGrid = exports.CircleAxis = exports.LineAxis = exports.Annotation = exports.Crosshair = exports.Component = exports.GroupComponent = exports.HtmlComponent = void 0; // G

var g_base_1 = __webpack_require__(27);

Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return g_base_1.Event;
  }
});
Object.defineProperty(exports, "AbstractGroup", {
  enumerable: true,
  get: function get() {
    return g_base_1.AbstractGroup;
  }
});
Object.defineProperty(exports, "AbstractShape", {
  enumerable: true,
  get: function get() {
    return g_base_1.AbstractShape;
  }
}); // adjust

var adjust_1 = __webpack_require__(409);

Object.defineProperty(exports, "registerAdjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.registerAdjust;
  }
});
Object.defineProperty(exports, "getAdjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.getAdjust;
  }
});
Object.defineProperty(exports, "Adjust", {
  enumerable: true,
  get: function get() {
    return adjust_1.Adjust;
  }
}); // attr

var attr_1 = __webpack_require__(249);

Object.defineProperty(exports, "getAttribute", {
  enumerable: true,
  get: function get() {
    return attr_1.getAttribute;
  }
});
Object.defineProperty(exports, "Attribute", {
  enumerable: true,
  get: function get() {
    return attr_1.Attribute;
  }
});

var attr_2 = __webpack_require__(249);

Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function get() {
    return attr_2.Color;
  }
}); // coordinate

var coord_1 = __webpack_require__(797);

Object.defineProperty(exports, "getCoordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.getCoordinate;
  }
});
Object.defineProperty(exports, "registerCoordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.registerCoordinate;
  }
});
Object.defineProperty(exports, "Coordinate", {
  enumerable: true,
  get: function get() {
    return coord_1.Coordinate;
  }
}); // scale

var scale_1 = __webpack_require__(108);

Object.defineProperty(exports, "getScale", {
  enumerable: true,
  get: function get() {
    return scale_1.getScale;
  }
});
Object.defineProperty(exports, "registerScale", {
  enumerable: true,
  get: function get() {
    return scale_1.registerScale;
  }
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return scale_1.Scale;
  }
}); // component

var component_1 = __webpack_require__(184);

Object.defineProperty(exports, "Annotation", {
  enumerable: true,
  get: function get() {
    return component_1.Annotation;
  }
});
Object.defineProperty(exports, "Component", {
  enumerable: true,
  get: function get() {
    return component_1.Component;
  }
});
Object.defineProperty(exports, "Crosshair", {
  enumerable: true,
  get: function get() {
    return component_1.Crosshair;
  }
});
Object.defineProperty(exports, "GroupComponent", {
  enumerable: true,
  get: function get() {
    return component_1.GroupComponent;
  }
});
Object.defineProperty(exports, "HtmlComponent", {
  enumerable: true,
  get: function get() {
    return component_1.HtmlComponent;
  }
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function get() {
    return component_1.Slider;
  }
});
Object.defineProperty(exports, "Scrollbar", {
  enumerable: true,
  get: function get() {
    return component_1.Scrollbar;
  }
}); // axis

var LineAxis = component_1.Axis.Line,
    CircleAxis = component_1.Axis.Circle;
exports.LineAxis = LineAxis;
exports.CircleAxis = CircleAxis; // grid

var LineGrid = component_1.Grid.Line,
    CircleGrid = component_1.Grid.Circle;
exports.LineGrid = LineGrid;
exports.CircleGrid = CircleGrid; // legend

var CategoryLegend = component_1.Legend.Category,
    ContinuousLegend = component_1.Legend.Continuous;
exports.CategoryLegend = CategoryLegend;
exports.ContinuousLegend = ContinuousLegend; // Tooltip

var HtmlTooltip = component_1.Tooltip.Html;
exports.HtmlTooltip = HtmlTooltip;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var util_1 = __webpack_require__(52);

var draw_1 = __webpack_require__(143);

var g_base_2 = __webpack_require__(27);

var Shape = __webpack_require__(142);

var group_1 = __webpack_require__(258);

var ShapeBase =
/** @class */
function (_super) {
  tslib_1.__extends(ShapeBase, _super);

  function ShapeBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this); // 


    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };

  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };

  ShapeBase.prototype.getGroupBase = function () {
    return group_1.default;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  ShapeBase.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };

  ShapeBase.prototype.calculateBBox = function () {
    var type = this.get('type');
    var lineWidth = this.getHitLineWidth(); // const attrs = this.attr();

    var bboxMethod = g_base_2.getBBoxMethod(type);
    var box = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box.x - halfLineWidth;
    var minY = box.y - halfLineWidth;
    var maxX = box.x + box.width + halfLineWidth;
    var maxY = box.y + box.height + halfLineWidth;
    return {
      x: minX,
      minX: minX,
      y: minY,
      minY: minY,
      width: box.width + lineWidth,
      height: box.height + lineWidth,
      maxX: maxX,
      maxY: maxY
    };
  };

  ShapeBase.prototype.isFill = function () {
    return !!this.attrs['fill'] || this.isClipShape();
  };

  ShapeBase.prototype.isStroke = function () {
    return !!this.attrs['stroke'];
  }; //  shape 


  ShapeBase.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save(); //  clip  context 

      draw_1.applyAttrsToContext(context, clip); //  clip 

      clip.createPath(context);
      context.restore(); // 

      context.clip();

      clip._afterDraw();
    }
  }; //  region 


  ShapeBase.prototype.draw = function (context, region) {
    var clip = this.cfg.clipShape; //  region

    if (region) {
      if (this.cfg.refresh === false) {
        // this._afterDraw();
        this.set('hasChanged', false);
        return;
      } //  clip 


      var bbox = this.getCanvasBBox();

      if (!util_1.intersectRect(region, bbox)) {
        // 
        this.set('hasChanged', false); //  cacheCanvasBBox  isInview 
        // 1. 
        // 2. refresh = false 

        if (this.cfg.isInView) {
          this._afterDraw();
        }

        return;
      }
    }

    context.save(); //  attrs  clip clip  matrix 

    draw_1.applyAttrsToContext(context, this);

    this._applyClip(context, clip);

    this.drawPath(context);
    context.restore();

    this._afterDraw();
  };

  ShapeBase.prototype.getCanvasViewBox = function () {
    var canvas = this.cfg.canvas;

    if (canvas) {
      // @ts-ignore
      return canvas.getViewRange();
    }

    return null;
  };

  ShapeBase.prototype.cacheCanvasBBox = function () {
    var canvasBBox = this.getCanvasViewBox(); // 

    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = util_1.intersectRect(bbox, canvasBBox);
      this.set('isInView', isInView); //  cacheCanvasBBox  null
      // 
      //  cacheCanvasBBox 

      if (isInView) {
        this.set('cacheCanvasBBox', bbox);
      } else {
        this.set('cacheCanvasBBox', null);
      }
    }
  };

  ShapeBase.prototype._afterDraw = function () {
    this.cacheCanvasBBox(); // 

    this.set('hasChanged', false);
    this.set('refresh', null);
  };

  ShapeBase.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('isInView', null);
    this.set('hasChanged', false);
  };
  /**
   * 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.drawPath = function (context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context context 
   */


  ShapeBase.prototype.fill = function (context) {
    context.fill();
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context context 
   */


  ShapeBase.prototype.stroke = function (context) {
    context.stroke();
  }; // 


  ShapeBase.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        opacity = _a.opacity,
        strokeOpacity = _a.strokeOpacity,
        fillOpacity = _a.fillOpacity;

    if (this.isFill()) {
      if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }

    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }

        this.stroke(context);
      }
    }

    this.afterDrawPath(context);
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.createPath = function (context) {};
  /**
   *  path 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.afterDrawPath = function (context) {};

  ShapeBase.prototype.isInShape = function (refX, refY) {
    // return HitUtil.isHitShape(this, refX, refY);
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  }; //  isInStroke  isInPath 


  ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    return false;
  };
  /**
   * 
   * @returns {number} 
   */


  ShapeBase.prototype.getHitLineWidth = function () {
    if (!this.isStroke()) {
      return 0;
    }

    var attrs = this.attrs;
    return attrs['lineWidth'] + attrs['lineAppendWidth'];
  };

  return ShapeBase;
}(g_base_1.AbstractShape);

exports.default = ShapeBase;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moveTo = exports.sortDom = exports.createDom = exports.createSVGElement = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);
/**
 *  svg 
 * @param type svg
 */


function createSVGElement(type) {
  return document.createElementNS('http://www.w3.org/2000/svg', type);
}

exports.createSVGElement = createSVGElement;
/**
 *  dom 
 * @param  {IShape} shape 
 * @return {SVGElement}
 */

function createDom(shape) {
  var type = constant_1.SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();

  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }

  var element = createSVGElement(type);

  if (shape.get('id')) {
    element.id = shape.get('id');
  }

  shape.set('el', element);
  shape.set('attrs', {}); //  defs  dom parent  context  defs 

  if (parent) {
    var parentNode = parent.get('el');

    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      // parentNode maybe null for group
      parentNode = parent.createDom();
      parent.set('el', parentNode);
      parentNode.appendChild(element);
    }
  }

  return element;
}

exports.createDom = createDom;
/**
 *  dom 
 * @param {IElement} element  
 * @param {sorter}   function 
 */

function sortDom(element, sorter) {
  var el = element.get('el');
  var childList = util_1.toArray(el.children).sort(sorter); // create empty fragment

  var fragment = document.createDocumentFragment();
  childList.forEach(function (child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}

exports.sortDom = sortDom;
/**
 *  dom 
 * @param {SVGElement} element     dom 
 * @param {number}     targetIndex ( 0 )
 */

function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter( //  defs 
  function (node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';
  }); // 

  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element); // 

  if (target) {
    //  > 
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      //  < 
      // 
      var targetNext = siblings[targetIndex + 1]; // 

      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        // 
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

exports.moveTo = moveTo;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _util = __webpack_require__(54);

var _draw = __webpack_require__(149);

var Shape = _interopRequireWildcard(__webpack_require__(148));

var _group = _interopRequireDefault(__webpack_require__(273));

var ShapeBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ShapeBase, _super);

  function ShapeBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ShapeBase.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this); // 


    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      lineWidth: 1,
      lineAppendWidth: 0,
      strokeOpacity: 1,
      fillOpacity: 1
    });
  };

  ShapeBase.prototype.getShapeBase = function () {
    return Shape;
  };

  ShapeBase.prototype.getGroupBase = function () {
    return _group.default;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  ShapeBase.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };

  ShapeBase.prototype.calculateBBox = function () {
    var type = this.get('type');
    var lineWidth = this.getHitLineWidth(); // const attrs = this.attr();

    var bboxMethod = (0, _gBase.getBBoxMethod)(type);
    var box = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box.x - halfLineWidth;
    var minY = box.y - halfLineWidth;
    var maxX = box.x + box.width + halfLineWidth;
    var maxY = box.y + box.height + halfLineWidth;
    return {
      x: minX,
      minX: minX,
      y: minY,
      minY: minY,
      width: box.width + lineWidth,
      height: box.height + lineWidth,
      maxX: maxX,
      maxY: maxY
    };
  };

  ShapeBase.prototype.isFill = function () {
    return !!this.attrs['fill'] || this.isClipShape();
  };

  ShapeBase.prototype.isStroke = function () {
    return !!this.attrs['stroke'];
  }; //  shape 


  ShapeBase.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save(); //  clip  context 

      (0, _draw.applyAttrsToContext)(context, clip); //  clip 

      clip.createPath(context);
      context.restore(); // 

      context.clip();

      clip._afterDraw();
    }
  }; //  region 


  ShapeBase.prototype.draw = function (context, region) {
    var clip = this.cfg.clipShape; //  region

    if (region) {
      if (this.cfg.refresh === false) {
        // this._afterDraw();
        this.set('hasChanged', false);
        return;
      } //  clip 


      var bbox = this.getCanvasBBox();

      if (!(0, _util.intersectRect)(region, bbox)) {
        // 
        this.set('hasChanged', false); //  cacheCanvasBBox  isInview 
        // 1. 
        // 2. refresh = false 

        if (this.cfg.isInView) {
          this._afterDraw();
        }

        return;
      }
    }

    context.save(); //  attrs  clip clip  matrix 

    (0, _draw.applyAttrsToContext)(context, this);

    this._applyClip(context, clip);

    this.drawPath(context);
    context.restore();

    this._afterDraw();
  };

  ShapeBase.prototype.getCanvasViewBox = function () {
    var canvas = this.cfg.canvas;

    if (canvas) {
      // @ts-ignore
      return canvas.getViewRange();
    }

    return null;
  };

  ShapeBase.prototype.cacheCanvasBBox = function () {
    var canvasBBox = this.getCanvasViewBox(); // 

    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = (0, _util.intersectRect)(bbox, canvasBBox);
      this.set('isInView', isInView); //  cacheCanvasBBox  null
      // 
      //  cacheCanvasBBox 

      if (isInView) {
        this.set('cacheCanvasBBox', bbox);
      } else {
        this.set('cacheCanvasBBox', null);
      }
    }
  };

  ShapeBase.prototype._afterDraw = function () {
    this.cacheCanvasBBox(); // 

    this.set('hasChanged', false);
    this.set('refresh', null);
  };

  ShapeBase.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('isInView', null);
    this.set('hasChanged', false);
  };
  /**
   * 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.drawPath = function (context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context context 
   */


  ShapeBase.prototype.fill = function (context) {
    context.fill();
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context context 
   */


  ShapeBase.prototype.stroke = function (context) {
    context.stroke();
  }; // 


  ShapeBase.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        opacity = _a.opacity,
        strokeOpacity = _a.strokeOpacity,
        fillOpacity = _a.fillOpacity;

    if (this.isFill()) {
      if (!(0, _util.isNil)(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }

    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!(0, _util.isNil)(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }

        this.stroke(context);
      }
    }

    this.afterDrawPath(context);
  };
  /**
   * @protected
   * 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.createPath = function (context) {};
  /**
   *  path 
   * @param {CanvasRenderingContext2D} context 
   */


  ShapeBase.prototype.afterDrawPath = function (context) {};

  ShapeBase.prototype.isInShape = function (refX, refY) {
    // return HitUtil.isHitShape(this, refX, refY);
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  }; //  isInStroke  isInPath 


  ShapeBase.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    return false;
  };
  /**
   * 
   * @returns {number} 
   */


  ShapeBase.prototype.getHitLineWidth = function () {
    if (!this.isStroke()) {
      return 0;
    }

    var attrs = this.attrs;
    return attrs['lineWidth'] + attrs['lineAppendWidth'];
  };

  return ShapeBase;
}(_gBase.AbstractShape);

var _default = ShapeBase;
exports.default = _default;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSVGElement = createSVGElement;
exports.createDom = createDom;
exports.sortDom = sortDom;
exports.moveTo = moveTo;

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

/**
 *  svg 
 * @param type svg
 */
function createSVGElement(type) {
  return document.createElementNS('http://www.w3.org/2000/svg', type);
}
/**
 *  dom 
 * @param  {IShape} shape 
 * @return {SVGElement}
 */


function createDom(shape) {
  var type = _constant.SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();

  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }

  var element = createSVGElement(type);

  if (shape.get('id')) {
    element.id = shape.get('id');
  }

  shape.set('el', element);
  shape.set('attrs', {}); //  defs  dom parent  context  defs 

  if (parent) {
    var parentNode = parent.get('el');

    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      // parentNode maybe null for group
      parentNode = parent.createDom();
      parent.set('el', parentNode);
      parentNode.appendChild(element);
    }
  }

  return element;
}
/**
 *  dom 
 * @param {IElement} element  
 * @param {sorter}   function 
 */


function sortDom(element, sorter) {
  var el = element.get('el');
  var childList = (0, _util.toArray)(el.children).sort(sorter); // create empty fragment

  var fragment = document.createDocumentFragment();
  childList.forEach(function (child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
/**
 *  dom 
 * @param {SVGElement} element     dom 
 * @param {number}     targetIndex ( 0 )
 */


function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter( //  defs 
  function (node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== 'defs';
  }); // 

  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element); // 

  if (target) {
    //  > 
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      //  < 
      // 
      var targetNext = siblings[targetIndex + 1]; // 

      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        // 
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return withChartInstance; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);

 // chart theme, 

var RootChartContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createContext(null);
RootChartContext.displayName = 'RootChartContext';
function withChartInstance(Component) {
  var Com = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.forwardRef(function (props, ref) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(RootChartContext.Consumer, null, function (ctx) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        ref: ref
      }, ctx, props));
    });
  });
  Com.displayName = Component.name;
  return Com;
}
;
/* harmony default export */ __webpack_exports__["a"] = (RootChartContext);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var each_1 = __webpack_require__(56);

exports.default = each_1.default;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setMatrixArrayType = setMatrixArrayType;
exports.toRadian = toRadian;
exports.equals = equals;
exports.RANDOM = exports.ARRAY_TYPE = exports.EPSILON = void 0;

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
exports.EPSILON = EPSILON;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
exports.ARRAY_TYPE = ARRAY_TYPE;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

exports.RANDOM = RANDOM;

function setMatrixArrayType(type) {
  exports.ARRAY_TYPE = ARRAY_TYPE = type;
}

var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */


function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uniq = exports.omit = exports.padEnd = exports.isBetween = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 * Determines whether between is
 * @param value
 * @param start
 * @param end
 * @returns true if between
 */


function isBetween(value, start, end) {
  var min = Math.min(start, end);
  var max = Math.max(start, end);
  return value >= min && value <= max;
}

exports.isBetween = isBetween;
/**
 * @ignore
 * pads the current string/array with a given value (repeated, if needed) so that the resulting reaches a given length.
 * The padding is applied from the end of the current value.
 *
 * @param source
 * @param targetLength
 * @param padValue
 * @returns
 */

function padEnd(source, targetLength, padValue) {
  if (util_1.isString(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (util_1.isArray(source)) {
    var sourceLength = source.length;

    if (sourceLength < targetLength) {
      var diff = targetLength - sourceLength;

      for (var i = 0; i < diff; i++) {
        source.push(padValue);
      }
    }
  }

  return source;
}

exports.padEnd = padEnd;
/**
 * @ignore
 * omit keys of an object.
 * @param obj
 * @param keys
 */

function omit(obj, keys) {
  keys.forEach(function (key) {
    delete obj[key];
  });
  return obj;
}

exports.omit = omit;
/**
 * @ignore
 * @param sourceArray
 * @param targetArray
 * @param map
 */

function uniq(sourceArray, targetArray, map) {
  if (targetArray === void 0) {
    targetArray = [];
  }

  if (map === void 0) {
    map = {};
  }

  for (var _i = 0, sourceArray_1 = sourceArray; _i < sourceArray_1.length; _i++) {
    var source = sourceArray_1[_i];

    if (!map[source]) {
      targetArray.push(source);
      map[source] = true;
    }
  }

  return targetArray;
}

exports.uniq = uniq;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toPoints = exports.getRegionBBox = exports.BBox = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);
/**
 * 
 */


var BBox =
/** @class */
function () {
  function BBox(x, y, width, height) {
    if (x === void 0) {
      x = 0;
    }

    if (y === void 0) {
      y = 0;
    }

    if (width === void 0) {
      width = 0;
    }

    if (height === void 0) {
      height = 0;
    }

    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
  }

  BBox.fromRange = function (minX, minY, maxX, maxY) {
    return new BBox(minX, minY, maxX - minX, maxY - minY);
  };

  BBox.fromObject = function (bbox) {
    return new BBox(bbox.minX, bbox.minY, bbox.width, bbox.height);
  };

  Object.defineProperty(BBox.prototype, "minX", {
    get: function get() {
      return this.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "maxX", {
    get: function get() {
      return this.x + this.width;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "minY", {
    get: function get() {
      return this.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "maxY", {
    get: function get() {
      return this.y + this.height;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "tl", {
    get: function get() {
      return {
        x: this.x,
        y: this.y
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "tr", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.y
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "bl", {
    get: function get() {
      return {
        x: this.x,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "br", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "top", {
    get: function get() {
      return {
        x: this.x + this.width / 2,
        y: this.minY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "right", {
    get: function get() {
      return {
        x: this.maxX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "bottom", {
    get: function get() {
      return {
        x: this.x + this.width / 2,
        y: this.maxY
      };
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BBox.prototype, "left", {
    get: function get() {
      return {
        x: this.minX,
        y: this.y + this.height / 2
      };
    },
    enumerable: false,
    configurable: true
  }); // end 

  /**
   * 
   * @param {BBox} bbox 
   * @returns      
   */

  BBox.prototype.isEqual = function (bbox) {
    return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
  };
  /**
   * 
   * @param child
   */


  BBox.prototype.contains = function (child) {
    return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
  };
  /**
   * 
   * @returns 
   */


  BBox.prototype.clone = function () {
    return new BBox(this.x, this.y, this.width, this.height);
  };
  /**
   * 
   * @param subBBox
   */


  BBox.prototype.add = function () {
    var subBBox = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }

    var bbox = this.clone();
    util_1.each(subBBox, function (b) {
      bbox.x = Math.min(b.x, bbox.x);
      bbox.y = Math.min(b.y, bbox.y);
      bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  /**
   * 
   * @param subBBox
   */


  BBox.prototype.merge = function () {
    var subBBox = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      subBBox[_i] = arguments[_i];
    }

    var bbox = this.clone();
    util_1.each(subBBox, function (b) {
      bbox.x = Math.max(b.x, bbox.x);
      bbox.y = Math.max(b.y, bbox.y);
      bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
      bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
    });
    return bbox;
  };
  /**
   * bbox 
   * @param subBBox
   * @param direction
   */


  BBox.prototype.cut = function (subBBox, direction) {
    var width = subBBox.width;
    var height = subBBox.height;

    switch (direction) {
      case constant_1.DIRECTION.TOP:
      case constant_1.DIRECTION.TOP_LEFT:
      case constant_1.DIRECTION.TOP_RIGHT:
        return BBox.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);

      case constant_1.DIRECTION.RIGHT:
      case constant_1.DIRECTION.RIGHT_TOP:
      case constant_1.DIRECTION.RIGHT_BOTTOM:
        return BBox.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);

      case constant_1.DIRECTION.BOTTOM:
      case constant_1.DIRECTION.BOTTOM_LEFT:
      case constant_1.DIRECTION.BOTTOM_RIGHT:
        return BBox.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);

      case constant_1.DIRECTION.LEFT:
      case constant_1.DIRECTION.LEFT_TOP:
      case constant_1.DIRECTION.LEFT_BOTTOM:
        return BBox.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);

      default:
        // 
        return this;
    }
  };
  /**
   * 
   * @param gap
   */


  BBox.prototype.shrink = function (gap) {
    var top = gap[0],
        right = gap[1],
        bottom = gap[2],
        left = gap[3];
    return new BBox(this.x + left, this.y + top, this.width - left - right, this.height - top - bottom);
  };
  /**
   * 
   * @param gap
   */


  BBox.prototype.expand = function (gap) {
    var top = gap[0],
        right = gap[1],
        bottom = gap[2],
        left = gap[3];
    return new BBox(this.x - left, this.y - top, this.width + left + right, this.height + top + bottom);
  };
  /**
   * get the gap of two bbox, if not exceed, then 0
   * @param bbox
   * @returns [top, right, bottom, left]
   */


  BBox.prototype.exceed = function (bbox) {
    return [Math.max(-this.minY + bbox.minY, 0), Math.max(this.maxX - bbox.maxX, 0), Math.max(this.maxY - bbox.maxY, 0), Math.max(-this.minX + bbox.minX, 0)];
  };
  /**
   * 
   * @param bbox
   */


  BBox.prototype.collide = function (bbox) {
    return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
  };
  /**
   * 
   * @returns 
   */


  BBox.prototype.size = function () {
    return this.width * this.height;
  };
  /**
   *  bbox 
   * @param p
   */


  BBox.prototype.isPointIn = function (p) {
    return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
  };

  return BBox;
}();

exports.BBox = BBox;
/**
 *  bbox  region  bbox
 * @param bbox
 * @param region
 */

exports.getRegionBBox = function (bbox, region) {
  var start = region.start,
      end = region.end;
  return new BBox(bbox.x + bbox.width * start.x, bbox.y + bbox.height * start.y, bbox.width * Math.abs(end.x - start.x), bbox.height * Math.abs(end.y - start.y));
};
/**
 *  bbox  points
 * @param bbox
 */


function toPoints(bbox) {
  return [[bbox.minX, bbox.minY], [bbox.maxX, bbox.minY], [bbox.maxX, bbox.maxY], [bbox.minX, bbox.maxY]];
}

exports.toPoints = toPoints;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMappingField = getMappingField;
exports.getMappingFunction = getMappingFunction;
exports.geometry = geometry;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

/**
 * 
 * @param options
 * @param field
 */
function getMappingField(o, field) {
  var xField = o.xField,
      yField = o.yField,
      colorField = o.colorField,
      shapeField = o.shapeField,
      sizeField = o.sizeField,
      styleField = o.styleField,
      _a = o.rawFields,
      rawFields = _a === void 0 ? [] : _a;
  var fields = []; //  color  bar  widthRatio 
  //  color  colorField  + rawFields
  // shape, size 

  if (field === 'color') {
    fields = (0, _tslib.__spreadArrays)([colorField || xField], rawFields);
  } else if (field === 'shape') {
    fields = (0, _tslib.__spreadArrays)([shapeField || xField], rawFields);
  } else if (field === 'size') {
    fields = (0, _tslib.__spreadArrays)([sizeField || xField], rawFields);
  } else {
    fields = (0, _tslib.__spreadArrays)([xField, yField, colorField, shapeField, sizeField, styleField], rawFields); // 

    var idx = ['x', 'y', 'color', 'shape', 'size', 'style'].indexOf(field);
    var f = fields[idx]; // 

    fields.splice(idx, 1); // 

    fields.unshift(f);
  }

  return (0, _util.uniq)(fields.filter(function (f) {
    return !!f;
  }));
}
/**
 * 
 * @param mappingFields
 * @param func
 */


function getMappingFunction(mappingFields, func) {
  if (!func) return undefined; // 

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var params = {};
    mappingFields.forEach(function (f, idx) {
      params[f] = args[idx];
    }); //  undefined

    delete params['undefined'];
    return func(params);
  };
}
/**
 *  geometry  adaptor
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var type = options.type,
      args = options.args,
      mapping = options.mapping,
      xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      shapeField = options.shapeField,
      sizeField = options.sizeField,
      tooltipFields = options.tooltipFields,
      label = options.label,
      state = options.state; //  mapping 

  if (!mapping) {
    return params;
  }

  var color = mapping.color,
      shape = mapping.shape,
      size = mapping.size,
      style = mapping.style,
      tooltip = mapping.tooltip; //  geometry

  var geometry = chart[type](args).position(xField + "*" + yField);
  /**
   * color 
   * g.color('red');
   * g.color('color', ['red', 'blue']);
   * g.color('x', (x, y) => 'red');
   * g.color('color', (color, x, y) => 'red');
   */

  if ((0, _util.isString)(color)) {
    colorField ? geometry.color(colorField, color) : geometry.color(color);
  } else if ((0, _util.isFunction)(color)) {
    var mappingFields = getMappingField(options, 'color');
    geometry.color(mappingFields.join('*'), getMappingFunction(mappingFields, color));
  } else {
    colorField && geometry.color(colorField, color);
  }
  /**
   * shape 
   * g.shape('rect');
   * g.shape('shape', ['rect', 'circle']);
   * g.shape('x*y', (x, y) => 'rect');
   * g.shape('shape*x*y', (shape, x, y) => 'rect');
   */


  if ((0, _util.isString)(shape)) {
    shapeField ? geometry.shape(shapeField, [shape]) : geometry.shape(shape); // [shape]  G2 
  } else if ((0, _util.isFunction)(shape)) {
    var mappingFields = getMappingField(options, 'shape');
    geometry.shape(mappingFields.join('*'), getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry.shape(shapeField, shape);
  }
  /**
   * size 
   * g.size(10);
   * g.size('size', [10, 20]);
   * g.size('x*y', (x, y) => 10);
   * g.color('size*x*y', (size, x, y) => 1-);
   */


  if ((0, _util.isNumber)(size)) {
    sizeField ? geometry.size(sizeField, size) : geometry.size(size);
  } else if ((0, _util.isFunction)(size)) {
    var mappingFields = getMappingField(options, 'size');
    geometry.size(mappingFields.join('*'), getMappingFunction(mappingFields, size));
  } else {
    sizeField && geometry.size(sizeField, size);
  }
  /**
   * style 
   * g.style({ fill: 'red' });
   * g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
   */


  if ((0, _util.isFunction)(style)) {
    var mappingFields = getMappingField(options, 'style');
    geometry.style(mappingFields.join('*'), getMappingFunction(mappingFields, style));
  } else if ((0, _util.isObject)(style)) {
    geometry.style(style);
  }
  /**
   * tooltip  API
   * g.tooltip('x*y*color', (x, y, color) => ({ name, value }));
   * g.tooltip(false);
   */


  if (tooltipFields === false) {
    geometry.tooltip(false);
  } else if (!(0, _util.isEmpty)(tooltipFields)) {
    geometry.tooltip(tooltipFields.join('*'), getMappingFunction(tooltipFields, tooltip));
  }
  /**
   * label 
   */


  if (label === false) {
    geometry.label(false);
  } else if (label) {
    var callback = label.callback,
        fields = label.fields,
        cfg = (0, _tslib.__rest)(label, ["callback", "fields"]);
    geometry.label({
      fields: fields || [yField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }
  /**
   * state 
   */


  if (state) {
    geometry.state(state);
  } //  x y 


  [xField, yField].filter(function (f) {
    return f !== colorField;
  }).forEach(function (f) {
    chart.legend(f, false);
  });
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, params), {
    // geometry adaptor  geometry  adaptor type 
    ext: {
      geometry: geometry
    }
  });
}

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/* harmony import */ var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);
/* harmony import */ var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2__);




var cloneDeep = function cloneDeep(deepObject) {
  var map = [];

  var clone = function clone(obj) {
    map.push(obj);

    if (map.includes(obj)) {
      return obj;
    }

    if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(obj) !== 'object' || obj === null) {
      return obj;
    }

    var rst;

    if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_1___default()(obj)) {
      rst = [];

      for (var i = 0, l = obj.length; i < l; i++) {
        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(obj[i]) === 'object' && obj[i] != null) {
          rst[i] = clone(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_2___default()(obj, function (value, k) {
        if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(value) === 'object' && value != null) {
          rst[k] = clone(value);
        } else {
          rst[k] = value;
        }
      });
    }

    return rst;
  };

  return clone(deepObject);
};

/* harmony default export */ __webpack_exports__["a"] = (cloneDeep);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3__);





function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  }

  return x !== x && y !== y; //  NaN == NaN
}

function length(obj) {
  if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(obj)) {
    return obj.length;
  }

  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_3___default()(obj)) {
    return Object.keys(obj).length;
  }

  return 0;
}

/* harmony default export */ __webpack_exports__["a"] = (function (objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objA) !== 'object' || objA === null || _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0___default()(objB) !== 'object' || objB === null) {
    return false;
  }

  if (_antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(objA) !== _antv_util_lib_is_array__WEBPACK_IMPORTED_MODULE_2___default()(objB)) {
    return false;
  }

  if (length(objA) !== length(objB)) {
    return false;
  }

  var ret = true;

  _antv_util_lib_each__WEBPACK_IMPORTED_MODULE_1___default()(objA, function (v, k) {
    if (!is(v, objB[k])) {
      ret = false;
      return ret;
    }

    return true;
  });

  return ret;
});

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bar = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var percent_1 = __webpack_require__(156);

var adaptor_1 = __webpack_require__(1050);
/**
 * 
 */


var Bar =
/** @class */
function (_super) {
  tslib_1.__extends(Bar, _super);

  function Bar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'bar';
    return _this;
  }
  /**
   * @override
   */


  Bar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        xField = _a.xField,
        yField = _a.yField,
        isPercent = _a.isPercent;
    this.chart.changeData(percent_1.getDataWhetherPecentage(data, xField, yField, xField, isPercent));
  };
  /**
   *   
   */


  Bar.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      barWidthRatio: 0.6,
      marginRatio: 1 / 32,
      tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Bar.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Bar;
}(plot_1.Plot);

exports.Bar = Bar;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Column = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var percent_1 = __webpack_require__(156);

var adaptor_1 = __webpack_require__(499);
/**
 * 
 */


var Column =
/** @class */
function (_super) {
  tslib_1.__extends(Column, _super);

  function Column() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'column';
    return _this;
  }
  /**
   * @override
   */


  Column.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        yField = _a.yField,
        xField = _a.xField,
        isPercent = _a.isPercent;
    this.chart.changeData(percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent));
  };
  /**
   *   
   */


  Column.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      columnWidthRatio: 0.6,
      marginRatio: 1 / 32,
      tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Column.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Column;
}(plot_1.Plot);

exports.Column = Column;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isObject = _interopRequireDefault(__webpack_require__(175));

function each(elements, func) {
  if (!elements) {
    return;
  }

  var rst;

  if ((0, _isArray.default)(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);

      if (rst === false) {
        break;
      }
    }
  } else if ((0, _isObject.default)(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);

        if (rst === false) {
          break;
        }
      }
    }
  }
}

var _default = each;
exports.default = _default;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

/**
 * 
 * @return {Boolean} 
 */
var isNumber = function isNumber(value) {
  return (0, _isType.default)(value, 'Number');
};

var _default = isNumber;
exports.default = _default;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distance = distance;
exports.isNumberEqual = isNumberEqual;
exports.getBBoxByArray = getBBoxByArray;
exports.getBBoxRange = getBBoxRange;
exports.piMod = piMod;

function minNum(array) {
  return Math.min.apply(null, array);
}

function maxNum(array) {
  return Math.max.apply(null, array);
}
/**
 * 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 * @return {number} 
 */


function distance(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function isNumberEqual(v1, v2) {
  return Math.abs(v1 - v2) < 0.001;
}

function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}

function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: minNum([x1, x2]),
    maxX: maxNum([x1, x2]),
    minY: minNum([y1, y2]),
    maxY: maxNum([y1, y2])
  };
}

function piMod(angle) {
  return (angle + Math.PI * 2) % (Math.PI * 2);
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMatrixByAngle = getMatrixByAngle;
exports.getMatrixByTranslate = getMatrixByTranslate;
exports.getAngleByMatrix = getAngleByMatrix;
exports.applyMatrix2BBox = applyMatrix2BBox;
exports.applyRotate = applyRotate;
exports.applyTranslate = applyTranslate;

var _matrixUtil = __webpack_require__(33);

var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];

function getMatrixByAngle(point, angle, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }

  if (!angle) {
    //  0  null  null
    return null;
  }

  var m = _matrixUtil.ext.transform(matrix, [['t', -point.x, -point.y], ['r', angle], ['t', point.x, point.y]]);

  return m;
}

function getMatrixByTranslate(point, currentMatrix) {
  if (!point.x && !point.y) {
    // 00  nan  null
    return null;
  }

  return _matrixUtil.ext.transform(currentMatrix || identityMatrix, [['t', point.x, point.y]]);
} // 


function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];

  _matrixUtil.vec3.transformMat3(out, xVector, matrix);

  return Math.atan2(out[1], out[0]);
} //  * 


function multiplyVec2(matrix, v) {
  var out = [0, 0];

  _matrixUtil.vec2.transformMat3(out, v, matrix);

  return out;
}

function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY,
    width: maxX - minX,
    height: maxY - minY
  };
}

function applyRotate(shape, rotate, x, y) {
  if (rotate) {
    var matrix = getMatrixByAngle({
      x: x,
      y: y
    }, rotate, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}

function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({
    x: x,
    y: y
  });
  shape.attr('matrix', translateMatrix);
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTooltipMapping = void 0;

var util_1 = __webpack_require__(0);
/**
 *  tooltip 
 * @param tooltip
 * @param defaultFields
 */


function getTooltipMapping(tooltip, defaultFields) {
  if (tooltip === false) {
    return {
      fields: false
    };
  }

  var fields = util_1.get(tooltip, 'fields');
  var formatter = util_1.get(tooltip, 'formatter');

  if (formatter && !fields) {
    fields = defaultFields;
  }

  return {
    fields: fields,
    formatter: formatter
  };
}

exports.getTooltipMapping = getTooltipMapping;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geometry = exports.getMappingFunction = exports.getMappingField = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);
/**
 * 
 * @param options
 * @param field
 */


function getMappingField(o, field) {
  var xField = o.xField,
      yField = o.yField,
      colorField = o.colorField,
      shapeField = o.shapeField,
      sizeField = o.sizeField,
      styleField = o.styleField,
      _a = o.rawFields,
      rawFields = _a === void 0 ? [] : _a;
  var fields = []; //  color  bar  widthRatio 
  //  color  colorField  + rawFields
  // shape, size 

  if (field === 'color') {
    fields = tslib_1.__spreadArrays([colorField || xField], rawFields);
  } else if (field === 'shape') {
    fields = tslib_1.__spreadArrays([shapeField || xField], rawFields);
  } else if (field === 'size') {
    fields = tslib_1.__spreadArrays([sizeField || xField], rawFields);
  } else {
    fields = tslib_1.__spreadArrays([xField, yField, colorField, shapeField, sizeField, styleField], rawFields); // 

    var idx = ['x', 'y', 'color', 'shape', 'size', 'style'].indexOf(field);
    var f = fields[idx]; // 

    fields.splice(idx, 1); // 

    fields.unshift(f);
  }

  return util_1.uniq(fields.filter(function (f) {
    return !!f;
  }));
}

exports.getMappingField = getMappingField;
/**
 * 
 * @param mappingFields
 * @param func
 */

function getMappingFunction(mappingFields, func) {
  if (!func) return undefined; // 

  return function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var params = {};
    mappingFields.forEach(function (f, idx) {
      params[f] = args[idx];
    }); //  undefined

    delete params['undefined'];
    return func(params);
  };
}

exports.getMappingFunction = getMappingFunction;
/**
 *  geometry  adaptor
 * @param params
 */

function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var type = options.type,
      args = options.args,
      mapping = options.mapping,
      xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      shapeField = options.shapeField,
      sizeField = options.sizeField,
      tooltipFields = options.tooltipFields,
      label = options.label,
      state = options.state; //  mapping 

  if (!mapping) {
    return params;
  }

  var color = mapping.color,
      shape = mapping.shape,
      size = mapping.size,
      style = mapping.style,
      tooltip = mapping.tooltip; //  geometry

  var geometry = chart[type](args).position(xField + "*" + yField);
  /**
   * color 
   * g.color('red');
   * g.color('color', ['red', 'blue']);
   * g.color('x', (x, y) => 'red');
   * g.color('color', (color, x, y) => 'red');
   */

  if (util_1.isString(color)) {
    colorField ? geometry.color(colorField, color) : geometry.color(color);
  } else if (util_1.isFunction(color)) {
    var mappingFields = getMappingField(options, 'color');
    geometry.color(mappingFields.join('*'), getMappingFunction(mappingFields, color));
  } else {
    colorField && geometry.color(colorField, color);
  }
  /**
   * shape 
   * g.shape('rect');
   * g.shape('shape', ['rect', 'circle']);
   * g.shape('x*y', (x, y) => 'rect');
   * g.shape('shape*x*y', (shape, x, y) => 'rect');
   */


  if (util_1.isString(shape)) {
    shapeField ? geometry.shape(shapeField, [shape]) : geometry.shape(shape); // [shape]  G2 
  } else if (util_1.isFunction(shape)) {
    var mappingFields = getMappingField(options, 'shape');
    geometry.shape(mappingFields.join('*'), getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry.shape(shapeField, shape);
  }
  /**
   * size 
   * g.size(10);
   * g.size('size', [10, 20]);
   * g.size('x*y', (x, y) => 10);
   * g.color('size*x*y', (size, x, y) => 1-);
   */


  if (util_1.isNumber(size)) {
    sizeField ? geometry.size(sizeField, size) : geometry.size(size);
  } else if (util_1.isFunction(size)) {
    var mappingFields = getMappingField(options, 'size');
    geometry.size(mappingFields.join('*'), getMappingFunction(mappingFields, size));
  } else {
    sizeField && geometry.size(sizeField, size);
  }
  /**
   * style 
   * g.style({ fill: 'red' });
   * g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
   */


  if (util_1.isFunction(style)) {
    var mappingFields = getMappingField(options, 'style');
    geometry.style(mappingFields.join('*'), getMappingFunction(mappingFields, style));
  } else if (util_1.isObject(style)) {
    geometry.style(style);
  }
  /**
   * tooltip  API
   * g.tooltip('x*y*color', (x, y, color) => ({ name, value }));
   * g.tooltip(false);
   */


  if (tooltipFields === false) {
    geometry.tooltip(false);
  } else if (!util_1.isEmpty(tooltipFields)) {
    geometry.tooltip(tooltipFields.join('*'), getMappingFunction(tooltipFields, tooltip));
  }
  /**
   * label 
   */


  if (label === false) {
    geometry.label(false);
  } else if (label) {
    var callback = label.callback,
        fields = label.fields,
        cfg = tslib_1.__rest(label, ["callback", "fields"]);

    geometry.label({
      fields: fields || [yField],
      callback: callback,
      cfg: utils_1.transformLabel(cfg)
    });
  }
  /**
   * state 
   */


  if (state) {
    geometry.state(state);
  } //  x y 


  [xField, yField].filter(function (f) {
    return f !== colorField;
  }).forEach(function (f) {
    chart.legend(f, false);
  });
  return tslib_1.__assign(tslib_1.__assign({}, params), {
    // geometry adaptor  geometry  adaptor type 
    ext: {
      geometry: geometry
    }
  });
}

exports.geometry = geometry;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTooltipMapping = getTooltipMapping;

var _util = __webpack_require__(0);

/**
 *  tooltip 
 * @param tooltip
 * @param defaultFields
 */
function getTooltipMapping(tooltip, defaultFields) {
  if (tooltip === false) {
    return {
      fields: false
    };
  }

  var fields = (0, _util.get)(tooltip, 'fields');
  var formatter = (0, _util.get)(tooltip, 'formatter');

  if (formatter && !fields) {
    fields = defaultFields;
  }

  return {
    fields: fields,
    formatter: formatter
  };
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerTheme = exports.getTheme = void 0;

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(434);

var defaultTheme = util_2.createTheme({}); // 

var Themes = {
  default: defaultTheme
};
/**
 * 
 * @param theme 
 */

function getTheme(theme) {
  return util_1.get(Themes, util_1.lowerCase(theme), Themes.default);
}

exports.getTheme = getTheme;
/**
 * 
 * @param theme 
 * @param value 
 */

function registerTheme(theme, value) {
  Themes[util_1.lowerCase(theme)] = util_2.createTheme(value);
}

exports.registerTheme = registerTheme;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var map = {};

exports.default = function (prefix) {
  prefix = prefix || 'g';

  if (!map[prefix]) {
    map[prefix] = 1;
  } else {
    map[prefix] += 1;
  }

  return prefix + map[prefix];
};

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REACT_PIVATE_PROPS; });
var REACT_PIVATE_PROPS = ['children', 'hooks', 'ref'];
/* unused harmony default export */ var _unused_webpack_default_export = ({});

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

// isFinite,
var isNil = function isNil(value) {
  /**
   * isNil(null) => true
   * isNil() => true
   */
  return value === null || value === undefined;
};

var _default = isNil;
exports.default = _default;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "parsePath", {
  enumerable: true,
  get: function get() {
    return _parsePath.default;
  }
});
Object.defineProperty(exports, "catmullRom2Bezier", {
  enumerable: true,
  get: function get() {
    return _catmullRom2Bezier.default;
  }
});
Object.defineProperty(exports, "fillPath", {
  enumerable: true,
  get: function get() {
    return _fillPath.default;
  }
});
Object.defineProperty(exports, "fillPathByDiff", {
  enumerable: true,
  get: function get() {
    return _fillPathByDiff.default;
  }
});
Object.defineProperty(exports, "formatPath", {
  enumerable: true,
  get: function get() {
    return _formatPath.default;
  }
});
Object.defineProperty(exports, "pathIntersection", {
  enumerable: true,
  get: function get() {
    return _pathIntersection.default;
  }
});
Object.defineProperty(exports, "parsePathArray", {
  enumerable: true,
  get: function get() {
    return _parsePathArray.default;
  }
});
Object.defineProperty(exports, "parsePathString", {
  enumerable: true,
  get: function get() {
    return _parsePathString.default;
  }
});
Object.defineProperty(exports, "path2Curve", {
  enumerable: true,
  get: function get() {
    return _path2Curve.default;
  }
});
Object.defineProperty(exports, "path2Absolute", {
  enumerable: true,
  get: function get() {
    return _path2Absolute.default;
  }
});
Object.defineProperty(exports, "reactPath", {
  enumerable: true,
  get: function get() {
    return _rectPath.default;
  }
});
Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return _getArcParams.default;
  }
});
Object.defineProperty(exports, "path2Segments", {
  enumerable: true,
  get: function get() {
    return _path2Segments.default;
  }
});
Object.defineProperty(exports, "getLineIntersect", {
  enumerable: true,
  get: function get() {
    return _getLineIntersect.default;
  }
});
Object.defineProperty(exports, "isPolygonsIntersect", {
  enumerable: true,
  get: function get() {
    return _isPolygonsIntersect.default;
  }
});
Object.defineProperty(exports, "isPointInPolygon", {
  enumerable: true,
  get: function get() {
    return _pointInPolygon.default;
  }
});

var _parsePath = _interopRequireDefault(__webpack_require__(401));

var _catmullRom2Bezier = _interopRequireDefault(__webpack_require__(756));

var _fillPath = _interopRequireDefault(__webpack_require__(757));

var _fillPathByDiff = _interopRequireDefault(__webpack_require__(758));

var _formatPath = _interopRequireDefault(__webpack_require__(759));

var _pathIntersection = _interopRequireDefault(__webpack_require__(760));

var _parsePathArray = _interopRequireDefault(__webpack_require__(761));

var _parsePathString = _interopRequireDefault(__webpack_require__(405));

var _path2Curve = _interopRequireDefault(__webpack_require__(403));

var _path2Absolute = _interopRequireDefault(__webpack_require__(404));

var _rectPath = _interopRequireDefault(__webpack_require__(402));

var _getArcParams = _interopRequireDefault(__webpack_require__(406));

var _path2Segments = _interopRequireDefault(__webpack_require__(762));

var _getLineIntersect = _interopRequireDefault(__webpack_require__(407));

var _isPolygonsIntersect = _interopRequireDefault(__webpack_require__(763));

var _pointInPolygon = _interopRequireDefault(__webpack_require__(408));

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doGroupAppearAnimate = exports.doAnimate = exports.getDefaultAnimateCfg = exports.DEFAULT_ANIMATE_CFG = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var animation_1 = __webpack_require__(424); // 


exports.DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: 'easeQuadOut'
  },
  update: {
    duration: 400,
    easing: 'easeQuadInOut'
  },
  enter: {
    duration: 400,
    easing: 'easeQuadInOut'
  },
  leave: {
    duration: 350,
    easing: 'easeQuadIn'
  }
}; //  Geometry 

var GEOMETRY_ANIMATE_CFG = {
  interval: function interval(coordinate) {
    return {
      enter: {
        animation: coordinate.isRect ? coordinate.isTransposed ? 'scale-in-x' : 'scale-in-y' : 'fade-in'
      },
      update: {
        animation: coordinate.isPolar && coordinate.isTransposed ? 'sector-path-update' : null
      },
      leave: {
        animation: 'fade-out'
      }
    };
  },
  line: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  path: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  point: {
    appear: {
      animation: 'zoom-in'
    },
    enter: {
      animation: 'zoom-in'
    },
    leave: {
      animation: 'zoom-out'
    }
  },
  area: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  polygon: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  schema: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  edge: {
    enter: {
      animation: 'fade-in'
    },
    leave: {
      animation: 'fade-out'
    }
  },
  label: {
    appear: {
      animation: 'fade-in',
      delay: 450
    },
    enter: {
      animation: 'fade-in'
    },
    update: {
      animation: 'position-update'
    },
    leave: {
      animation: 'fade-out'
    }
  }
}; //  Geometry 

var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function line() {
    return {
      animation: 'wave-in'
    };
  },
  area: function area() {
    return {
      animation: 'wave-in'
    };
  },
  path: function path() {
    return {
      animation: 'fade-in'
    };
  },
  interval: function interval(coordinate) {
    var animation;

    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
    } else {
      animation = 'grow-in-xy';

      if (coordinate.isPolar && coordinate.isTransposed) {
        // pie chart
        animation = 'wave-in';
      }
    }

    return {
      animation: animation
    };
  },
  schema: function schema(coordinate) {
    var animation;

    if (coordinate.isRect) {
      animation = coordinate.isTransposed ? 'grow-in-x' : 'grow-in-y';
    } else {
      animation = 'grow-in-xy';
    }

    return {
      animation: animation
    };
  },
  polygon: function polygon() {
    return {
      animation: 'fade-in',
      duration: 500
    };
  },
  edge: function edge() {
    return {
      animation: 'fade-in'
    };
  }
}; // 

function parseAnimateConfig(animateCfg, data) {
  return {
    delay: util_1.isFunction(animateCfg.delay) ? animateCfg.delay(data) : animateCfg.delay,
    easing: util_1.isFunction(animateCfg.easing) ? animateCfg.easing(data) : animateCfg.easing,
    duration: util_1.isFunction(animateCfg.duration) ? animateCfg.duration(data) : animateCfg.duration,
    callback: animateCfg.callback
  };
}
/**
 * @ignore
 *  elementName  `animateType` `animateType` 
 * @param elementName 
 * @param coordinate 
 * @param animateType 
 */


function getDefaultAnimateCfg(elementName, coordinate, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];

  if (animateCfg) {
    if (util_1.isFunction(animateCfg)) {
      animateCfg = animateCfg(coordinate);
    }

    animateCfg = util_1.deepMix({}, exports.DEFAULT_ANIMATE_CFG, animateCfg);

    if (animateType) {
      return animateCfg[animateType];
    }
  }

  return animateCfg;
}

exports.getDefaultAnimateCfg = getDefaultAnimateCfg;
/**
 * @ignore
 * 
 *  shape 
 * @param shape 
 * @param animateCfg 
 * @param cfg 
 */

function doAnimate(shape, animateCfg, cfg) {
  var data = util_1.get(shape.get('origin'), 'data', constant_1.FIELD_ORIGIN);
  var animation = animateCfg.animation; // 

  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data);

  if (animation) {
    // 
    var animateFunction = animation_1.getAnimation(animation);

    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    //  toAttrs 
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}

exports.doAnimate = doAnimate;
/**
 * @ignore
 *  Geometry 
 * @param container 
 * @param animateCfg 
 * @param geometryType geometry 
 * @param coordinate 
 * @param minYPoint y 
 */

function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate);
    var animation = animation_1.getAnimation(util_1.get(defaultCfg, 'animation', ''));

    if (animation) {
      var cfg = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, exports.DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);

      container.stopAnimate(); //  container 

      animation(container, cfg, {
        coordinate: coordinate,
        minYPoint: minYPoint,
        toAttrs: null
      });
    }
  }
}

exports.doGroupAppearAnimate = doGroupAppearAnimate;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var adjust_1 = __webpack_require__(409);

var attr_1 = __webpack_require__(249);

var util_1 = __webpack_require__(0);

var animate_1 = __webpack_require__(96);

var base_1 = tslib_1.__importDefault(__webpack_require__(261));

var constant_1 = __webpack_require__(20);

var helper_1 = __webpack_require__(76);

var element_1 = tslib_1.__importDefault(__webpack_require__(269));

var label_1 = __webpack_require__(271);

var base_2 = __webpack_require__(29);

var group_data_1 = __webpack_require__(900);

var is_model_change_1 = __webpack_require__(437);

var parse_fields_1 = __webpack_require__(901);

var coordinate_1 = __webpack_require__(51); //  elementId  label element  labels labels 
//  ./label/base.ts#L263


function filterLabelsById(id, labelsMap) {
  var labels = [];
  util_1.each(labelsMap, function (label, labelId) {
    var elementId = labelId.split(' ')[0];

    if (elementId === id) {
      labels.push(label);
    }
  });
  return labels;
}
/**
 * Geometry 
 */


var Geometry =
/** @class */
function (_super) {
  tslib_1.__extends(Geometry, _super);
  /**
   *  Geometry 
   * @param cfg
   */


  function Geometry(cfg) {
    var _this = _super.call(this, cfg) || this;
    /** Geometry  */


    _this.type = 'base'; // 

    /** Attribute map  */

    _this.attributes = {};
    /** Element map */

    _this.elements = [];
    /**  key-value  Elementkey  Element  ID */

    _this.elementsMap = {};
    /** animate  */

    _this.animateOption = true;
    /**  */

    _this.attributeOption = {};
    /**  element  */

    _this.lastElementsMap = {};
    /**  */

    _this.generatePoints = false;
    /**  */

    _this.beforeMappingData = null;
    _this.adjusts = {};
    _this.idFields = [];
    _this.hasSorted = false;
    _this.isCoordinateChanged = false;
    var container = cfg.container,
        labelsContainer = cfg.labelsContainer,
        coordinate = cfg.coordinate,
        data = cfg.data,
        _a = cfg.sortable,
        sortable = _a === void 0 ? false : _a,
        _b = cfg.visible,
        visible = _b === void 0 ? true : _b,
        theme = cfg.theme,
        _c = cfg.scales,
        scales = _c === void 0 ? {} : _c,
        _d = cfg.scaleDefs,
        scaleDefs = _d === void 0 ? {} : _d,
        // 
    intervalPadding = cfg.intervalPadding,
        dodgePadding = cfg.dodgePadding,
        maxColumnWidth = cfg.maxColumnWidth,
        minColumnWidth = cfg.minColumnWidth,
        columnWidthRatio = cfg.columnWidthRatio,
        roseWidthRatio = cfg.roseWidthRatio,
        multiplePieWidthRatio = cfg.multiplePieWidthRatio,
        zIndexReversed = cfg.zIndexReversed;
    _this.container = container;
    _this.labelsContainer = labelsContainer;
    _this.coordinate = coordinate;
    _this.data = data;
    _this.sortable = sortable;
    _this.visible = visible;
    _this.userTheme = theme;
    _this.scales = scales;
    _this.scaleDefs = scaleDefs; // 

    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    _this.roseWidthRatio = roseWidthRatio;
    _this.multiplePieWidthRatio = multiplePieWidthRatio;
    _this.zIndexReversed = zIndexReversed;
    return _this;
  }
  /**
   *  position 
   *
   * @example
   * ```typescript
   * // : [{ x: 'A', y: 10, color: 'red' }]
   * geometry.position('x*y');
   * geometry.position([ 'x', 'y' ]);
   * geometry.position({
   *   fields: [ 'x', 'y' ],
   * });
   * ```
   *
   * @param cfg 
   * @returns
   */


  Geometry.prototype.position = function (cfg) {
    var positionCfg = cfg;

    if (!util_1.isPlainObject(cfg)) {
      // 
      positionCfg = {
        fields: parse_fields_1.parseFields(cfg)
      };
    }

    var fields = util_1.get(positionCfg, 'fields');

    if (fields.length === 1) {
      //  1*xx
      fields.unshift('1');
      util_1.set(positionCfg, 'fields', fields);
    }

    util_1.set(this.attributeOption, 'position', positionCfg);
    return this;
  };

  Geometry.prototype.color = function (field, cfg) {
    this.createAttrOption('color', field, cfg);
    return this;
  };

  Geometry.prototype.shape = function (field, cfg) {
    this.createAttrOption('shape', field, cfg);
    return this;
  };

  Geometry.prototype.size = function (field, cfg) {
    this.createAttrOption('size', field, cfg);
    return this;
  };
  /**
   * G2 
   * 1. dodge
   * 2. stack
   * 3. symmetric
   * 4. jitter
   *
   *
   * **Tip**
   * +  'dodge' :
   * ```typescript
   * geometry.adjust('dodge', {
   *   marginRatio: 0, //  0  1 
   *   dodgeBy: 'x', //  'dodge' 
   * });
   * ```
   *
   * +  'stack' :
   * ```typescript
   * geometry.adjust('stack', {
   *   reverseOrder: false, // 
   * });
   * ```
   *
   * @example
   * ```typescript
   * geometry.adjust('stack');
   *
   * geometry.adjust({
   *   type: 'stack',
   *   reverseOrder: false,
   * });
   *
   * //  adjust
   * geometry.adjust([ 'stack', 'dodge' ]);
   *
   * geometry.adjust([
   *   { type: 'stack' },
   *   { type: 'dodge', dodgeBy: 'x' },
   * ]);
   * ```
   *
   * @param adjustCfg 
   * @returns
   */


  Geometry.prototype.adjust = function (adjustCfg) {
    var adjusts = adjustCfg;

    if (util_1.isString(adjustCfg) || util_1.isPlainObject(adjustCfg)) {
      adjusts = [adjustCfg];
    }

    util_1.each(adjusts, function (adjust, index) {
      if (!util_1.isObject(adjust)) {
        adjusts[index] = {
          type: adjust
        };
      }
    });
    this.adjustOption = adjusts;
    return this;
  };

  Geometry.prototype.style = function (field, styleFunc) {
    if (util_1.isString(field)) {
      var fields = parse_fields_1.parseFields(field);
      this.styleOption = {
        fields: fields,
        callback: styleFunc
      };
    } else {
      var _a = field,
          fields = _a.fields,
          callback = _a.callback,
          cfg = _a.cfg;

      if (fields || callback || cfg) {
        this.styleOption = field;
      } else {
        this.styleOption = {
          cfg: field
        };
      }
    }

    return this;
  };

  Geometry.prototype.tooltip = function (field, cfg) {
    if (util_1.isString(field)) {
      var fields = parse_fields_1.parseFields(field);
      this.tooltipOption = {
        fields: fields,
        callback: cfg
      };
    } else {
      this.tooltipOption = field;
    }

    return this;
  };
  /**
   * Geometry 
   *
   * + `animate(false)` 
   * + `animate(true)` 
   *
   * 
   * 1. appear: 
   * 2. enter: 
   * 3. update: 
   * 4. leave: 
   *
   * @example
   * ```typescript
   * animate({
   *   enter: {
   *     duration: 1000, // enter 
   *   },
   *   leave: false, //  leave 
   * });
   * ```
   *
   * @param cfg 
   * @returns
   */


  Geometry.prototype.animate = function (cfg) {
    this.animateOption = cfg;
    return this;
  };

  Geometry.prototype.label = function (field, secondParam, thirdParam) {
    if (util_1.isString(field)) {
      var labelOption = {};
      var fields = parse_fields_1.parseFields(field);
      labelOption.fields = fields;

      if (util_1.isFunction(secondParam)) {
        labelOption.callback = secondParam;
      } else if (util_1.isPlainObject(secondParam)) {
        labelOption.cfg = secondParam;
      }

      if (thirdParam) {
        labelOption.cfg = thirdParam;
      }

      this.labelOption = labelOption;
    } else {
      this.labelOption = field;
    }

    return this;
  };
  /**
   * 
   *
   * @example
   * ```ts
   * chart.interval().state({
   *   selected: {
   *     animate: { duration: 100, easing: 'easeLinear' },
   *     style: {
   *       lineWidth: 2,
   *       stroke: '#000',
   *     },
   *   },
   * });
   * ```
   *
   *  shape  shape  G.Group  group  shape
   *  group  shape  'name' (shape.set('name', 'xx')) 'name'  key shape   key
   *
   * ```ts
   * chart.interval().shape('groupShape').state({
   *   selected: {
   *     style: {
   *       0: { lineWidth: 2 },
   *       1: { fillOpacity: 1 },
   *     }
   *   }
   * });
   * ```
   *
   * @param cfg 
   */


  Geometry.prototype.state = function (cfg) {
    this.stateOption = cfg;
    return this;
  };
  /**
   *  shape  shape  shape  shape 
   *
   * @example
   * ```ts
   * chart.interval().customInfo({ yourData: 'hello, g2!' });
   * ```
   *
   *  shape 
   *
   * ```ts
   * registerShape('interval', 'your-shape', {
   *   draw(shapeInfo, container) {
   *     const { customInfo } = shapeInfo;
   *     console.log(customInfo); // will log { yourData: 'hello, g2!' }.
   *   }
   * });
   * ```
   *
   * @param cfg
   */


  Geometry.prototype.customInfo = function (cfg) {
    this.customOption = cfg;
    return this;
  };
  /**
   *  Geomtry 
   *  [[Attribute]] and [[Scale]] 
   */


  Geometry.prototype.init = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.setCfg(cfg);
    this.initAttributes(); // 
    //  ->  -> adjust

    this.processData(this.data); //  scale

    this.adjustScale();
  };
  /**
   * Geometry 
   * @param [cfg] 
   */


  Geometry.prototype.update = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    var data = cfg.data,
        isDataChanged = cfg.isDataChanged,
        isCoordinateChanged = cfg.isCoordinateChanged;

    var _a = this,
        attributeOption = _a.attributeOption,
        lastAttributeOption = _a.lastAttributeOption;

    if (!util_1.isEqual(attributeOption, lastAttributeOption)) {
      // 
      this.init(cfg);
    } else if (data && (isDataChanged || !util_1.isEqual(data, this.data))) {
      // 
      this.setCfg(cfg);
      this.initAttributes(); // 

      this.processData(data); //  ->  -> adjust
    } else {
      //  coordinate 
      this.setCfg(cfg);
    } //  scale


    this.adjustScale();
    this.isCoordinateChanged = isCoordinateChanged;
  };
  /**
   * 
   */


  Geometry.prototype.paint = function (isUpdate) {
    var _this = this;

    if (isUpdate === void 0) {
      isUpdate = false;
    }

    if (this.animateOption) {
      this.animateOption = util_1.deepMix({}, animate_1.getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
    }

    this.defaultSize = undefined;
    this.elements = [];
    this.elementsMap = {};
    var offscreenGroup = this.getOffscreenGroup();
    offscreenGroup.clear();
    var beforeMappingData = this.beforeMappingData;
    var dataArray = this.beforeMapping(beforeMappingData);
    var mappingArray = [];

    for (var index = 0, length_1 = dataArray.length; index < length_1; index++) {
      var eachGroup = dataArray[index];
      var mappingData = this.mapping(eachGroup);
      mappingArray.push(mappingData);
      this.createElements(mappingData, index, isUpdate);
    }

    if (this.canDoGroupAnimation(isUpdate)) {
      //  appear.animation
      var container = this.container;
      var type = this.type;
      var coordinate = this.coordinate;
      var animateCfg = util_1.get(this.animateOption, 'appear');
      var yScale = this.getYScale();
      var yMinPoint = coordinate.convert({
        x: 0,
        y: yScale.scale(this.getYMinValue())
      });
      animate_1.doGroupAppearAnimate(container, animateCfg, type, coordinate, yMinPoint);
    } //  label


    if (this.labelOption) {
      this.renderLabels(util_1.flatten(mappingArray), isUpdate);
    }

    this.dataArray = mappingArray; //  elements

    util_1.each(this.lastElementsMap, function (deletedElement) {
      // 
      deletedElement.animate = _this.animateOption;
      deletedElement.destroy();
    });
    this.lastElementsMap = this.elementsMap; // 

    this.lastAttributeOption = tslib_1.__assign({}, this.attributeOption);

    if (this.visible === false) {
      //  visible: false
      this.changeVisible(false);
    }
  };
  /**
   *  Geometry
   * @override
   */


  Geometry.prototype.clear = function () {
    var _a = this,
        container = _a.container,
        geometryLabel = _a.geometryLabel,
        offscreenGroup = _a.offscreenGroup;

    if (container) {
      container.clear();
    }

    if (geometryLabel) {
      geometryLabel.clear();
    }

    if (offscreenGroup) {
      offscreenGroup.clear();
    } // 


    this.scaleDefs = undefined;
    this.attributes = {};
    this.scales = {};
    this.elementsMap = {};
    this.lastElementsMap = {};
    this.elements = [];
    this.adjusts = {};
    this.dataArray = null;
    this.beforeMappingData = null;
    this.lastAttributeOption = undefined;
    this.defaultSize = undefined;
    this.idFields = [];
    this.groupScales = undefined;
    this.hasSorted = false;
    this.isCoordinateChanged = false;
  };
  /**
   *  Geometry 
   */


  Geometry.prototype.destroy = function () {
    this.clear();
    var container = this.container;
    container.remove(true);

    if (this.offscreenGroup) {
      this.offscreenGroup.remove(true);
      this.offscreenGroup = null;
    }

    if (this.geometryLabel) {
      this.geometryLabel.destroy();
      this.geometryLabel = null;
    }

    this.theme = undefined;
    this.shapeFactory = undefined;

    _super.prototype.destroy.call(this);
  };
  /**
   *  scale 
   * @returns
   */


  Geometry.prototype.getGroupScales = function () {
    return this.groupScales;
  };
  /**
   * 
   */


  Geometry.prototype.getAttribute = function (name) {
    return this.attributes[name];
  };
  /**  x  scale  */


  Geometry.prototype.getXScale = function () {
    return this.getAttribute('position').scales[0];
  };
  /**  y  scale  */


  Geometry.prototype.getYScale = function () {
    return this.getAttribute('position').scales[1];
  };
  /**
   * 
   */


  Geometry.prototype.getGroupAttributes = function () {
    var rst = [];
    util_1.each(this.attributes, function (attr) {
      if (constant_1.GROUP_ATTRS.includes(attr.type)) {
        rst.push(attr);
      }
    });
    return rst;
  };
  /**  */


  Geometry.prototype.getDefaultValue = function (attrName) {
    var value;
    var attr = this.getAttribute(attrName);

    if (attr && util_1.isEmpty(attr.scales)) {
      // 
      value = attr.values[0];
    }

    return value;
  };
  /**
   *  Attribute 
   * @param attr Attribute 
   * @param obj 
   * @returns
   */


  Geometry.prototype.getAttributeValues = function (attr, obj) {
    var params = [];
    var scales = attr.scales;

    for (var index = 0, length_2 = scales.length; index < length_2; index++) {
      var scale = scales[index];
      var field = scale.field;

      if (scale.isIdentity) {
        params.push(scale.values);
      } else {
        params.push(obj[field]);
      }
    }

    return attr.mapping.apply(attr, params);
  };

  Geometry.prototype.getAdjust = function (adjustType) {
    return this.adjusts[adjustType];
  };
  /**
   *  shape  marker 
   * @param shapeName shape 
   * @param cfg marker 
   * @returns
   */


  Geometry.prototype.getShapeMarker = function (shapeName, cfg) {
    var shapeFactory = this.getShapeFactory();
    return shapeFactory.getMarker(shapeName, cfg);
  };
  /**
   *  Geometry  Elements
   *
   * ```typescript
   * getElementsBy((element) => {
   *   const data = element.getData();
   *
   *   return data.a === 'a';
   * });
   * ```
   *
   * @param condition 
   * @returns
   */


  Geometry.prototype.getElementsBy = function (condition) {
    return this.elements.filter(function (element) {
      return condition(element);
    });
  };
  /**
   *  id
   * @param data Element 
   * @returns
   */


  Geometry.prototype.getElementId = function (data) {
    data = util_1.isArray(data) ? data[0] : data;
    var originData = data[constant_1.FIELD_ORIGIN]; //  id 

    if (this.idFields.length) {
      var elementId = originData[this.idFields[0]];

      for (var index = 1; index < this.idFields.length; index++) {
        elementId += '-' + originData[this.idFields[index]];
      }

      return elementId;
    }

    var type = this.type;
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var xField = xScale.field || 'x';
    var yField = yScale.field || 'y';
    var yVal = originData[yField];
    var xVal;

    if (xScale.type === 'identity') {
      xVal = xScale.values[0];
    } else {
      xVal = originData[xField];
    }

    var id;

    if (type === 'interval' || type === 'schema') {
      id = "" + xVal;
    } else if (type === 'line' || type === 'area' || type === 'path') {
      id = type;
    } else {
      id = xVal + "-" + yVal;
    }

    var groupScales = this.groupScales;

    for (var index = 0, length_3 = groupScales.length; index < length_3; index++) {
      var groupScale = groupScales[index];
      var field = groupScale.field;
      id = id + "-" + originData[field];
    } //  dodge  adjust  dodgeBy 


    var dodgeAdjust = this.getAdjust('dodge');

    if (dodgeAdjust) {
      var dodgeBy = dodgeAdjust.dodgeBy;

      if (dodgeBy) {
        id = id + "-" + originData[dodgeBy];
      }
    }

    if (this.getAdjust('jitter')) {
      id = id + "-" + data.x + "-" + data.y;
    }

    return id;
  };
  /**
   *  scale 
   */


  Geometry.prototype.getScaleFields = function () {
    var fields = [];
    var tmpMap = {};

    var _a = this,
        attributeOption = _a.attributeOption,
        labelOption = _a.labelOption,
        tooltipOption = _a.tooltipOption; //  fields


    for (var attributeType in attributeOption) {
      if (attributeOption.hasOwnProperty(attributeType)) {
        var eachOpt = attributeOption[attributeType];

        if (eachOpt.fields) {
          helper_1.uniq(eachOpt.fields, fields, tmpMap);
        } else if (eachOpt.values) {
          //  size(10), shape('circle') 
          helper_1.uniq(eachOpt.values, fields, tmpMap);
        }
      }
    } //  label 


    if (labelOption && labelOption.fields) {
      helper_1.uniq(labelOption.fields, fields, tmpMap);
    } //  tooltip 


    if (util_1.isObject(tooltipOption) && tooltipOption.fields) {
      helper_1.uniq(tooltipOption.fields, fields, tmpMap);
    }

    return fields;
  };
  /**
   *  geometry
   * @param visible
   */


  Geometry.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);

    var elements = this.elements;

    for (var index = 0, length_4 = elements.length; index < length_4; index++) {
      var element = elements[index];
      element.changeVisible(visible);
    }

    if (visible) {
      if (this.container) {
        this.container.show();
      }

      if (this.labelsContainer) {
        this.labelsContainer.show();
      }
    } else {
      if (this.container) {
        this.container.hide();
      }

      if (this.labelsContainer) {
        this.labelsContainer.hide();
      }
    }
  };
  /**
   *  & 
   * @return fields string[]
   */


  Geometry.prototype.getGroupFields = function () {
    var groupFields = [];
    var tmpMap = {}; // 

    for (var index = 0, length_5 = constant_1.GROUP_ATTRS.length; index < length_5; index++) {
      var attributeName = constant_1.GROUP_ATTRS[index];
      var cfg = this.attributeOption[attributeName];

      if (cfg && cfg.fields) {
        helper_1.uniq(cfg.fields, groupFields, tmpMap);
      }
    }

    return groupFields;
  };
  /**
   *  x y 
   */


  Geometry.prototype.getXYFields = function () {
    var _a = this.attributeOption.position.fields,
        x = _a[0],
        y = _a[1];
    return [x, y];
  };
  /**
   *  Geometry  shapes
   * @returns shapes
   */


  Geometry.prototype.getShapes = function () {
    return this.elements.map(function (element) {
      return element.shape;
    });
  };
  /**
   *  Group
   * @returns
   */


  Geometry.prototype.getOffscreenGroup = function () {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase(); // 

      this.offscreenGroup = new GroupCtor({});
    }

    return this.offscreenGroup;
  }; // 


  Geometry.prototype.sort = function (mappingArray) {
    if (!this.hasSorted) {
      // 
      var xScale_1 = this.getXScale();
      var xField_1 = xScale_1.field;

      for (var index = 0; index < mappingArray.length; index++) {
        var itemArr = mappingArray[index];
        itemArr.sort(function (obj1, obj2) {
          return xScale_1.translate(obj1[constant_1.FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[constant_1.FIELD_ORIGIN][xField_1]);
        });
      }
    }

    this.hasSorted = true;
  };
  /**
   *  Geometry Interval  Y  0 
   */


  Geometry.prototype.adjustScale = function () {
    var yScale = this.getYScale(); //  stack adjust yScale 

    if (yScale && this.getAdjust('stack')) {
      this.updateStackRange(yScale, this.beforeMappingData);
    }
  };
  /**
   *  Geometry  Shape 
   */


  Geometry.prototype.getShapeFactory = function () {
    var shapeType = this.shapeType;

    if (!base_2.getShapeFactory(shapeType)) {
      return;
    }

    if (!this.shapeFactory) {
      this.shapeFactory = util_1.clone(base_2.getShapeFactory(shapeType)); //  view  shapeFactory  coordinate 
    } //  shapeFactory coordinate shapeFactory 


    this.shapeFactory.coordinate = this.coordinate; // theme 

    this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
    return this.shapeFactory;
  };
  /**
   *  Shape 
   * @param obj  ->  -> adjust 
   * @returns
   */


  Geometry.prototype.createShapePointsCfg = function (obj) {
    var xScale = this.getXScale();
    var yScale = this.getYScale();
    var x = this.normalizeValues(obj[xScale.field], xScale);
    var y; //  y 

    if (yScale) {
      y = this.normalizeValues(obj[yScale.field], yScale);
    } else {
      y = obj.y ? obj.y : 0.1;
    }

    return {
      x: x,
      y: y,
      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined
    };
  };
  /**
   *  Element 
   * @param mappingDatum Element 
   * @param [isUpdate] 
   * @returns element  Element 
   */


  Geometry.prototype.createElement = function (mappingDatum, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var container = this.container;
    var shapeCfg = this.getDrawCfg(mappingDatum); // 

    var shapeFactory = this.getShapeFactory();
    var element = new element_1.default({
      shapeFactory: shapeFactory,
      container: container,
      offscreenGroup: this.getOffscreenGroup()
    });
    element.animate = this.animateOption;
    element.geometry = this;
    element.draw(shapeCfg, isUpdate); // 

    return element;
  };
  /**
   * 
   * @param mappingDatum 
   * @returns draw cfg
   */


  Geometry.prototype.getDrawCfg = function (mappingDatum) {
    var originData = mappingDatum[constant_1.FIELD_ORIGIN]; // 

    var cfg = {
      mappingData: mappingDatum,
      data: originData,
      x: mappingDatum.x,
      y: mappingDatum.y,
      color: mappingDatum.color,
      size: mappingDatum.size,
      isInCircle: this.coordinate.isPolar,
      customInfo: this.customOption
    };
    var shapeName = mappingDatum.shape;

    if (!shapeName && this.getShapeFactory()) {
      shapeName = this.getShapeFactory().defaultShapeType;
    }

    cfg.shape = shapeName; // 

    var theme = this.theme.geometries[this.shapeType];
    cfg.defaultStyle = util_1.get(theme, [shapeName, 'default'], {}).style;

    if (!cfg.defaultStyle && this.getShapeFactory()) {
      cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme);
    }

    var styleOption = this.styleOption;

    if (styleOption) {
      cfg.style = this.getStyleCfg(styleOption, originData);
    }

    if (this.generatePoints) {
      cfg.points = mappingDatum.points;
      cfg.nextPoints = mappingDatum.nextPoints;
    }

    return cfg;
  };
  /**
   *  Elements
   * @param mappingData
   * @param [isUpdate]
   * @returns elements
   */


  Geometry.prototype.createElements = function (mappingData, index, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var _a = this,
        lastElementsMap = _a.lastElementsMap,
        elementsMap = _a.elementsMap,
        elements = _a.elements;

    for (var subIndex = 0, length_6 = mappingData.length; subIndex < length_6; subIndex++) {
      var mappingDatum = mappingData[subIndex];
      var id = this.getElementId(mappingDatum);

      if (elementsMap[id]) {
        //  index 
        id = id + "-" + index + "-" + subIndex;
      }

      var result = lastElementsMap[id];

      if (!result) {
        //  element
        result = this.createElement(mappingDatum, isUpdate);
      } else {
        // element 
        var currentShapeCfg = this.getDrawCfg(mappingDatum);
        var preShapeCfg = result.getModel();

        if (this.isCoordinateChanged || is_model_change_1.isModelChange(currentShapeCfg, preShapeCfg)) {
          result.animate = this.animateOption; // 

          result.update(currentShapeCfg); //  element
        }

        delete lastElementsMap[id];
      }

      elements.push(result);
      elementsMap[id] = result;
    } //  elements  zIndex 


    if (this.zIndexReversed) {
      var length_7 = elements.length;
      elements.forEach(function (ele, idx) {
        ele.shape.setZIndex(length_7 - idx);
      });
    }

    return elements;
  };
  /**
   *  label 
   */


  Geometry.prototype.getLabelType = function () {
    var _a = this,
        labelOption = _a.labelOption,
        coordinate = _a.coordinate,
        type = _a.type;

    var coordinateType = coordinate.type,
        isTransposed = coordinate.isTransposed;
    var labelType = util_1.get(labelOption, ['cfg', 'type']);

    if (!labelType) {
      // 
      if (coordinateType === 'polar') {
        // 
        labelType = isTransposed ? 'pie' : 'polar';
      } else if (coordinateType === 'theta') {
        // theta 
        labelType = 'pie';
      } else if (type === 'interval' || type === 'polygon') {
        labelType = 'interval';
      } else {
        labelType = 'base';
      }
    }

    return labelType;
  };
  /**
   *  Y 
   */


  Geometry.prototype.getYMinValue = function () {
    var yScale = this.getYScale();
    var min = yScale.min,
        max = yScale.max;
    var value;

    if (min >= 0) {
      value = min;
    } else if (max <= 0) {
      //  ymin  0
      value = max;
    } else {
      value = 0;
    }

    return value;
  }; // 


  Geometry.prototype.createAttrOption = function (attrName, field, cfg) {
    if (util_1.isNil(field) || util_1.isObject(field)) {
      if (util_1.isObject(field) && util_1.isEqual(Object.keys(field), ['values'])) {
        // shape({ values: [ 'funnel' ] })
        util_1.set(this.attributeOption, attrName, {
          fields: field.values
        });
      } else {
        util_1.set(this.attributeOption, attrName, field);
      }
    } else {
      var attrCfg = {};

      if (util_1.isNumber(field)) {
        // size(3)
        attrCfg.values = [field];
      } else {
        attrCfg.fields = parse_fields_1.parseFields(field);
      }

      if (cfg) {
        if (util_1.isFunction(cfg)) {
          attrCfg.callback = cfg;
        } else {
          attrCfg.values = cfg;
        }
      }

      util_1.set(this.attributeOption, attrName, attrCfg);
    }
  };

  Geometry.prototype.initAttributes = function () {
    var _this = this;

    var _a = this,
        attributes = _a.attributes,
        attributeOption = _a.attributeOption,
        theme = _a.theme,
        shapeType = _a.shapeType;

    this.groupScales = [];
    var tmpMap = {};

    var _loop_1 = function _loop_1(attrType) {
      if (attributeOption.hasOwnProperty(attrType)) {
        var option = attributeOption[attrType];

        if (!option) {
          return {
            value: void 0
          };
        }

        var attrCfg = tslib_1.__assign({}, option);

        var callback = attrCfg.callback,
            values = attrCfg.values,
            _a = attrCfg.fields,
            fields = _a === void 0 ? [] : _a; //  scale

        var scales = fields.map(function (field) {
          var scale = _this.scales[field];

          if (scale.isCategory && !tmpMap[field] && constant_1.GROUP_ATTRS.includes(attrType)) {
            _this.groupScales.push(scale);

            tmpMap[field] = true;
          }

          return scale;
        });
        attrCfg.scales = scales;

        if (attrType !== 'position' && scales.length === 1 && scales[0].type === 'identity') {
          //  color('red'), size(5)
          attrCfg.values = scales[0].values;
        } else if (!callback && !values) {
          // 
          if (attrType === 'size') {
            attrCfg.values = theme.sizes;
          } else if (attrType === 'shape') {
            attrCfg.values = theme.shapes[shapeType] || [];
          } else if (attrType === 'color') {
            if (scales.length) {
              // 
              attrCfg.values = scales[0].values.length <= 10 ? theme.colors10 : theme.colors20;
            } else {
              attrCfg.values = theme.colors10;
            }
          }
        }

        var AttributeCtor = attr_1.getAttribute(attrType);
        attributes[attrType] = new AttributeCtor(attrCfg);
      }
    }; //  attrOption Attribute 


    for (var attrType in attributeOption) {
      var state_1 = _loop_1(attrType);

      if ((0, _typeof2.default)(state_1) === "object") return state_1.value;
    }
  }; //  ->  -> adjust 


  Geometry.prototype.processData = function (data) {
    this.hasSorted = false;
    var scales = this.getAttribute('position').scales;
    var categoryScales = scales.filter(function (scale) {
      return scale.isCategory;
    });
    var groupedArray = this.groupData(data); // 

    var beforeAdjust = [];

    for (var i = 0, len = groupedArray.length; i < len; i++) {
      var subData = groupedArray[i];
      var arr = [];

      for (var j = 0, subLen = subData.length; j < subLen; j++) {
        var originData = subData[j];
        var item = {}; // tslint:disable-next-line: forin

        for (var k in originData) {
          item[k] = originData[k];
        }

        item[constant_1.FIELD_ORIGIN] = originData; // , 

        for (var _i = 0, categoryScales_1 = categoryScales; _i < categoryScales_1.length; _i++) {
          var scale = categoryScales_1[_i];
          var field = scale.field;
          item[field] = scale.translate(item[field]);
        }

        arr.push(item);
      }

      beforeAdjust.push(arr);
    }

    var dataArray = this.adjustData(beforeAdjust); //  adjust 

    this.beforeMappingData = dataArray;
    return dataArray;
  }; // 


  Geometry.prototype.adjustData = function (dataArray) {
    var adjustOption = this.adjustOption;

    var _a = this,
        intervalPadding = _a.intervalPadding,
        dodgePadding = _a.dodgePadding,
        theme = _a.theme; // theme


    var maxColumnWidth = this.maxColumnWidth || theme.maxColumnWidth;
    var minColumnWidth = this.minColumnWidth || theme.minColumnWidth;
    var columnWidthRatio = this.columnWidthRatio || theme.columnWidthRatio;
    var result = dataArray;

    if (adjustOption) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field;
      var yField = yScale ? yScale.field : null;
      var xDimensionLength = coordinate_1.getXDimensionLength(this.coordinate);
      var groupNum = xScale.values.length; // size

      var sizeAttr = this.getAttribute('size');
      var defaultSize = void 0;

      if (sizeAttr) {
        defaultSize = sizeAttr.values[0];
      }

      for (var i = 0, len = adjustOption.length; i < len; i++) {
        var adjust = adjustOption[i];

        var adjustCfg = tslib_1.__assign({
          xField: xField,
          yField: yField,
          intervalPadding: intervalPadding,
          dodgePadding: dodgePadding,
          xDimensionLength: xDimensionLength,
          groupNum: groupNum,
          defaultSize: defaultSize,
          maxColumnWidth: maxColumnWidth,
          minColumnWidth: minColumnWidth,
          columnWidthRatio: columnWidthRatio
        }, adjust);

        var type = adjust.type;

        if (type === 'dodge') {
          var adjustNames = [];

          if (xScale.isCategory || xScale.type === 'identity') {
            adjustNames.push('x');
          } else if (!yScale) {
            adjustNames.push('y');
          } else {
            throw new Error('dodge is not support linear attribute, please use category attribute!');
          }

          adjustCfg.adjustNames = adjustNames; //  columnWidthRatio 
          // theme

          adjustCfg.dodgeRatio = columnWidthRatio;
        } else if (type === 'stack') {
          var coordinate = this.coordinate;

          if (!yScale) {
            // size
            adjustCfg.height = coordinate.getHeight();
            var size = this.getDefaultValue('size') || 3;
            adjustCfg.size = size;
          } //  transpose 


          if (!coordinate.isTransposed && util_1.isNil(adjustCfg.reverseOrder)) {
            adjustCfg.reverseOrder = true;
          }
        }

        var adjustCtor = adjust_1.getAdjust(type);
        var adjustInstance = new adjustCtor(adjustCfg);
        result = adjustInstance.process(result);
        this.adjusts[type] = adjustInstance;
      }
    }

    return result;
  }; // 


  Geometry.prototype.groupData = function (data) {
    var groupScales = this.getGroupScales();
    var scaleDefs = this.scaleDefs;
    var appendConditions = {};
    var groupFields = [];

    for (var index = 0; index < groupScales.length; index++) {
      var scale = groupScales[index];
      var field = scale.field;
      groupFields.push(field);

      if (util_1.get(scaleDefs, [field, 'values'])) {
        //  view.scale()  values 
        appendConditions[field] = scaleDefs[field].values;
      }
    }

    return group_data_1.group(data, groupFields, appendConditions);
  }; // 


  Geometry.prototype.updateStackRange = function (scale, dataArray) {
    var mergeArray = util_1.flatten(dataArray);
    var field = scale.field;
    var min = scale.min;
    var max = scale.max;

    for (var index = 0; index < mergeArray.length; index++) {
      var obj = mergeArray[index];
      var tmpMin = Math.min.apply(null, obj[field]);
      var tmpMax = Math.max.apply(null, obj[field]);

      if (tmpMin < min) {
        min = tmpMin;
      }

      if (tmpMax > max) {
        max = tmpMax;
      }
    }

    var scaleDefs = this.scaleDefs;
    var cfg = {};

    if (min < scale.min && !util_1.get(scaleDefs, [field, 'min'])) {
      //  min
      cfg.min = min;
    }

    if (max > scale.max && !util_1.get(scaleDefs, [field, 'max'])) {
      //  max
      cfg.max = max;
    }

    scale.change(cfg);
  }; // 


  Geometry.prototype.beforeMapping = function (beforeMappingData) {
    //  clone  points  clone
    // const source = clone(beforeMappingData);
    var source = beforeMappingData;

    if (this.sortable) {
      this.sort(source);
    }

    if (this.generatePoints) {
      // 
      for (var index = 0, length_8 = source.length; index < length_8; index++) {
        var currentData = source[index];
        this.generateShapePoints(currentData);
        var nextData = source[index + 1];

        if (nextData) {
          this.generateShapePoints(nextData);
          currentData[0].nextPoints = nextData[0].points;
        }
      }
    }

    return source;
  }; //  shape 


  Geometry.prototype.generateShapePoints = function (data) {
    var shapeFactory = this.getShapeFactory();
    var shapeAttr = this.getAttribute('shape');

    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var cfg = this.createShapePointsCfg(obj);
      var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
      var points = shapeFactory.getShapePoints(shape, cfg);
      obj.points = points;
    }
  }; // 


  Geometry.prototype.normalizeValues = function (values, scale) {
    var rst = [];

    if (util_1.isArray(values)) {
      for (var index = 0; index < values.length; index++) {
        var value = values[index];
        rst.push(scale.scale(value));
      }
    } else {
      rst = scale.scale(values);
    }

    return rst;
  }; // 


  Geometry.prototype.mapping = function (data) {
    var attributes = this.attributes;
    var mappingData = [];

    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var newRecord = {
        _origin: record[constant_1.FIELD_ORIGIN],
        points: record.points,
        nextPoints: record.nextPoints
      };

      for (var k in attributes) {
        if (attributes.hasOwnProperty(k)) {
          var attr = attributes[k];
          var names = attr.names;
          var values = this.getAttributeValues(attr, record);

          if (names.length > 1) {
            // position 
            for (var j = 0; j < values.length; j += 1) {
              var val = values[j];
              var name_1 = names[j];
              newRecord[name_1] = util_1.isArray(val) && val.length === 1 ? val[0] : val; // 
            }
          } else {
            // values.length === 1 
            // shape('a', ['dot', 'dash']), color('a', ['red', 'yellow'])
            newRecord[names[0]] = values.length === 1 ? values[0] : values;
          }
        }
      }

      this.convertPoint(newRecord); //  xy 

      mappingData.push(newRecord);
    }

    return mappingData;
  }; // 


  Geometry.prototype.convertPoint = function (mappingRecord) {
    var x = mappingRecord.x,
        y = mappingRecord.y;
    var rstX;
    var rstY;
    var obj;
    var coordinate = this.coordinate;

    if (util_1.isArray(x) && util_1.isArray(y)) {
      rstX = [];
      rstY = [];

      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
        obj = coordinate.convert({
          x: x[i],
          y: y[j]
        });
        rstX.push(obj.x);
        rstY.push(obj.y);
      }
    } else if (util_1.isArray(y)) {
      rstY = [];

      for (var index = 0; index < y.length; index++) {
        var yVal = y[index];
        obj = coordinate.convert({
          x: x,
          y: yVal
        });

        if (rstX && rstX !== obj.x) {
          if (!util_1.isArray(rstX)) {
            rstX = [rstX];
          }

          rstX.push(obj.x);
        } else {
          rstX = obj.x;
        }

        rstY.push(obj.y);
      }
    } else if (util_1.isArray(x)) {
      rstX = [];

      for (var index = 0; index < x.length; index++) {
        var xVal = x[index];
        obj = coordinate.convert({
          x: xVal,
          y: y
        });

        if (rstY && rstY !== obj.y) {
          if (!util_1.isArray(rstY)) {
            rstY = [rstY];
          }

          rstY.push(obj.y);
        } else {
          rstY = obj.y;
        }

        rstX.push(obj.x);
      }
    } else {
      var point = coordinate.convert({
        x: x,
        y: y
      });
      rstX = point.x;
      rstY = point.y;
    }

    mappingRecord.x = rstX;
    mappingRecord.y = rstY;
  }; //  style 


  Geometry.prototype.getStyleCfg = function (styleOption, originData) {
    var _a = styleOption.fields,
        fields = _a === void 0 ? [] : _a,
        callback = styleOption.callback,
        cfg = styleOption.cfg;

    if (cfg) {
      // 
      return cfg;
    }

    var params = fields.map(function (field) {
      return originData[field];
    });
    return callback.apply(void 0, params);
  };

  Geometry.prototype.setCfg = function (cfg) {
    var _this = this;

    var coordinate = cfg.coordinate,
        data = cfg.data,
        theme = cfg.theme,
        scaleDefs = cfg.scaleDefs;

    if (coordinate) {
      this.coordinate = coordinate;
    }

    if (data) {
      this.data = data;
    }

    if (scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.idFields = [];
      util_1.each(scaleDefs, function (scaleDef, field) {
        if (scaleDef && scaleDef.key) {
          _this.idFields.push(field);
        }
      });
    }

    if (theme) {
      this.theme = this.userTheme ? util_1.deepMix({}, theme, this.userTheme) : theme; //  geometry 
    }
  };

  Geometry.prototype.renderLabels = function (mappingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var geometryLabel = this.geometryLabel;

    if (!geometryLabel) {
      // 
      var labelType = this.getLabelType();
      var GeometryLabelsCtor = label_1.getGeometryLabel(labelType);
      geometryLabel = new GeometryLabelsCtor(this);
      this.geometryLabel = geometryLabel;
    }

    geometryLabel.render(mappingArray, isUpdate); //  label  element 

    var labelsMap = geometryLabel.labelsRenderer.shapesMap;
    util_1.each(this.elementsMap, function (element, id) {
      var labels = filterLabelsById(id, labelsMap); // element  label 

      if (labels.length) {
        element.labelShape = labels;

        for (var i = 0; i < labels.length; i++) {
          var label = labels[i];
          var labelChildren = label.getChildren();

          for (var j = 0; j < labelChildren.length; j++) {
            var child = labelChildren[j];
            child.cfg.name = ['element', 'label'];
            child.cfg.element = element;
          }
        }
      }
    });
  };
  /**
   * 
   * 
   * 1. 
   * 2.  geometry 
   * 3.  appear 
   * 4.  appear.animation
   */


  Geometry.prototype.canDoGroupAnimation = function (isUpdate) {
    return !isUpdate && this.animateOption && (util_1.get(this.animateOption, 'appear') === undefined || util_1.get(this.animateOption, 'appear') && util_1.get(this.animateOption, ['appear', 'animation']) === undefined);
  };

  return Geometry;
}(base_1.default);

exports.default = Geometry;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.points = points;
exports.visitPoints = visitPoints;

// Adapted from vega-statistics by Jeffrey Heer
// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/points.js
function points(data, x, y, sort) {
  data = data.filter(function (d) {
    var u = x(d),
        v = y(d);
    return u != null && isFinite(u) && v != null && isFinite(v);
  });

  if (sort) {
    data.sort(function (a, b) {
      return x(a) - x(b);
    });
  }

  var n = data.length,
      X = new Float64Array(n),
      Y = new Float64Array(n); // extract values, calculate means

  var ux = 0,
      uy = 0,
      xv,
      yv,
      d;

  for (var i = 0; i < n;) {
    d = data[i];
    X[i] = xv = +x(d);
    Y[i] = yv = +y(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  } // mean center the data


  for (var _i = 0; _i < n; ++_i) {
    X[_i] -= ux;
    Y[_i] -= uy;
  }

  return [X, Y, ux, uy];
}

function visitPoints(data, x, y, cb) {
  var iterations = 0;

  for (var i = 0, n = data.length; i < n; i++) {
    var d = data[i],
        dx = +x(d),
        dy = +y(d);

    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
      cb(dx, dy, iterations++);
    }
  }
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var animate_1 = __webpack_require__(96);

var graphics_1 = __webpack_require__(45);

var labels_1 = tslib_1.__importDefault(__webpack_require__(902));

function avg(arr) {
  var sum = 0;
  util_1.each(arr, function (value) {
    sum += value;
  });
  return sum / arr.length;
}
/**
 * Geometry Label  Geometry  label 
 */


var GeometryLabel =
/** @class */
function () {
  function GeometryLabel(geometry) {
    this.geometry = geometry;
  }

  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {
    var _this = this;

    var items = [];
    var labelCfgs = this.getLabelCfgs(mapppingArray); //  label  xy  x, y

    util_1.each(mapppingArray, function (mappingData, index) {
      var labelCfg = labelCfgs[index];

      if (!labelCfg || util_1.isNil(mappingData.x) || util_1.isNil(mappingData.y)) {
        items.push(null);
        return;
      }

      var labelContent = !util_1.isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
      labelCfg.content = labelContent;
      var total = labelContent.length;
      util_1.each(labelContent, function (content, subIndex) {
        if (util_1.isNil(content) || content === '') {
          items.push(null);
          return;
        }

        var item = tslib_1.__assign(tslib_1.__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));

        if (!item.textAlign) {
          item.textAlign = _this.getLabelAlign(item, subIndex, total);
        }

        if (item.offset <= 0) {
          item.labelLine = null;
        }

        items.push(item);
      });
    });
    return items;
  };

  GeometryLabel.prototype.render = function (mapppingArray, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var labelItems = this.getLabelItems(mapppingArray);
    var labelsRenderer = this.getLabelsRenderer();
    var shapes = this.getGeometryShapes(); // 

    labelsRenderer.render(labelItems, shapes, isUpdate);
  };

  GeometryLabel.prototype.clear = function () {
    var labelsRenderer = this.labelsRenderer;

    if (labelsRenderer) {
      labelsRenderer.clear();
    }
  };

  GeometryLabel.prototype.destroy = function () {
    var labelsRenderer = this.labelsRenderer;

    if (labelsRenderer) {
      labelsRenderer.destroy();
    }

    this.labelsRenderer = null;
  }; // geometry  Coordinate  Coordinate


  GeometryLabel.prototype.getCoordinate = function () {
    return this.geometry.coordinate;
  };
  /**
   *  label 
   */


  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {
    var geometry = this.geometry;
    var type = geometry.type,
        theme = geometry.theme;

    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {
      // polygon  (interval  middle)  offset  0  
      return util_1.get(theme, 'innerLabels', {});
    }

    return util_1.get(theme, 'labels', {});
  };
  /**
   *  label 
   * @param labelCfg
   */


  GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var type = geometry.type,
        theme = geometry.theme;
    var themedLabelCfg;

    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {
      // polygon  offset  0  
      themedLabelCfg = util_1.deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);
    } else {
      themedLabelCfg = util_1.deepMix({}, defaultLabelCfg, theme.labels, labelCfg);
    }

    return themedLabelCfg;
  };
  /**
   *  label 
   * @param labelPointCfg
   * @param mappingData
   * @param index
   * @param position
   */


  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};
  /**
   * @desc  label offset
   */


  GeometryLabel.prototype.getLabelOffset = function (offset) {
    var coordinate = this.getCoordinate();
    var vector = this.getOffsetVector(offset);
    return coordinate.isTransposed ? vector[0] : vector[1];
  };
  /**
   *  label  ()
   * @param labelCfg
   * @param index
   * @param total
   * @return {Point} offsetPoint
   */


  GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {
    var offset = labelCfg.offset;
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var dim = transposed ? 'x' : 'y';
    var factor = transposed ? 1 : -1; // y transposed

    var offsetPoint = {
      x: 0,
      y: 0
    };

    if (index > 0 || total === 1) {
      // 0
      offsetPoint[dim] = offset * factor;
    } else {
      offsetPoint[dim] = offset * factor * -1;
    }

    return offsetPoint;
  };
  /**
   *  label 
   * @param labelCfg
   * @param mappingData
   * @param index
   * @returns label point
   */


  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
    var coordinate = this.getCoordinate();
    var total = labelCfg.content.length;

    function getDimValue(value, idx, isAvg) {
      if (isAvg === void 0) {
        isAvg = false;
      }

      var v = value;

      if (util_1.isArray(v)) {
        if (labelCfg.content.length === 1) {
          if (isAvg) {
            v = avg(v);
          } else {
            //  label y,  y
            if (v.length <= 2) {
              v = v[value.length - 1];
            } else {
              v = avg(v);
            }
          }
        } else {
          v = v[idx];
        }
      }

      return v;
    }

    var label = {
      content: labelCfg.content[index],
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      color: '#fff'
    };
    var shape = util_1.isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
    var isFunnel = shape === 'funnel' || shape === 'pyramid'; // 

    if (this.geometry.type === 'polygon') {
      var centroid = graphics_1.getPolygonCentroid(mappingData.x, mappingData.y);
      label.x = centroid[0];
      label.y = centroid[1];
    } else if (this.geometry.type === 'interval' && !isFunnel) {
      // label X 
      label.x = getDimValue(mappingData.x, index, true);
      label.y = getDimValue(mappingData.y, index);
    } else {
      label.x = getDimValue(mappingData.x, index);
      label.y = getDimValue(mappingData.y, index);
    } // 


    if (isFunnel) {
      var nextPoints = util_1.get(mappingData, 'nextPoints');
      var points = util_1.get(mappingData, 'points');

      if (nextPoints) {
        // 
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(nextPoints[1]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      } else if (shape === 'pyramid') {
        var point1 = coordinate.convert(points[1]);
        var point2 = coordinate.convert(points[2]);
        label.x = (point1.x + point2.x) / 2;
        label.y = (point1.y + point2.y) / 2;
      }
    }

    if (labelCfg.position) {
      //  label  position 
      this.setLabelPosition(label, mappingData, index, labelCfg.position);
    }

    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);
    label.start = {
      x: label.x,
      y: label.y
    };
    label.x += offsetPoint.x;
    label.y += offsetPoint.y;
    label.color = mappingData.color;
    return label;
  };
  /**
   * 
   * @param item
   * @param index
   * @param total
   * @returns
   */


  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {
    var align = 'center';
    var coordinate = this.getCoordinate();

    if (coordinate.isTransposed) {
      var offset = item.offset;

      if (offset < 0) {
        align = 'right';
      } else if (offset === 0) {
        align = 'center';
      } else {
        align = 'left';
      }

      if (total > 1 && index === 0) {
        if (align === 'right') {
          align = 'left';
        } else if (align === 'left') {
          align = 'right';
        }
      }
    }

    return align;
  };
  /**
   *  label  id
   * @param mappingData label 
   */


  GeometryLabel.prototype.getLabelId = function (mappingData) {
    var geometry = this.geometry;
    var type = geometry.type;
    var xScale = geometry.getXScale();
    var yScale = geometry.getYScale();
    var origin = mappingData[constant_1.FIELD_ORIGIN]; // 

    var labelId = geometry.getElementId(mappingData);

    if (type === 'line' || type === 'area') {
      //  labels labels line id  x 
      labelId += " " + origin[xScale.field];
    } else if (type === 'path') {
      // path  x  y  x y  id
      labelId += " " + origin[xScale.field] + "-" + origin[yScale.field];
    }

    return labelId;
  }; //  labels 


  GeometryLabel.prototype.getLabelsRenderer = function () {
    var _a = this.geometry,
        labelsContainer = _a.labelsContainer,
        labelOption = _a.labelOption,
        canvasRegion = _a.canvasRegion,
        animateOption = _a.animateOption;
    var coordinate = this.geometry.coordinate;
    var labelsRenderer = this.labelsRenderer;

    if (!labelsRenderer) {
      labelsRenderer = new labels_1.default({
        container: labelsContainer,
        layout: util_1.get(labelOption, ['cfg', 'layout'], {
          type: this.defaultLayout
        })
      });
      this.labelsRenderer = labelsRenderer;
    }

    labelsRenderer.region = canvasRegion; //  geometry  label 

    labelsRenderer.animate = animateOption ? animate_1.getDefaultAnimateCfg('label', coordinate) : false;
    return labelsRenderer;
  };

  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {
    var _this = this;

    var geometry = this.geometry;
    var labelOption = geometry.labelOption,
        scales = geometry.scales,
        coordinate = geometry.coordinate;
    var _a = labelOption,
        fields = _a.fields,
        callback = _a.callback,
        cfg = _a.cfg;
    var labelScales = fields.map(function (field) {
      return scales[field];
    });
    var labelCfgs = [];
    util_1.each(mapppingArray, function (mappingData, index) {
      var origin = mappingData[constant_1.FIELD_ORIGIN]; // 

      var originText = _this.getLabelText(origin, labelScales);

      var callbackCfg;

      if (callback) {
        //  callback  cfg  callback 
        var originValues = fields.map(function (field) {
          return origin[field];
        });
        callbackCfg = callback.apply(void 0, originValues);

        if (util_1.isNil(callbackCfg)) {
          labelCfgs.push(null);
          return;
        }
      }

      var labelCfg = tslib_1.__assign(tslib_1.__assign({
        id: _this.getLabelId(mappingData),
        elementId: _this.geometry.getElementId(mappingData),
        data: origin,
        // 
        mappingData: mappingData,
        coordinate: coordinate
      }, cfg), callbackCfg);

      if (util_1.isFunction(labelCfg.position)) {
        labelCfg.position = labelCfg.position(origin, mappingData, index);
      }

      var offset = _this.getLabelOffset(labelCfg.offset || 0); // defaultCfg  innerLabels & labels


      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position); // labelCfg priority: defaultCfg < cfg < callbackCfg


      labelCfg = util_1.deepMix({}, defaultLabelCfg, labelCfg); //  offset

      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
      var content = labelCfg.content;

      if (util_1.isFunction(content)) {
        labelCfg.content = content(origin, mappingData, index);
      } else if (util_1.isUndefined(content)) {
        //  content
        labelCfg.content = originText[0];
      }

      labelCfgs.push(labelCfg);
    });
    return labelCfgs;
  };

  GeometryLabel.prototype.getLabelText = function (origin, scales) {
    var labelTexts = [];
    util_1.each(scales, function (scale) {
      var value = origin[scale.field];

      if (util_1.isArray(value)) {
        value = value.map(function (subVal) {
          return scale.getText(subVal);
        });
      } else {
        value = scale.getText(value);
      }

      if (util_1.isNil(value) || value === '') {
        labelTexts.push(null);
      } else {
        labelTexts.push(value);
      }
    });
    return labelTexts;
  };

  GeometryLabel.prototype.getOffsetVector = function (offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var coordinate = this.getCoordinate();
    var actualOffset = 0;

    if (util_1.isNumber(offset)) {
      actualOffset = offset;
    } //  x,y  x y


    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);
  };

  GeometryLabel.prototype.getGeometryShapes = function () {
    var geometry = this.geometry;
    var shapes = {};
    util_1.each(geometry.elementsMap, function (element, id) {
      shapes[id] = element.shape;
    }); //  shape  shape.getBBox()  offscreenGroup 

    util_1.each(geometry.getOffscreenGroup().getChildren(), function (child) {
      var id = geometry.getElementId(child.get('origin').mappingData);
      shapes[id] = child;
    });
    return shapes;
  };

  return GeometryLabel;
}();

exports.default = GeometryLabel;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getConstraint = exports.getShapeAttrs = void 0;

var util_1 = __webpack_require__(0);

var get_path_points_1 = __webpack_require__(277);

var get_style_1 = __webpack_require__(40);

var path_1 = __webpack_require__(146);

function getPath(points, isInCircle, smooth, registeredShape, constraint) {
  var path = [];

  if (points.length) {
    var topLinePoints_1 = []; // area 

    var bottomLinePoints_1 = []; // area 

    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];
      topLinePoints_1.push(point[1]);
      bottomLinePoints_1.push(point[0]);
    }

    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    util_1.each([topLinePoints_1, bottomLinePoints_1], function (pointsData, index) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];

      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        // 
        subPath = index === 0 ? [['M', p1.x - 0.5, p1.y], ['L', p1.x + 0.5, p1.y]] : [['L', p1.x + 0.5, p1.y], ['L', p1.x - 0.5, p1.y]];
      } else {
        if (isInCircle) {
          parsedPoints.push({
            x: p1.x,
            y: p1.y
          });
        }

        if (smooth) {
          subPath = path_1.getSplinePath(parsedPoints, false, constraint);
        } else {
          subPath = path_1.getLinePath(parsedPoints, false);
        }

        if (index > 0) {
          subPath[0][0] = 'L';
        }
      }

      path = path.concat(subPath);
    });
    path.push(['Z']);
  }

  return path;
}
/**
 * @ignore
 * Gets shape attrs
 * @param cfg
 * @param isStroke
 * @param smooth
 * @param registeredShape
 * @param [constraint]
 * @returns
 */


function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = get_style_1.getStyle(cfg, isStroke, !isStroke, 'lineWidth');
  var connectNulls = cfg.connectNulls,
      isInCircle = cfg.isInCircle,
      points = cfg.points,
      showSinglePoint = cfg.showSinglePoint;
  var pathPoints = get_path_points_1.getPathPoints(points, connectNulls, showSinglePoint); //  connectNulls 

  var path = [];

  for (var i = 0, len = pathPoints.length; i < len; i++) {
    var eachPoints = pathPoints[i];
    path = path.concat(getPath(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }

  attrs.path = path;
  return attrs;
}

exports.getShapeAttrs = getShapeAttrs;
/**
 * @ignore
 * Gets constraint
 * @param coordinate
 * @returns constraint
 */

function getConstraint(coordinate) {
  var start = coordinate.start,
      end = coordinate.end;
  return [[start.x, end.y], [end.x, start.y]];
}

exports.getConstraint = getConstraint;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

var _default = function _default(str) {
  return (0, _isType.default)(str, 'String');
};

exports.default = _default;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeFromArray = removeFromArray;
exports.isParent = isParent;
exports.isAllowCapture = isAllowCapture;
Object.defineProperty(exports, "isNil", {
  enumerable: true,
  get: function get() {
    return _util.isNil;
  }
});
Object.defineProperty(exports, "isFunction", {
  enumerable: true,
  get: function get() {
    return _util.isFunction;
  }
});
Object.defineProperty(exports, "isString", {
  enumerable: true,
  get: function get() {
    return _util.isString;
  }
});
Object.defineProperty(exports, "isObject", {
  enumerable: true,
  get: function get() {
    return _util.isObject;
  }
});
Object.defineProperty(exports, "isArray", {
  enumerable: true,
  get: function get() {
    return _util.isArray;
  }
});
Object.defineProperty(exports, "mix", {
  enumerable: true,
  get: function get() {
    return _util.mix;
  }
});
Object.defineProperty(exports, "each", {
  enumerable: true,
  get: function get() {
    return _util.each;
  }
});
Object.defineProperty(exports, "upperFirst", {
  enumerable: true,
  get: function get() {
    return _util.upperFirst;
  }
});
exports.isBrowser = void 0;

var _util = __webpack_require__(0);

function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);

  if (index !== -1) {
    arr.splice(index, 1);
  }
}

var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
exports.isBrowser = isBrowser;

// 
function isParent(container, shape) {
  //  shape  canvas 
  if (container.isCanvas()) {
    return true;
  }

  var parent = shape.getParent();
  var isParent = false;

  while (parent) {
    if (parent === container) {
      isParent = true;
      break;
    }

    parent = parent.getParent();
  }

  return isParent;
}

function isAllowCapture(element) {
  // @ts-ignore
  return element.cfg.visible && element.cfg.capture;
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

// todo 
var toScaleString = function toScaleString(scale, value) {
  if ((0, _util.isString)(value)) {
    return value;
  }

  return scale.invert(scale.scale(value));
};
/**
 * 
 * @class Base
 */


var Attribute =
/** @class */
function () {
  function Attribute(cfg) {
    this.names = [];
    this.scales = [];
    this.linear = false;
    this.values = [];

    this.callback = function () {
      return [];
    }; // 


    this._parseCfg(cfg);
  }
  /**
   * 
   * @param params  scale 
   */


  Attribute.prototype.mapping = function () {
    var _this = this;

    var params = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }

    var values = params.map(function (param, idx) {
      return _this._toOriginParam(param, _this.scales[idx]);
    });
    return this.callback.apply(this, values);
  };
  /**
   * 
   * @param percent
   */


  Attribute.prototype.getLinearValue = function (percent) {
    // 
    var steps = this.values.length - 1;
    var step = Math.floor(steps * percent);
    var leftPercent = steps * percent - step; // todo 

    var start = this.values[step];
    var end = step === steps ? start : this.values[step + 1]; // 

    return start + (end - start) * leftPercent;
  };
  /**
   * 
   */


  Attribute.prototype.getNames = function () {
    var scales = this.scales;
    var names = this.names;
    var length = Math.min(scales.length, names.length);
    var rst = [];

    for (var i = 0; i < length; i += 1) {
      rst.push(names[i]);
    }

    return rst;
  };
  /**
   * 
   */


  Attribute.prototype.getFields = function () {
    return this.scales.map(function (scale) {
      return scale.field;
    });
  };
  /**
   * 
   * @param name
   */


  Attribute.prototype.getScale = function (name) {
    return this.scales[this.names.indexOf(name)];
  };
  /**
   *  callback callback  values 
   * @param params
   */


  Attribute.prototype.defaultCallback = function () {
    var _this = this;

    var params = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    } //  params  fields values 


    if (params.length === 0) {
      return this.values;
    }

    return params.map(function (param, idx) {
      var scale = _this.scales[idx];
      return scale.type === 'identity' ? scale.values[0] : _this._getAttributeValue(scale, param);
    });
  }; // 


  Attribute.prototype._parseCfg = function (cfg) {
    var _this = this;

    var _a = cfg.type,
        type = _a === void 0 ? 'base' : _a,
        _b = cfg.names,
        names = _b === void 0 ? [] : _b,
        _c = cfg.scales,
        scales = _c === void 0 ? [] : _c,
        _d = cfg.values,
        values = _d === void 0 ? [] : _d,
        callback = cfg.callback;
    this.type = type;
    this.scales = scales;
    this.values = values;
    this.names = names; //  callback 

    this.callback = function () {
      var params = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      /**
       *  callback  null ,  callback 
       */


      if (callback) {
        // 
        var ret = callback.apply(void 0, params);

        if (!(0, _util.isNil)(ret)) {
          return [ret];
        }
      } //  callback  callback 


      return _this.defaultCallback.apply(_this, params);
    };
  }; // 


  Attribute.prototype._getAttributeValue = function (scale, value) {
    //  values 
    if (scale.isCategory && !this.linear) {
      //  scale 
      var idx = scale.translate(value);
      return this.values[idx % this.values.length];
    } // 


    var percent = scale.scale(value);
    return this.getLinearValue(percent);
  };
  /**
   *  scale 
   * @param param
   * @param scale
   * @private
   */


  Attribute.prototype._toOriginParam = function (param, scale) {
    // 
    //  scale 
    return !scale.isLinear ? (0, _util.isArray)(param) ? param.map(function (p) {
      return toScaleString(scale, p);
    }) : toScaleString(scale, param) : param;
  };

  return Attribute;
}();

var _default = Attribute;
exports.default = _default;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Controller = void 0;

var util_1 = __webpack_require__(0);
/**
 * Component Controller 
 * 1.  option 
 * 2.  API
 * 3. 
 */


var Controller =
/** @class */
function () {
  function Controller(view) {
    /**  */
    this.visible = true;
    /**  component */

    this.components = [];
    this.view = view;
  }
  /**
   * clear
   * @param includeOption  option used in annotation
   */


  Controller.prototype.clear = function (includeOption) {
    // destroy all components
    util_1.each(this.components, function (co) {
      co.component.destroy();
    }); // clear all component instance

    this.components = [];
  };
  /**
   * destroy the component
   */


  Controller.prototype.destroy = function () {
    this.clear();
  };
  /**
   * get all components
   * @returns components array
   */


  Controller.prototype.getComponents = function () {
    return this.components;
  };
  /**
   * change visibility of component
   * @param visible
   */


  Controller.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }

    this.components.forEach(function (co) {
      if (visible) {
        co.component.show();
      } else {
        co.component.hide();
      }
    });
    this.visible = visible;
  };

  return Controller;
}();

exports.Controller = Controller;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Facet = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var axis_1 = __webpack_require__(263);
/**
 * facet 
 *  -  facet
 *  - 
 *
 * 
 *
 *  init
 * 1. 
 * 2. 
 *
 *  render
 * 1. view 
 * 2. title
 * 3. axis
 *
 *  clear
 * 1.  view
 *
 *  destroy
 * 1. clear
 * 2. 
 * 3.  group
 */


var Facet =
/** @class */
function () {
  function Facet(view, cfg) {
    /**  */
    this.destroyed = false;
    /**  */

    this.facets = [];
    this.view = view;
    this.cfg = util_1.deepMix({}, this.getDefaultCfg(), cfg);
  }
  /**
   * 
   */


  Facet.prototype.init = function () {
    // 
    if (!this.container) {
      this.container = this.createContainer();
    } // 


    var data = this.view.getData();
    this.facets = this.generateFacets(data);
  };
  /**
   *  view 
   *  -  view
   *  - 
   *  - title
   *
   *  
   */


  Facet.prototype.render = function () {
    this.renderViews();
  };
  /**
   *  facet
   */


  Facet.prototype.update = function () {//  facet  View  Geometry  view 
  };
  /**
   * clear  init 
   * 
   */


  Facet.prototype.clear = function () {
    this.clearFacetViews();
  };
  /**
   * 
   */


  Facet.prototype.destroy = function () {
    this.clear();

    if (this.container) {
      this.container.remove(true);
      this.container = undefined;
    }

    this.destroyed = true;
    this.view = undefined;
    this.facets = [];
  };
  /**
   *  facet  view
   * @param facet
   */


  Facet.prototype.facetToView = function (facet) {
    var region = facet.region,
        data = facet.data,
        _a = facet.padding,
        padding = _a === void 0 ? this.cfg.padding : _a;
    var view = this.view.createView({
      region: region,
      padding: padding
    }); // 

    view.data(data || []);
    facet.view = view; // 

    this.beforeEachView(view, facet);
    var eachView = this.cfg.eachView;

    if (eachView) {
      eachView(view, facet);
    } // 


    this.afterEachView(view, facet);
    return view;
  }; // 


  Facet.prototype.createContainer = function () {
    var foregroundGroup = this.view.getLayer(constant_1.LAYER.FORE);
    return foregroundGroup.addGroup();
  };
  /**
   *  view
   */


  Facet.prototype.renderViews = function () {
    this.createFacetViews();
  };
  /**
   *   view
   */


  Facet.prototype.createFacetViews = function () {
    var _this = this; //   view


    return this.facets.map(function (facet) {
      return _this.facetToView(facet);
    });
  };
  /**
   *  view  facetView
   */


  Facet.prototype.clearFacetViews = function () {
    var _this = this; //  view  view


    util_1.each(this.facets, function (facet) {
      if (facet.view) {
        _this.view.removeView(facet.view);

        facet.view = undefined;
      }
    });
  }; // 

  /**
   * 
   * @protected
   * @param data 
   * @param field 
   * @return 
   */


  Facet.prototype.getFieldValues = function (data, field) {
    var rst = [];
    var cache = {}; //  Nil 

    util_1.each(data, function (d) {
      var value = d[field];

      if (!util_1.isNil(value) && !cache[value]) {
        rst.push(value);
        cache[value] = true;
      }
    });
    return rst;
  };
  /**
   *  region
   * @param rows row 
   * @param cols col 
   * @param xIndex x  index
   * @param yIndex y  index
   */


  Facet.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
    // x, y  100% 
    var xRatio = 1 / (cols === 0 ? 1 : cols);
    var yRatio = 1 / (rows === 0 ? 1 : rows);
    var start = {
      x: xRatio * xIndex,
      y: yRatio * yIndex
    };
    var end = {
      x: xRatio * (xIndex + 1),
      y: yRatio * (yIndex + 1)
    };
    return {
      start: start,
      end: end
    };
  };

  Facet.prototype.getDefaultCfg = function () {
    return {
      eachView: undefined,
      showTitle: true,
      padding: 10,
      fields: []
    };
  };
  /**
   *  title  title columnTitlerowTitle
   */


  Facet.prototype.getDefaultTitleCfg = function () {
    // @ts-ignore
    var fontFamily = this.view.getTheme().fontFamily;
    return {
      style: {
        fontSize: 14,
        fill: '#666',
        fontFamily: fontFamily
      }
    };
  };
  /**
   *  axis 
   * @param view
   * @param facet
   */


  Facet.prototype.processAxis = function (view, facet) {
    var options = view.getOptions();
    var coordinateOption = options.coordinate;
    var geometries = view.geometries;
    var coordinateType = util_1.get(coordinateOption, 'type', 'rect');

    if (coordinateType === 'rect' && geometries.length) {
      if (util_1.isNil(options.axes)) {
        // @ts-ignore
        options.axes = {};
      }

      var axes = options.axes;

      var _a = geometries[0].getXYFields(),
          x = _a[0],
          y = _a[1];

      var xOption = axis_1.getAxisOption(axes, x);
      var yOption = axis_1.getAxisOption(axes, y);

      if (xOption !== false) {
        options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
      }

      if (yOption !== false) {
        options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
      }
    }
  };
  /**
   * 
   * @param conditions
   */


  Facet.prototype.getFacetDataFilter = function (conditions) {
    return function (datum) {
      // 
      return util_1.every(conditions, function (condition) {
        var field = condition.field,
            value = condition.value;

        if (!util_1.isNil(value) && field) {
          return datum[field] === value;
        }

        return true;
      });
    };
  };

  return Facet;
}();

exports.Facet = Facet;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adjustYMetaByZero = adjustYMetaByZero;
exports.transformDataToNodeLinkData = transformDataToNodeLinkData;

var _util = __webpack_require__(0);

/**
 * 
 * @param data
 * @param field
 */
function adjustYMetaByZero(data, field) {
  // 
  var numberData = data.filter(function (datum) {
    var v = (0, _util.get)(datum, [field]);
    return (0, _util.isNumber)(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function (datum) {
    return (0, _util.get)(datum, [field]) >= 0;
  });
  var ltZero = numberData.every(function (datum) {
    return (0, _util.get)(datum, [field]) <= 0;
  }); //  { min: 0, max: undefined }  update({ max: 0 })  { min: 0, max: 0 }

  if (gtZero) {
    return {
      min: 0
    };
  }

  if (ltZero) {
    return {
      max: 0
    };
  }

  return {};
}
/**
 * 
 * @param data
 * @param sourceField
 * @param targetField
 * @param weightField
 */


function transformDataToNodeLinkData(data, sourceField, targetField, weightField) {
  if (!Array.isArray(data)) {
    return {
      nodes: [],
      links: []
    };
  } //   const nodes = [];


  var links = []; // 

  var nodesMap = {};
  var nodesIndex = -1; //  chord layout 

  data.forEach(function (datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField]; // source node

    if (!nodesMap[source]) {
      nodesMap[source] = {
        id: ++nodesIndex,
        name: source
      };
    }

    if (!nodesMap[target]) {
      nodesMap[target] = {
        id: ++nodesIndex,
        name: target
      };
    } // links


    links.push({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      // sourceName: source,
      // targetName: target,
      value: weight
    });
  });
  return {
    nodes: Object.values(nodesMap),
    links: links
  };
}

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function constant() {
    return x;
  };
}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Category", {
  enumerable: true,
  get: function get() {
    return _base2.default;
  }
});
Object.defineProperty(exports, "TimeCat", {
  enumerable: true,
  get: function get() {
    return _time.default;
  }
});
Object.defineProperty(exports, "Linear", {
  enumerable: true,
  get: function get() {
    return _linear.default;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return _log.default;
  }
});
Object.defineProperty(exports, "Pow", {
  enumerable: true,
  get: function get() {
    return _pow.default;
  }
});
Object.defineProperty(exports, "Time", {
  enumerable: true,
  get: function get() {
    return _time2.default;
  }
});
Object.defineProperty(exports, "Quantize", {
  enumerable: true,
  get: function get() {
    return _quantize.default;
  }
});
Object.defineProperty(exports, "Quantile", {
  enumerable: true,
  get: function get() {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "getScale", {
  enumerable: true,
  get: function get() {
    return _factory.getScale;
  }
});
Object.defineProperty(exports, "registerScale", {
  enumerable: true,
  get: function get() {
    return _factory.registerScale;
  }
});
Object.defineProperty(exports, "Identity", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
Object.defineProperty(exports, "getTickMethod", {
  enumerable: true,
  get: function get() {
    return _index2.getTickMethod;
  }
});
Object.defineProperty(exports, "registerTickMethod", {
  enumerable: true,
  get: function get() {
    return _index2.registerTickMethod;
  }
});

var _base = _interopRequireDefault(__webpack_require__(139));

var _base2 = _interopRequireDefault(__webpack_require__(413));

var _time = _interopRequireDefault(__webpack_require__(777));

var _linear = _interopRequireDefault(__webpack_require__(414));

var _log = _interopRequireDefault(__webpack_require__(780));

var _pow = _interopRequireDefault(__webpack_require__(781));

var _time2 = _interopRequireDefault(__webpack_require__(782));

var _quantize = _interopRequireDefault(__webpack_require__(415));

var _quantile = _interopRequireDefault(__webpack_require__(783));

var _factory = __webpack_require__(784);

var _index = _interopRequireDefault(__webpack_require__(785));

var _index2 = __webpack_require__(786);

(0, _factory.registerScale)('cat', _base2.default);
(0, _factory.registerScale)('category', _base2.default);
(0, _factory.registerScale)('identity', _index.default);
(0, _factory.registerScale)('linear', _linear.default);
(0, _factory.registerScale)('log', _log.default);
(0, _factory.registerScale)('pow', _pow.default);
(0, _factory.registerScale)('time', _time2.default);
(0, _factory.registerScale)('timeCat', _time.default);
(0, _factory.registerScale)('quantize', _quantize.default);
(0, _factory.registerScale)('quantile', _quantile.default);

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createThemeByStyleSheet = void 0;

var tslib_1 = __webpack_require__(1);

var component_1 = __webpack_require__(184);

var matrix_util_1 = __webpack_require__(33);

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);
/**
 *  axis 
 * @param styleSheet
 */


function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: 'center',
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: 'middle',
        fontFamily: styleSheet.fontFamily
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: {
        type: 'equidistance',
        cfg: {
          minGap: 6
        }
      },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: 'line',
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
/**
 *
 * @param styleSheet
 */
// export function

/**
 *  legend 
 * @param styleSheet
 */


function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: 'circle',
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: 'start',
        textBaseline: 'middle'
      }
    },
    flipPage: true,
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
  };
}
/**
 * 
 * @param styleSheet 
 */


function createThemeByStyleSheet(styleSheet) {
  var _a;

  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: 'round',
        lineJoin: 'round'
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    padding: 'auto',
    fontFamily: styleSheet.fontFamily,
    // Theme

    /** geometrygeometrynull */
    columnWidthRatio: 1 / 2,

    /**  */
    maxColumnWidth: null,

    /**  */
    minColumnWidth: null,

    /**  */
    roseWidthRatio: 0.9999999,

    /** / */
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    shapes: {
      point: ['hollow-circle', 'hollow-square', 'hollow-bowtie', 'hollow-diamond', 'hollow-hexagon', 'hollow-triangle', 'hollow-triangle-down', 'circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down', 'cross', 'tick', 'plus', 'hyphen', 'line'],
      line: ['line', 'dash', 'dot', 'smooth'],
      area: ['area', 'smooth', 'line', 'smooth-line'],
      interval: ['rect', 'hollow-rect', 'line', 'tick']
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function style(element) {
              var coordinate = element.geometry.coordinate;

              if (coordinate.isPolar && coordinate.isTransposed) {
                var _a = graphics_1.getAngle(element.getModel(), coordinate),
                    startAngle = _a.startAngle,
                    endAngle = _a.endAngle;

                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: matrix_util_1.ext.transform(null, [['t', x, y]])
                };
              }

              return shapeStyles.interval.selected;
            }
          }
        },
        'hollow-rect': {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.default), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          active: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.active), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          inactive: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.inactive), {
              lineCap: null,
              lineDash: [1, 1]
            })
          },
          selected: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.selected), {
              lineCap: null,
              lineDash: [1, 1]
            })
          }
        },
        dash: {
          default: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.default), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          active: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.active), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          inactive: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.inactive), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          },
          selected: {
            style: tslib_1.__assign(tslib_1.__assign({}, shapeStyles.line.selected), {
              lineCap: null,
              lineDash: [5.5, 1]
            })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        'triangle-down': {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        'hollow-circle': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-square': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-bowtie': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-diamond': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-hexagon': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-triangle': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        'hollow-triangle-down': {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        'smooth-line': {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: util_1.deepMix({}, axisStyles, {
          position: 'top',
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        }),
        bottom: util_1.deepMix({}, axisStyles, {
          position: 'bottom',
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        }),
        left: util_1.deepMix({}, axisStyles, {
          position: 'left',
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        }),
        right: util_1.deepMix({}, axisStyles, {
          position: 'right',
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        }),
        circle: util_1.deepMix({}, axisStyles, {
          title: null,
          grid: util_1.deepMix({}, axisStyles.grid, {
            line: {
              type: 'line'
            }
          })
        }),
        radius: util_1.deepMix({}, axisStyles, {
          title: null,
          grid: util_1.deepMix({}, axisStyles.grid, {
            line: {
              type: 'circle'
            }
          })
        })
      },
      legend: {
        common: legendStyles,
        right: util_1.deepMix({}, legendStyles, {
          layout: 'vertical',
          padding: styleSheet.legendVerticalPadding
        }),
        left: util_1.deepMix({}, legendStyles, {
          layout: 'vertical',
          padding: styleSheet.legendVerticalPadding
        }),
        top: util_1.deepMix({}, legendStyles, {
          layout: 'horizontal',
          padding: styleSheet.legendHorizontalPadding
        }),
        bottom: util_1.deepMix({}, legendStyles, {
          layout: 'horizontal',
          padding: styleSheet.legendHorizontalPadding
        }),
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: 'color',
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: 'rail',
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: 'middle',
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: 'auto',
        marker: {
          symbol: 'circle',
          stroke: '#fff',
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffSetY: 0,
          shadowColor: 'rgba(0,0,0,0.09)',
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: 'rgba(0, 0, 0, 0.25)',
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        // tooltip dom 
        domStyles: (_a = {}, _a["" + component_1.TOOLTIP_CSS_CONST.CONTAINER_CLASS] = {
          position: 'absolute',
          visibility: 'hidden',
          zIndex: 8,
          transition: 'left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s',
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: styleSheet.tooltipContainerBorderRadius + "px",
          color: styleSheet.tooltipTextFillColor,
          fontSize: styleSheet.tooltipTextFontSize + "px",
          fontFamily: styleSheet.fontFamily,
          lineHeight: styleSheet.tooltipTextLineHeight + "px",
          padding: '0 12px 0 12px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.TITLE_CLASS] = {
          marginBottom: '12px',
          marginTop: '12px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.LIST_CLASS] = {
          margin: 0,
          listStyleType: 'none',
          padding: 0
        }, _a["" + component_1.TOOLTIP_CSS_CONST.LIST_ITEM_CLASS] = {
          listStyleType: 'none',
          padding: 0,
          marginBottom: '12px',
          marginTop: '12px',
          marginLeft: 0,
          marginRight: 0
        }, _a["" + component_1.TOOLTIP_CSS_CONST.MARKER_CLASS] = {
          width: '8px',
          height: '8px',
          borderRadius: '50%',
          display: 'inline-block',
          marginRight: '8px'
        }, _a["" + component_1.TOOLTIP_CSS_CONST.VALUE_CLASS] = {
          display: 'inline-block',
          float: 'right',
          marginLeft: '30px'
        }, _a)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: 'start',
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: 'start',
              fontFamily: styleSheet.fontFamily,
              textBaseline: 'bottom'
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: 'middle',
            textAlign: 'start',
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: 'start',
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: 'upward',
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: 'center',
              textBaseline: 'bottom',
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8]
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}

exports.createThemeByStyleSheet = createThemeByStyleSheet;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hue = hue;
exports.gamma = gamma;
exports.default = nogamma;

var _constant = _interopRequireDefault(__webpack_require__(391));

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, _constant.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0, _constant.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0, _constant.default)(isNaN(a) ? b : a);
}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ = _interopRequireWildcard(__webpack_require__(0));

var _constant = __webpack_require__(248);

var Adjust =
/** @class */
function () {
  function Adjust(cfg) {
    var xField = cfg.xField,
        yField = cfg.yField,
        _a = cfg.adjustNames,
        adjustNames = _a === void 0 ? ['x', 'y'] : _a;
    this.adjustNames = adjustNames;
    this.xField = xField;
    this.yField = yField;
  }
  /**
   *  adjust 
   * @param dim
   */


  Adjust.prototype.isAdjust = function (dim) {
    return this.adjustNames.indexOf(dim) >= 0;
  };

  Adjust.prototype.getAdjustRange = function (dim, dimValue, values) {
    var yField = this.yField;
    var index = values.indexOf(dimValue);
    var length = values.length;
    var pre;
    var next; //  y  y 

    if (!yField && this.isAdjust('y')) {
      pre = 0;
      next = 1;
    } else if (length > 1) {
      // 
      pre = values[index === 0 ? 0 : index - 1]; // 

      next = values[index === length - 1 ? length - 1 : index + 1];

      if (index !== 0) {
        pre += (dimValue - pre) / 2;
      } else {
        pre -= (next - dimValue) / 2;
      }

      if (index !== length - 1) {
        next -= (next - dimValue) / 2;
      } else {
        next += (dimValue - values[length - 2]) / 2;
      }
    } else {
      pre = dimValue === 0 ? 0 : dimValue - 0.5;
      next = dimValue === 0 ? 1 : dimValue + 0.5;
    }

    return {
      pre: pre,
      next: next
    };
  };

  Adjust.prototype.adjustData = function (groupedDataArray, mergedData) {
    var _this = this; // 


    var dimValuesMap = this.getDimValues(mergedData); // 

    _.each(groupedDataArray, function (dataArray, index) {
      // 
      //  dim 
      _.each(dimValuesMap, function (values, dim) {
        // 
        _this.adjustDim(dim, values, dataArray, index);
      });
    });
  };
  /**
   * adjustData
   * @param data 
   * @param dim 
   * @return 
   */


  Adjust.prototype.groupData = function (data, dim) {
    // 
    _.each(data, function (record) {
      if (record[dim] === undefined) {
        record[dim] = _constant.DEFAULT_Y;
      }
    }); //  dim 


    return _.groupBy(data, dim);
  };
  /** @override */


  Adjust.prototype.adjustDim = function (dim, values, data, index) {};
  /**
   * 
   * @param mergedData 
   * @return 
   */


  Adjust.prototype.getDimValues = function (mergedData) {
    var _a = this,
        xField = _a.xField,
        yField = _a.yField;

    var dimValuesMap = {}; // 

    var dims = [];

    if (xField && this.isAdjust('x')) {
      dims.push(xField);
    }

    if (yField && this.isAdjust('y')) {
      dims.push(yField);
    }

    dims.forEach(function (dim) {
      // 
      dimValuesMap[dim] = _.valuesOfKey(mergedData, dim).sort(function (v1, v2) {
        return v1 - v2;
      });
    }); //  y

    if (!yField && this.isAdjust('y')) {
      var dim = 'y';
      dimValuesMap[dim] = [_constant.DEFAULT_Y, 1]; //  y  0  1 
    }

    return dimValuesMap;
  };

  return Adjust;
}();

var _default = Adjust;
exports.default = _default;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "addEventListener", {
  enumerable: true,
  get: function get() {
    return _addEventListener.default;
  }
});
Object.defineProperty(exports, "createDom", {
  enumerable: true,
  get: function get() {
    return _createDom.default;
  }
});
Object.defineProperty(exports, "getHeight", {
  enumerable: true,
  get: function get() {
    return _getHeight.default;
  }
});
Object.defineProperty(exports, "getOuterHeight", {
  enumerable: true,
  get: function get() {
    return _getOuterHeight.default;
  }
});
Object.defineProperty(exports, "getOuterWidth", {
  enumerable: true,
  get: function get() {
    return _getOuterWidth.default;
  }
});
Object.defineProperty(exports, "getRatio", {
  enumerable: true,
  get: function get() {
    return _getRatio.default;
  }
});
Object.defineProperty(exports, "getStyle", {
  enumerable: true,
  get: function get() {
    return _getStyle.default;
  }
});
Object.defineProperty(exports, "getWidth", {
  enumerable: true,
  get: function get() {
    return _getWidth.default;
  }
});
Object.defineProperty(exports, "modifyCSS", {
  enumerable: true,
  get: function get() {
    return _modifyCss.default;
  }
});

var _addEventListener = _interopRequireDefault(__webpack_require__(814));

var _createDom = _interopRequireDefault(__webpack_require__(815));

var _getHeight = _interopRequireDefault(__webpack_require__(420));

var _getOuterHeight = _interopRequireDefault(__webpack_require__(816));

var _getOuterWidth = _interopRequireDefault(__webpack_require__(817));

var _getRatio = _interopRequireDefault(__webpack_require__(818));

var _getStyle = _interopRequireDefault(__webpack_require__(141));

var _getWidth = _interopRequireDefault(__webpack_require__(421));

var _modifyCss = _interopRequireDefault(__webpack_require__(819));

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var chart_1 = __webpack_require__(890);

Object.defineProperty(exports, "Chart", {
  enumerable: true,
  get: function get() {
    return chart_1.default;
  }
});

var view_1 = __webpack_require__(432);

Object.defineProperty(exports, "View", {
  enumerable: true,
  get: function get() {
    return view_1.default;
  }
});
Object.defineProperty(exports, "registerGeometry", {
  enumerable: true,
  get: function get() {
    return view_1.registerGeometry;
  }
});

var event_1 = __webpack_require__(268);

Object.defineProperty(exports, "Event", {
  enumerable: true,
  get: function get() {
    return event_1.default;
  }
});

var controller_1 = __webpack_require__(435);

Object.defineProperty(exports, "registerComponentController", {
  enumerable: true,
  get: function get() {
    return controller_1.registerComponentController;
  }
});

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @file utils of label
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkShapeOverlap = exports.getOverlapArea = exports.getlLabelBackgroundInfo = exports.findLabelTextShape = void 0;

var util_1 = __webpack_require__(0);

var transform_1 = __webpack_require__(115);
/**
 *  Label Group  shape 
 * @param label
 */


function findLabelTextShape(label) {
  return label.find(function (el) {
    return el.get('type') === 'text';
  });
}

exports.findLabelTextShape = findLabelTextShape;
/**
 * : box () + rotation ()
 */

function getlLabelBackgroundInfo(labelGroup, labelItem, padding) {
  if (padding === void 0) {
    padding = [0, 0, 0, 0];
  }

  var content = labelGroup.getChildren()[0];

  if (content) {
    var labelShape = content.clone(); // revert rotate

    if (labelItem.rotate) {
      transform_1.rotate(labelShape, -labelItem.rotate);
    } // use `getCanvasBBox`, because if Shape is been translated, `getBBox` is not the actual box position


    var _a = labelShape.getCanvasBBox(),
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;

    labelShape.destroy();
    var boxPadding = padding;

    if (util_1.isNil(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (util_1.isNumber(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }

    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: labelItem.rotate || 0
    };
  }
}

exports.getlLabelBackgroundInfo = getlLabelBackgroundInfo;
/**
 * 
 */

function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}

exports.getOverlapArea = getOverlapArea;
/**  */

function checkShapeOverlap(cur, dones) {
  var box = cur.getBBox();
  return util_1.some(dones, function (done) {
    var target = done.getBBox();
    return getOverlapArea(box, target, 2) > 0;
  });
}

exports.checkShapeOverlap = checkShapeOverlap;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoom = exports.getIdentityMatrix = exports.rotate = exports.getRotateMatrix = exports.translate = exports.transform = void 0;

var matrix_util_1 = __webpack_require__(33);

var transform = matrix_util_1.ext.transform;
exports.transform = transform;
/**
 * 
 * @param element 
 * @param x x 
 * @param y y 
 */

function translate(element, x, y) {
  var matrix = transform(element.getMatrix(), [['t', x, y]]);
  element.setMatrix(matrix);
}

exports.translate = translate;
/**
 *  ()
 * @param element 
 * @param rotateRadian 
 */

function getRotateMatrix(element, rotateRadian) {
  var _a = element.attr(),
      x = _a.x,
      y = _a.y;

  var matrix = transform(element.getMatrix(), [['t', -x, -y], ['r', rotateRadian], ['t', x, y]]);
  return matrix;
}

exports.getRotateMatrix = getRotateMatrix;
/**
 * 
 * @param element 
 * @param rotateRadian 
 */

function rotate(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}

exports.rotate = rotate;
/**
 * 
 * @returns identity matrix
 */

function getIdentityMatrix() {
  return [1, 0, 0, 0, 1, 0, 0, 0, 1];
}

exports.getIdentityMatrix = getIdentityMatrix;
/**
 * 
 * @param element 
 * @param ratio 
 */

function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform(element.getMatrix(), [['t', -x, -y], ['s', ratio, ratio], ['t', x, y]]);
  element.setMatrix(matrix);
}

exports.zoom = zoom;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAnglePoint = exports.getFactTitleConfig = void 0;

var constant_1 = __webpack_require__(20);
/**
 * @ignore
 *  facet title 
 */


function getFactTitleConfig(direction) {
  if ([constant_1.DIRECTION.TOP, constant_1.DIRECTION.BOTTOM].includes(direction)) {
    return {
      offsetX: 0,
      offsetY: direction === constant_1.DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: 'center',
        textBaseline: direction === constant_1.DIRECTION.TOP ? 'bottom' : 'top'
      }
    };
  }

  if ([constant_1.DIRECTION.LEFT, constant_1.DIRECTION.RIGHT].includes(direction)) {
    return {
      offsetX: direction === constant_1.DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction === constant_1.DIRECTION.LEFT ? 'right' : 'left',
        textBaseline: 'middle',
        rotate: Math.PI / 2
      }
    };
  }

  return {};
}

exports.getFactTitleConfig = getFactTitleConfig;
/**
 * @ignore
 *   
 * @param center
 * @param r
 * @param angle
 */

function getAnglePoint(center, r, angle) {
  return {
    x: center.x + r * Math.cos(angle),
    y: center.y + r * Math.sin(angle)
  };
}

exports.getAnglePoint = getAnglePoint;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var toString = {}.toString;

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};

exports.default = isType;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTinyData = void 0;

var util_1 = __webpack_require__(0);

function getTinyData(data) {
  return util_1.map(data || [], function (y, x) {
    return {
      x: "" + x,
      y: y
    };
  });
}

exports.getTinyData = getTinyData;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLOYGON_Y = exports.PLOYGON_X = exports.FUNNEL_TOTAL_PERCENT = exports.FUNNEL_CONVERSATION = exports.FUNNEL_MAPPING_VALUE = exports.FUNNEL_PERCENT = void 0; // : data[n][yField] / data[0][yField]

exports.FUNNEL_PERCENT = '$$percentage$$'; // 

exports.FUNNEL_MAPPING_VALUE = '$$mappingValue$$'; // : data[n][yField] / data[n-1][yField];

exports.FUNNEL_CONVERSATION = '$$conversion$$'; // 
// data[n][yField] / sum(data[0-n][yField])

exports.FUNNEL_TOTAL_PERCENT = '$$totalPercentage$$'; //  x 

exports.PLOYGON_X = '$$x$$';
exports.PLOYGON_Y = '$$y$$';

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determination = determination;

var _points = __webpack_require__(98);

// Given a dataset, x- and y-accessors, the mean center of the y values, and a predict function,
// return the coefficient of determination, or R squared.
function determination(data, x, y, uY, predict) {
  var SSE = 0,
      SST = 0;
  (0, _points.visitPoints)(data, x, y, function (dx, dy) {
    var sse = dy - predict(dx),
        sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_COLORS = exports.AXIS_META_CONFIG_KEYS = void 0;

/**
 *  meta  key 
 */
var AXIS_META_CONFIG_KEYS = ['type', 'alias', 'tickCount', 'tickInterval', 'min', 'max', 'nice', 'minLimit', 'maxLimit', // 
'range', 'tickMethod', // type: 'log' 
'base', // type: 'exp' 
'exponent', // time 
'mask'];
/**
 * 
 */

exports.AXIS_META_CONFIG_KEYS = AXIS_META_CONFIG_KEYS;
var DEFAULT_COLORS = {
  GRADIENT: {
    CONTINUOUS: '#BAE7FF-#1890FF-#0050B3'
  }
};
exports.DEFAULT_COLORS = DEFAULT_COLORS;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.percent = percent;
exports.getDataWhetherPecentage = getDataWhetherPecentage;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _number = __webpack_require__(518);

/**
 * 
 * @param data
 * @param measure
 * @param groupField
 * @param as
 */
function percent(data, measure, groupField, as) {
  // 1.  max 
  var sumMap = (0, _util.reduce)(data, function (map, datum) {
    var groupValue = datum[groupField];
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = (0, _number.isRealNumber)(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map()); // 2. 

  return (0, _util.map)(data, function (datum) {
    var _a;

    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = (0, _number.isRealNumber)(v) ? v / sumMap.get(groupValue) : 0;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, datum), (_a = {}, _a[as] = percentage, _a));
  });
}
/**
 *  ()
 * @param isPercent 
 */


function getDataWhetherPecentage(data, yField, groupField, asField, isPercent) {
  return !isPercent ? data : percent(data, yField, groupField, asField);
}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTinyData = getTinyData;

var _util = __webpack_require__(0);

function getTinyData(data) {
  return (0, _util.map)(data || [], function (y, x) {
    return {
      x: "" + x,
      y: y
    };
  });
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PLOYGON_Y = exports.PLOYGON_X = exports.FUNNEL_TOTAL_PERCENT = exports.FUNNEL_CONVERSATION = exports.FUNNEL_MAPPING_VALUE = exports.FUNNEL_PERCENT = void 0;
// : data[n][yField] / data[0][yField]
var FUNNEL_PERCENT = '$$percentage$$'; // 

exports.FUNNEL_PERCENT = FUNNEL_PERCENT;
var FUNNEL_MAPPING_VALUE = '$$mappingValue$$'; // : data[n][yField] / data[n-1][yField];

exports.FUNNEL_MAPPING_VALUE = FUNNEL_MAPPING_VALUE;
var FUNNEL_CONVERSATION = '$$conversion$$'; // 
// data[n][yField] / sum(data[0-n][yField])

exports.FUNNEL_CONVERSATION = FUNNEL_CONVERSATION;
var FUNNEL_TOTAL_PERCENT = '$$totalPercentage$$'; //  x 

exports.FUNNEL_TOTAL_PERCENT = FUNNEL_TOTAL_PERCENT;
var PLOYGON_X = '$$x$$';
exports.PLOYGON_X = PLOYGON_X;
var PLOYGON_Y = '$$y$$';
exports.PLOYGON_Y = PLOYGON_Y;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var WILDCARD = '*';
/* event-emitter */

var EventEmitter =
/** @class */
function () {
  function EventEmitter() {
    this._events = {};
  }
  /**
   * 
   * @param evt
   * @param callback
   * @param once
   */


  EventEmitter.prototype.on = function (evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }

    this._events[evt].push({
      callback: callback,
      once: !!once
    });

    return this;
  };
  /**
   * 
   * @param evt
   * @param callback
   */


  EventEmitter.prototype.once = function (evt, callback) {
    this.on(evt, callback, true);
    return this;
  };
  /**
   * 
   * @param evt
   * @param args
   */


  EventEmitter.prototype.emit = function (evt) {
    var _this = this;

    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD] || []; //  emit 

    var doEmit = function doEmit(es) {
      var length = es.length;

      for (var i = 0; i < length; i++) {
        if (!es[i]) {
          continue;
        }

        var _a = es[i],
            callback = _a.callback,
            once = _a.once;

        if (once) {
          es.splice(i, 1);

          if (es.length === 0) {
            delete _this._events[evt];
          }

          length--;
          i--;
        }

        callback.apply(_this, args);
      }
    };

    doEmit(events);
    doEmit(wildcardEvents);
  };
  /**
   * channel
   * @param evt
   * @param callback
   */


  EventEmitter.prototype.off = function (evt, callback) {
    if (!evt) {
      // evt 
      this._events = {};
    } else {
      if (!callback) {
        // evt callback 
        delete this._events[evt];
      } else {
        // evt callback 
        var events = this._events[evt] || [];
        var length_1 = events.length;

        for (var i = 0; i < length_1; i++) {
          if (events[i].callback === callback) {
            events.splice(i, 1);
            length_1--;
            i--;
          }
        }

        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }

    return this;
  };
  /*  */


  EventEmitter.prototype.getEvents = function () {
    return this._events;
  };

  return EventEmitter;
}();

var _default = EventEmitter;
exports.default = _default;

/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return useChartInstance; });
/* unused harmony export useChartTheme */
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _context_root__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(73);


function useChartInstance() {
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_root__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]).chart;
}
function useChartTheme() {
  // todo: theme  charttheme
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.useContext(_context_root__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]).theme;
}

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));
/**
 * Tooltip  Action
 * @ignore
 */


var TooltipAction =
/** @class */
function (_super) {
  tslib_1.__extends(TooltipAction, _super);

  function TooltipAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.timeStamp = 0;
    return _this;
  }
  /**
   *  Tooltip
   * @returns
   */


  TooltipAction.prototype.show = function () {
    var context = this.context;
    var ev = context.event;
    var view = context.view;
    var isTooltipLocked = view.isTooltipLocked();

    if (isTooltipLocked) {
      //  tooltip
      return;
    }

    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date(); //  showDelay  16ms tooltip  enterable

    var showDelay = util_1.get(context.view.getOptions(), 'tooltip.showDelay', 16);

    if (timeStamp - lastTimeStamp > showDelay) {
      var preLoc = this.location;
      var curLoc = {
        x: ev.x,
        y: ev.y
      };

      if (!preLoc || !util_1.isEqual(preLoc, curLoc)) {
        this.showTooltip(view, curLoc);
      }

      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  /**
   *  Tooltip
   * @returns
   */


  TooltipAction.prototype.hide = function () {
    var view = this.context.view;
    var tooltip = view.getController('tooltip');
    var _a = this.context.event,
        clientX = _a.clientX,
        clientY = _a.clientY; //  enterable +  tooltip 

    if (tooltip.isCursorEntered({
      x: clientX,
      y: clientY
    })) {
      return;
    } //  tooltip 


    if (view.isTooltipLocked()) {
      return;
    }

    this.hideTooltip(view);
    this.location = null;
  };

  TooltipAction.prototype.showTooltip = function (view, point) {
    // 
    view.showTooltip(point);
  };

  TooltipAction.prototype.hideTooltip = function (view) {
    view.hideTooltip();
  };

  return TooltipAction;
}(base_1.default);

exports.default = TooltipAction;

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AreaGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(316);
/* harmony import */ var _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(279);
/* harmony import */ var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_7__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Area', _antv_g2_lib_geometry_area__WEBPACK_IMPORTED_MODULE_4___default.a);

var AreaGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(AreaGeom, _BaseGemo);

  var _super = _createSuper(AreaGeom);

  function AreaGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, AreaGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'area';
    return _this;
  }

  return AreaGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LineGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(320);
/* harmony import */ var _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(281);
/* harmony import */ var _antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_line_step__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }






Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Line', _antv_g2_lib_geometry_line__WEBPACK_IMPORTED_MODULE_4___default.a);

var LineGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(LineGeom, _BaseGemo);

  var _super = _createSuper(LineGeom);

  function LineGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, LineGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'line';
    return _this;
  }

  return LineGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]);



/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PointGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(321);
/* harmony import */ var _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(457);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_point_hollow__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(458);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_point_image__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(459);
/* harmony import */ var _antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_point_solid__WEBPACK_IMPORTED_MODULE_9__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



 // 




Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Point', _antv_g2_lib_geometry_point__WEBPACK_IMPORTED_MODULE_4___default.a);

var PointGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(PointGeom, _BaseGemo);

  var _super = _createSuper(PointGeom);

  function PointGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, PointGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'point';
    return _this;
  }

  return PointGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antvLight = exports.createLightStyleSheet = void 0;
var BLACK_COLORS = {
  100: '#000',
  95: '#0D0D0D',
  85: '#262626',
  65: '#595959',
  45: '#8C8C8C',
  25: '#BFBFBF',
  15: '#D9D9D9',
  6: '#F0F0F0'
};
var WHITE_COLORS = {
  100: '#FFFFFF',
  95: '#F2F2F2',
  85: '#D9D9D9',
  65: '#A6A6A6',
  45: '#737373',
  25: '#404040',
  15: '#262626',
  6: '#0F0F0F'
};
var QUALITATIVE_10 = ['#5B8FF9', '#5AD8A6', '#5D7092', '#F6BD16', '#6F5EF9', '#6DC8EC', '#945FB9', '#FF9845', '#1E9493', '#FF99C3'];
var QUALITATIVE_20 = ['#5B8FF9', '#CDDDFD', '#5AD8A6', '#CDF3E4', '#5D7092', '#CED4DE', '#F6BD16', '#FCEBB9', '#6F5EF9', '#D3CEFD', '#6DC8EC', '#D3EEF9', '#945FB9', '#DECFEA', '#FF9845', '#FFE0C7', '#1E9493', '#BBDEDE', '#FF99C3', '#FFE0ED'];

exports.createLightStyleSheet = function (cfg) {
  if (cfg === void 0) {
    cfg = {};
  }

  var _a = cfg.backgroundColor,
      backgroundColor = _a === void 0 ? 'transparent' : _a,
      _b = cfg.paletteQualitative10,
      paletteQualitative10 = _b === void 0 ? QUALITATIVE_10 : _b,
      _c = cfg.paletteQualitative20,
      paletteQualitative20 = _c === void 0 ? QUALITATIVE_20 : _c,
      _d = cfg.paletteSemanticRed,
      paletteSemanticRed = _d === void 0 ? '#F4664A' : _d,
      _e = cfg.paletteSemanticGreen,
      paletteSemanticGreen = _e === void 0 ? '#30BF78' : _e,
      _f = cfg.paletteSemanticYellow,
      paletteSemanticYellow = _f === void 0 ? '#FAAD14' : _f,
      _g = cfg.fontFamily,
      fontFamily = _g === void 0 ? "\"-apple-system\", \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"" : _g;
  var _h = cfg.brandColor,
      brandColor = _h === void 0 ? paletteQualitative10[0] : _h;
  return {
    /**  */
    backgroundColor: backgroundColor,

    /**  */
    brandColor: brandColor,

    /**  1 10  */
    paletteQualitative10: paletteQualitative10,

    /**  2 10  */
    paletteQualitative20: paletteQualitative20,

    /**  */
    paletteSemanticRed: paletteSemanticRed,

    /**  */
    paletteSemanticGreen: paletteSemanticGreen,

    /**  */
    paletteSemanticYellow: paletteSemanticYellow,

    /**  */
    fontFamily: fontFamily,
    // --------------------  --------------------

    /**  */
    axisLineBorderColor: BLACK_COLORS[25],

    /**  */
    axisLineBorder: 1,

    /**  lineDash  */
    axisLineDash: null,

    /**  */
    axisTitleTextFillColor: BLACK_COLORS[65],

    /**  */
    axisTitleTextFontSize: 12,

    /**  */
    axisTitleTextLineHeight: 12,

    /**  */
    axisTitleTextFontWeight: 'normal',

    /**  */
    axisTitleSpacing: 12,

    /**  */
    axisTickLineBorderColor: BLACK_COLORS[25],

    /**  */
    axisTickLineLength: 4,

    /**  */
    axisTickLineBorder: 1,

    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS[15],

    /**  */
    axisSubTickLineLength: 2,

    /**  */
    axisSubTickLineBorder: 1,

    /**  */
    axisLabelFillColor: BLACK_COLORS[45],

    /**  */
    axisLabelFontSize: 12,

    /**  */
    axisLabelLineHeight: 12,

    /**  */
    axisLabelFontWeight: 'normal',

    /**  */
    axisLabelOffset: 8,

    /**  */
    axisGridBorderColor: BLACK_COLORS[15],

    /**  */
    axisGridBorder: 1,

    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------

    /**  */
    legendTitleTextFillColor: BLACK_COLORS[45],

    /**  */
    legendTitleTextFontSize: 12,

    /**  */
    legendTitleTextLineHeight: 21,

    /**  */
    legendTitleTextFontWeight: 'normal',

    /**  marker  */
    legendMarkerColor: brandColor,

    /**  marker  */
    legendMarkerSpacing: 8,

    /**  marker  */
    legendMarkerSize: 4,

    /**  'circle' marker  */
    legendCircleMarkerSize: 4,

    /**  'square' marker  */
    legendSquareMarkerSize: 4,

    /**  'line' marker  */
    legendLineMarkerSize: 5,

    /**  */
    legendItemNameFillColor: BLACK_COLORS[65],

    /**  */
    legendItemNameFontSize: 12,

    /**  */
    legendItemNameLineHeight: 12,

    /**  */
    legendItemNameFontWeight: 'normal',

    /**  */
    legendItemSpacing: 24,

    /**  */
    legendItemMarginBottom: 12,

    /**   */
    legendPadding: [8, 8, 8, 8],

    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],

    /**  */
    legendVerticalPadding: [0, 8, 0, 8],

    /**  */
    sliderRailFillColor: BLACK_COLORS[15],

    /**  */
    sliderRailBorder: 0,

    /**  */
    sliderRailBorderColor: null,

    /**  */
    sliderRailWidth: 100,

    /**  */
    sliderRailHeight: 12,

    /**  */
    sliderLabelTextFillColor: BLACK_COLORS[45],

    /**  */
    sliderLabelTextFontSize: 12,

    /**  */
    sliderLabelTextLineHeight: 12,

    /**  */
    sliderLabelTextFontWeight: 'normal',

    /**  */
    sliderHandlerFillColor: BLACK_COLORS[6],

    /**  */
    sliderHandlerWidth: 10,

    /**  */
    sliderHandlerHeight: 14,

    /**  */
    sliderHandlerBorder: 1,

    /**  */
    sliderHandlerBorderColor: BLACK_COLORS[25],
    // -------------------- Annotation --------------------

    /** arc  */
    annotationArcBorderColor: BLACK_COLORS[15],

    /** arc  */
    annotationArcBorder: 1,

    /** line  */
    annotationLineBorderColor: BLACK_COLORS[25],

    /** line  */
    annotationLineBorder: 1,

    /** lube  */
    annotationLineDash: null,

    /** text  */
    annotationTextFillColor: BLACK_COLORS[65],

    /** text  */
    annotationTextFontSize: 12,

    /** text  */
    annotationTextLineHeight: 12,

    /** text  */
    annotationTextFontWeight: 'normal',

    /** text  */
    annotationTextBorderColor: null,

    /** text  */
    annotationTextBorder: 0,

    /** region  */
    annotationRegionFillColor: BLACK_COLORS[100],

    /** region  */
    annotationRegionFillOpacity: 0.06,

    /** region  */
    annotationRegionBorder: 0,

    /** region  */
    annotationRegionBorderColor: null,

    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------

    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],

    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,

    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,

    /** tooltip  */
    tooltipContainerFillColor: 'rgb(255, 255, 255)',
    tooltipContainerFillOpacity: 0.95,

    /** tooltip  */
    tooltipContainerShadow: '0px 0px 10px #aeaeae',

    /** tooltip  */
    tooltipContainerBorderRadius: 3,

    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS[65],

    /** tooltip  */
    tooltipTextFontSize: 12,

    /** tooltip  */
    tooltipTextLineHeight: 12,

    /** tooltip  */
    tooltipTextFontWeight: 'bold',
    // -------------------- Geometry labels --------------------

    /** Geometry label  */
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: '#2c3542',
    labelFillColorLight: '#ffffff',

    /** Geometry label  */
    labelFontSize: 12,

    /** Geometry label  */
    labelLineHeight: 12,

    /** Geometry label  */
    labelFontWeight: 'normal',

    /** Geometry label  */
    labelBorderColor: null,

    /** Geometry label  */
    labelBorder: 0,

    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS[100],

    /** Geometry innerLabel  */
    innerLabelFontSize: 12,

    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,

    /** Geometry innerLabel  */
    innerLabelFontWeight: 'normal',

    /** Geometry innerLabel  */
    innerLabelBorderColor: null,

    /** Geometry innerLabel  */
    innerLabelBorder: 0,

    /** Geometry overflowLabel  */
    overflowLabelFillColor: BLACK_COLORS[65],

    /** Geometry overflowLabel  */
    overflowLabelFontSize: 12,

    /** Geometry overflowLabel  */
    overflowLabelLineHeight: 12,

    /** Geometry overflowLabel  */
    overflowLabelFontWeight: 'normal',

    /** Geometry overflowLabel  */
    overflowLabelBorderColor: WHITE_COLORS[100],

    /** Geometry overflowLabel  */
    overflowLabelBorder: 1,

    /** Geometry label */
    labelLineBorder: 1,

    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS[25],
    // -------------------- Geometry --------------------

    /**  */
    pointFillColor: brandColor,

    /**  */
    pointFillOpacity: 0.95,

    /**  */
    pointSize: 4,

    /**  */
    pointBorder: 1,

    /**  */
    pointBorderColor: WHITE_COLORS[100],

    /**  */
    pointBorderOpacity: 1,

    /**  active  */
    pointActiveBorderColor: BLACK_COLORS[100],

    /**  selected  */
    pointSelectedBorder: 2,

    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS[100],

    /**  inactive  */
    pointInactiveFillOpacity: 0.3,

    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,

    /**  */
    hollowPointSize: 4,

    /**  */
    hollowPointBorder: 1,

    /**  */
    hollowPointBorderColor: brandColor,

    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],

    /**  active  */
    hollowPointActiveBorder: 1,

    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS[100],

    /**  active  */
    hollowPointActiveBorderOpacity: 1,

    /**  selected  */
    hollowPointSelectedBorder: 2,

    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS[100],

    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,

    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,

    /**  */
    lineBorder: 2,

    /**  */
    lineBorderColor: brandColor,

    /**  */
    lineBorderOpacity: 1,

    /**  Active  */
    lineActiveBorder: 3,

    /**  selected  */
    lineSelectedBorder: 3,

    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,

    /** area  */
    areaFillColor: brandColor,

    /** area  */
    areaFillOpacity: 0.25,

    /** area  active  */
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,

    /** area  selected  */
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,

    /** area inactive  */
    areaInactiveFillOpacity: 0.3,

    /** hollowArea  */
    hollowAreaBorderColor: brandColor,

    /** hollowArea  */
    hollowAreaBorder: 2,

    /** hollowArea  */
    hollowAreaBorderOpacity: 1,

    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],

    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],

    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,

    /** interval  */
    intervalFillColor: brandColor,

    /** interval  */
    intervalFillOpacity: 0.95,

    /** interval active  */
    intervalActiveBorder: 1,

    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,

    /** interval selected  */
    intervalSelectedBorder: 2,

    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS[100],

    /** interval selected  */
    intervalSelectedBorderOpacity: 1,

    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,

    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,

    /** interval  */
    hollowIntervalBorder: 2,

    /** hollowInterval  */
    hollowIntervalBorderColor: brandColor,

    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],

    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,

    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],

    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,

    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],

    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,

    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
};

exports.antvLight = exports.createLightStyleSheet();

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return withContainer; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);



var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


function withContainer(Component) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ChartContainer';
  var Cls = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.forwardRef(function (props, ref) {
    var container = Object(react__WEBPACK_IMPORTED_MODULE_2__["useRef"])();

    var _useState = Object(react__WEBPACK_IMPORTED_MODULE_2__["useState"])(false),
        _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_1___default()(_useState, 2),
        inited = _useState2[0],
        setInited = _useState2[1];

    var _a = props,
        _a$className = _a.className,
        className = _a$className === void 0 ? "bizcharts" : _a$className,
        containerStyle = _a.containerStyle,
        options = __rest(_a, ["className", "containerStyle"]);

    Object(react__WEBPACK_IMPORTED_MODULE_2__["useEffect"])(function () {
      setInited(true);
    }, []); // @ts-ignore

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement("div", {
      ref: container,
      className: className,
      // @ts-ignore
      style: object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
        position: 'relative',
        height: props.height || '100%',
        width: props.width || '100%'
      }, containerStyle)
    }, inited ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(Component, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
      ref: ref,
      container: container.current
    }, options)) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_2___default.a.Fragment, null));
  });
  Cls.displayName = name || Component.name;
  return Cls;
}
;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Area = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var percent_1 = __webpack_require__(156);

var adaptor_1 = __webpack_require__(1053);

var Area =
/** @class */
function (_super) {
  tslib_1.__extends(Area, _super);

  function Area() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'area';
    return _this;
  }
  /**
   *   
   */


  Area.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
          type: 'x'
        }
      },
      isStack: true,
      // 
      line: {},
      legend: {
        position: 'top-left'
      }
    });
  };
  /**
   * @override
   * @param data
   */


  Area.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        isPercent = _a.isPercent,
        xField = _a.xField,
        yField = _a.yField;
    this.chart.changeData(percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent));
  };
  /**
   *   
   */


  Area.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Area;
}(plot_1.Plot);

exports.Area = Area;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heatmap = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1058); // registered shapes


__webpack_require__(1059);

__webpack_require__(1060);

var Heatmap =
/** @class */
function (_super) {
  tslib_1.__extends(Heatmap, _super);

  function Heatmap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'heatmap';
    return _this;
  }
  /**
   * 
   */


  Heatmap.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  Heatmap.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      type: 'polygon',
      legend: false,
      xAxis: {
        tickLine: null,
        line: null,
        grid: {
          alignTick: false,
          line: {
            style: {
              lineWidth: 1,
              lineDash: null,
              stroke: '#f0f0f0'
            }
          }
        }
      },
      yAxis: {
        grid: {
          alignTick: false,
          line: {
            style: {
              lineWidth: 1,
              lineDash: null,
              stroke: '#f0f0f0'
            }
          }
        }
      }
    });
  };

  return Heatmap;
}(plot_1.Plot);

exports.Heatmap = Heatmap;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rose = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1064);

var Rose =
/** @class */
function (_super) {
  tslib_1.__extends(Rose, _super);

  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'rose';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Rose.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *  options 
   */


  Rose.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: false,
      yAxis: false,
      legend: {
        position: 'right',
        offsetX: -10
      },
      sectorStyle: {
        stroke: '#fff',
        lineWidth: 1
      },
      label: {
        layout: {
          type: 'limit-in-shape'
        }
      },
      tooltip: {
        shared: true,
        showMarkers: false
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Rose.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Rose;
}(plot_1.Plot);

exports.Rose = Rose;

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export BASE_EVENT_NAMES */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pickEventName; });
/* unused harmony export DRAG_EVENT_NAMES */
/* unused harmony export MOBILE_EVENT_NAMES */
/* unused harmony export LIFE_CIRCLE_NAMES */
/* unused harmony export LEGEND_EVENT_TARGETS */
/* unused harmony export GEOM_NAME */
/* unused harmony export LEGEND_EVENT */
/* unused harmony export AXIS_EVENT_TARGET */
/* unused harmony export ANNOTATION_EVENT_TARGET */
/* unused harmony export TOOLTIP_EVENT */
/* harmony import */ var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74);
/* harmony import */ var _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0__);
// /[^on]+\S+(?=(Click)\b)/

var BASE_EVENT_NAMES = ['mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'contextmenu', 'click'];
var EVENT_ACTION_NAMES = ['mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'contextmenu', 'click', 'show', 'hide', 'change'];
var RegExpEvent = new RegExp("^on(.*)(?=(".concat(EVENT_ACTION_NAMES.map(function (k) {
  return k.replace(/^\S/, function (s) {
    return s.toUpperCase();
  });
}).join('|'), "))"));
var pickEventName = function pickEventName(props) {
  var names = [];
  _antv_util_lib_for_in__WEBPACK_IMPORTED_MODULE_0___default()(props, function (v, k) {
    var event = k.match(/^on(.*)/);

    if (event) {
      var res = k.match(RegExpEvent);

      if (res) {
        var target = res[1].replace(/([A-Z])/g, "-$1").toLowerCase();

        if (target) {
          names.push([k, "".concat(target.replace('-', ''), ":").concat(res[2].toLowerCase())]);
        } else {
          names.push([k, res[2].toLowerCase()]);
        }
      } else {
        names.push([k, event[1].toLowerCase()]);
      }
    }
  });
  return names;
};
var DRAG_EVENT_NAMES = ['dragstart', 'drag', 'dragend', 'dragover', 'dragenter', 'dragleave', 'drop'];
var MOBILE_EVENT_NAMES = ['touchstart', 'touchmove', 'touchend'];
var LIFE_CIRCLE_NAMES = ['beforerender', 'afterrender', 'beforepaint', 'afterpaint', 'beforechangedata', 'afterchangedata', 'beforeclear', 'afterclear', 'beforedestroy'];
var LEGEND_EVENT_TARGETS = ['legend', 'legend-title', 'legend-item', 'legend-item-name', 'legend-item-Maker', 'legend-item-value'];
var GEOM_NAME = ['line', 'area', 'point', 'interval', 'polygon', 'edge', 'schema'];
var LEGEND_EVENT = ['legend:valuechanged'];
var AXIS_EVENT_TARGET = ['axis-label', 'axis-line', 'axis-tick', 'axis-title'];
var ANNOTATION_EVENT_TARGET = ['annotation', 'annotation-line', 'annotation-line-text', 'annotation-image', 'annotation-region', 'annotation-text'];
var TOOLTIP_EVENT = ['tooltip:show', 'tooltip:hide', 'tooltip:change'];

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObjectLike = _interopRequireDefault(__webpack_require__(236));

var _isType = _interopRequireDefault(__webpack_require__(67));

var isPlainObject = function isPlainObject(value) {
  /**
   * isObjectLike(new Foo) => false
   * isObjectLike([1, 2, 3]) => false
   * isObjectLike({ x: 0, y: 0 }) => true
   * isObjectLike(Object.create(null)) => true
   */
  if (!(0, _isObjectLike.default)(value) || !(0, _isType.default)(value, 'Object')) {
    return false;
  }

  if (Object.getPrototypeOf(value) === null) {
    return true;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
};

var _default = isPlainObject;
exports.default = _default;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _default = function _default(value) {
  if ((0, _isNil.default)(value)) return '';
  return value.toString();
};

exports.default = _default;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _register = __webpack_require__(412);

var Scale =
/** @class */
function () {
  function Scale(cfg) {
    /**
     * 
     */
    this.type = 'base';
    /**
     * 
     */

    this.isCategory = false;
    /**
     * linear, time 
     */

    this.isLinear = false;
    /**
     * linear,time,log, pow, quantile, quantize 
     */

    this.isContinuous = false;
    /**
     * 
     */

    this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  } // transform/map


  Scale.prototype.translate = function (v) {
    return v;
  };
  /**  */


  Scale.prototype.change = function (cfg) {
    // 
    (0, _util.assign)(this.__cfg__, cfg);
    this.init();
  };

  Scale.prototype.clone = function () {
    return this.constructor(this.__cfg__);
  };
  /** ticks */


  Scale.prototype.getTicks = function () {
    var _this = this;

    return (0, _util.map)(this.ticks, function (tick, idx) {
      if ((0, _util.isObject)(tick)) {
        // Tick
        return tick;
      }

      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
  /** Tick */


  Scale.prototype.getText = function (value, key) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value, key) : value;

    if ((0, _util.isNil)(res) || !(0, _util.isFunction)(res.toString)) {
      return '';
    }

    return res.toString();
  }; //  scale 


  Scale.prototype.getConfig = function (key) {
    return this.__cfg__[key];
  }; // scale


  Scale.prototype.init = function () {
    (0, _util.assign)(this, this.__cfg__);
    this.setDomain();

    if ((0, _util.isEmpty)(this.getConfig('ticks'))) {
      this.ticks = this.calculateTicks();
    }
  }; // 


  Scale.prototype.initCfg = function () {};

  Scale.prototype.setDomain = function () {};

  Scale.prototype.calculateTicks = function () {
    var tickMethod = this.tickMethod;
    var ticks = [];

    if ((0, _util.isString)(tickMethod)) {
      var method = (0, _register.getTickMethod)(tickMethod);

      if (!method) {
        throw new Error('There is no method to to calculate ticks!');
      }

      ticks = method(this);
    } else if ((0, _util.isFunction)(tickMethod)) {
      ticks = tickMethod(this);
    }

    return ticks;
  }; // range 


  Scale.prototype.rangeMin = function () {
    return (0, _util.head)(this.range);
  }; // range 


  Scale.prototype.rangeMax = function () {
    return (0, _util.last)(this.range);
  };
  /**  0~1 */


  Scale.prototype.calcPercent = function (value, min, max) {
    if ((0, _util.isNumber)(value)) {
      return (value - min) / (max - min);
    }

    return NaN;
  };
  /** 0~1 */


  Scale.prototype.calcValue = function (percent, min, max) {
    return min + percent * (max - min);
  };

  return Scale;
}();

var _default = Scale;
exports.default = _default;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMaxLabelWidth = getMaxLabelWidth;
exports.getLabelLength = getLabelLength;
exports.testLabel = testLabel;
exports.ellipsisLabel = ellipsisLabel;

var _util = __webpack_require__(0);

var _text = __webpack_require__(804);

var ELLIPSIS_CODE = "\u2026";
var ELLIPSIS_CODE_LENGTH = 2; // 

/**  */

var OPTIMIZE_THRESHOLD = 400;
/**
 *  getMaxLabelWidth label 
 *  label 
 *  label 
 * @param labels
 */

function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function (label) {
    var text = label.attr('text');
    return (0, _util.isNil)(text) ? '' : "" + text;
  });
  var maxLen = 0;
  var maxIdx = 0;

  for (var i = 0; i < texts.length; i += 1) {
    var len = 0;

    for (var j = 0; j <= texts[i].length; j += 1) {
      var code = texts[i].charCodeAt(j);

      if (code >= 19968 && code <= 40869) {
        len += 2;
      } else {
        len += 1;
      }
    }

    if (len > maxLen) {
      maxLen = len;
      maxIdx = i;
    }
  }

  return labels[maxIdx].getBBox().width;
}
/**  label */


function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }

  var max = 0;
  (0, _util.each)(labels, function (label) {
    var bbox = label.getBBox();
    var width = bbox.width;

    if (max < width) {
      max = width;
    }
  });
  return max;
}
/** label */


function getLabelLength(isVertical, label) {
  var bbox = label.getCanvasBBox();
  return isVertical ? bbox.width : bbox.height;
}
/* label */


function testLabel(label, limitLength) {
  return label.getBBox().width < limitLength;
}
/**  text shape  */


function ellipsisLabel(isVertical, label, limitLength, position) {
  if (position === void 0) {
    position = 'tail';
  }

  var text = label.attr('text');
  var labelLength = getLabelLength(isVertical, label);
  var codeLength = (0, _text.strLen)(text);
  var ellipsised = false;

  if (limitLength < labelLength) {
    var reseveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH; // 

    var newText = void 0;

    if (reseveLength >= 0) {
      newText = (0, _text.ellipsisString)(text, reseveLength, position);
    } else {
      newText = ELLIPSIS_CODE;
    }

    if (newText) {
      label.attr('text', newText);
      ellipsised = true;
    }
  }

  if (ellipsised) {
    label.set('tip', text);
  } else {
    label.set('tip', null);
  }

  return ellipsised;
}

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getStyle;

/**
 * 
 * @param  {Object} dom DOM
 * @param  {String} name 
 * @param  {Any} defaultValue 
 * @return {String} 
 */
function getStyle(dom, name, defaultValue) {
  var v;

  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name]; // dom.style  style 
  } catch (e) {// do nothing
  } finally {
    v = v === undefined ? defaultValue : v;
  }

  return v;
}

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(69);

Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return base_1.default;
  }
});

var circle_1 = __webpack_require__(855);

Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return circle_1.default;
  }
});

var ellipse_1 = __webpack_require__(856);

Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return ellipse_1.default;
  }
});

var image_1 = __webpack_require__(857);

Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return image_1.default;
  }
});

var line_1 = __webpack_require__(858);

Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return line_1.default;
  }
});

var marker_1 = __webpack_require__(859);

Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return marker_1.default;
  }
});

var path_1 = __webpack_require__(860);

Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return path_1.default;
  }
});

var polygon_1 = __webpack_require__(862);

Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.default;
  }
});

var polyline_1 = __webpack_require__(863);

Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return polyline_1.default;
  }
});

var rect_1 = __webpack_require__(864);

Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return rect_1.default;
  }
});

var text_1 = __webpack_require__(867);

Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return text_1.default;
  }
});

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeView = exports.getMergedRegion = exports.getRefreshRegion = exports.refreshElement = exports.drawPath = exports.clearChanged = exports.checkChildrenRefresh = exports.checkRefresh = exports.drawChildren = exports.applyAttrsToContext = void 0;

var util_1 = __webpack_require__(0);

var parse_1 = __webpack_require__(425);

var arc_params_1 = __webpack_require__(426);

var util_2 = __webpack_require__(52);

var ArrowUtil = __webpack_require__(187);

var SHAPE_ATTRS_MAP = {
  fill: 'fillStyle',
  stroke: 'strokeStyle',
  opacity: 'globalAlpha'
};

function applyAttrsToContext(context, element) {
  var attrs = element.attr();

  for (var k in attrs) {
    var v = attrs[k]; //  canvas 

    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;

    if (name_1 === 'matrix' && v) {
      // 
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === 'lineDash' && context.setLineDash) {
      // 
      util_1.isArray(v) && context.setLineDash(v);
    } else {
      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {
        // pattern 
        //  hasUpdate 
        v = parse_1.parseStyle(context, element, v);
      } else if (name_1 === 'globalAlpha') {
        // opacity  opacity  opacity 
        v = v * context.globalAlpha;
      }

      context[name_1] = v;
    }
  }
}

exports.applyAttrsToContext = applyAttrsToContext;

function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}

exports.drawChildren = drawChildren; // https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE

function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get('refreshElements'); //  refresh

  util_1.each(refreshElements, function (el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;

      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });

  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    // 
    checkChildrenRefresh(children, region);
  }
}

exports.checkRefresh = checkRefresh; // 

function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.cfg.visible) {
      //  hasChanged refresh
      if (child.cfg.hasChanged) {
        //  change refresh
        child.cfg.refresh = true;

        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        // / refresh = true changed
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        // 
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;

        if (refresh && child.isGroup()) {
          // 
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}

exports.checkChildrenRefresh = checkChildrenRefresh; //  refreshElements  changed 
//  elements  group

function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false; // 

    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}

exports.clearChanged = clearChanged; //  refresh

function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // let refresh = true;
    //  bbox bbox 
    // const bbox = child.cfg.canvasBBox;
    // if (bbox) {
    //   // 
    //   refresh = intersectRect(bbox, region);
    // }

    child.cfg.refresh = true; //  refresh

    if (child.isGroup()) {
      setChildrenRefresh(child.get('children'), region);
    }
  }
}

function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && util_2.intersectRect(bbox, region);
  return isAllow;
} //  path


function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path,
      startArrow = attrs.startArrow,
      endArrow = attrs.endArrow;

  if (!path) {
    return;
  }

  var currentPoint = [0, 0]; // 

  var startMovePoint = [0, 0]; //  M 

  var distance = {
    dx: 0,
    dy: 0
  };
  context.beginPath();

  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];

    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {
      //  Z  segment  segment 
      var lastPath = path[i + 1];

      if (lastPath[0] === 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }

    var dx = distance.dx,
        dy = distance.dy; // V,H,S,T 

    switch (command) {
      case 'M':
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;

      case 'L':
        context.lineTo(params[1] - dx, params[2] - dy);
        break;

      case 'Q':
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;

      case 'C':
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;

      case 'A':
        {
          var arcParams = void 0; // 

          if (arcParamsCache) {
            arcParams = arcParamsCache[i];

            if (!arcParams) {
              arcParams = arc_params_1.default(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = arc_params_1.default(currentPoint, params);
          }

          var cx = arcParams.cx,
              cy = arcParams.cy,
              rx = arcParams.rx,
              ry = arcParams.ry,
              startAngle = arcParams.startAngle,
              endAngle = arcParams.endAngle,
              xRotation = arcParams.xRotation,
              sweepFlag = arcParams.sweepFlag; //  api

          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }

          break;
        }

      case 'Z':
        context.closePath();
        break;

      default:
        break;
    } //  Z  M 


    if (command === 'Z') {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}

exports.drawPath = drawPath; // (Shape  Group)

function refreshElement(element, changeType) {
  var canvas = element.get('canvas'); //  canvas 

  if (canvas) {
    if (changeType === 'remove') {
      //  remove element 
      // destroy 
      //  hack 
      element._cacheCanvasBBox = element.get('cacheCanvasBBox');
    } // 


    if (!element.get('hasChanged')) {
      //  hasChanged
      element.set('hasChanged', true); // 
      // if (canvas.get('localRefresh')) {
      //   canvas.refreshElement(element, changeType, canvas);
      // }
      //  https://github.com/antvis/g/issues/422 
      //  15% 

      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {
        canvas.refreshElement(element, changeType, canvas);

        if (canvas.get('autoDraw')) {
          canvas.draw();
        }
      }
    }
  }
}

exports.refreshElement = refreshElement;

function getRefreshRegion(element) {
  var region;

  if (!element.destroyed) {
    var cacheBox = element.get('cacheCanvasBBox');
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height); //  bbox  NaN   0 

    if (validCache && validBBox) {
      region = util_2.mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    // 
    region = element['_cacheCanvasBBox'];
  }

  return region;
}

exports.getRefreshRegion = getRefreshRegion;

function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }

  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  util_1.each(elements, function (el) {
    var region = getRefreshRegion(el);

    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: Math.min.apply(null, minXArr),
    minY: Math.min.apply(null, minYArr),
    maxX: Math.max.apply(null, maxXArr),
    maxY: Math.max.apply(null, maxYArr)
  };
}

exports.getMergedRegion = getMergedRegion;

function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  } //  null


  if (!util_2.intersectRect(region, viewRegion)) {
    return null;
  }

  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

exports.mergeView = mergeView;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setClip = exports.setTransform = exports.setShadow = void 0;

var dom_1 = __webpack_require__(70);

function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };

  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute('filter');
  } else {
    var id = context.find('filter', cfg);

    if (!id) {
      id = context.addShadow(cfg);
    }

    el.setAttribute('filter', "url(#" + id + ")");
  }
}

exports.setShadow = setShadow;

function setTransform(model) {
  var matrix = model.attr().matrix;

  if (matrix) {
    var el = model.cfg.el;
    var transform = [];

    for (var i = 0; i < 9; i += 3) {
      transform.push(matrix[i] + "," + matrix[i + 1]);
    }

    transform = transform.join(',');

    if (transform.indexOf('NaN') === -1) {
      el.setAttribute('transform', "matrix(" + transform + ")");
    } else {
      console.warn('invalid matrix:', matrix);
    }
  }
}

exports.setTransform = setTransform;

function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get('el');

  if (!clip) {
    el.removeAttribute('clip-path');
  } else if (clip && !el.hasAttribute('clip-path')) {
    dom_1.createDom(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute('clip-path', "url(#" + id + ")");
  }
}

exports.setClip = setClip;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultCategoryScaleRange = exports.getName = exports.syncScale = exports.createScaleByField = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var dependents_1 = __webpack_require__(68);

var coordinate_1 = __webpack_require__(51);

var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
/**
 * 
 * @param field 
 * @param data 
 * @returns default type 
 */

function getDefaultType(value) {
  var type = 'linear';

  if (dateRegex.test(value)) {
    type = 'timeCat';
  } else if (util_1.isString(value)) {
    type = 'cat';
  }

  return type;
}
/**
 * @ignore
 *  `field`  scale
 * @param field 
 * @param [data] 
 * @param [scaleDef] 
 * @returns scale  Scale 
 */


function createScaleByField(field, data, scaleDef) {
  var validData = data || [];

  if (util_1.isNumber(field) || util_1.isNil(util_1.firstValue(validData, field)) && util_1.isEmpty(scaleDef)) {
    var Identity = dependents_1.getScale('identity');
    return new Identity({
      field: field.toString(),
      values: [field]
    });
  }

  var values = util_1.valuesOfKey(validData, field); // 

  var type = util_1.get(scaleDef, 'type', getDefaultType(values[0]));
  var ScaleCtor = dependents_1.getScale(type);
  return new ScaleCtor(tslib_1.__assign({
    field: field,
    values: values
  }, scaleDef));
}

exports.createScaleByField = createScaleByField;
/**
 * @ignore
 *  scale
 * @todo  scale.update() 
 * @param scale  scale 
 * @param newScale  Scale
 */

function syncScale(scale, newScale) {
  if (scale.type !== 'identity' && newScale.type !== 'identity') {
    var obj = {};

    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }

    scale.change(obj);
  }
}

exports.syncScale = syncScale;
/**
 * @ignore
 * get the scale name, if alias exist, return alias, or else field
 * @param scale
 * @returns the name of field
 */

function getName(scale) {
  return scale.alias || scale.field;
}

exports.getName = getName;
/**
 *  scale values  coordinate  range
 * @param scale  scale 
 * @param coordinate coordinate 
 * @param theme theme
 */

function getDefaultCategoryScaleRange(scale, coordinate, theme) {
  var values = scale.values;
  var count = values.length;
  var range;

  if (count === 1) {
    range = [0.5, 1]; // , [0.5,0.5] 
  } else {
    var widthRatio = 1;
    var offset = 0;

    if (coordinate_1.isFullCircle(coordinate)) {
      if (!coordinate.isTransposed) {
        range = [0, 1 - 1 / count];
      } else {
        widthRatio = util_1.get(theme, 'widthRatio.multiplePie', 1 / 1.3);
        offset = 1 / count * widthRatio;
        range = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count / 2; // 

      range = [offset, 1 - offset]; // 
    }
  }

  return range;
}

exports.getDefaultCategoryScaleRange = getDefaultCategoryScaleRange;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertPolarPath = exports.convertNormalPath = exports.getSplinePath = exports.getLinePath = exports.catmullRom2bezier = exports.smoothBezier = void 0;

var matrix_util_1 = __webpack_require__(33);

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51);

function _points2path(points, isInCircle) {
  var path = [];

  if (points.length) {
    path.push(['M', points[0].x, points[0].y]);

    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path.push(['L', item.x, item.y]);
    }

    if (isInCircle) {
      path.push(['Z']);
    }
  }

  return path;
}

function _convertArr(arr, coord) {
  var tmp = [arr[0]];

  for (var i = 1, len = arr.length; i < len; i = i + 2) {
    var point = coord.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point.x, point.y);
  }

  return tmp;
}

function _convertArcPath(path, coord) {
  var isTransposed = coord.isTransposed;
  var r = path[1];
  var x = path[6];
  var y = path[7];
  var point = coord.convert({
    x: x,
    y: y
  });
  var direction = isTransposed ? 0 : 1;
  return ['A', r, r, 0, 0, direction, point.x, point.y];
}

function _convertPolarPath(pre, cur, coord) {
  var isTransposed = coord.isTransposed,
      startAngle = coord.startAngle,
      endAngle = coord.endAngle;
  var prePoint = pre[0].toLowerCase() === 'a' ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? 'y' : 'x';
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction = curPoint[xDim] >= prePoint[xDim] ? 1 : 0; // 

  var flag = angleRange > Math.PI ? 1 : 0; // 

  var convertPoint = coord.convert(curPoint);
  var r = coordinate_1.getDistanceToCenter(coord, convertPoint);

  if (r >= 0.5) {
    // 1
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord.convert(middlePoint);
      rst.push(['A', r, r, 0, flag, direction, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(['A', r, r, 0, flag, direction, convertPoint.x, convertPoint.y]);
    }
  }

  return rst;
} // 


function _filterFullCirleLine(path) {
  util_1.each(path, function (subPath, index) {
    var cur = subPath;

    if (cur[0].toLowerCase() === 'a') {
      var pre = path[index - 1];
      var next = path[index + 1];

      if (next && next[0].toLowerCase() === 'a') {
        if (pre && pre[0].toLowerCase() === 'l') {
          pre[0] = 'M';
        }
      } else if (pre && pre[0].toLowerCase() === 'a') {
        if (next && next[0].toLowerCase() === 'l') {
          next[0] = 'M';
        }
      }
    }
  });
}
/**
 * @ignore
 * 
 */


exports.smoothBezier = function (points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min;
  var max;

  if (hasConstraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min = matrix_util_1.vec2.min([0, 0], min, point);
      max = matrix_util_1.vec2.max([0, 0], max, point);
    }

    min = matrix_util_1.vec2.min([0, 0], min, constraint[0]);
    max = matrix_util_1.vec2.max([0, 0], max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(point);
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    var v = [0, 0];
    v = matrix_util_1.vec2.sub(v, nextPoint, prevPoint);
    v = matrix_util_1.vec2.scale(v, v, smooth);
    var d0 = matrix_util_1.vec2.distance(point, prevPoint);
    var d1 = matrix_util_1.vec2.distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    var v1 = matrix_util_1.vec2.scale([0, 0], v, -d0);
    var v2 = matrix_util_1.vec2.scale([0, 0], v, d1);
    var cp0 = matrix_util_1.vec2.add([0, 0], point, v1);
    var cp1 = matrix_util_1.vec2.add([0, 0], point, v2);

    if (hasConstraint) {
      cp0 = matrix_util_1.vec2.max([0, 0], cp0, min);
      cp0 = matrix_util_1.vec2.min([0, 0], cp0, max);
      cp1 = matrix_util_1.vec2.max([0, 0], cp1, min);
      cp1 = matrix_util_1.vec2.min([0, 0], cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
};
/**
 * @ignore
 * 
 */


function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];

  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }

  var controlPointList = exports.smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;

  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  return d1;
}

exports.catmullRom2bezier = catmullRom2bezier;
/**
 * @ignore
 *  path
 */

function getLinePath(points, isInCircle) {
  return _points2path(points, isInCircle);
}

exports.getLinePath = getLinePath;
/**
 * @ignore
 * 
 */

function getSplinePath(points, isInCircle, constaint) {
  var data = [];
  var first = points[0];
  var prePoint = null;

  if (points.length <= 2) {
    // 
    return getLinePath(points, isInCircle);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
      data.push(point.x);
      data.push(point.y);
      prePoint = point;
    }
  }

  var constraint = constaint || [// 
  [0, 0], [1, 1]];
  var splinePath = catmullRom2bezier(data, isInCircle, constraint);
  splinePath.unshift(['M', first.x, first.y]);
  return splinePath;
}

exports.getSplinePath = getSplinePath;
/**
 * @ignore
 * 
 */

function convertNormalPath(coord, path) {
  var tmp = [];
  util_1.each(path, function (subPath) {
    var action = subPath[0];

    switch (action.toLowerCase()) {
      case 'm':
      case 'l':
      case 'c':
        tmp.push(_convertArr(subPath, coord));
        break;

      case 'a':
        tmp.push(_convertArcPath(subPath, coord));
        break;

      case 'z':
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}

exports.convertNormalPath = convertNormalPath;
/**
 * @ignore
 * 
 */

function convertPolarPath(coord, path) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals;
  util_1.each(path, function (subPath, index) {
    var action = subPath[0];

    switch (action.toLowerCase()) {
      case 'm':
      case 'c':
      case 'q':
        tmp.push(_convertArr(subPath, coord));
        break;

      case 'l':
        pre = path[index - 1];
        cur = subPath;
        transposed = coord.isTransposed; // 

        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];

        if (equals) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord));
        } else {
          // y 
          tmp.push(_convertArr(subPath, coord));
        }

        break;

      case 'a':
        tmp.push(_convertArcPath(subPath, coord));
        break;

      case 'z':
      default:
        tmp.push(subPath);
        break;
    }
  });

  _filterFullCirleLine(tmp); // 


  return tmp;
}

exports.convertPolarPath = convertPolarPath;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerSymbols = void 0;
/** @ignore */

exports.MarkerSymbols = {
  hexagon: function hexagon(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [['M', x, y - r], ['L', x + diffX, y - r / 2], ['L', x + diffX, y + r / 2], ['L', x, y + r], ['L', x - diffX, y + r / 2], ['L', x - diffX, y - r / 2], ['Z']];
  },
  bowtie: function bowtie(x, y, r) {
    var diffY = r - 1.5;
    return [['M', x - r, y - diffY], ['L', x + r, y + diffY], ['L', x + r, y - diffY], ['L', x - r, y + diffY], ['Z']];
  },
  cross: function cross(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y + r], ['M', x + r, y - r], ['L', x - r, y + r]];
  },
  tick: function tick(x, y, r) {
    return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
  },
  plus: function plus(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y], ['M', x, y - r], ['L', x, y + r]];
  },
  hyphen: function hyphen(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  line: function line(x, y, r) {
    return [['M', x, y - r], ['L', x, y + r]];
  }
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return _ellipse.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _image.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return _marker.default;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return _rect.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});

var _base = _interopRequireDefault(__webpack_require__(71));

var _circle = _interopRequireDefault(__webpack_require__(908));

var _ellipse = _interopRequireDefault(__webpack_require__(909));

var _image = _interopRequireDefault(__webpack_require__(910));

var _line = _interopRequireDefault(__webpack_require__(911));

var _marker = _interopRequireDefault(__webpack_require__(912));

var _path = _interopRequireDefault(__webpack_require__(913));

var _polygon = _interopRequireDefault(__webpack_require__(915));

var _polyline = _interopRequireDefault(__webpack_require__(916));

var _rect = _interopRequireDefault(__webpack_require__(917));

var _text = _interopRequireDefault(__webpack_require__(920));

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyAttrsToContext = applyAttrsToContext;
exports.drawChildren = drawChildren;
exports.checkRefresh = checkRefresh;
exports.checkChildrenRefresh = checkChildrenRefresh;
exports.clearChanged = clearChanged;
exports.drawPath = drawPath;
exports.refreshElement = refreshElement;
exports.getRefreshRegion = getRefreshRegion;
exports.getMergedRegion = getMergedRegion;
exports.mergeView = mergeView;

var _util = __webpack_require__(0);

var _parse = __webpack_require__(439);

var _arcParams = _interopRequireDefault(__webpack_require__(440));

var _util2 = __webpack_require__(54);

var ArrowUtil = _interopRequireWildcard(__webpack_require__(190));

var SHAPE_ATTRS_MAP = {
  fill: 'fillStyle',
  stroke: 'strokeStyle',
  opacity: 'globalAlpha'
};

function applyAttrsToContext(context, element) {
  var attrs = element.attr();

  for (var k in attrs) {
    var v = attrs[k]; //  canvas 

    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;

    if (name_1 === 'matrix' && v) {
      // 
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === 'lineDash' && context.setLineDash) {
      // 
      (0, _util.isArray)(v) && context.setLineDash(v);
    } else {
      if (name_1 === 'strokeStyle' || name_1 === 'fillStyle') {
        // pattern 
        //  hasUpdate 
        v = (0, _parse.parseStyle)(context, element, v);
      } else if (name_1 === 'globalAlpha') {
        // opacity  opacity  opacity 
        v = v * context.globalAlpha;
      }

      context[name_1] = v;
    }
  }
}

function drawChildren(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
} // https://www.yuque.com/antv/ou292n/pcgt5g#OW1QE


function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get('refreshElements'); //  refresh

  (0, _util.each)(refreshElements, function (el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;

      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });

  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    // 
    checkChildrenRefresh(children, region);
  }
} // 


function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];

    if (child.cfg.visible) {
      //  hasChanged refresh
      if (child.cfg.hasChanged) {
        //  change refresh
        child.cfg.refresh = true;

        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        // / refresh = true changed
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        // 
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;

        if (refresh && child.isGroup()) {
          // 
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
} //  refreshElements  changed 
//  elements  group


function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false; // 

    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
} //  refresh


function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i]; // let refresh = true;
    //  bbox bbox 
    // const bbox = child.cfg.canvasBBox;
    // if (bbox) {
    //   // 
    //   refresh = intersectRect(bbox, region);
    // }

    child.cfg.refresh = true; //  refresh

    if (child.isGroup()) {
      setChildrenRefresh(child.get('children'), region);
    }
  }
}

function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && (0, _util2.intersectRect)(bbox, region);
  return isAllow;
} //  path


function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path,
      startArrow = attrs.startArrow,
      endArrow = attrs.endArrow;

  if (!path) {
    return;
  }

  var currentPoint = [0, 0]; // 

  var startMovePoint = [0, 0]; //  M 

  var distance = {
    dx: 0,
    dy: 0
  };
  context.beginPath();

  for (var i = 0; i < path.length; i++) {
    var params = path[i];
    var command = params[0];

    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path.length - 2 && path[i + 1][0] === 'Z' && endArrow && endArrow.d) {
      //  Z  segment  segment 
      var lastPath = path[i + 1];

      if (lastPath[0] === 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== 'Z') {
        var tangent = shape.getEndTangent();
        distance = ArrowUtil.getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }

    var dx = distance.dx,
        dy = distance.dy; // V,H,S,T 

    switch (command) {
      case 'M':
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;

      case 'L':
        context.lineTo(params[1] - dx, params[2] - dy);
        break;

      case 'Q':
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;

      case 'C':
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;

      case 'A':
        {
          var arcParams = void 0; // 

          if (arcParamsCache) {
            arcParams = arcParamsCache[i];

            if (!arcParams) {
              arcParams = (0, _arcParams.default)(currentPoint, params);
              arcParamsCache[i] = arcParams;
            }
          } else {
            arcParams = (0, _arcParams.default)(currentPoint, params);
          }

          var cx = arcParams.cx,
              cy = arcParams.cy,
              rx = arcParams.rx,
              ry = arcParams.ry,
              startAngle = arcParams.startAngle,
              endAngle = arcParams.endAngle,
              xRotation = arcParams.xRotation,
              sweepFlag = arcParams.sweepFlag; //  api

          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }

          break;
        }

      case 'Z':
        context.closePath();
        break;

      default:
        break;
    } //  Z  M 


    if (command === 'Z') {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
} // (Shape  Group)


function refreshElement(element, changeType) {
  var canvas = element.get('canvas'); //  canvas 

  if (canvas) {
    if (changeType === 'remove') {
      //  remove element 
      // destroy 
      //  hack 
      element._cacheCanvasBBox = element.get('cacheCanvasBBox');
    } // 


    if (!element.get('hasChanged')) {
      //  hasChanged
      element.set('hasChanged', true); // 
      // if (canvas.get('localRefresh')) {
      //   canvas.refreshElement(element, changeType, canvas);
      // }
      //  https://github.com/antvis/g/issues/422 
      //  15% 

      if (!(element.cfg.parent && element.cfg.parent.get('hasChanged'))) {
        canvas.refreshElement(element, changeType, canvas);

        if (canvas.get('autoDraw')) {
          canvas.draw();
        }
      }
    }
  }
}

function getRefreshRegion(element) {
  var region;

  if (!element.destroyed) {
    var cacheBox = element.get('cacheCanvasBBox');
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height); //  bbox  NaN   0 

    if (validCache && validBBox) {
      region = (0, _util2.mergeRegion)(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    // 
    region = element['_cacheCanvasBBox'];
  }

  return region;
}

function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }

  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  (0, _util.each)(elements, function (el) {
    var region = getRefreshRegion(el);

    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: Math.min.apply(null, minXArr),
    minY: Math.min.apply(null, minYArr),
    maxX: Math.max.apply(null, maxXArr),
    maxY: Math.max.apply(null, maxYArr)
  };
}

function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  } //  null


  if (!(0, _util2.intersectRect)(region, viewRegion)) {
    return null;
  }

  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setShadow = setShadow;
exports.setTransform = setTransform;
exports.setClip = setClip;

var _dom = __webpack_require__(72);

function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };

  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute('filter');
  } else {
    var id = context.find('filter', cfg);

    if (!id) {
      id = context.addShadow(cfg);
    }

    el.setAttribute('filter', "url(#" + id + ")");
  }
}

function setTransform(model) {
  var matrix = model.attr().matrix;

  if (matrix) {
    var el = model.cfg.el;
    var transform = [];

    for (var i = 0; i < 9; i += 3) {
      transform.push(matrix[i] + "," + matrix[i + 1]);
    }

    transform = transform.join(',');

    if (transform.indexOf('NaN') === -1) {
      el.setAttribute('transform', "matrix(" + transform + ")");
    } else {
      console.warn('invalid matrix:', matrix);
    }
  }
}

function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get('el');

  if (!clip) {
    el.removeAttribute('clip-path');
  } else if (clip && !el.hasAttribute('clip-path')) {
    (0, _dom.createDom)(clip);
    clip.createPath(context);
    var id = context.addClip(clip);
    el.setAttribute('clip-path', "url(#" + id + ")");
  }
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRectWithCornerRadius = exports.getFunnelPath = exports.getIntervalRectPath = exports.getBackgroundRectPath = exports.parseRadius = exports.getRectPath = exports.getRectPoints = void 0;

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);
/**
 * @ignore
 * 
 * @param pointInfo 
 * @param [isPyramid] 
 * @returns rect points 
 */


function getRectPoints(pointInfo, isPyramid) {
  if (isPyramid === void 0) {
    isPyramid = false;
  }

  var x = pointInfo.x,
      y = pointInfo.y,
      y0 = pointInfo.y0,
      size = pointInfo.size; //  4 
  // 1. x, y 
  // 2. yx
  // 3. xy
  // 4. x, y 

  var yMin;
  var yMax;

  if (util_1.isArray(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }

  var xMin;
  var xMax;

  if (util_1.isArray(x)) {
    xMin = x[0], xMax = x[1];
  } else {
    xMin = x - size / 2;
    xMax = x + size / 2;
  }

  var points = [{
    x: xMin,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }];

  if (isPyramid) {
    // 
    // 
    // 1
    // |   2
    // 0
    points.push({
      x: xMax,
      y: (yMax + yMin) / 2
    });
  } else {
    // 
    // 1 ---- 2
    // |      |
    // 0 ---- 3
    points.push({
      x: xMax,
      y: yMax
    }, {
      x: xMax,
      y: yMin
    });
  }

  return points;
}

exports.getRectPoints = getRectPoints;
/**
 * @ignore
 *  path
 * @param points 
 * @param isClosed path 
 * @returns  path
 */

function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }

  var path = [];
  var firstPoint = points[0];
  path.push(['M', firstPoint.x, firstPoint.y]);

  for (var i = 1, len = points.length; i < len; i++) {
    path.push(['L', points[i].x, points[i].y]);
  } //  shape="line" path  lineCap 


  if (isClosed) {
    path.push(['L', firstPoint.x, firstPoint.y]); // 

    path.push(['z']);
  }

  return path;
}

exports.getRectPath = getRectPath;
/**
 *  rect path  radius
 * @returns  path  arc 
 */

function parseRadius(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;

  if (util_1.isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  } //  


  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }

  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }

  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}

exports.parseRadius = parseRadius;
/**
 *  interval  path
 * @param cfg 
 * @param points  4 
 * @param coordinate 
 * @returns  path
 */

function getBackgroundRectPath(cfg, points, coordinate) {
  var path = [];

  if (coordinate.isRect) {
    var p0 = coordinate.isTransposed ? {
      x: coordinate.start.x,
      y: points[0].y
    } : {
      x: points[0].x,
      y: coordinate.start.y
    };
    var p1 = coordinate.isTransposed ? {
      x: coordinate.end.x,
      y: points[2].y
    } : {
      x: points[3].x,
      y: coordinate.end.y
    }; // corner radius of background shape works only in 

    var radius = util_1.get(cfg, ['background', 'style', 'radius']);

    if (radius) {
      var width = coordinate.isTransposed ? Math.abs(points[0].y - points[2].y) : points[2].x - points[1].x;
      var height = coordinate.isTransposed ? coordinate.getWidth() : coordinate.getHeight();

      var _a = parseRadius(radius, Math.min(width, height)),
          r1 = _a[0],
          r2 = _a[1],
          r3 = _a[2],
          r4 = _a[3];

      path.push(['M', p0.x, p1.y + r1]);
      r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p0.x + r1, p1.y]);
      path.push(['L', p1.x - r2, p1.y]);
      r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p1.x, p1.y + r2]);
      path.push(['L', p1.x, p0.y - r3]);
      r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p1.x - r3, p0.y]);
      path.push(['L', p0.x + r4, p0.y]);
      r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    } else {
      path.push(['M', p0.x, p0.y]);
      path.push(['L', p1.x, p0.y]);
      path.push(['L', p1.x, p1.y]);
      path.push(['L', p0.x, p1.y]);
      path.push(['L', p0.x, p0.y]);
    }

    path.push(['z']);
  }

  if (coordinate.isPolar) {
    var center = coordinate.getCenter();

    var _b = graphics_1.getAngle(cfg, coordinate),
        startAngle = _b.startAngle,
        endAngle = _b.endAngle;

    if (coordinate.type !== 'theta' && !coordinate.isTransposed) {
      //  path
      path = graphics_1.getSectorPath(center.x, center.y, coordinate.getRadius(), startAngle, endAngle);
    } else {
      var pow = function pow(v) {
        return Math.pow(v, 2);
      };

      var r1 = Math.sqrt(pow(center.x - points[0].x) + pow(center.y - points[0].y));
      var r2 = Math.sqrt(pow(center.x - points[2].x) + pow(center.y - points[2].y)); //  path coordinate 

      path = graphics_1.getSectorPath(center.x, center.y, r1, coordinate.startAngle, coordinate.endAngle, r2);
    }
  }

  return path;
}

exports.getBackgroundRectPath = getBackgroundRectPath;
/**
 * @ignore
 *  path
 * @param points 
 * @param lineCap 'round'
 * @param coor 
 * @returns  path
 */

function getIntervalRectPath(points, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === 'rect';
  var path = [];
  var r = (points[2].x - points[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;

  if (lineCap === 'round') {
    if (isRect) {
      path.push(['M', points[0].x, points[0].y + ry]);
      path.push(['L', points[1].x, points[1].y - ry]);
      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y - ry]);
      path.push(['L', points[3].x, points[3].y + ry]);
      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y + ry]);
    } else {
      path.push(['M', points[0].x, points[0].y]);
      path.push(['L', points[1].x, points[1].y]);
      path.push(['A', r, r, 0, 0, 1, points[2].x, points[2].y]);
      path.push(['L', points[3].x, points[3].y]);
      path.push(['A', r, r, 0, 0, 1, points[0].x, points[0].y]);
    }

    path.push(['z']);
  } else {
    path = getRectPath(points);
  }

  return path;
}

exports.getIntervalRectPath = getIntervalRectPath;
/**
 * @ignore
 *  funnel  path
 * @param points 
 * @param nextPoints 
 * @param isPyramid 
 * @returns  path
 */

function getFunnelPath(points, nextPoints, isPyramid) {
  var path = [];

  if (!util_1.isNil(nextPoints)) {
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', nextPoints[1].x, nextPoints[1].y], ['L', nextPoints[0].x, nextPoints[0].y], ['Z']);
  } else if (isPyramid) {
    // 
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[2].x, points[2].y], ['Z']);
  } else {
    // 
    path.push(['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']);
  }

  return path;
}

exports.getFunnelPath = getFunnelPath;
/**
 *   
 * - 
 */

function getRectWithCornerRadius(points, coordinate, radius) {
  var _a, _b, _c, _d; //  


  var p0 = points[0],
      p1 = points[1],
      p2 = points[2],
      p3 = points[3];
  var _e = [0, 0, 0, 0],
      r1 = _e[0],
      r2 = _e[1],
      r3 = _e[2],
      r4 = _e[3];
  /**
   *  p1  p2
   *      
   *  p0  p3
   *
   *  
   *
   *  p0  p3
   *      
   *  p1  p2
   */

  if (p0.y < p1.y
  /**  */
  ) {
      p1 = points[0], p0 = points[1], p3 = points[2], p2 = points[3];
      _a = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r4 = _a[0], r3 = _a[1], r2 = _a[2], r1 = _a[3];
    } else {
    _b = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _b[0], r2 = _b[1], r3 = _b[2], r4 = _b[3];
  }
  /**
   * 
   *  p1  p2
   *      
   *  p0  p3
   *
   * (  x   y ) p0  radius: [r3, r2, r1, r4]
   * p3  p2
   *     
   * P0  p1points[3]
   *
   *  y 
   *
   *  p0  p1
   *      
   *  p3  p2
   */


  if (coordinate.isTransposed) {
    p0 = points[0], p3 = points[1], p2 = points[2], p1 = points[3];

    if (points[0].x > points[1].x
    /**  */
    ) {
        p3 = points[0], p0 = points[1], p1 = points[2], p2 = points[3];
        _c = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r1 = _c[0], r4 = _c[1], r3 = _c[2], r2 = _c[3];
      } else {
      _d = parseRadius(radius, Math.min(p3.x - p0.x, p0.y - p1.y)), r2 = _d[0], r3 = _d[1], r4 = _d[2], r1 = _d[3];
    }
  }

  var path = [];
  path.push(['M', p1.x, p1.y + r1]);
  r1 !== 0 && path.push(['A', r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
  path.push(['L', p2.x - r2, p2.y]);
  r2 !== 0 && path.push(['A', r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
  path.push(['L', p3.x, p3.y - r3]);
  r3 !== 0 && path.push(['A', r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
  path.push(['L', p0.x + r4, p0.y]);
  r4 !== 0 && path.push(['A', r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
  path.push(['L', p1.x, p1.y + r1]);
  path.push(['z']);
  return path;
}

exports.getRectWithCornerRadius = getRectWithCornerRadius;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TOOLTIP_OPTIONS = exports.Y_FIELD = exports.X_FIELD = void 0;

var util_1 = __webpack_require__(0);

exports.X_FIELD = 'x';
exports.Y_FIELD = 'y';
exports.DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + util_1.get(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: 'x'
  }
};

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformDataToNodeLinkData = exports.adjustYMetaByZero = void 0;

var util_1 = __webpack_require__(0);
/**
 * 
 * @param data
 * @param field
 */


function adjustYMetaByZero(data, field) {
  // 
  var numberData = data.filter(function (datum) {
    var v = util_1.get(datum, [field]);
    return util_1.isNumber(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function (datum) {
    return util_1.get(datum, [field]) >= 0;
  });
  var ltZero = numberData.every(function (datum) {
    return util_1.get(datum, [field]) <= 0;
  }); //  { min: 0, max: undefined }  update({ max: 0 })  { min: 0, max: 0 }

  if (gtZero) {
    return {
      min: 0
    };
  }

  if (ltZero) {
    return {
      max: 0
    };
  }

  return {};
}

exports.adjustYMetaByZero = adjustYMetaByZero;
/**
 * 
 * @param data
 * @param sourceField
 * @param targetField
 * @param weightField
 */

function transformDataToNodeLinkData(data, sourceField, targetField, weightField) {
  if (!Array.isArray(data)) {
    return {
      nodes: [],
      links: []
    };
  } //   const nodes = [];


  var links = []; // 

  var nodesMap = {};
  var nodesIndex = -1; //  chord layout 

  data.forEach(function (datum) {
    var source = datum[sourceField];
    var target = datum[targetField];
    var weight = datum[weightField]; // source node

    if (!nodesMap[source]) {
      nodesMap[source] = {
        id: ++nodesIndex,
        name: source
      };
    }

    if (!nodesMap[target]) {
      nodesMap[target] = {
        id: ++nodesIndex,
        name: target
      };
    } // links


    links.push({
      source: nodesMap[source].id,
      target: nodesMap[target].id,
      // sourceName: source,
      // targetName: target,
      value: weight
    });
  });
  return {
    nodes: Object.values(nodesMap),
    links: links
  };
}

exports.transformDataToNodeLinkData = transformDataToNodeLinkData;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(1037);

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataWhetherPecentage = exports.percent = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var number_1 = __webpack_require__(490);
/**
 * 
 * @param data
 * @param measure
 * @param groupField
 * @param as
 */


function percent(data, measure, groupField, as) {
  // 1.  max 
  var sumMap = util_1.reduce(data, function (map, datum) {
    var groupValue = datum[groupField];
    var sum = map.has(groupValue) ? map.get(groupValue) : 0;
    var v = datum[measure];
    sum = number_1.isRealNumber(v) ? sum + v : sum;
    map.set(groupValue, sum);
    return map;
  }, new Map()); // 2. 

  return util_1.map(data, function (datum) {
    var _a;

    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = number_1.isRealNumber(v) ? v / sumMap.get(groupValue) : 0;
    return tslib_1.__assign(tslib_1.__assign({}, datum), (_a = {}, _a[as] = percentage, _a));
  });
}

exports.percent = percent;
/**
 *  ()
 * @param isPercent 
 */

function getDataWhetherPecentage(data, yField, groupField, asField, isPercent) {
  return !isPercent ? data : percent(data, yField, groupField, asField);
}

exports.getDataWhetherPecentage = getDataWhetherPecentage;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpose = interpose;

var _geometry = __webpack_require__(1080);

// Given a start point, an end point, and a prediciton function,
// returns a smooth line.
function interpose(xmin, xmax, predict) {
  var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
  var precision = 1 * Math.pow(10, -l / 2 - 1),
      maxIter = 1e4;
  var points = [px(xmin), px(xmax)],
      iter = 0;

  while (find(points) && iter < maxIter) {
    ;
  }

  return points;

  function px(x) {
    return [x, predict(x)];
  }

  function find(points) {
    iter++;
    var n = points.length;
    var found = false;

    for (var i = 0; i < n - 1; i++) {
      var p0 = points[i],
          p1 = points[i + 1],
          m = (0, _geometry.midpoint)([p0, p1]),
          mp = px(m[0]),
          a0 = (0, _geometry.angle)([p0, m]),
          a1 = (0, _geometry.angle)([p0, mp]),
          a = Math.abs(a0 - a1);

      if (a > precision) {
        points.splice(i + 1, 0, mp);
        found = true;
      }
    }

    return found;
  }
}

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ols = ols;

// Ordinary Least Squares from vega-statistics by Jeffrey Heer
// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
// Source: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/packages/vega-statistics/src/regression/ols.js
function ols(uX, uY, uXY, uX2) {
  var delta = uX2 - uX * uX,
      slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
      intercept = uY - slope * uX;
  return [intercept, slope];
}

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TOOLTIP_OPTIONS = exports.Y_FIELD = exports.X_FIELD = void 0;

var _util = __webpack_require__(0);

var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var Y_FIELD = 'y';
exports.Y_FIELD = Y_FIELD;
var DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + (0, _util.get)(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: 'x'
  }
};
exports.DEFAULT_TOOLTIP_OPTIONS = DEFAULT_TOOLTIP_OPTIONS;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "path", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});

var _path = _interopRequireDefault(__webpack_require__(1242));

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.tau = exports.halfPi = exports.pi = exports.epsilon = exports.sqrt = exports.sin = exports.min = exports.max = exports.cos = exports.atan2 = exports.abs = void 0;
var abs = Math.abs;
exports.abs = abs;
var atan2 = Math.atan2;
exports.atan2 = atan2;
var cos = Math.cos;
exports.cos = cos;
var max = Math.max;
exports.max = max;
var min = Math.min;
exports.min = min;
var sin = Math.sin;
exports.sin = sin;
var sqrt = Math.sqrt;
exports.sqrt = sqrt;
var epsilon = 1e-12;
exports.epsilon = epsilon;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var tau = 2 * pi;
exports.tau = tau;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];

    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series) {
  var n = series.length,
      o = new Array(n);

  while (--n >= 0) {
    o[n] = n;
  }

  return o;
}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var constant_1 = __webpack_require__(20);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));

var element_1 = tslib_1.__importDefault(__webpack_require__(269));
/**  ShapeFactory */


__webpack_require__(276);

var is_model_change_1 = __webpack_require__(437);
/**
 * Path 
 * 
 */


var Path =
/** @class */
function (_super) {
  tslib_1.__extends(Path, _super);

  function Path(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'path';
    _this.shapeType = 'line';
    var _a = cfg.connectNulls,
        connectNulls = _a === void 0 ? false : _a,
        _b = cfg.showSinglePoint,
        showSinglePoint = _b === void 0 ? true : _b;
    _this.connectNulls = connectNulls;
    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  /**
   *  Element  PathLineArea Element
   * @param mappingData
   * @param [isUpdate]
   * @returns elements
   */


  Path.prototype.createElements = function (mappingData, index, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    } // Path  element 


    var _a = this,
        lastElementsMap = _a.lastElementsMap,
        elementsMap = _a.elementsMap,
        elements = _a.elements,
        container = _a.container;

    var elementId = this.getElementId(mappingData);
    var shapeCfg = this.getShapeInfo(mappingData);
    var result = lastElementsMap[elementId];

    if (!result) {
      var shapeFactory = this.getShapeFactory();
      result = new element_1.default({
        shapeFactory: shapeFactory,
        container: container,
        offscreenGroup: this.getOffscreenGroup()
      });
      result.geometry = this;
      result.animate = this.animateOption;
      result.draw(shapeCfg, isUpdate); //  shape
    } else {
      // element 
      var preShapeCfg = result.getModel();

      if (this.isCoordinateChanged || is_model_change_1.isModelChange(preShapeCfg, shapeCfg)) {
        result.animate = this.animateOption; // 

        result.update(shapeCfg); //  element
      }

      delete lastElementsMap[elementId];
    }

    elements.push(result);
    elementsMap[elementId] = result;
    return elements;
  };
  /**
   * 
   * @param mappingData 
   */


  Path.prototype.getPointsAndData = function (mappingData) {
    var points = [];
    var data = [];

    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push({
        x: obj.x,
        y: obj.y
      });
      data.push(obj[constant_1.FIELD_ORIGIN]);
    }

    return {
      points: points,
      data: data
    };
  };

  Path.prototype.getShapeInfo = function (mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);

    var _a = this.getPointsAndData(mappingData),
        points = _a.points,
        data = _a.data;

    shapeCfg.mappingData = mappingData;
    shapeCfg.data = data;
    shapeCfg.isStack = !!this.getAdjust('stack');
    shapeCfg.points = points;
    shapeCfg.connectNulls = this.connectNulls;
    shapeCfg.showSinglePoint = this.showSinglePoint;
    return shapeCfg;
  };

  return Path;
}(base_1.default);

exports.default = Path;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.STATUS_ACTIVE = exports.STATUS_UNACTIVE = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var highlight_util_1 = __webpack_require__(287);

var state_1 = tslib_1.__importDefault(__webpack_require__(283));

var constant_1 = __webpack_require__(20);

exports.STATUS_UNACTIVE = constant_1.ELEMENT_STATE.INACTIVE;
exports.STATUS_ACTIVE = constant_1.ELEMENT_STATE.ACTIVE;
/**
 * @ignore
 * highlight
 */

var ElementHighlight =
/** @class */
function (_super) {
  tslib_1.__extends(ElementHighlight, _super);

  function ElementHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = exports.STATUS_ACTIVE;
    return _this;
  } //  highlight


  ElementHighlight.prototype.setElementsStateByItem = function (elements, field, item, enable) {
    var _this = this;

    var callback = function callback(el) {
      return _this.isMathItem(el, field, item);
    };

    this.setHighlightBy(elements, callback, enable);
  }; //  highlight


  ElementHighlight.prototype.setElementHighlight = function (el, callback) {
    if (callback(el)) {
      if (el.hasState(exports.STATUS_UNACTIVE)) {
        el.setState(exports.STATUS_UNACTIVE, false);
      }

      el.setState(exports.STATUS_ACTIVE, true);
    } else if (!el.hasState(exports.STATUS_ACTIVE)) {
      el.setState(exports.STATUS_UNACTIVE, true);
    }
  };

  ElementHighlight.prototype.setHighlightBy = function (elements, callback, enable) {
    var _this = this;

    if (enable) {
      //  highlight  element  active
      //  active unactive
      util_1.each(elements, function (el) {
        _this.setElementHighlight(el, callback);
      });
    } else {
      //  highlight highlight
      var activeElements = util_2.getElementsByState(this.context.view, exports.STATUS_ACTIVE);
      var allCancel_1 = true; //  activeElements  highlight

      util_1.each(activeElements, function (el) {
        if (!callback(el)) {
          allCancel_1 = false;
          return false;
        }
      });

      if (allCancel_1) {
        //  activeunactive 
        this.clear();
      } else {
        //  highlight,  element  unactive
        //  element 
        util_1.each(elements, function (el) {
          if (callback(el)) {
            if (el.hasState(exports.STATUS_ACTIVE)) {
              el.setState(exports.STATUS_ACTIVE, false);
            }

            el.setState(exports.STATUS_UNACTIVE, true);
          }
        });
      }
    }
  }; //  highlight


  ElementHighlight.prototype.setElementState = function (element, enable) {
    var view = this.context.view;
    var elements = util_2.getElements(view);
    this.setHighlightBy(elements, function (el) {
      return element === el;
    }, enable);
  };

  ElementHighlight.prototype.highlight = function () {
    this.setState();
  }; //  active unactive 


  ElementHighlight.prototype.clear = function () {
    var view = this.context.view;
    highlight_util_1.clearHighlight(view);
  };

  return ElementHighlight;
}(state_1.default);

exports.default = ElementHighlight;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathIn = void 0;
/**
 * @ignore
 * 
 * path 
 * @param element 
 * @param animateCfg 
 * @param cfg 
 */

function pathIn(element, animateCfg, cfg) {
  // @ts-ignore
  var length = element.getTotalLength(); // 

  element.attr('lineDash', [length]);
  element.animate(function (ratio) {
    return {
      // 
      lineDashOffset: (1 - ratio) * length
    };
  }, animateCfg);
}

exports.pathIn = pathIn;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antvDark = exports.createDarkStyleSheet = void 0;
var WHITE_COLORS = {
  100: '#000',
  95: '#0D0D0D',
  85: '#262626',
  65: '#595959',
  45: '#8C8C8C',
  25: '#BFBFBF',
  15: '#D9D9D9',
  6: '#F0F0F0'
};
var BLACK_COLORS = {
  100: '#FFFFFF',
  95: '#F2F2F2',
  85: '#D9D9D9',
  65: '#A6A6A6',
  45: '#737373',
  25: '#404040',
  15: '#262626',
  6: '#0F0F0F'
};
var QUALITATIVE_10 = ['#5B8FF9', '#5AD8A6', '#5D7092', '#F6BD16', '#E86452', '#6DC8EC', '#945FB9', '#FF9845', '#1E9493', '#FF99C3'];
var QUALITATIVE_20 = ['#5B8FF9', '#CDDDFD', '#5AD8A6', '#CDF3E4', '#5D7092', '#CED4DE', '#F6BD16', '#FCEBB9', '#E86452', '#F8D0CB', '#6DC8EC', '#D3EEF9', '#945FB9', '#DECFEA', '#FF9845', '#FFE0C7', '#1E9493', '#BBDEDE', '#FF99C3', '#FFE0ED'];

exports.createDarkStyleSheet = function (cfg) {
  if (cfg === void 0) {
    cfg = {};
  }

  var _a = cfg.backgroundColor,
      backgroundColor = _a === void 0 ? '#141414' : _a,
      _b = cfg.paletteQualitative10,
      paletteQualitative10 = _b === void 0 ? QUALITATIVE_10 : _b,
      _c = cfg.paletteQualitative20,
      paletteQualitative20 = _c === void 0 ? QUALITATIVE_20 : _c,
      _d = cfg.paletteSemanticRed,
      paletteSemanticRed = _d === void 0 ? '#F4664A' : _d,
      _e = cfg.paletteSemanticGreen,
      paletteSemanticGreen = _e === void 0 ? '#30BF78' : _e,
      _f = cfg.paletteSemanticYellow,
      paletteSemanticYellow = _f === void 0 ? '#FAAD14' : _f,
      _g = cfg.fontFamily,
      fontFamily = _g === void 0 ? "\"-apple-system\", \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial,\n    \"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n    \"Noto Color Emoji\"" : _g;
  var _h = cfg.brandColor,
      brandColor = _h === void 0 ? paletteQualitative10[0] : _h;
  return {
    /**  */
    backgroundColor: backgroundColor,

    /**  */
    brandColor: brandColor,

    /**  1 10  */
    paletteQualitative10: paletteQualitative10,

    /**  2 10  */
    paletteQualitative20: paletteQualitative20,

    /**  */
    paletteSemanticRed: paletteSemanticRed,

    /**  */
    paletteSemanticGreen: paletteSemanticGreen,

    /**  */
    paletteSemanticYellow: paletteSemanticYellow,

    /**  */
    fontFamily: fontFamily,
    // --------------------  --------------------

    /**  */
    axisLineBorderColor: BLACK_COLORS[25],

    /**  */
    axisLineBorder: 1,

    /**  lineDash  */
    axisLineDash: null,

    /**  */
    axisTitleTextFillColor: BLACK_COLORS[65],

    /**  */
    axisTitleTextFontSize: 12,

    /**  */
    axisTitleTextLineHeight: 12,

    /**  */
    axisTitleTextFontWeight: 'normal',

    /**  */
    axisTitleSpacing: 12,

    /**  */
    axisTickLineBorderColor: BLACK_COLORS[25],

    /**  */
    axisTickLineLength: 4,

    /**  */
    axisTickLineBorder: 1,

    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS[15],

    /**  */
    axisSubTickLineLength: 2,

    /**  */
    axisSubTickLineBorder: 1,

    /**  */
    axisLabelFillColor: BLACK_COLORS[45],

    /**  */
    axisLabelFontSize: 12,

    /**  */
    axisLabelLineHeight: 12,

    /**  */
    axisLabelFontWeight: 'normal',

    /**  */
    axisLabelOffset: 8,

    /**  */
    axisGridBorderColor: BLACK_COLORS[15],

    /**  */
    axisGridBorder: 1,

    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------

    /**  */
    legendTitleTextFillColor: BLACK_COLORS[45],

    /**  */
    legendTitleTextFontSize: 12,

    /**  */
    legendTitleTextLineHeight: 21,

    /**  */
    legendTitleTextFontWeight: 'normal',

    /**  marker  */
    legendMarkerColor: QUALITATIVE_10[0],

    /**  marker  */
    legendMarkerSpacing: 8,

    /**  marker  */
    legendMarkerSize: 4,

    /**  'circle' marker  */
    legendCircleMarkerSize: 4,

    /**  'square' marker  */
    legendSquareMarkerSize: 4,

    /**  'line' marker  */
    legendLineMarkerSize: 5,

    /**  */
    legendItemNameFillColor: BLACK_COLORS[65],

    /**  */
    legendItemNameFontSize: 12,

    /**  */
    legendItemNameLineHeight: 12,

    /**  */
    legendItemNameFontWeight: 'normal',

    /**  */
    legendItemSpacing: 24,

    /**  */
    legendItemMarginBottom: 12,

    /**   */
    legendSpacing: 16,

    /**   */
    legendPadding: [8, 8, 8, 8],

    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],

    /**  */
    legendVerticalPadding: [0, 8, 0, 8],

    /**  */
    sliderRailFillColor: BLACK_COLORS[15],

    /**  */
    sliderRailBorder: 0,

    /**  */
    sliderRailBorderColor: null,

    /**  */
    sliderRailWidth: 100,

    /**  */
    sliderRailHeight: 12,

    /**  */
    sliderLabelTextFillColor: BLACK_COLORS[45],

    /**  */
    sliderLabelTextFontSize: 12,

    /**  */
    sliderLabelTextLineHeight: 12,

    /**  */
    sliderLabelTextFontWeight: 'normal',

    /**  */
    sliderHandlerFillColor: WHITE_COLORS[6],

    /**  */
    sliderHandlerWidth: 10,

    /**  */
    sliderHandlerHeight: 14,

    /**  */
    sliderHandlerBorder: 1,

    /**  */
    sliderHandlerBorderColor: WHITE_COLORS[25],
    // -------------------- Annotation --------------------

    /** arc  */
    annotationArcBorderColor: BLACK_COLORS[15],

    /** arc  */
    annotationArcBorder: 1,

    /** line  */
    annotationLineBorderColor: BLACK_COLORS[25],

    /** line  */
    annotationLineBorder: 1,

    /** lube  */
    annotationLineDash: null,

    /** text  */
    annotationTextFillColor: BLACK_COLORS[65],

    /** text  */
    annotationTextFontSize: 12,

    /** text  */
    annotationTextLineHeight: 12,

    /** text  */
    annotationTextFontWeight: 'normal',

    /** text  */
    annotationTextBorderColor: null,

    /** text  */
    annotationTextBorder: 0,

    /** region  */
    annotationRegionFillColor: BLACK_COLORS[100],

    /** region  */
    annotationRegionFillOpacity: 0.06,

    /** region  */
    annotationRegionBorder: 0,

    /** region  */
    annotationRegionBorderColor: null,

    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------

    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],

    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,

    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,

    /** tooltip  */
    tooltipContainerFillColor: '#1f1f1f',
    tooltipContainerFillOpacity: 0.95,

    /** tooltip  */
    tooltipContainerShadow: '0px 2px 4px rgba(0,0,0,.5)',

    /** tooltip  */
    tooltipContainerBorderRadius: 3,

    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS[65],

    /** tooltip  */
    tooltipTextFontSize: 12,

    /** tooltip  */
    tooltipTextLineHeight: 12,

    /** tooltip  */
    tooltipTextFontWeight: 'bold',
    // -------------------- Geometry labels --------------------

    /** Geometry label  */
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: '#2c3542',
    labelFillColorLight: '#ffffff',

    /** Geometry label  */
    labelFontSize: 12,

    /** Geometry label  */
    labelLineHeight: 12,

    /** Geometry label  */
    labelFontWeight: 'normal',

    /** Geometry label  */
    labelBorderColor: null,

    /** Geometry label  */
    labelBorder: 0,

    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS[100],

    /** Geometry innerLabel  */
    innerLabelFontSize: 12,

    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,

    /** Geometry innerLabel  */
    innerLabelFontWeight: 'normal',

    /** Geometry innerLabel  */
    innerLabelBorderColor: null,

    /** Geometry innerLabel  */
    innerLabelBorder: 0,

    /** Geometry label  */
    overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFillColorDark: '#2c3542',
    overflowLabelFillColorLight: '#ffffff',

    /** Geometry label  */
    overflowLabelFontSize: 12,

    /** Geometry label  */
    overflowLabelLineHeight: 12,

    /** Geometry label  */
    overflowLabelFontWeight: 'normal',

    /** Geometry label  */
    overflowLabelBorderColor: WHITE_COLORS[100],

    /** Geometry label  */
    overflowLabelBorder: 1,

    /** Geometry label */
    labelLineBorder: 1,

    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS[25],
    // -------------------- Geometry --------------------

    /**  */
    pointFillColor: QUALITATIVE_10[0],

    /**  */
    pointFillOpacity: 0.95,

    /**  */
    pointSize: 4,

    /**  */
    pointBorder: 1,

    /**  */
    pointBorderColor: WHITE_COLORS[100],

    /**  */
    pointBorderOpacity: 1,

    /**  active  */
    pointActiveBorderColor: BLACK_COLORS[100],

    /**  selected  */
    pointSelectedBorder: 2,

    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS[100],

    /**  inactive  */
    pointInactiveFillOpacity: 0.3,

    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,

    /**  */
    hollowPointSize: 4,

    /**  */
    hollowPointBorder: 1,

    /**  */
    hollowPointBorderColor: QUALITATIVE_10[0],

    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],

    /**  active  */
    hollowPointActiveBorder: 1,

    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS[100],

    /**  active  */
    hollowPointActiveBorderOpacity: 1,

    /**  selected  */
    hollowPointSelectedBorder: 2,

    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS[100],

    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,

    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,

    /**  */
    lineBorder: 2,

    /**  */
    lineBorderColor: QUALITATIVE_10[0],

    /**  */
    lineBorderOpacity: 1,

    /**  Active  */
    lineActiveBorder: 3,

    /**  selected  */
    lineSelectedBorder: 3,

    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,

    /** area  */
    areaFillColor: QUALITATIVE_10[0],

    /** area  */
    areaFillOpacity: 0.25,

    /** area  active  */
    areaActiveFillColor: QUALITATIVE_10[0],
    areaActiveFillOpacity: 0.5,

    /** area  selected  */
    areaSelectedFillColor: QUALITATIVE_10[0],
    areaSelectedFillOpacity: 0.5,

    /** area inactive  */
    areaInactiveFillOpacity: 0.3,

    /** hollowArea  */
    hollowAreaBorderColor: QUALITATIVE_10[0],

    /** hollowArea  */
    hollowAreaBorder: 2,

    /** hollowArea  */
    hollowAreaBorderOpacity: 1,

    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],

    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],

    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,

    /** interval  */
    intervalFillColor: QUALITATIVE_10[0],

    /** interval  */
    intervalFillOpacity: 0.95,

    /** interval active  */
    intervalActiveBorder: 1,

    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,

    /** interval selected  */
    intervalSelectedBorder: 2,

    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS[100],

    /** interval selected  */
    intervalSelectedBorderOpacity: 1,

    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,

    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,

    /** interval  */
    hollowIntervalBorder: 2,

    /** hollowInterval  */
    hollowIntervalBorderColor: QUALITATIVE_10[0],

    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],

    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,

    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],

    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,

    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],

    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,

    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
};

exports.antvDark = exports.createDarkStyleSheet();

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(99));
/**
 *  label
 */


var IntervalLabel =
/** @class */
function (_super) {
  tslib_1.__extends(IntervalLabel, _super);

  function IntervalLabel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   *  interval label  value 
   * @param labelCfg
   */


  IntervalLabel.prototype.getLabelValueDir = function (mappingData) {
    // points  x/y  transpose 
    var dim = 'y';
    var points = mappingData.points;
    return points[0][dim] <= points[2][dim] ? 1 : -1;
  };
  /**
   *  interval  label 
   * @param labelCfg
   * @param index
   * @param total
   */


  IntervalLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {
    var _a;

    var point = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index, total);

    var transposed = this.getCoordinate().isTransposed;
    var dim = transposed ? 'x' : 'y';
    var dir = this.getLabelValueDir(labelCfg.mappingData);
    return tslib_1.__assign(tslib_1.__assign({}, point), (_a = {}, _a[dim] = point[dim] * dir, _a));
  };
  /**
   *  interval label 
   * @param labelCfg
   */


  IntervalLabel.prototype.getThemedLabelCfg = function (labelCfg) {
    var geometry = this.geometry;
    var defaultLabelCfg = this.getDefaultLabelCfg();
    var theme = geometry.theme; //  interval label position  middle offset  0

    return util_1.deepMix({}, defaultLabelCfg, theme.labels, labelCfg.position === 'middle' ? {
      offset: 0
    } : {}, labelCfg);
  };

  IntervalLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {
    var coordinate = this.getCoordinate();
    var transposed = coordinate.isTransposed;
    var shapePoints = mappingData.points;
    var point0 = coordinate.convert(shapePoints[0]);
    var point2 = coordinate.convert(shapePoints[2]);
    var dir = this.getLabelValueDir(mappingData);
    var top;
    var right;
    var bottom;
    var left;
    var shape = util_1.isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;

    if (shape === 'funnel' || shape === 'pyramid') {
      // 
      var nextPoints = util_1.get(mappingData, 'nextPoints');
      var points = util_1.get(mappingData, 'points');

      if (nextPoints) {
        // 
        var p0 = coordinate.convert(points[0]);
        var p1 = coordinate.convert(points[1]);
        var nextP0 = coordinate.convert(nextPoints[0]);
        var nextP1 = coordinate.convert(nextPoints[1]); // TODO: 

        if (transposed) {
          top = Math.min(nextP0.y, p0.y);
          bottom = Math.max(nextP0.y, p0.y);
          right = (p1.x + nextP1.x) / 2;
          left = (p0.x + nextP0.x) / 2;
        } else {
          top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
          right = nextP1.x;
          left = p0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right = point2.x;
        left = point0.x;
      }
    } else {
      top = Math.min(point2.y, point0.y);
      bottom = Math.max(point2.y, point0.y);
      right = point2.x;
      left = point0.x;
    }

    switch (position) {
      case 'right':
        labelPointCfg.x = right;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
        break;

      case 'left':
        labelPointCfg.x = left;
        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', dir > 0 ? 'left' : 'right');
        break;

      case 'bottom':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }

        labelPointCfg.y = bottom;
        labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
        break;

      case 'middle':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }

        labelPointCfg.y = (top + bottom) / 2;
        labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', 'middle');
        break;

      case 'top':
        if (transposed) {
          labelPointCfg.x = (right + left) / 2;
        }

        labelPointCfg.y = top;
        labelPointCfg.textAlign = util_1.get(labelPointCfg, 'textAlign', 'center');
        labelPointCfg.textBaseline = util_1.get(labelPointCfg, 'textBaseline', dir > 0 ? 'bottom' : 'top');
        break;

      default:
        break;
    }
  };

  return IntervalLabel;
}(base_1.default);

exports.default = IntervalLabel;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51);

var graphics_1 = __webpack_require__(45);

var polar_1 = tslib_1.__importDefault(__webpack_require__(212));
/**
 *  label
 */


var PieLabel =
/** @class */
function (_super) {
  tslib_1.__extends(PieLabel, _super);

  function PieLabel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.defaultLayout = 'distribute';
    return _this;
  }

  PieLabel.prototype.getDefaultLabelCfg = function (offset, position) {
    var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);

    return util_1.deepMix({}, cfg, util_1.get(this.geometry.theme, 'pieLabels', {}));
  };
  /** @override */


  PieLabel.prototype.getLabelOffset = function (offset) {
    return _super.prototype.getLabelOffset.call(this, offset) || 0;
  };

  PieLabel.prototype.getLabelRotate = function (angle, offset, isLabelLimit) {
    var rotate;

    if (offset < 0) {
      rotate = angle;

      if (rotate > Math.PI / 2) {
        rotate = rotate - Math.PI;
      }

      if (rotate < -Math.PI / 2) {
        rotate = rotate + Math.PI;
      }
    }

    return rotate;
  };

  PieLabel.prototype.getLabelAlign = function (point) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var align;

    if (point.angle <= Math.PI / 2 && point.x >= center.x) {
      align = 'left';
    } else {
      align = 'right';
    }

    if (point.offset <= 0) {
      if (align === 'right') {
        align = 'left';
      } else {
        align = 'right';
      }
    }

    return align;
  };

  PieLabel.prototype.getArcPoint = function (point) {
    return point;
  };

  PieLabel.prototype.getPointAngle = function (point) {
    var coordinate = this.getCoordinate();
    var startPoint = {
      x: util_1.isArray(point.x) ? point.x[0] : point.x,
      y: point.y[0]
    };
    var endPoint = {
      x: util_1.isArray(point.x) ? point.x[1] : point.x,
      y: point.y[1]
    };
    var angle;
    var startAngle = coordinate_1.getAngleByPoint(coordinate, startPoint);

    if (point.points && point.points[0].y === point.points[1].y) {
      angle = startAngle;
    } else {
      var endAngle = coordinate_1.getAngleByPoint(coordinate, endPoint);

      if (startAngle >= endAngle) {
        // 100% pie slice
        endAngle = endAngle + Math.PI * 2;
      }

      angle = startAngle + (endAngle - startAngle) / 2;
    }

    return angle;
  };
  /** @override */


  PieLabel.prototype.getCirclePoint = function (angle, offset) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = coordinate.getRadius() + offset;
    return tslib_1.__assign(tslib_1.__assign({}, graphics_1.polarToCartesian(center.x, center.y, r, angle)), {
      angle: angle,
      r: r
    });
  };

  return PieLabel;
}(polar_1.default);

exports.default = PieLabel;

/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return visibleHelper; });
/* unused harmony export visibleHelperInvert */
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(593);
/* harmony import */ var _antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(62);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4__);




 // plot visible 

var visibleHelper = function visibleHelper(cfg) {
  var defaultVisible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (_antv_util_lib_is_string__WEBPACK_IMPORTED_MODULE_2___default()(cfg) || /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(cfg)) {
    return {
      visible: true,
      text: cfg
    };
  }

  if (_antv_util_lib_is_boolean__WEBPACK_IMPORTED_MODULE_3___default()(cfg)) {
    return {
      visible: cfg
    };
  }

  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default()(cfg)) {
    return object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
      visible: true
    }, cfg);
  }

  return {
    visible: defaultVisible
  };
};
var visibleHelperInvert = function visibleHelperInvert(cfg) {
  // @ts-ignore
  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_4___default()(cfg) && cfg.visible !== false) {
    // @ts-ignore
    return cfg.text;
  }

  return cfg;
};

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Connector */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return registerConnector; });
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(202);
/* harmony import */ var _antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(127);
/* harmony import */ var _antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

// todo: 




var CONNECTOR_MAP = {};
var Connector = /*#__PURE__*/function () {
  function Connector(type) {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, Connector);

    this.cfg = {
      shared: true
    };
    this.chartMap = {};
    this.state = {};
    this.id = Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["uniqueId"])('bx-action');
    this.type = type || 'tooltip';
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(Connector, [{
    key: "connect",
    value: function connect(id, chart, pointFinder) {
      this.chartMap[id] = {
        chart: chart,
        pointFinder: pointFinder
      };
      chart.interaction("connect-".concat(this.type, "-").concat(this.id));

      if (this.type === 'tooltip' && this.cfg.shared) {
        if (Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["get"])(chart, ['options', 'tooltip', 'shared']) === undefined) {
          Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["set"])(chart, ['options', 'tooltip', 'shared'], true);
        }

        ;
      }

      return this;
    }
  }, {
    key: "unConnect",
    value: function unConnect(id) {
      this.chartMap[id].chart.removeInteraction("connect-".concat(this.type, "-").concat(this.id));
      delete this.chartMap[id];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      Object(_antv_g2_lib_interaction_action_register__WEBPACK_IMPORTED_MODULE_5__["unregisterAction"])("connect-".concat(this.type, "-").concat(this.id));
    }
  }]);

  return Connector;
}(); // tooltip

var createTooltipConnector = function createTooltipConnector() {
  var cm = new Connector('tooltip');
  Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerAction"])("connect-tooltip-".concat(cm.id), /*#__PURE__*/function (_TooltipAction) {
    _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_0___default()(ConnectTooltip, _TooltipAction);

    var _super = _createSuper(ConnectTooltip);

    function ConnectTooltip() {
      var _this;

      _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_3___default()(this, ConnectTooltip);

      _this = _super.apply(this, arguments);
      _this.CM = cm;
      return _this;
    }

    _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_4___default()(ConnectTooltip, [{
      key: "showTooltip",
      value: function showTooltip(view, point) {
        var records = view.getTooltipItems(point) || point;
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["forIn"])(this.CM.chartMap, function (item) {
          var chart = item.chart,
              pointFinder = item.pointFinder;

          if (chart.destroyed || !chart.visible) {
            return;
          }

          if (pointFinder) {
            var triggerPoint = pointFinder(records, chart); // 

            if (triggerPoint) {
              chart.showTooltip(triggerPoint);
            }

            ;
          } else {
            chart.showTooltip(point);
          }
        });
      }
    }, {
      key: "hideTooltip",
      value: function hideTooltip() {
        Object(_antv_util__WEBPACK_IMPORTED_MODULE_7__["forIn"])(this.CM.chartMap, function (_ref) {
          var chart = _ref.chart;
          return chart.hideTooltip();
        });
      }
    }]);

    return ConnectTooltip;
  }(_antv_g2_lib_interaction_action_component_tooltip_geometry__WEBPACK_IMPORTED_MODULE_6___default.a));
  Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerInteraction"])("connect-tooltip-".concat(cm.id), {
    start: [{
      trigger: 'plot:mousemove',
      action: "connect-tooltip-".concat(cm.id, ":show")
    }],
    end: [{
      trigger: 'plot:mouseleave',
      action: "connect-tooltip-".concat(cm.id, ":hide")
    }]
  });
  return cm;
};

var registerConnector = function registerConnector(cid, tid, chart, shared, pointFinder) {
  var connector = CONNECTOR_MAP[cid]; // 

  if (chart === null && connector) {
    connector.unConnect(tid);
    return;
  } //  & 


  if (connector) {
    connector.connect(tid, chart, pointFinder);
  } else {
    CONNECTOR_MAP[cid] = createTooltipConnector(); // shared false sharedtooltip

    CONNECTOR_MAP[cid].cfg.shared = !!shared;
    CONNECTOR_MAP[cid].connect(tid, chart, pointFinder);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (createTooltipConnector);

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.growInXY = exports.growInY = exports.growInX = void 0;

var util_1 = __webpack_require__(907);
/**
 * @ignore
 * 
 * x 
 * @param element 
 * @param animateCfg 
 * @param cfg 
 */


function growInX(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
      minYPoint = cfg.minYPoint;
  util_1.doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'x');
}

exports.growInX = growInX;
/**
 * @ignore
 * 
 * y 
 * @param element 
 * @param animateCfg 
 * @param cfg 
 */

function growInY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
      minYPoint = cfg.minYPoint;
  util_1.doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'y');
}

exports.growInY = growInY;
/**
 * @ignore
 * 
 * 
 * @param element 
 * @param animateCfg 
 * @param cfg 
 */

function growInXY(element, animateCfg, cfg) {
  var coordinate = cfg.coordinate,
      minYPoint = cfg.minYPoint;
  util_1.doScaleAnimate(element, animateCfg, coordinate, minYPoint, 'xy');
}

exports.growInXY = growInXY;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_array_1 = __webpack_require__(22);

var is_plain_object_1 = __webpack_require__(989);

var MAX_MIX_LEVEL = 5;

function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;

  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];

      if (value !== null && is_plain_object_1.default(value)) {
        if (!is_plain_object_1.default(dist[key])) {
          dist[key] = {};
        }

        if (level < maxLevel) {
          _deepMix(dist[key], value, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if (is_array_1.default(value)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value);
      } else if (value !== undefined) {
        dist[key] = value;
      }
    }
  }
} // todo 


var deepMix = function deepMix(rst) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }

  return rst;
};

exports.default = deepMix;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var contains = function contains(arr, value) {
  if (!(0, _isArrayLike.default)(arr)) {
    return false;
  }

  return arr.indexOf(value) > -1;
};

var _default = contains;
exports.default = _default;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _default = function _default(value) {
  /**
   * isObject({}) => true
   * isObject([1, 2, 3]) => true
   * isObject(Function) => true
   * isObject(null) => false
   */
  var type = (0, _typeof2.default)(value);
  return value !== null && type === 'object' || type === 'function';
};

exports.default = _default;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.length = length;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.hermite = hermite;
exports.bezier = bezier;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformMat3 = transformMat3;
exports.transformQuat = transformQuat;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(3);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */


function fromValues(x, y, z) {
  var out = new glMatrix.ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */


function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */


function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  var z = glMatrix.RANDOM() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */


function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */


function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

exports.forEach = forEach;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b = +b, function (t) {
    return a * (1 - t) + b * t;
  };
}

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(86);

var vec2 = _interopRequireWildcard(__webpack_require__(386));

var _default = {
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {object} 
   */
  box: function box(x1, y1, x2, y2) {
    return (0, _util.getBBoxByArray)([x1, x2], [y1, y2]);
  },

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  length: function length(x1, y1, x2, y2) {
    return (0, _util.distance)(x1, y1, x2, y2);
  },

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} t 
   * @return {object}  x, y 
   */
  pointAt: function pointAt(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointDistance: function pointDistance(x1, y1, x2, y2, x, y) {
    //  x1, y1  p, p1, p2  a
    // p1a = p1p.p1p2/|p1p2| * (p1p )
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);

    if (cross < 0) {
      return (0, _util.distance)(x1, y1, x, y);
    }

    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);

    if (cross > lengthSquare) {
      return (0, _util.distance)(x2, y2, x, y);
    }

    return this.pointToLine(x1, y1, x2, y2, x, y);
  },

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointToLine: function pointToLine(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1]; // 

    if (vec2.exactEquals(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }

    var u = [-d[1], d[0]];
    vec2.normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(vec2.dot(a, u));
  },

  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  tangentAngle: function tangentAngle(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
exports.default = _default;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;

var isGradientColor = function isGradientColor(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
}; //  tag 


var createTmp = function createTmp() {
  var i = document.createElement('i');
  i.title = 'Web Colour Picker';
  i.style.display = 'none';
  document.body.appendChild(i);
  return i;
}; // 


var getValue = function getValue(start, end, percent, index) {
  return start[index] + (end[index] - start[index]) * percent;
}; // 


function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
} // rgb 


var rgb2arr = function rgb2arr(str) {
  return [parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16)];
}; //  0-255 16


var toHex = function toHex(value) {
  var x16Value = Math.round(value).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
}; // 


var calColor = function calColor(points, percent) {
  var fixedPercent = isNaN(Number(percent)) || percent < 0 ? 0 : percent > 1 ? 1 : Number(percent);
  var steps = points.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left = steps * fixedPercent - step;
  var start = points[step];
  var end = step === steps ? start : points[step + 1];
  return arr2rgb([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);
}; //  toRGB  memoize 
// const colorCache = {};


var iEl;
/**
 *  rgb 
 * @param {color} color 
 * @return  '#ffffff' 
 */

var toRGB = function toRGB(color) {
  //  rgb
  if (color[0] === '#' && color.length === 7) {
    return color;
  }

  if (!iEl) {
    // 
    iEl = createTmp();
  }

  iEl.style.color = color;
  var rst = document.defaultView.getComputedStyle(iEl, '').getPropertyValue('color');
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function (s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
/**
 * 
 * @param colors 
 * @return 
 */


var gradient = function gradient(colors) {
  var colorArray = (0, _util.isString)(colors) ? colors.split('-') : colors;
  var points = (0, _util.map)(colorArray, function (color) {
    return rgb2arr(color.indexOf('#') === -1 ? toRGB(color) : color);
  }); // 

  return function (percent) {
    return calColor(points, percent);
  };
};

var toCSSGradient = function toCSSGradient(gradientColor) {
  if (isGradientColor(gradientColor)) {
    var cssColor_1;
    var steps = void 0;

    if (gradientColor[0] === 'l') {
      // 
      var arr = regexLG.exec(gradientColor);
      var angle = +arr[1] + 90; // css  g 

      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle + "deg, ";
    } else if (gradientColor[0] === 'r') {
      // 
      cssColor_1 = 'radial-gradient(';
      var arr = regexRG.exec(gradientColor);
      steps = arr[4];
    }

    var colorStops_1 = steps.match(regexColorStop);
    (0, _util.each)(colorStops_1, function (item, index) {
      var itemArr = item.split(':');
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";

      if (index !== colorStops_1.length - 1) {
        cssColor_1 += ', ';
      }
    });
    cssColor_1 += ')';
    return cssColor_1;
  }

  return gradientColor;
};

var _default = {
  rgb2arr: rgb2arr,
  gradient: gradient,
  toRGB: (0, _util.memoize)(toRGB),
  toCSSGradient: toCSSGradient
};
exports.default = _default;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.timeFormat = timeFormat;
exports.toTimeStamp = toTimeStamp;
exports.getTickInterval = getTickInterval;
exports.YEAR = exports.MONTH = exports.DAY = exports.HOUR = exports.MINUTE = exports.SECOND = void 0;

var _util = __webpack_require__(0);

var fecha1 = _interopRequireWildcard(__webpack_require__(778));

var _bisector = _interopRequireDefault(__webpack_require__(779));

var FORMAT_METHOD = 'format';

function timeFormat(time, mask) {
  var method = fecha1[FORMAT_METHOD] || fecha1.default[FORMAT_METHOD];
  return method(time, mask);
}
/**
 * 
 * @param value 
 */


function toTimeStamp(value) {
  if ((0, _util.isString)(value)) {
    if (value.indexOf('T') > 0) {
      value = new Date(value).getTime();
    } else {
      // new Date('2010/01/10')  new Date('2010-01-10') :
      // : Fri Jan 10 2020 02:40:13 GMT+0800 ()
      //  Sun Jan 10 2010 08:00:00 GMT+0800 ()
      value = new Date(value.replace(/-/gi, '/')).getTime();
    }
  }

  if ((0, _util.isDate)(value)) {
    value = value.getTime();
  }

  return value;
}

var SECOND = 1000;
exports.SECOND = SECOND;
var MINUTE = 60 * SECOND;
exports.MINUTE = MINUTE;
var HOUR = 60 * MINUTE;
exports.HOUR = HOUR;
var DAY = 24 * HOUR;
exports.DAY = DAY;
var MONTH = DAY * 31;
exports.MONTH = MONTH;
var YEAR = DAY * 365;
exports.YEAR = YEAR;
var intervals = [['HH:mm:ss', SECOND], ['HH:mm:ss', SECOND * 10], ['HH:mm:ss', SECOND * 30], ['HH:mm', MINUTE], ['HH:mm', MINUTE * 10], ['HH:mm', MINUTE * 30], ['HH', HOUR], ['HH', HOUR * 6], ['HH', HOUR * 12], ['YYYY-MM-DD', DAY], ['YYYY-MM-DD', DAY * 4], ['YYYY-WW', DAY * 7], ['YYYY-MM', MONTH], ['YYYY-MM', MONTH * 4], ['YYYY-MM', MONTH * 6], ['YYYY', DAY * 380]];

function getTickInterval(min, max, tickCount) {
  var target = (max - min) / tickCount;
  var idx = (0, _bisector.default)(function (o) {
    return o[1];
  })(intervals, target) - 1;
  var interval = intervals[idx];

  if (idx < 0) {
    interval = intervals[0];
  } else if (idx >= intervals.length) {
    interval = (0, _util.last)(intervals);
  }

  return interval;
}

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(139));

/**
 * 
 * @class
 */
var Continuous =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Continuous, _super);

  function Continuous() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.isContinuous = true;
    return _this;
  }

  Continuous.prototype.scale = function (value) {
    if ((0, _util.isNil)(value)) {
      return NaN;
    }

    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max = this.max;
    var min = this.min;

    if (max === min) {
      return rangeMin;
    }

    var percent = this.getScalePercent(value);
    return rangeMin + percent * (rangeMax - rangeMin);
  };

  Continuous.prototype.init = function () {
    _super.prototype.init.call(this); // init  min, max  ticks 


    var ticks = this.ticks;
    var firstTick = (0, _util.head)(ticks);
    var lastTick = (0, _util.last)(ticks);

    if (firstTick < this.min) {
      this.min = firstTick;
    }

    if (lastTick > this.max) {
      this.max = lastTick;
    } // strict-limit 


    if (!(0, _util.isNil)(this.minLimit)) {
      this.min = firstTick;
    }

    if (!(0, _util.isNil)(this.maxLimit)) {
      this.max = lastTick;
    }
  };

  Continuous.prototype.setDomain = function () {
    var _a = (0, _util.getRange)(this.values),
        min = _a.min,
        max = _a.max;

    if ((0, _util.isNil)(this.min)) {
      this.min = min;
    }

    if ((0, _util.isNil)(this.max)) {
      this.max = max;
    }

    if (this.min > this.max) {
      this.min = min;
      this.max = max;
    }
  };

  Continuous.prototype.calculateTicks = function () {
    var _this = this;

    var ticks = _super.prototype.calculateTicks.call(this);

    if (!this.nice) {
      ticks = (0, _util.filter)(ticks, function (tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }

    return ticks;
  }; // 


  Continuous.prototype.getScalePercent = function (value) {
    var max = this.max;
    var min = this.min;
    return (value - min) / (max - min);
  };

  Continuous.prototype.getInvertPercent = function (value) {
    return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };

  return Continuous;
}(_base.default);

var _default = Continuous;
exports.default = _default;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calBase = calBase;
exports.log = log;
exports.getLogPositiveMin = getLogPositiveMin;

var _util = __webpack_require__(0);

// ab x^^a = b;x
//  b  
function calBase(a, b) {
  var e = Math.E;
  var value;

  if (b >= 0) {
    value = Math.pow(e, Math.log(b) / a); // 
  } else {
    value = Math.pow(e, Math.log(-b) / a) * -1; // 
  }

  return value;
}

function log(a, b) {
  if (a === 1) {
    return 1;
  }

  return Math.log(b) / Math.log(a);
}

function getLogPositiveMin(values, base, max) {
  if ((0, _util.isNil)(max)) {
    max = Math.max.apply(null, values);
  }

  var positiveMin = max;
  (0, _util.each)(values, function (value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });

  if (positiveMin === max) {
    positiveMin = max / base;
  }

  if (positiveMin > 1) {
    positiveMin = 1;
  }

  return positiveMin;
}

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _matrixUtil = __webpack_require__(33);

var _util = __webpack_require__(0);

/**
 * Coordinate Base Class
 */
var Coordinate =
/** @class */
function () {
  function Coordinate(cfg) {
    // 
    this.type = 'coordinate';
    this.isRect = false;
    this.isHelix = false;
    this.isPolar = false;
    this.isReflectX = false;
    this.isReflectY = false;
    var start = cfg.start,
        end = cfg.end,
        _a = cfg.matrix,
        matrix = _a === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a,
        _b = cfg.isTransposed,
        isTransposed = _b === void 0 ? false : _b;
    this.start = start;
    this.end = end;
    this.matrix = matrix;
    this.originalMatrix = (0, _tslib.__spreadArrays)(matrix); // 

    this.isTransposed = isTransposed;
  }
  /**
   * 
   */


  Coordinate.prototype.initial = function () {
    // centerwidthheight
    this.center = {
      x: (this.start.x + this.end.x) / 2,
      y: (this.start.y + this.end.y) / 2
    };
    this.width = Math.abs(this.end.x - this.start.x);
    this.height = Math.abs(this.end.y - this.start.y);
  };
  /**
   * 
   * @param cfg
   */


  Coordinate.prototype.update = function (cfg) {
    (0, _util.assign)(this, cfg);
    this.initial();
  };

  Coordinate.prototype.convertDim = function (percent, dim) {
    var _a;

    var _b = this[dim],
        start = _b.start,
        end = _b.end; // 

    if (this.isReflect(dim)) {
      _a = [end, start], start = _a[0], end = _a[1];
    }

    return start + percent * (end - start);
  };

  Coordinate.prototype.invertDim = function (value, dim) {
    var _a;

    var _b = this[dim],
        start = _b.start,
        end = _b.end; // 

    if (this.isReflect(dim)) {
      _a = [end, start], start = _a[0], end = _a[1];
    }

    return (value - start) / (end - start);
  };
  /**
   * 
   * @param x    x 
   * @param y    y 
   * @param tag  0 0, 1
   * @return     [x, y, z]
   */


  Coordinate.prototype.applyMatrix = function (x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }

    var matrix = this.matrix;
    var vector = [x, y, tag];

    _matrixUtil.vec3.transformMat3(vector, vector, matrix);

    return vector;
  };
  /**
   * 
   * @param x    x 
   * @param y    y 
   * @param tag  0 0, 1
   * @return     [x, y, z]
   */


  Coordinate.prototype.invertMatrix = function (x, y, tag) {
    if (tag === void 0) {
      tag = 0;
    }

    var matrix = this.matrix;

    var inverted = _matrixUtil.mat3.invert([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);

    var vector = [x, y, tag];

    if (inverted) {
      // 
      _matrixUtil.vec3.transformMat3(vector, vector, inverted);
    }

    return vector;
  };
  /**
   * 
   * @param point 
   * @return      
   */


  Coordinate.prototype.convert = function (point) {
    var _a = this.convertPoint(point),
        x = _a.x,
        y = _a.y;

    var vector = this.applyMatrix(x, y, 1);
    return {
      x: vector[0],
      y: vector[1]
    };
  };
  /**
   * 
   * @param point 
   * @return      
   */


  Coordinate.prototype.invert = function (point) {
    var vector = this.invertMatrix(point.x, point.y, 1);
    return this.invertPoint({
      x: vector[0],
      y: vector[1]
    });
  };
  /**
   * 
   * @param  radian 
   * @return        
   */


  Coordinate.prototype.rotate = function (radian) {
    var matrix = this.matrix;
    var center = this.center;

    _matrixUtil.ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);

    _matrixUtil.ext.leftRotate(matrix, matrix, radian);

    _matrixUtil.ext.leftTranslate(matrix, matrix, [center.x, center.y]);

    return this;
  };
  /**
   * 
   * @param dim 
   * @return    
   */


  Coordinate.prototype.reflect = function (dim) {
    if (dim === 'x') {
      this.isReflectX = !this.isReflectX;
    } else {
      this.isReflectY = !this.isReflectY;
    }

    return this;
  };
  /**
   * 
   * @param s1 x 
   * @param s2 y 
   * @return     
   */


  Coordinate.prototype.scale = function (s1, s2) {
    var matrix = this.matrix;
    var center = this.center;

    _matrixUtil.ext.leftTranslate(matrix, matrix, [-center.x, -center.y]);

    _matrixUtil.ext.leftScale(matrix, matrix, [s1, s2]);

    _matrixUtil.ext.leftTranslate(matrix, matrix, [center.x, center.y]);

    return this;
  };
  /**
   * 
   * @param x x 
   * @param y y 
   * @return    
   */


  Coordinate.prototype.translate = function (x, y) {
    var matrix = this.matrix;

    _matrixUtil.ext.leftTranslate(matrix, matrix, [x, y]);

    return this;
  };
  /**
   *  x y 
   * @return 
   */


  Coordinate.prototype.transpose = function () {
    this.isTransposed = !this.isTransposed;
    return this;
  };

  Coordinate.prototype.getCenter = function () {
    return this.center;
  };

  Coordinate.prototype.getWidth = function () {
    return this.width;
  };

  Coordinate.prototype.getHeight = function () {
    return this.height;
  };

  Coordinate.prototype.getRadius = function () {
    return this.radius;
  };
  /**
   * whether has reflect
   * @param dim
   */


  Coordinate.prototype.isReflect = function (dim) {
    return dim === 'x' ? this.isReflectX : this.isReflectY;
  };
  /**
   *  matrix
   * @param matrix  matrix
   */


  Coordinate.prototype.resetMatrix = function (matrix) {
    // 
    this.matrix = matrix ? matrix : (0, _tslib.__spreadArrays)(this.originalMatrix);
  };

  return Coordinate;
}();

var _default = Coordinate;
exports.default = _default;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Annotation: true,
  Axis: true,
  Crosshair: true,
  Grid: true,
  Legend: true,
  Tooltip: true,
  Component: true,
  GroupComponent: true,
  HtmlComponent: true,
  Slider: true,
  Scrollbar: true,
  propagationDelegate: true,
  TOOLTIP_CSS_CONST: true
};
Object.defineProperty(exports, "Component", {
  enumerable: true,
  get: function get() {
    return _component.default;
  }
});
Object.defineProperty(exports, "GroupComponent", {
  enumerable: true,
  get: function get() {
    return _groupComponent.default;
  }
});
Object.defineProperty(exports, "HtmlComponent", {
  enumerable: true,
  get: function get() {
    return _htmlComponent.default;
  }
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function get() {
    return _slider.Slider;
  }
});
Object.defineProperty(exports, "Scrollbar", {
  enumerable: true,
  get: function get() {
    return _scrollbar.Scrollbar;
  }
});
Object.defineProperty(exports, "propagationDelegate", {
  enumerable: true,
  get: function get() {
    return _event.propagationDelegate;
  }
});
exports.TOOLTIP_CSS_CONST = exports.Tooltip = exports.Legend = exports.Grid = exports.Crosshair = exports.Axis = exports.Annotation = void 0;

var Annotation = _interopRequireWildcard(__webpack_require__(802));

exports.Annotation = Annotation;

var Axis = _interopRequireWildcard(__webpack_require__(820));

exports.Axis = Axis;

var Crosshair = _interopRequireWildcard(__webpack_require__(827));

exports.Crosshair = Crosshair;

var Grid = _interopRequireWildcard(__webpack_require__(832));

exports.Grid = Grid;

var Legend = _interopRequireWildcard(__webpack_require__(835));

exports.Legend = Legend;

var Tooltip = _interopRequireWildcard(__webpack_require__(838));

exports.Tooltip = Tooltip;

var _component = _interopRequireDefault(__webpack_require__(252));

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _htmlComponent = _interopRequireDefault(__webpack_require__(186));

var _slider = __webpack_require__(842);

var _scrollbar = __webpack_require__(849);

var _interfaces = __webpack_require__(851);

Object.keys(_interfaces).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interfaces[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interfaces[key];
    }
  });
});

var _types = __webpack_require__(852);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _event = __webpack_require__(419);

var TOOLTIP_CSS_CONST = _interopRequireWildcard(__webpack_require__(257));

exports.TOOLTIP_CSS_CONST = TOOLTIP_CSS_CONST;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderTag = renderTag;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _label = __webpack_require__(140);

var _matrix = __webpack_require__(87);

var _util2 = __webpack_require__(44);

function renderTag(container, tagCfg) {
  var x = tagCfg.x,
      y = tagCfg.y,
      content = tagCfg.content,
      style = tagCfg.style,
      id = tagCfg.id,
      name = tagCfg.name,
      rotate = tagCfg.rotate,
      maxLength = tagCfg.maxLength,
      autoEllipsis = tagCfg.autoEllipsis,
      isVertical = tagCfg.isVertical,
      ellipsisPosition = tagCfg.ellipsisPosition,
      background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id + "-group",
    name: name + "-group",
    attrs: {
      x: x,
      y: y
    }
  }); // Text shape

  var text = tagGroup.addShape({
    type: 'text',
    id: id,
    name: name,
    attrs: (0, _tslib.__assign)({
      x: 0,
      y: 0,
      text: content
    }, style)
  }); // maxLength  background  padding 

  var padding = (0, _util2.formatPadding)((0, _util.get)(background, 'padding', 0));

  if (maxLength && autoEllipsis) {
    var maxTextLength = maxLength - (padding[1] + padding[3]); // 

    (0, _label.ellipsisLabel)(!isVertical, text, maxTextLength, ellipsisPosition);
  }

  if (background) {
    // 
    var backgroundStyle = (0, _util.get)(background, 'style', {});

    var _a = text.getCanvasBBox(),
        minX = _a.minX,
        minY = _a.minY,
        width = _a.width,
        height = _a.height;

    var tagBg = tagGroup.addShape('rect', {
      id: id + "-bg",
      name: id + "-bg",
      attrs: (0, _tslib.__assign)({
        x: minX - padding[3],
        y: minY - padding[0],
        width: width + padding[1] + padding[3],
        height: height + padding[0] + padding[2]
      }, backgroundStyle)
    });
    tagBg.toBack();
  }

  (0, _matrix.applyTranslate)(tagGroup, x, y);
  (0, _matrix.applyRotate)(tagGroup, rotate, x, y);
}

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _domUtil = __webpack_require__(112);

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(44);

var _component = _interopRequireDefault(__webpack_require__(252));

var HtmlComponent =
/** @class */
function (_super) {
  (0, _tslib.__extends)(HtmlComponent, _super);

  function HtmlComponent() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  HtmlComponent.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      container: null,
      containerTpl: '<div></div>',
      updateAutoRender: true,
      containerClassName: '',
      parent: null
    });
    return cfg;
  };

  HtmlComponent.prototype.getContainer = function () {
    return this.get('container');
  };
  /**
   * 
   */


  HtmlComponent.prototype.show = function () {
    var container = this.get('container');
    container.style.display = '';
    this.set('visible', true);
  };
  /**
   * 
   */


  HtmlComponent.prototype.hide = function () {
    var container = this.get('container');
    container.style.display = 'none';
    this.set('visible', false);
  };
  /**
   * 
   * @param capture 
   */


  HtmlComponent.prototype.setCapture = function (capture) {
    var container = this.getContainer();
    var value = capture ? 'auto' : 'none';
    container.style.pointerEvents = value;
    this.set('capture', capture);
  };

  HtmlComponent.prototype.getBBox = function () {
    var container = this.getContainer();
    var x = parseFloat(container.style.left) || 0;
    var y = parseFloat(container.style.top) || 0;
    return (0, _util2.createBBox)(x, y, container.clientWidth, container.clientHeight);
  };

  HtmlComponent.prototype.clear = function () {
    var container = this.get('container');
    (0, _util2.clearDom)(container);
  };

  HtmlComponent.prototype.destroy = function () {
    this.removeEvent();
    this.removeDom();

    _super.prototype.destroy.call(this);
  };
  /**
   *  init DOM 
   */


  HtmlComponent.prototype.init = function () {
    _super.prototype.init.call(this);

    this.initContainer();
    this.initDom();
    this.resetStyles(); // 

    this.applyStyles(); // 

    this.initEvent();
    this.initCapture();
    this.initVisible();
  };

  HtmlComponent.prototype.initCapture = function () {
    this.setCapture(this.get('capture'));
  };

  HtmlComponent.prototype.initVisible = function () {
    if (!this.get('visible')) {
      // 
      this.hide();
    } else {
      this.show();
    }
  };

  HtmlComponent.prototype.initDom = function () {};

  HtmlComponent.prototype.initContainer = function () {
    var container = this.get('container');

    if ((0, _util.isNil)(container)) {
      //  container 
      container = this.createDom();
      var parent_1 = this.get('parent');

      if ((0, _util.isString)(parent_1)) {
        parent_1 = document.getElementById(parent_1);
        this.set('parent', parent_1);
      }

      parent_1.appendChild(container);
      this.set('container', container);
    } else if ((0, _util.isString)(container)) {
      //  id,  container
      container = document.getElementById(container);
      this.set('container', container);
    } // else container  DOM


    if (!this.get('parent')) {
      this.set('parent', container.parentNode);
    }
  }; // 


  HtmlComponent.prototype.resetStyles = function () {
    var style = this.get('domStyles');
    var defaultStyles = this.get('defaultStyles');

    if (!style) {
      style = defaultStyles;
    } else {
      style = (0, _util.deepMix)({}, defaultStyles, style);
    }

    this.set('domStyles', style);
  }; // 


  HtmlComponent.prototype.applyStyles = function () {
    var domStyles = this.get('domStyles');

    if (!domStyles) {
      return;
    }

    var container = this.getContainer();
    this.applyChildrenStyles(container, domStyles);
    var containerClassName = this.get('containerClassName');

    if (containerClassName && (0, _util2.hasClass)(container, containerClassName)) {
      var containerCss = domStyles[containerClassName];
      (0, _domUtil.modifyCSS)(container, containerCss);
    }
  };

  HtmlComponent.prototype.applyChildrenStyles = function (element, styles) {
    (0, _util.each)(styles, function (style, name) {
      var elements = element.getElementsByClassName(name);
      (0, _util.each)(elements, function (el) {
        (0, _domUtil.modifyCSS)(el, style);
      });
    });
  }; //  DOM


  HtmlComponent.prototype.applyStyle = function (cssName, dom) {
    var domStyles = this.get('domStyles');
    (0, _domUtil.modifyCSS)(dom, domStyles[cssName]);
  };
  /**
   * @protected
   */


  HtmlComponent.prototype.createDom = function () {
    var containerTpl = this.get('containerTpl');
    return (0, _domUtil.createDom)(containerTpl);
  };
  /**
   * @protected
   * 
   */


  HtmlComponent.prototype.initEvent = function () {};
  /**
   * @protected
   *  DOM
   */


  HtmlComponent.prototype.removeDom = function () {
    var container = this.get('container'); // parentNode

    container && container.parentNode && container.parentNode.removeChild(container);
  };
  /**
   * @protected
   * 
   */


  HtmlComponent.prototype.removeEvent = function () {};

  HtmlComponent.prototype.updateInner = function (cfg) {
    // 
    if ((0, _util.hasKey)(cfg, 'domStyles')) {
      this.resetStyles();
      this.applyStyles();
    } // 


    this.resetPosition();
  };

  HtmlComponent.prototype.resetPosition = function () {};

  ;
  return HtmlComponent;
}(_component.default);

var _default = HtmlComponent;
exports.default = _default;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEndArrow = exports.addStartArrow = exports.getShortenOffset = void 0;

var tslib_1 = __webpack_require__(1);

var shape_1 = __webpack_require__(142);

var sin = Math.sin,
    cos = Math.cos,
    atan2 = Math.atan2,
    PI = Math.PI;

function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke,
      lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new shape_1.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: {
      //  10 60 
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      //  shape stroke 
      stroke: stroke,
      lineWidth: lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 *  path 
 * 1.  (0, 0)
 * 2.  X 
 */


function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow,
      endArrow = attrs.endArrow,
      stroke = attrs.stroke,
      lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;

  var d = arrowAttrs.d,
      arrowFill = arrowAttrs.fill,
      arrowStroke = arrowAttrs.stroke,
      arrowLineWidth = arrowAttrs.lineWidth,
      restAttrs = tslib_1.__rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);

  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);

  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }

  var arrowShape = new shape_1.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: tslib_1.__assign(tslib_1.__assign({}, restAttrs), {
      //  stroke  lineWidth shape 
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      //  shape 
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 *  d  d, 
 * |----------------
 * |<|--------------
 * |
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 * @param {number} d  
 * @return {{dx: number, dy: number}} 
 */


function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}

exports.getShortenOffset = getShortenOffset;
/**
 * 
 * @param {IShape} shape 
 * @param {ShapeAttrs} attrs shape 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */

function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.startArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set('startArrowShape', null);
  }
}

exports.addStartArrow = addStartArrow;
/**
 * 
 * @param {IShape} shape 
 * @param {ShapeAttrs} attrs shape 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */

function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.endArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set('startArrowShape', null);
  }
}

exports.addEndArrow = addEndArrow;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g_math_1 = __webpack_require__(35);

function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2; // 
  //  lineWidth 

  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  } // 


  return g_math_1.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

exports.default = inLine;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(63);

Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return base_1.default;
  }
});

var circle_1 = __webpack_require__(870);

Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return circle_1.default;
  }
});

var dom_1 = __webpack_require__(871);

Object.defineProperty(exports, "Dom", {
  enumerable: true,
  get: function get() {
    return dom_1.default;
  }
});

var ellipse_1 = __webpack_require__(872);

Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return ellipse_1.default;
  }
});

var image_1 = __webpack_require__(873);

Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return image_1.default;
  }
});

var line_1 = __webpack_require__(874);

Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return line_1.default;
  }
});

var marker_1 = __webpack_require__(875);

Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return marker_1.default;
  }
});

var path_1 = __webpack_require__(877);

Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return path_1.default;
  }
});

var polygon_1 = __webpack_require__(878);

Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return polygon_1.default;
  }
});

var polyline_1 = __webpack_require__(879);

Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return polyline_1.default;
  }
});

var rect_1 = __webpack_require__(880);

Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return rect_1.default;
  }
});

var text_1 = __webpack_require__(882);

Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return text_1.default;
  }
});

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShortenOffset = getShortenOffset;
exports.addStartArrow = addStartArrow;
exports.addEndArrow = addEndArrow;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _tslib = __webpack_require__(1);

var _shape = __webpack_require__(148);

var sin = Math.sin,
    cos = Math.cos,
    atan2 = Math.atan2,
    PI = Math.PI;

function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke,
      lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new _shape.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: {
      //  10 60 
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      //  shape stroke 
      stroke: stroke,
      lineWidth: lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 *  path 
 * 1.  (0, 0)
 * 2.  X 
 */


function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow,
      endArrow = attrs.endArrow,
      stroke = attrs.stroke,
      lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d,
      arrowFill = arrowAttrs.fill,
      arrowStroke = arrowAttrs.stroke,
      arrowLineWidth = arrowAttrs.lineWidth,
      restAttrs = (0, _tslib.__rest)(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);

  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }

  var arrowShape = new _shape.Path({
    type: 'path',
    canvas: shape.get('canvas'),
    isArrowShape: true,
    attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, restAttrs), {
      //  stroke  lineWidth shape 
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      //  shape 
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? 'startArrowShape' : 'endArrowShape', arrowShape);
}
/**
 *  d  d, 
 * |----------------
 * |<|--------------
 * |
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 * @param {number} d  
 * @return {{dx: number, dy: number}} 
 */


function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
/**
 * 
 * @param {IShape} shape 
 * @param {ShapeAttrs} attrs shape 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */


function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.startArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set('startArrowShape', null);
  }
}
/**
 * 
 * @param {IShape} shape 
 * @param {ShapeAttrs} attrs shape 
 * @param {number} x1  x
 * @param {number} y1  y
 * @param {number} x2  x
 * @param {number} y2  y
 */


function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if ((0, _typeof2.default)(attrs.endArrow) === 'object') {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set('startArrowShape', null);
  }
}

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inLine;

var _gMath = __webpack_require__(35);

function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2; // 
  //  lineWidth 

  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY + halfWidth)) {
    return false;
  } // 


  return _gMath.Line.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Dom", {
  enumerable: true,
  get: function get() {
    return _dom.default;
  }
});
Object.defineProperty(exports, "Ellipse", {
  enumerable: true,
  get: function get() {
    return _ellipse.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _image.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Marker", {
  enumerable: true,
  get: function get() {
    return _marker.default;
  }
});
Object.defineProperty(exports, "Path", {
  enumerable: true,
  get: function get() {
    return _path.default;
  }
});
Object.defineProperty(exports, "Polygon", {
  enumerable: true,
  get: function get() {
    return _polygon.default;
  }
});
Object.defineProperty(exports, "Polyline", {
  enumerable: true,
  get: function get() {
    return _polyline.default;
  }
});
Object.defineProperty(exports, "Rect", {
  enumerable: true,
  get: function get() {
    return _rect.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});

var _base = _interopRequireDefault(__webpack_require__(64));

var _circle = _interopRequireDefault(__webpack_require__(923));

var _dom = _interopRequireDefault(__webpack_require__(924));

var _ellipse = _interopRequireDefault(__webpack_require__(925));

var _image = _interopRequireDefault(__webpack_require__(926));

var _line = _interopRequireDefault(__webpack_require__(927));

var _marker = _interopRequireDefault(__webpack_require__(928));

var _path = _interopRequireDefault(__webpack_require__(930));

var _polygon = _interopRequireDefault(__webpack_require__(931));

var _polyline = _interopRequireDefault(__webpack_require__(932));

var _rect = _interopRequireDefault(__webpack_require__(933));

var _text = _interopRequireDefault(__webpack_require__(935));

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_2 = __webpack_require__(30);

var util_3 = __webpack_require__(30);
/**
 *  Action 
 * @class
 * @ignore
 */


var ListState =
/** @class */
function (_super) {
  tslib_1.__extends(ListState, _super);

  function ListState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = '';
    _this.ignoreItemStates = [];
    return _this;
  }
  /**  */


  ListState.prototype.getTriggerListInfo = function () {
    var delegateObject = util_3.getDelegationObject(this.context);
    var info = null;

    if (util_3.isList(delegateObject)) {
      info = {
        item: delegateObject.item,
        list: delegateObject.component
      };
    }

    return info;
  }; //  Action 


  ListState.prototype.getAllowComponents = function () {
    var _this = this;

    var view = this.context.view;
    var components = util_2.getComponents(view);
    var rst = [];
    util_1.each(components, function (component) {
      if (component.isList() && _this.allowSetStateByElement(component)) {
        rst.push(component);
      }
    });
    return rst;
  };
  /**  */


  ListState.prototype.hasState = function (list, item) {
    return list.hasState(item, this.stateName);
  };
  /**  */


  ListState.prototype.clearAllComponentsState = function () {
    var _this = this;

    var components = this.getAllowComponents();
    util_1.each(components, function (component) {
      component.clearItemsState(_this.stateName);
    });
  }; //  component  active scale 


  ListState.prototype.allowSetStateByElement = function (component) {
    var field = component.get('field');

    if (!field) {
      return false;
    }

    if (this.cfg && this.cfg.componentNames) {
      var name_1 = component.get('name'); //  component name

      if (this.cfg.componentNames.indexOf(name_1) === -1) {
        return false;
      }
    }

    var view = this.context.view;
    var scale = util_3.getScaleByField(view, field);
    return scale && scale.isCategory;
  }; // 


  ListState.prototype.allowSetStateByItem = function (item, list) {
    var ignoreStates = this.ignoreItemStates;

    if (ignoreStates.length) {
      var filterStates = ignoreStates.filter(function (state) {
        return list.hasState(item, state);
      });
      return filterStates.length === 0;
    }

    return true; // 
  }; //  item active


  ListState.prototype.setStateByElement = function (component, element, enable) {
    var field = component.get('field');
    var view = this.context.view;
    var scale = util_3.getScaleByField(view, field);
    var value = util_3.getElementValue(element, field);
    var text = scale.getText(value);
    this.setItemsState(component, text, enable);
  }; // 


  ListState.prototype.setStateEnable = function (enable) {
    var _this = this;

    var element = util_3.getCurrentElement(this.context);

    if (element) {
      // trigger by element
      var components = this.getAllowComponents();
      util_1.each(components, function (component) {
        _this.setStateByElement(component, element, enable);
      });
    } else {
      // 
      var delegateObject = util_3.getDelegationObject(this.context);

      if (util_3.isList(delegateObject)) {
        var item = delegateObject.item,
            component = delegateObject.component;

        if (this.allowSetStateByElement(component) && this.allowSetStateByItem(item, component)) {
          this.setItemState(component, item, enable);
        }
      }
    }
  }; //  item 


  ListState.prototype.setItemsState = function (list, name, enable) {
    var _this = this;

    var items = list.getItems();
    util_1.each(items, function (item) {
      if (item.name === name) {
        _this.setItemState(list, item, enable);
      }
    });
  }; //  item 


  ListState.prototype.setItemState = function (list, item, enable) {
    list.setItemState(item, this.stateName, enable);
  };
  /**
   * 
   */


  ListState.prototype.setState = function () {
    this.setStateEnable(true);
  };
  /**
   * 
   */


  ListState.prototype.reset = function () {
    this.setStateEnable(false);
  };
  /**
   * 
   */


  ListState.prototype.toggle = function () {
    var triggerInfo = this.getTriggerListInfo();

    if (triggerInfo && triggerInfo.item) {
      var list = triggerInfo.list,
          item = triggerInfo.item;
      var enable = this.hasState(list, item);
      this.setItemState(list, item, !enable);
    }
  };
  /**
   * 
   */


  ListState.prototype.clear = function () {
    var triggerInfo = this.getTriggerListInfo();

    if (triggerInfo) {
      triggerInfo.list.clearItemsState(this.stateName);
    } else {
      this.clearAllComponentsState();
    }
  };

  return ListState;
}(base_1.default);

exports.default = ListState;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MASK_VIEW_ID = exports.RANGE_VIEW_ID = exports.INDICATEOR_VIEW_ID = exports.DEFAULT_COLOR = exports.PERCENT = exports.RANGE_TYPE = exports.RANGE_VALUE = void 0;
exports.RANGE_VALUE = 'range';
exports.RANGE_TYPE = 'type';
exports.PERCENT = 'percent';
exports.DEFAULT_COLOR = '#f0f0f0';
/**    */

exports.INDICATEOR_VIEW_ID = 'indicator-view';
exports.RANGE_VIEW_ID = 'range-view';
/** meter   mask  view */

exports.MASK_VIEW_ID = 'range-mask-view';

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MASK_VIEW_ID = exports.RANGE_VIEW_ID = exports.INDICATEOR_VIEW_ID = exports.DEFAULT_COLOR = exports.PERCENT = exports.RANGE_TYPE = exports.RANGE_VALUE = void 0;
var RANGE_VALUE = 'range';
exports.RANGE_VALUE = RANGE_VALUE;
var RANGE_TYPE = 'type';
exports.RANGE_TYPE = RANGE_TYPE;
var PERCENT = 'percent';
exports.PERCENT = PERCENT;
var DEFAULT_COLOR = '#f0f0f0';
/**    */

exports.DEFAULT_COLOR = DEFAULT_COLOR;
var INDICATEOR_VIEW_ID = 'indicator-view';
exports.INDICATEOR_VIEW_ID = INDICATEOR_VIEW_ID;
var RANGE_VIEW_ID = 'range-view';
/** meter   mask  view */

exports.RANGE_VIEW_ID = RANGE_VIEW_ID;
var MASK_VIEW_ID = 'range-mask-view';
exports.MASK_VIEW_ID = MASK_VIEW_ID;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = count;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function count(values, valueof) {
  var count = 0;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null && (value = +value) >= value) {
          ++count;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          ++count;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return count;
}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        this._context.lineTo(x, y);

        break;
    }
  }
};

function _default(context) {
  return new Linear(context);
}

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {}

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = _point;
exports.Basis = Basis;
exports.default = _default;

function _point(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 3:
        _point(this, this._x1, this._y1);

      // proceed

      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);

      // proceed

      default:
        _point(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new Basis(context);
}

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = _point;
exports.Cardinal = Cardinal;
exports.default = void 0;

function _point(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        _point(this, this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        this._x1 = x, this._y1 = y;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        _point(this, x, y);

        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCallbackAction = exports.unregisterAction = exports.registerAction = exports.getActionClass = exports.createAction = void 0;

var tslib_1 = __webpack_require__(1);

var callback_1 = tslib_1.__importDefault(__webpack_require__(892));

var util_1 = __webpack_require__(0); // Action 


var ActionCache = {};
/**
 *  Action 
 * @param actionName - action 
 * @param context 
 * @returns Action 
 */

function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;

  if (actionOption) {
    var ActionClass = actionOption.ActionClass,
        cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }

  return action;
}

exports.createAction = createAction;
/**
 *  action  name 
 * @param actionName action  name
 */

function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return util_1.get(actionOption, 'ActionClass');
}

exports.getActionClass = getActionClass;
/**
 *  Action
 * @param actionName - action 
 * @param ActionClass -  action 
 */

function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass: ActionClass,
    cfg: cfg
  };
}

exports.registerAction = registerAction;
/**
 *  Action
 * @param actionName action 
 */

function unregisterAction(actionName) {
  delete ActionCache[actionName];
}

exports.unregisterAction = unregisterAction;
/**
 *  Action 
 * @param callback - action 
 * @param context 
 * @returns Action 
 */

function createCallbackAction(callback, context) {
  var action = new callback_1.default(context);
  action.callback = callback;
  action.name = 'callback';
  return action;
}

exports.createCallbackAction = createCallbackAction;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var dependents_1 = __webpack_require__(68);

var coordinate_1 = __webpack_require__(51);

var graphics_1 = __webpack_require__(45);

var tooltip_1 = __webpack_require__(266);

var bbox_1 = __webpack_require__(77);

var base_1 = __webpack_require__(104);

var event_1 = tslib_1.__importDefault(__webpack_require__(268)); // Filter duplicates, use `name`, `color`, `value` and `title` property values as condition


function uniq(items) {
  var uniqItems = [];

  var _loop_1 = function _loop_1(index) {
    var item = items[index];
    var result = util_1.find(uniqItems, function (subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });

    if (!result) {
      uniqItems.push(item);
    }
  };

  for (var index = 0; index < items.length; index++) {
    _loop_1(index);
  }

  return uniqItems;
}
/** @ignore */


var Tooltip =
/** @class */
function (_super) {
  tslib_1.__extends(Tooltip, _super);

  function Tooltip() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.isLocked = false;
    return _this;
  }

  Object.defineProperty(Tooltip.prototype, "name", {
    get: function get() {
      return 'tooltip';
    },
    enumerable: false,
    configurable: true
  });

  Tooltip.prototype.init = function () {};

  Tooltip.prototype.isVisible = function () {
    var option = this.view.getOptions().tooltip;
    return option !== false;
  };

  Tooltip.prototype.render = function () {};
  /**
   * Shows tooltip
   * @param point
   */


  Tooltip.prototype.showTooltip = function (point) {
    this.point = point;

    if (!this.isVisible()) {
      //  tooltip(false) 
      return;
    }

    var view = this.view;
    var items = this.getTooltipItems(point);

    if (!items.length) {
      //  tooltip 
      this.hideTooltip();
      return;
    }

    var title = this.getTitle(items);
    var dataPoint = {
      x: items[0].x,
      y: items[0].y
    }; // 

    view.emit('tooltip:show', event_1.default.fromData(view, 'tooltip:show', tslib_1.__assign({
      items: items,
      title: title
    }, point)));
    var cfg = this.getTooltipCfg();
    var follow = cfg.follow,
        showMarkers = cfg.showMarkers,
        showCrosshairs = cfg.showCrosshairs,
        showContent = cfg.showContent,
        marker = cfg.marker;
    var lastItems = this.items;
    var lastTitle = this.title;

    if (!util_1.isEqual(lastTitle, title) || !util_1.isEqual(lastItems, items)) {
      //  tooltip
      view.emit('tooltip:change', event_1.default.fromData(view, 'tooltip:change', tslib_1.__assign({
        items: items,
        title: title
      }, point)));

      if (showContent) {
        //  tooltip  tooltip
        if (!this.tooltip) {
          // 
          this.renderTooltip();
        }

        this.tooltip.update(util_1.mix({}, cfg, {
          items: this.getItemsAfterProcess(items),
          title: title
        }, follow ? point : {}));
        this.tooltip.show();
      }

      if (showMarkers) {
        //  tooltipMarkerstooltipMarkers 
        this.renderTooltipMarkers(items, marker);
      }
    } else {
      // 
      if (this.tooltip && follow) {
        this.tooltip.update(point);
        this.tooltip.show(); // tooltip 
      }

      if (this.tooltipMarkersGroup) {
        this.tooltipMarkersGroup.show();
      }
    }

    this.items = items;
    this.title = title;

    if (showCrosshairs) {
      //  tooltip 
      var isCrosshairsFollowCursor = util_1.get(cfg, ['crosshairs', 'follow'], false); // 

      this.renderCrosshairs(isCrosshairsFollowCursor ? point : dataPoint, cfg);
    }
  };

  Tooltip.prototype.hideTooltip = function () {
    var follow = this.getTooltipCfg().follow;

    if (!follow) {
      this.point = null;
      return;
    } // hide the tooltipMarkers


    var tooltipMarkersGroup = this.tooltipMarkersGroup;

    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.hide();
    } // hide crosshairs


    var xCrosshair = this.xCrosshair;
    var yCrosshair = this.yCrosshair;

    if (xCrosshair) {
      xCrosshair.hide();
    }

    if (yCrosshair) {
      yCrosshair.hide();
    }

    var tooltip = this.tooltip;

    if (tooltip) {
      tooltip.hide();
    }

    this.view.emit('tooltip:hide', event_1.default.fromData(this.view, 'tooltip:hide', {}));
    this.point = null;
  };
  /**
   * lockTooltip
   */


  Tooltip.prototype.lockTooltip = function () {
    this.isLocked = true;

    if (this.tooltip) {
      // tooltip contianer 
      this.tooltip.setCapture(true);
    }
  };
  /**
   * unlockTooltip
   */


  Tooltip.prototype.unlockTooltip = function () {
    this.isLocked = false;
    var cfg = this.getTooltipCfg();

    if (this.tooltip) {
      //  capture 
      this.tooltip.setCapture(cfg.capture);
    }
  };
  /**
   * isTooltipLocked
   */


  Tooltip.prototype.isTooltipLocked = function () {
    return this.isLocked;
  };

  Tooltip.prototype.clear = function () {
    var _a = this,
        tooltip = _a.tooltip,
        xCrosshair = _a.xCrosshair,
        yCrosshair = _a.yCrosshair,
        tooltipMarkersGroup = _a.tooltipMarkersGroup;

    if (tooltip) {
      tooltip.hide();
      tooltip.clear();
    }

    if (xCrosshair) {
      xCrosshair.clear();
    }

    if (yCrosshair) {
      yCrosshair.clear();
    }

    if (tooltipMarkersGroup) {
      tooltipMarkersGroup.clear();
    }

    this.reset();
  };

  Tooltip.prototype.destroy = function () {
    if (this.tooltip) {
      this.tooltip.destroy();
    }

    if (this.xCrosshair) {
      this.xCrosshair.destroy();
    }

    if (this.yCrosshair) {
      this.yCrosshair.destroy();
    }

    if (this.guideGroup) {
      this.guideGroup.remove(true);
    }

    this.reset();
  };

  Tooltip.prototype.reset = function () {
    this.items = null;
    this.title = null;
    this.tooltipMarkersGroup = null;
    this.tooltipCrosshairsGroup = null;
    this.xCrosshair = null;
    this.yCrosshair = null;
    this.tooltip = null;
    this.guideGroup = null;
    this.isLocked = false;
    this.point = null;
  };

  Tooltip.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }

    var _a = this,
        tooltip = _a.tooltip,
        tooltipMarkersGroup = _a.tooltipMarkersGroup,
        xCrosshair = _a.xCrosshair,
        yCrosshair = _a.yCrosshair;

    if (visible) {
      if (tooltip) {
        tooltip.show();
      }

      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.show();
      }

      if (xCrosshair) {
        xCrosshair.show();
      }

      if (yCrosshair) {
        yCrosshair.show();
      }
    } else {
      if (tooltip) {
        tooltip.hide();
      }

      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }

      if (xCrosshair) {
        xCrosshair.hide();
      }

      if (yCrosshair) {
        yCrosshair.hide();
      }
    }

    this.visible = visible;
  };

  Tooltip.prototype.getTooltipItems = function (point) {
    var items = this.findItemsFromView(this.view, point);

    if (items.length) {
      // 
      items = util_1.flatten(items);

      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var itemArr = items_1[_i];

        for (var _a = 0, itemArr_1 = itemArr; _a < itemArr_1.length; _a++) {
          var item = itemArr_1[_a];
          var _b = item.mappingData,
              x = _b.x,
              y = _b.y;
          item.x = util_1.isArray(x) ? x[x.length - 1] : x;
          item.y = util_1.isArray(y) ? y[y.length - 1] : y;
        }
      }

      var shared = this.getTooltipCfg().shared; // shared: false  shape  view  Geometry shape

      if (shared === false && items.length > 1) {
        var snapItem = items[0];
        var min = Math.abs(point.y - snapItem[0].y);

        for (var _c = 0, items_2 = items; _c < items_2.length; _c++) {
          var aItem = items_2[_c];
          var yDistance = Math.abs(point.y - aItem[0].y);

          if (yDistance <= min) {
            snapItem = aItem;
            min = yDistance;
          }
        }

        items = [snapItem];
      }

      return uniq(util_1.flatten(items));
    }

    return [];
  };

  Tooltip.prototype.layout = function () {};

  Tooltip.prototype.update = function () {
    if (this.point) {
      this.showTooltip(this.point);
    }

    if (this.tooltip) {
      // #2279 resizetooltip
      // tooltip
      var canvas = this.view.getCanvas(); // TODO  tooltip  canvas 
      //  region

      this.tooltip.set('region', {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: canvas.get('width'),
          y: canvas.get('height')
        }
      });
    }
  };
  /**
   *  enter tooltip 
   * @param point
   */


  Tooltip.prototype.isCursorEntered = function (point) {
    //  tooltip dom 
    if (this.tooltip) {
      var el = this.tooltip.getContainer();
      var capture = this.tooltip.get('capture');

      if (el && capture) {
        var _a = el.getBoundingClientRect(),
            x = _a.x,
            y = _a.y,
            width = _a.width,
            height = _a.height;

        return new bbox_1.BBox(x, y, width, height).isPointIn(point);
      }
    }

    return false;
  }; //  tooltip  view.tooltip()  tooltip


  Tooltip.prototype.getTooltipCfg = function () {
    var view = this.view;
    var option = view.getOptions().tooltip;
    var processOption = this.processCustomContent(option);
    var theme = view.getTheme();
    var defaultCfg = util_1.get(theme, ['components', 'tooltip'], {});
    var enterable = util_1.get(processOption, 'enterable', defaultCfg.enterable);
    return util_1.deepMix({}, defaultCfg, processOption, {
      capture: enterable || this.isLocked ? true : false
    });
  }; // process customContent


  Tooltip.prototype.processCustomContent = function (option) {
    if (util_1.isBoolean(option) || !util_1.get(option, 'customContent')) {
      return option;
    }

    var currentCustomContent = option.customContent;

    var customContent = function customContent(title, items) {
      var content = currentCustomContent(title, items) || '';
      return util_1.isString(content) ? '<div class="g2-tooltip">' + content + '</div>' : content;
    };

    return tslib_1.__assign(tslib_1.__assign({}, option), {
      customContent: customContent
    });
  };

  Tooltip.prototype.getTitle = function (items) {
    var title = items[0].title || items[0].name;
    this.title = title;
    return title;
  };

  Tooltip.prototype.renderTooltip = function () {
    var canvas = this.view.getCanvas();
    var region = {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: canvas.get('width'),
        y: canvas.get('height')
      }
    };
    var cfg = this.getTooltipCfg();
    var tooltip = new dependents_1.HtmlTooltip(tslib_1.__assign(tslib_1.__assign({
      parent: canvas.get('el').parentNode,
      region: region
    }, cfg), {
      visible: false,
      crosshairs: null
    }));
    tooltip.init();
    this.tooltip = tooltip;
  };

  Tooltip.prototype.renderTooltipMarkers = function (items, marker) {
    var tooltipMarkersGroup = this.getTooltipMarkersGroup();

    for (var _i = 0, items_3 = items; _i < items_3.length; _i++) {
      var item = items_3[_i];
      var x = item.x,
          y = item.y;

      var attrs = tslib_1.__assign(tslib_1.__assign({
        fill: item.color,
        symbol: 'circle',
        shadowColor: item.color
      }, marker), {
        x: x,
        y: y
      });

      tooltipMarkersGroup.addShape('marker', {
        attrs: attrs
      });
    }
  };

  Tooltip.prototype.renderCrosshairs = function (point, cfg) {
    var crosshairsType = util_1.get(cfg, ['crosshairs', 'type'], 'x'); //  x 

    if (crosshairsType === 'x') {
      if (this.yCrosshair) {
        this.yCrosshair.hide();
      }

      this.renderXCrosshairs(point, cfg);
    } else if (crosshairsType === 'y') {
      if (this.xCrosshair) {
        this.xCrosshair.hide();
      }

      this.renderYCrosshairs(point, cfg);
    } else if (crosshairsType === 'xy') {
      this.renderXCrosshairs(point, cfg);
      this.renderYCrosshairs(point, cfg);
    }
  }; //  x  tooltip 


  Tooltip.prototype.renderXCrosshairs = function (point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();

    if (!coordinate_1.isPointInCoordinate(coordinate, point)) {
      return;
    }

    var start;
    var end;

    if (coordinate.isRect) {
      if (coordinate.isTransposed) {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      } else {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      }
    } else {
      //  x  crosshairs 
      var angle = coordinate_1.getAngleByPoint(coordinate, point);
      var center = coordinate.getCenter();
      var radius = coordinate.getRadius();
      end = graphics_1.polarToCartesian(center.x, center.y, radius, angle);
      start = center;
    }

    var cfg = util_1.deepMix({
      start: start,
      end: end,
      container: this.getTooltipCrosshairsGroup()
    }, util_1.get(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('x', point, tooltipCfg));
    delete cfg.type; //  Crosshairs  type 

    var xCrosshair = this.xCrosshair;

    if (xCrosshair) {
      xCrosshair.update(cfg);
    } else {
      xCrosshair = new dependents_1.Crosshair.Line(cfg);
      xCrosshair.init();
    }

    xCrosshair.render();
    xCrosshair.show();
    this.xCrosshair = xCrosshair;
  }; //  y 


  Tooltip.prototype.renderYCrosshairs = function (point, tooltipCfg) {
    var coordinate = this.getViewWithGeometry(this.view).getCoordinate();

    if (!coordinate_1.isPointInCoordinate(coordinate, point)) {
      return;
    }

    var cfg;
    var type;

    if (coordinate.isRect) {
      var start = void 0;
      var end = void 0;

      if (coordinate.isTransposed) {
        start = {
          x: point.x,
          y: coordinate.end.y
        };
        end = {
          x: point.x,
          y: coordinate.start.y
        };
      } else {
        start = {
          x: coordinate.start.x,
          y: point.y
        };
        end = {
          x: coordinate.end.x,
          y: point.y
        };
      }

      cfg = {
        start: start,
        end: end
      };
      type = 'Line';
    } else {
      //  y  crosshairs 
      cfg = {
        center: coordinate.getCenter(),
        // @ts-ignore
        radius: coordinate_1.getDistanceToCenter(coordinate, point),
        startAngle: coordinate.startAngle,
        endAngle: coordinate.endAngle
      };
      type = 'Circle';
    }

    cfg = util_1.deepMix({
      container: this.getTooltipCrosshairsGroup()
    }, cfg, util_1.get(tooltipCfg, 'crosshairs', {}), this.getCrosshairsText('y', point, tooltipCfg));
    delete cfg.type; //  Crosshairs  type 

    var yCrosshair = this.yCrosshair;

    if (yCrosshair) {
      // 
      if (coordinate.isRect && yCrosshair.get('type') === 'circle' || !coordinate.isRect && yCrosshair.get('type') === 'line') {
        yCrosshair = new dependents_1.Crosshair[type](cfg);
        yCrosshair.init();
      } else {
        yCrosshair.update(cfg);
      }
    } else {
      yCrosshair = new dependents_1.Crosshair[type](cfg);
      yCrosshair.init();
    }

    yCrosshair.render();
    yCrosshair.show();
    this.yCrosshair = yCrosshair;
  };

  Tooltip.prototype.getCrosshairsText = function (type, point, tooltipCfg) {
    var textCfg = util_1.get(tooltipCfg, ['crosshairs', 'text']);
    var follow = util_1.get(tooltipCfg, ['crosshairs', 'follow']);
    var items = this.items;

    if (textCfg) {
      var view = this.getViewWithGeometry(this.view); // 

      var firstItem = items[0];
      var xScale = view.getXScale();
      var yScale = view.getYScales()[0];
      var xValue = void 0;
      var yValue = void 0;

      if (follow) {
        // 
        var invertPoint = this.view.getCoordinate().invert(point);
        xValue = xScale.invert(invertPoint.x); // 

        yValue = yScale.invert(invertPoint.y); // 
      } else {
        xValue = firstItem.data[xScale.field];
        yValue = firstItem.data[yScale.field];
      }

      var content = type === 'x' ? xValue : yValue;

      if (util_1.isFunction(textCfg)) {
        textCfg = textCfg(type, content, items, point);
      } else {
        textCfg.content = content;
      }

      return {
        text: textCfg
      };
    }
  }; //  tooltipMarkers  crosshairs 


  Tooltip.prototype.getGuideGroup = function () {
    if (!this.guideGroup) {
      var foregroundGroup = this.view.foregroundGroup;
      this.guideGroup = foregroundGroup.addGroup({
        name: 'tooltipGuide',
        capture: false
      });
    }

    return this.guideGroup;
  }; //  tooltipMarkers 


  Tooltip.prototype.getTooltipMarkersGroup = function () {
    var tooltipMarkersGroup = this.tooltipMarkersGroup;

    if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
      tooltipMarkersGroup.clear();
      tooltipMarkersGroup.show();
    } else {
      tooltipMarkersGroup = this.getGuideGroup().addGroup({
        name: 'tooltipMarkersGroup'
      });
      tooltipMarkersGroup.toFront();
      this.tooltipMarkersGroup = tooltipMarkersGroup;
    }

    return tooltipMarkersGroup;
  }; //  tooltip crosshairs 


  Tooltip.prototype.getTooltipCrosshairsGroup = function () {
    var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;

    if (!tooltipCrosshairsGroup) {
      tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
        name: 'tooltipCrosshairsGroup',
        capture: false
      });
      tooltipCrosshairsGroup.toBack();
      this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
    }

    return tooltipCrosshairsGroup;
  };

  Tooltip.prototype.getTooltipItemsByHitShape = function (geometry, point, title) {
    var showNil = this.getTooltipCfg().showNil;
    var result = [];
    var container = geometry.container;
    var shape = container.getShape(point.x, point.y);

    if (shape && shape.get('visible') && shape.get('origin')) {
      var mappingData = shape.get('origin').mappingData;
      var items = tooltip_1.getTooltipItems(mappingData, geometry, title, showNil);

      if (items.length) {
        result.push(items);
      }
    }

    return result;
  };

  Tooltip.prototype.getTooltipItemsByFindData = function (geometry, point, title) {
    var showNil = this.getTooltipCfg().showNil;
    var result = [];
    var dataArray = geometry.dataArray;

    if (!util_1.isEmpty(dataArray)) {
      geometry.sort(dataArray); //  tooltip 

      for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {
        var data = dataArray_1[_i];
        var record = tooltip_1.findDataByPoint(point, data, geometry);

        if (record) {
          var elementId = geometry.getElementId(record);
          var element = geometry.elementsMap[elementId];

          if (geometry.type === 'heatmap' || element.visible) {
            // Heatmap  Element
            //  tooltip 
            var items = tooltip_1.getTooltipItems(record, geometry, title, showNil);

            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    }

    return result;
  };

  Tooltip.prototype.findItemsFromView = function (view, point) {
    if (view.getOptions().tooltip === false) {
      //  view  tooltip
      return [];
    }

    var result = []; //  view 

    var geometries = view.geometries;

    var _a = this.getTooltipCfg(),
        shared = _a.shared,
        title = _a.title,
        reversed = _a.reversed;

    for (var _i = 0, geometries_1 = geometries; _i < geometries_1.length; _i++) {
      var geometry = geometries_1[_i];

      if (geometry.visible && geometry.tooltipOption !== false) {
        // geometry  tooltip
        var geometryType = geometry.type;
        var tooltipItems = void 0;

        if (['point', 'edge', 'polygon'].includes(geometryType)) {
          // 
          tooltipItems = this.getTooltipItemsByHitShape(geometry, point, title);
        } else if (['area', 'line', 'path', 'heatmap'].includes(geometryType)) {
          //  'area', 'line', 'path' tooltip
          tooltipItems = this.getTooltipItemsByFindData(geometry, point, title);
        } else {
          if (shared !== false) {
            tooltipItems = this.getTooltipItemsByFindData(geometry, point, title);
          } else {
            tooltipItems = this.getTooltipItemsByHitShape(geometry, point, title);
          }
        }

        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          } // geometry  item geometry.tooltip('x*y*z')


          result.push(tooltipItems);
        }
      }
    } // 


    for (var _b = 0, _c = view.views; _b < _c.length; _b++) {
      var childView = _c[_b];
      result = result.concat(this.findItemsFromView(childView, point));
    }

    return result;
  }; // FIXME: hack 
  //  tooltip  Chart chart  Geometry  View 


  Tooltip.prototype.getViewWithGeometry = function (view) {
    var _this = this;

    if (view.geometries.length) {
      return view;
    }

    return util_1.find(view.views, function (childView) {
      return _this.getViewWithGeometry(childView);
    });
  };
  /**
   *  items  items
   * 
   */


  Tooltip.prototype.getItemsAfterProcess = function (originalItems) {
    var customItems = this.getTooltipCfg().customItems;
    var fn = customItems ? customItems : function (v) {
      return v;
    };
    return fn(originalItems);
  };

  return Tooltip;
}(base_1.Controller);

exports.default = Tooltip;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  Shape: true,
  Canvas: true,
  Group: true,
  getArcParams: true
};
Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return _arcParams.default;
  }
});
exports.Shape = exports.version = void 0;

var Shape = _interopRequireWildcard(__webpack_require__(148));

exports.Shape = Shape;

var _gBase = __webpack_require__(27);

Object.keys(_gBase).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _gBase[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _gBase[key];
    }
  });
});

var _canvas = _interopRequireDefault(__webpack_require__(921));

var _group = _interopRequireDefault(__webpack_require__(273));

var _arcParams = _interopRequireDefault(__webpack_require__(440));

var version = '0.5.6';
exports.version = version;

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Arc; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var Arc = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(Arc, _Base);

  var _super = _createSuper(Arc);

  function Arc() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Arc);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'arc';
    return _this;
  }

  return Arc;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataMarker; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var DataMarker = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(DataMarker, _Base);

  var _super = _createSuper(DataMarker);

  function DataMarker() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, DataMarker);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'dataMarker';
    return _this;
  }

  return DataMarker;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DataRegion; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var DataRegion = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(DataRegion, _Base);

  var _super = _createSuper(DataRegion);

  function DataRegion() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, DataRegion);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'dataRegion';
    return _this;
  }

  return DataRegion;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Image; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var Image = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(Image, _Base);

  var _super = _createSuper(Image);

  function Image() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Image);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'image';
    return _this;
  }

  return Image;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Line; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var Line = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(Line, _Base);

  var _super = _createSuper(Line);

  function Line() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Line);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'line';
    return _this;
  }

  return Line;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Region; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var Region = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(Region, _Base);

  var _super = _createSuper(Region);

  function Region() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Region);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'region';
    return _this;
  }

  return Region;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Text; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var Text = /*#__PURE__*/function (_Base) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(Text, _Base);

  var _super = _createSuper(Text);

  function Text() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Text);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'text';
    return _this;
  }

  return Text;
}(_base__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]);


;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51);

var coordinate_2 = __webpack_require__(51);

var base_1 = tslib_1.__importDefault(__webpack_require__(99));

var HALF_PI = Math.PI / 2;
/**
 *  label
 */

var PolarLabel =
/** @class */
function (_super) {
  tslib_1.__extends(PolarLabel, _super);

  function PolarLabel() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @override
   * @desc  label offset
   * polar & theta coordinate supportstringtype, should transform to number
   */


  PolarLabel.prototype.getLabelOffset = function (offset) {
    var coordinate = this.getCoordinate();
    var actualOffset = 0;

    if (util_1.isNumber(offset)) {
      actualOffset = offset;
    } else if (util_1.isString(offset) && offset.indexOf('%') !== -1) {
      var r = coordinate.getRadius();

      if (coordinate.innerRadius > 0) {
        r = r * (1 - coordinate.innerRadius);
      }

      actualOffset = parseFloat(offset) * 0.01 * r;
    }

    return actualOffset;
  };
  /**
   * @override
   *  labelItems,  percent
   * @param mapppingArray
   */


  PolarLabel.prototype.getLabelItems = function (mapppingArray) {
    var items = _super.prototype.getLabelItems.call(this, mapppingArray);

    var yScale = this.geometry.getYScale();
    return util_1.map(items, function (item) {
      if (item && yScale) {
        var percent = yScale.scale(util_1.get(item.data, yScale.field));
        return tslib_1.__assign(tslib_1.__assign({}, item), {
          percent: percent
        });
      }

      return item;
    });
  };
  /**
   * @override
   * 
   * @param point
   */


  PolarLabel.prototype.getLabelAlign = function (point) {
    var coordinate = this.getCoordinate();
    var align;

    if (point.labelEmit) {
      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';
    } else if (!coordinate.isTransposed) {
      align = 'center';
    } else {
      var center = coordinate.getCenter();
      var offset = point.offset;

      if (Math.abs(point.x - center.x) < 1) {
        align = 'center';
      } else if (point.angle > Math.PI || point.angle <= 0) {
        align = offset > 0 ? 'left' : 'right';
      } else {
        align = offset > 0 ? 'right' : 'left';
      }
    }

    return align;
  };
  /**
   * @override
   *  label 
   * @param labelCfg
   * @param mappingData
   * @param index
   */


  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {
    var factor = 1;
    var arcPoint;
    var content = labelCfg.content[index];

    if (this.isToMiddle(mappingData)) {
      arcPoint = this.getMiddlePoint(mappingData.points);
    } else {
      if (labelCfg.content.length === 1 && index === 0) {
        index = 1;
      } else if (index === 0) {
        factor = -1;
      }

      arcPoint = this.getArcPoint(mappingData, index);
    }

    var offset = labelCfg.offset * factor;
    var middleAngle = this.getPointAngle(arcPoint);
    var isLabelEmit = labelCfg.labelEmit;
    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);

    if (labelPositionCfg.r === 0) {
      // 
      labelPositionCfg.content = '';
    } else {
      labelPositionCfg.content = content;
      labelPositionCfg.angle = middleAngle;
      labelPositionCfg.color = mappingData.color;
    }

    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
    labelPositionCfg.start = {
      x: arcPoint.x,
      y: arcPoint.y
    };
    return labelPositionCfg;
  };
  /**
   * 
   */


  PolarLabel.prototype.getArcPoint = function (mappingData, index) {
    if (index === void 0) {
      index = 0;
    }

    if (!util_1.isArray(mappingData.x) && !util_1.isArray(mappingData.y)) {
      return {
        x: mappingData.x,
        y: mappingData.y
      };
    }

    return {
      x: util_1.isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,
      y: util_1.isArray(mappingData.y) ? mappingData.y[index] : mappingData.y
    };
  };
  /**
   * 
   * @param point
   */


  PolarLabel.prototype.getPointAngle = function (point) {
    return coordinate_2.getAngleByPoint(this.getCoordinate(), point);
  };
  /**
   * 
   * @param angle
   * @param offset
   * @param point
   * @param isLabelEmit
   */


  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {
    var coordinate = this.getCoordinate();
    var center = coordinate.getCenter();
    var r = coordinate_1.getDistanceToCenter(coordinate, point);

    if (r === 0) {
      return tslib_1.__assign(tslib_1.__assign({}, center), {
        r: r
      });
    }

    var labelAngle = angle;

    if (coordinate.isTransposed && r > offset && !isLabelEmit) {
      var appendAngle = Math.asin(offset / (2 * r));
      labelAngle = angle + appendAngle * 2;
    } else {
      r = r + offset;
    }

    return {
      x: center.x + r * Math.cos(labelAngle),
      y: center.y + r * Math.sin(labelAngle),
      r: r
    };
  };
  /**
   *  label 
   * @param angle
   * @param offset
   * @param isLabelEmit
   */


  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {
    var rotate = angle + HALF_PI;

    if (isLabelEmit) {
      rotate -= HALF_PI;
    }

    if (rotate) {
      if (rotate > HALF_PI) {
        rotate = rotate - Math.PI;
      } else if (rotate < -HALF_PI) {
        rotate = rotate + Math.PI;
      }
    }

    return rotate;
  }; // 


  PolarLabel.prototype.getMiddlePoint = function (points) {
    var coordinate = this.getCoordinate();
    var count = points.length;
    var middlePoint = {
      x: 0,
      y: 0
    };
    util_1.each(points, function (point) {
      middlePoint.x += point.x;
      middlePoint.y += point.y;
    });
    middlePoint.x /= count;
    middlePoint.y /= count;
    middlePoint = coordinate.convert(middlePoint);
    return middlePoint;
  }; // 


  PolarLabel.prototype.isToMiddle = function (mappingData) {
    return mappingData.x.length > 2;
  };

  return PolarLabel;
}(base_1.default);

exports.default = PolarLabel;

/***/ }),
/* 213 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Coordinate; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42);



var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


 // import _tranPropsToArray from '../../utils/tranPropsToArray';


function Coordinate(props) {
  var type = props.type,
      transpose = props.transpose,
      rotate = props.rotate,
      scale = props.scale,
      reflect = props.reflect,
      actions = props.actions,
      options = __rest(props, ["type", "transpose", "rotate", "scale", "reflect", "actions"]);

  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])();
  var coordIns = view.coordinate(); // 

  coordIns.update({});

  if (type) {
    view.coordinate(type, object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, options));
  } else {
    view.coordinate('rect', object_assign__WEBPACK_IMPORTED_MODULE_1___default()({}, options));
  }

  if (rotate) {
    coordIns.rotate(rotate);
  }

  if (scale) {
    coordIns.scale.apply(coordIns, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(scale));
  }

  if (!_antv_util_lib_is_nil__WEBPACK_IMPORTED_MODULE_2___default()(reflect)) {
    coordIns.reflect(reflect);
  }

  if (transpose) {
    coordIns.transpose();
  }

  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_3___default()(actions)) {
    actions(coordIns);
  }

  return null;
}

/***/ }),
/* 214 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EdgeGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(317);
/* harmony import */ var _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(447);
/* harmony import */ var _antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_edge__WEBPACK_IMPORTED_MODULE_7__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Edge', _antv_g2_lib_geometry_edge__WEBPACK_IMPORTED_MODULE_4___default.a);

var EdgeGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(EdgeGeom, _BaseGemo);

  var _super = _createSuper(EdgeGeom);

  function EdgeGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, EdgeGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'edge';
    return _this;
  }

  return EdgeGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HeatmapGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(318);
/* harmony import */ var _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }




Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Heatmap', _antv_g2_lib_geometry_heatmap__WEBPACK_IMPORTED_MODULE_4___default.a);

var HeatmapGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(HeatmapGeom, _BaseGemo);

  var _super = _createSuper(HeatmapGeom);

  function HeatmapGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, HeatmapGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'heatmap';
    return _this;
  }

  return HeatmapGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IntervalGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(319);
/* harmony import */ var _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(168);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(169);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(452);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_interval_funnel__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(453);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_interval_hollow_rect__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(454);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_interval_line__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(455);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_interval_pyramid__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(456);
/* harmony import */ var _antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_interval_tick__WEBPACK_IMPORTED_MODULE_13__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

 // import PropsTypes from 'prop-types';





Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerGeometry"])('Interval', _antv_g2_lib_geometry_interval__WEBPACK_IMPORTED_MODULE_4___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerGeometryLabel"])('interval', _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_5___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerGeometryLabel"])('pie', _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_6___default.a);




 // 

Object(_core__WEBPACK_IMPORTED_MODULE_8__["registerInteraction"])('active-region', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'active-region:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'active-region:hide'
  }]
});

var IntervalGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(IntervalGeom, _BaseGemo);

  var _super = _createSuper(IntervalGeom);

  function IntervalGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, IntervalGeom);

    _this = _super.apply(this, arguments);
    _this.interactionTypes = ['active-region', 'element-highlight']; // static propsTypes = {
    //   'active-region': PropsTypes.bool,
    //   'element-highlight': PropsTypes.bool,
    // }
    // static defaultProps = {
    //   'active-region': true,
    //   'element-highlight': false,
    //   'position': 'x*y'
    // }

    _this.GemoBaseClassName = 'interval';
    return _this;
  }

  return IntervalGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]);



/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PolygonGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(322);
/* harmony import */ var _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(449);
/* harmony import */ var _antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_polygon__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(462);
/* harmony import */ var _antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_polygon_square__WEBPACK_IMPORTED_MODULE_8__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }






Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Polygon', _antv_g2_lib_geometry_polygon__WEBPACK_IMPORTED_MODULE_4___default.a);

var PolygonGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(PolygonGeom, _BaseGemo);

  var _super = _createSuper(PolygonGeom);

  function PolygonGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, PolygonGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'polygon';
    return _this;
  }

  return PolygonGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);
/* harmony import */ var _antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(276);
/* harmony import */ var _antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_line__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(279);
/* harmony import */ var _antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_area__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(62);
/* harmony import */ var _antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(173);
/* harmony import */ var _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(15);
/* harmony import */ var _antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(18);
/* harmony import */ var _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(61);
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(d3_color__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(42);
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(129);
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(130);
/* harmony import */ var _Area__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(128);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};


 // 













var areaStyle = {
  "default": {
    "style": {
      "fill": "#5B8FF9",
      "fillOpacity": 0.25,
      "stroke": null
    }
  },
  "active": {
    "style": {
      "fillOpacity": 0.5
    }
  },
  "inactive": {
    "style": {
      "fillOpacity": 0.4
    }
  },
  "selected": {
    "style": {
      "fillOpacity": 0.5
    }
  }
};

var LineAdvance = function LineAdvance(props) {
  var point = props.point,
      area = props.area,
      shape = props.shape,
      cfg = __rest(props, ["point", "area", "shape"]);

  var pointCfg = {
    shape: 'circle'
  };
  var areaCfg = {
    shape: shape === 'smooth' ? 'gradient-smooth' : 'gradient'
  };
  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])();
  var theme = view.getTheme(); // todo: g2

  theme.geometries.area.gradient = areaStyle; // todo: g2

  theme.geometries.area['gradient-smooth'] = areaStyle; // shared

  if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'shared']) === undefined) {
    _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'shared'], true);
  }

  ; // showCrosshairs

  if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'showCrosshairs']) === undefined) {
    _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'showCrosshairs'], true);
  }

  ;

  if (_antv_util_lib_get__WEBPACK_IMPORTED_MODULE_7___default()(view, ['options', 'tooltip', 'showMarkers']) === undefined) {
    _antv_util_lib_set__WEBPACK_IMPORTED_MODULE_8___default()(view, ['options', 'tooltip', 'showMarkers'], true);
  }

  ;

  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default()(pointCfg)) {
    _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default()(pointCfg, point);
  }

  if (_antv_util_lib_is_object__WEBPACK_IMPORTED_MODULE_5___default()(areaCfg)) {
    _antv_util_lib_deep_mix__WEBPACK_IMPORTED_MODULE_6___default()(areaCfg, area);
  }

  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_1___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Line__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
    shape: shape,
    state: {
      "default": {
        style: {
          shadowColor: '#ddd',
          shadowBlur: 3,
          shadowOffsetY: 2
        }
      },
      active: {
        style: {
          shadowColor: '#ddd',
          shadowBlur: 3,
          shadowOffsetY: 5
        }
      }
    }
  }, cfg)), !!area && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Area__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg, {
    tooltip: false
  }, areaCfg)), !!point && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_Point__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({
    size: 3
  }, cfg, {
    state: {
      active: {
        style: {
          stroke: '#fff',
          lineWidth: 1.5,
          strokeOpacity: 0.9
        }
      }
    },
    tooltip: false
  }, pointCfg)));
}; // Area  shape


Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerShape"])('area', 'gradient', {
  draw: function draw(cfg, container) {
    var attrs = Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getShapeAttrs"])(cfg, false, false, this);
    var c = attrs.fill;
    var clr = d3_color__WEBPACK_IMPORTED_MODULE_10__["color"](c);

    if (clr) {
      attrs.fill = "l (90) 0:".concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 1).formatRgb(), " 1:").concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 0.1).formatRgb());
    } // attrs.fill = 'red';


    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  }
});
/**
 * 
 */

Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerShape"])('area', 'gradient-smooth', {
  draw: function draw(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getShapeAttrs"])(cfg, false, true, this, Object(_antv_g2_lib_geometry_shape_area_util__WEBPACK_IMPORTED_MODULE_2__["getConstraint"])(coordinate));
    var c = attrs.fill;
    var clr = d3_color__WEBPACK_IMPORTED_MODULE_10__["color"](c);

    if (clr) {
      attrs.fill = "l (90) 0:".concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 1).formatRgb(), " 1:").concat(d3_color__WEBPACK_IMPORTED_MODULE_10__["rgb"](clr.r, clr.g, clr.b, 0.1).formatRgb());
    } // attrs.fill = 'red';


    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  }
});
/* harmony default export */ __webpack_exports__["a"] = (LineAdvance);

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var superPropBase = __webpack_require__(905);

function _get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    module.exports = _get = Reflect.get;
  } else {
    module.exports = _get = function _get(target, property, receiver) {
      var base = superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return _get(target, property, receiver || target);
}

module.exports = _get;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fadeOut = exports.fadeIn = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 *  shape 
 * 
 * @param shape 
 * @param animateCfg 
 * @param cfg 
 */


function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: util_1.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity'),
    strokeOpacity: util_1.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity'),
    opacity: util_1.isNil(shape.attr('opacity')) ? 1 : shape.attr('opacity')
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}

exports.fadeIn = fadeIn;
/**
 * @ignore
 *  shape 
 * 
 * @param shape 
 * @param animateCfg 
 * @param cfg 
 */

function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing,
      duration = animateCfg.duration,
      delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function () {
    shape.remove(true);
  }, delay);
}

exports.fadeOut = fadeOut;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scaleInY = exports.scaleInX = void 0;

var matrix_util_1 = __webpack_require__(33);
/**
 * @ignore
 *  x 
 * @param shape
 * @param animateCfg
 * @param shapeModel
 */


function scaleInX(shape, animateCfg, cfg) {
  var box = shape.getBBox();
  var mappingData = shape.get('origin').mappingData;
  var points = mappingData.points; // x 

  var x = points[0].y - points[1].y > 0 ? box.maxX : box.minX;
  var y = (box.minY + box.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 1], ['t', x, y]])
  }, animateCfg);
}

exports.scaleInX = scaleInX;
/**
 * @ignore
 *  y 
 * @param shape
 * @param animateCfg
 * @param shapeModel
 */

function scaleInY(shape, animateCfg, cfg) {
  var box = shape.getBBox();
  var mappingData = shape.get('origin').mappingData;
  var x = (box.minX + box.maxX) / 2;
  var points = mappingData.points; //  shape 

  var y = points[0].y - points[1].y <= 0 ? box.maxY : box.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 100], ['t', x, y]])
  }, animateCfg);
}

exports.scaleInY = scaleInY;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zoomOut = exports.zoomIn = void 0;

var tslib_1 = __webpack_require__(1);

var matrix_util_1 = __webpack_require__(33);

var util_1 = __webpack_require__(0);

function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    util_1.each(shape.getChildren(), function (child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);

    if (type === 'zoomIn') {
      // 
      var matrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 100], ['t', x, y]])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]])
      }, tslib_1.__assign(tslib_1.__assign({}, animateCfg), {
        callback: function callback() {
          shape.remove(true);
        }
      }));
    }
  }
}
/**
 * @ignore
 *  shape 
 * shape 
 * @param shape 
 * @param animateCfg 
 * @param cfg 
 */


function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, 'zoomIn');
}

exports.zoomIn = zoomIn;
/**
 * @ignore
 *  shape 
 * shape 
 * @param shape 
 * @param animateCfg 
 * @param cfg 
 */

function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, 'zoomOut');
}

exports.zoomOut = zoomOut;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.overlap = exports.fixedOverlap = void 0;

var util_1 = __webpack_require__(0);

var MAX_TIMES = 100;
/**
 * @ignore
 * Greedy 
 */

var Greedy =
/** @class */
function () {
  function Greedy(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    this.bitmap = {};
    var _a = cfg.xGap,
        xGap = _a === void 0 ? 1 : _a,
        _b = cfg.yGap,
        yGap = _b === void 0 ? 8 : _b;
    this.xGap = xGap;
    this.yGap = yGap;
  }

  Greedy.prototype.hasGap = function (bbox) {
    var hasGap = true;
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY);

    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
        continue;
      }

      if (i === minX || i === maxX) {
        for (var j = minY; j <= maxY; j++) {
          if (bitmap[i][j]) {
            hasGap = false;
            break;
          }
        }
      } else {
        if (bitmap[i][minY] || bitmap[i][maxY]) {
          hasGap = false;
          break;
        }
      }
    }

    return hasGap;
  };

  Greedy.prototype.fillGap = function (bbox) {
    var bitmap = this.bitmap;
    var minX = Math.round(bbox.minX);
    var maxX = Math.round(bbox.maxX);
    var minY = Math.round(bbox.minY);
    var maxY = Math.round(bbox.maxY); // filling grid

    for (var i = minX; i <= maxX; i += 1) {
      if (!bitmap[i]) {
        bitmap[i] = {};
      }
    }

    for (var i = minX; i <= maxX; i += this.xGap) {
      for (var j = minY; j <= maxY; j += this.yGap) {
        bitmap[i][j] = true;
      }

      bitmap[i][maxY] = true;
    } // filling y edges


    if (this.yGap !== 1) {
      for (var i = minY; i <= maxY; i += 1) {
        bitmap[minX][i] = true;
        bitmap[maxX][i] = true;
      }
    } // filling x edges


    if (this.xGap !== 1) {
      for (var i = minX; i <= maxX; i += 1) {
        bitmap[i][minY] = true;
        bitmap[i][maxY] = true;
      }
    }
  };

  Greedy.prototype.destroy = function () {
    this.bitmap = {};
  };

  return Greedy;
}();

function spiralFill(label, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }

  var dt = -1;

  var _a = label.attr(),
      x = _a.x,
      y = _a.y;

  var bbox = label.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;

  var f = function f(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };

  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }

  var canFill = false;
  var times = 0;
  var accessedCache = {};

  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];

    if (!dx && !dy || accessedCache[dx + "-" + dy]) {
      continue;
    }

    label.attr({
      x: x + dx,
      y: y + dy
    });

    if (dx + dy < 0) {
      label.attr('textAlign', 'right');
    }

    times++;

    if (greedy.hasGap(label.getCanvasBBox())) {
      greedy.fillGap(label.getCanvasBBox());
      canFill = true;
      accessedCache[dx + "-" + dy] = true;
      break;
    }
  }

  return canFill;
}
/*
 *  label
 *                5
 *        ------------------
 *        |    1   |   0   |
 *    8   4   7
 *        |    2   |   3   |
 *        
 *                 6
 */


function adjustLabelPosition(label, x, y, index) {
  var _a = label.getCanvasBBox(),
      width = _a.width,
      height = _a.height;

  var attrs = {
    x: x,
    y: y,
    textAlign: 'center'
  };

  switch (index) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = 'left';
      break;

    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = 'right';
      break;

    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = 'right';
      break;

    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = 'left';
      break;

    case 5:
      attrs.y -= height * 2 + 2;
      break;

    case 6:
      attrs.y += height * 2 + 2;
      break;

    case 7:
      attrs.x += width + 1;
      attrs.textAlign = 'left';
      break;

    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = 'right';
      break;

    default:
      break;
  }

  label.attr(attrs);
  return label.getCanvasBBox();
}
/**
 * @ignore
 * label  label  label 
 *  'overlap'  label 
 * @param labels  label 
 */


function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  util_1.each(labels, function (label) {
    var labelShape = label.find(function (shape) {
      return shape.get('type') === 'text';
    });

    if (!spiralFill(labelShape, greedy)) {
      label.remove(true);
    }
  });
  greedy.destroy();
}

exports.fixedOverlap = fixedOverlap;
/**
 * @ignore
 * label  label   label  label **** label
 * @param labels  label 
 */

function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  util_1.each(labels, function (label) {
    var labelShape = label.find(function (shape) {
      return shape.get('type') === 'text';
    });

    var _a = labelShape.attr(),
        x = _a.x,
        y = _a.y;

    var canFill = false;

    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);

      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }

    if (!canFill) {
      label.remove(true);
    }
  });
  greedy.destroy();
}

exports.overlap = overlap;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var highlight_util_1 = __webpack_require__(287);

var range_state_1 = tslib_1.__importDefault(__webpack_require__(285));
/**
 * @ignore
 *  highlight  Action
 */


var ElementRangeHighlight =
/** @class */
function (_super) {
  tslib_1.__extends(ElementRangeHighlight, _super);

  function ElementRangeHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  } //  active unactive 


  ElementRangeHighlight.prototype.clearViewState = function (view) {
    highlight_util_1.clearHighlight(view);
  };
  /**
   *  highlight
   */


  ElementRangeHighlight.prototype.highlight = function () {
    this.setState();
  };

  ElementRangeHighlight.prototype.setElementsState = function (elements, enable, allElements) {
    highlight_util_1.setHighlightBy(allElements, function (el) {
      return elements.indexOf(el) >= 0;
    }, enable);
  };

  return ElementRangeHighlight;
}(range_state_1.default);

exports.default = ElementRangeHighlight;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var list_highlight_util_1 = __webpack_require__(966);

var list_state_1 = tslib_1.__importDefault(__webpack_require__(193));

var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
/**
 * highlight Action  active  inactive 
 * @class
 * @ignore
 */

var ListHighlight =
/** @class */
function (_super) {
  tslib_1.__extends(ListHighlight, _super);

  function ListHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = STATUS_ACTIVE;
    _this.ignoreItemStates = ['unchecked']; //  unchecked 

    return _this;
  } //  item.name  highlight 


  ListHighlight.prototype.setItemsState = function (list, name, enable) {
    this.setHighlightBy(list, function (item) {
      return item.name === name;
    }, enable);
  }; //  item 


  ListHighlight.prototype.setItemState = function (list, item, enable) {
    var items = list.getItems();
    this.setHighlightBy(list, function (el) {
      return el === item;
    }, enable);
  }; //  highlight


  ListHighlight.prototype.setHighlightBy = function (list, callback, enable) {
    var items = list.getItems();

    if (enable) {
      //  highlight  Highlight 
      util_1.each(items, function (item) {
        if (callback(item)) {
          if (list.hasState(item, STATUS_UNACTIVE)) {
            list.setItemState(item, STATUS_UNACTIVE, false);
          }

          list.setItemState(item, STATUS_ACTIVE, true);
        } else if (!list.hasState(item, STATUS_ACTIVE)) {
          list.setItemState(item, STATUS_UNACTIVE, true);
        }
      });
    } else {
      var activeItems = list.getItemsByState(STATUS_ACTIVE);
      var allCancel_1 = true; //  activeItems 

      util_1.each(activeItems, function (item) {
        if (!callback(item)) {
          allCancel_1 = false;
          return false;
        }
      });

      if (allCancel_1) {
        this.clear();
      } else {
        //  highlight,  element  unactive
        //  element 
        util_1.each(items, function (item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_ACTIVE)) {
              list.setItemState(item, STATUS_ACTIVE, false);
            }

            list.setItemState(item, STATUS_UNACTIVE, true);
          }
        });
      }
    }
  };
  /**
   * highlight 
   */


  ListHighlight.prototype.highlight = function () {
    this.setState();
  }; //  active  unactive


  ListHighlight.prototype.clear = function () {
    var triggerInfo = this.getTriggerListInfo();

    if (triggerInfo) {
      list_highlight_util_1.clearList(triggerInfo.list);
    } else {
      //  component 
      var components = this.getAllowComponents();
      util_1.each(components, function (component) {
        component.clearItemsState(STATUS_ACTIVE);
        component.clearItemsState(STATUS_UNACTIVE);
      });
    }
  };

  return ListHighlight;
}(list_state_1.default);

exports.default = ListHighlight;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
}

exports.default = debounce;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* from @antv */

/**
 * Our default sum is the [Kahan-Babuska algorithm](https://pdfs.semanticscholar.org/1760/7d467cda1d0277ad272deb2113533131dc09.pdf).
 * This method is an improvement over the classical
 * [Kahan summation algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm).
 * It aims at computing the sum of a list of numbers while correcting for
 * floating-point errors. Traditionally, sums are calculated as many
 * successive additions, each one with its own floating-point roundoff. These
 * losses in precision add up as the number of numbers increases. This alternative
 * algorithm is more accurate than the simple way of calculating sums by simple
 * addition.
 *
 * This runs on `O(n)`, linear time in respect to the array.
 *
 * @param {Array<number>} x input
 * @return {number} sum of all input numbers
 * @example
 * sum([1, 2, 3]); // => 6
 */
function sumFnc(x) {
  // If the array is empty, we needn't bother computing its sum
  if (x.length === 0) {
    return 0;
  } // Initializing the sum as the first number in the array


  var sum = x[0]; // Keeping track of the floating-point error correction

  var correction = 0;
  var transition;

  for (var i = 1; i < x.length; i++) {
    transition = sum + x[i]; // Here we need to update the correction in a different fashion
    // if the new absolute value is greater than the absolute sum

    if (Math.abs(sum) >= Math.abs(x[i])) {
      correction += sum - transition + x[i];
    } else {
      correction += x[i] - transition + sum;
    }

    sum = transition;
  } // Returning the corrected sum


  return sum + correction;
}

/* harmony default export */ __webpack_exports__["a"] = (sumFnc);

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function get() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.delete = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function defineConfigurable(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function getWindowOf(target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations.delete(target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

var _default = index;
exports.default = _default;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(359)))

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_object_like_1 = __webpack_require__(471);

var is_array_like_1 = __webpack_require__(988);

var is_string_1 = __webpack_require__(50);

var isEqual = function isEqual(value, other) {
  if (value === other) {
    return true;
  }

  if (!value || !other) {
    return false;
  }

  if (is_string_1.default(value) || is_string_1.default(other)) {
    return false;
  }

  if (is_array_like_1.default(value) || is_array_like_1.default(other)) {
    if (value.length !== other.length) {
      return false;
    }

    var rst = true;

    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);

      if (!rst) {
        break;
      }
    }

    return rst;
  }

  if (is_object_like_1.default(value) || is_object_like_1.default(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);

    if (valueKeys.length !== otherKeys.length) {
      return false;
    }

    var rst = true;

    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);

      if (!rst) {
        break;
      }
    }

    return rst;
  }

  return false;
};

exports.default = isEqual;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Line = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(491);

__webpack_require__(1019);

var Line =
/** @class */
function (_super) {
  tslib_1.__extends(Line, _super);

  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'line';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Line.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *   
   */


  Line.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
          type: 'x'
        }
      },
      legend: {
        position: 'top-left'
      },
      isStack: false
    });
  };
  /**
   *   
   */


  Line.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Line;
}(plot_1.Plot);

exports.Line = Line;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pie = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1054);

var contants_1 = __webpack_require__(501);

var utils_1 = __webpack_require__(502);

__webpack_require__(1055);

var Pie =
/** @class */
function (_super) {
  tslib_1.__extends(Pie, _super);

  function Pie() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'pie';
    return _this;
  }
  /**
   *   
   * @static 
   */


  Pie.getDefaultOptions = function () {
    return contants_1.DEFAULT_OPTIONS;
  };
  /**
   * 
   * @param data
   */


  Pie.prototype.changeData = function (data) {
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = utils_1.processIllegalData(prevOptions.data, angleField);
    var curData = utils_1.processIllegalData(data, angleField); //  0

    if (utils_1.isAllZero(prevData, angleField) || utils_1.isAllZero(curData, angleField)) {
      this.update({
        data: data
      });
    } else {
      this.updateOption({
        data: data
      });
      this.chart.data(curData); // todo  G2  afterrender  annotations

      adaptor_1.pieAnnotation({
        chart: this.chart,
        options: this.options
      });
      this.chart.render(true);
    }
  };
  /**
   *   ,  base 
   */


  Pie.prototype.getDefaultOptions = function () {
    return Pie.getDefaultOptions();
  };
  /**
   *   
   */


  Pie.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Pie;
}(plot_1.Plot);

exports.Pie = Pie;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scatter = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1077);

__webpack_require__(498);

var Scatter =
/** @class */
function (_super) {
  tslib_1.__extends(Scatter, _super);

  function Scatter() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'point';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Scatter.prototype.changeData = function (data) {
    this.updateOption(adaptor_1.transformOptions(utils_1.deepAssign({}, this.options, {
      data: data
    })));

    var _a = this,
        options = _a.options,
        chart = _a.chart;

    adaptor_1.meta({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
  /**
   * 
   */


  Scatter.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  Scatter.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      size: 4,
      tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: true,
        crosshairs: {
          type: 'xy'
        }
      }
    });
  };

  return Scatter;
}(plot_1.Plot);

exports.Scatter = Scatter;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.Shape = void 0;

var tslib_1 = __webpack_require__(1);

var Shape = __webpack_require__(142);

exports.Shape = Shape;

tslib_1.__exportStar(__webpack_require__(27), exports);

var canvas_1 = __webpack_require__(868);

Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return canvas_1.default;
  }
});

var group_1 = __webpack_require__(258);

Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return group_1.default;
  }
});

var arc_params_1 = __webpack_require__(426);

Object.defineProperty(exports, "getArcParams", {
  enumerable: true,
  get: function get() {
    return arc_params_1.default;
  }
});
exports.version = '0.5.6';

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(616);

module.exports = Function.prototype.bind || implementation;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var isObjectLike = function isObjectLike(value) {
  /**
   * isObjectLike({}) => true
   * isObjectLike([1, 2, 3]) => true
   * isObjectLike(Function) => false
   * isObjectLike(null) => false
   */
  return (0, _typeof2.default)(value) === 'object' && value !== null;
};

var _default = isObjectLike;
exports.default = _default;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mix;

// FIXME: Mutable param should be forbidden in static lang.
function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {
      dist[key] = obj[key];
    }
  }
}

function mix(dist, src1, src2, src3) {
  if (src1) _mix(dist, src1);
  if (src2) _mix(dist, src2);
  if (src3) _mix(dist, src3);
  return dist;
}

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.detect = detect;
exports.browserName = browserName;
exports.parseUserAgent = parseUserAgent;
exports.detectOS = detectOS;
exports.getNodeVersion = getNodeVersion;
exports.ReactNativeInfo = exports.BotInfo = exports.SearchBotDeviceInfo = exports.NodeInfo = exports.BrowserInfo = void 0;

var __spreadArrays = void 0 && (void 0).__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
};

var BrowserInfo =
/** @class */
function () {
  function BrowserInfo(name, version, os) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.type = 'browser';
  }

  return BrowserInfo;
}();

exports.BrowserInfo = BrowserInfo;

var NodeInfo =
/** @class */
function () {
  function NodeInfo(version) {
    this.version = version;
    this.type = 'node';
    this.name = 'node';
    this.os = process.platform;
  }

  return NodeInfo;
}();

exports.NodeInfo = NodeInfo;

var SearchBotDeviceInfo =
/** @class */
function () {
  function SearchBotDeviceInfo(name, version, os, bot) {
    this.name = name;
    this.version = version;
    this.os = os;
    this.bot = bot;
    this.type = 'bot-device';
  }

  return SearchBotDeviceInfo;
}();

exports.SearchBotDeviceInfo = SearchBotDeviceInfo;

var BotInfo =
/** @class */
function () {
  function BotInfo() {
    this.type = 'bot';
    this.bot = true; // NOTE: deprecated test name instead

    this.name = 'bot';
    this.version = null;
    this.os = null;
  }

  return BotInfo;
}();

exports.BotInfo = BotInfo;

var ReactNativeInfo =
/** @class */
function () {
  function ReactNativeInfo() {
    this.type = 'react-native';
    this.name = 'react-native';
    this.version = null;
    this.os = null;
  }

  return ReactNativeInfo;
}();

exports.ReactNativeInfo = ReactNativeInfo;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /EdgA?\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['searchbot', SEARCHBOX_UA_REGEX]];
var operatingSystemRules = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];

function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }

  if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return new ReactNativeInfo();
  }

  if (typeof navigator !== 'undefined') {
    return parseUserAgent(navigator.userAgent);
  }

  return getNodeVersion();
}

function matchUserAgent(ua) {
  // opted for using reduce here rather than Array#first with a regex.test call
  // this is primarily because using the reduce we only perform the regex
  // execution once rather than once for the test and for the exec again below
  // probably something that needs to be benchmarked though
  return ua !== '' && userAgentRules.reduce(function (matched, _a) {
    var browser = _a[0],
        regex = _a[1];

    if (matched) {
      return matched;
    }

    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}

function browserName(ua) {
  var data = matchUserAgent(ua);
  return data ? data[0] : null;
}

function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);

  if (!matchedRule) {
    return null;
  }

  var name = matchedRule[0],
      match = matchedRule[1];

  if (name === 'searchbot') {
    return new BotInfo();
  }

  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);

  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }

  var version = versionParts.join('.');
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);

  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }

  return new BrowserInfo(name, version, os);
}

function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii],
        os = _a[0],
        regex = _a[1];
    var match = regex.exec(ua);

    if (match) {
      return os;
    }
  }

  return null;
}

function getNodeVersion() {
  var isNode = typeof process !== 'undefined' && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}

function createVersionParts(count) {
  var output = [];

  for (var ii = 0; ii < count; ii++) {
    output.push('0');
  }

  return output;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(703)))

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.multiplyMatrix = multiplyMatrix;
exports.multiplyVec2 = multiplyVec2;
exports.invert = invert;

/**
 * @fileoverview  gl-matrix,  g-mobile  g-webgl  matrix 
 *  2D  gl-matrix
 * @author dxq613@gmail.com
 */

/**
 * 3
 * @param {number[]} a 1
 * @param {number[]} b 2
 */
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * 32
 * @param {number[]} m 
 * @param {number[]} v 
 */


function multiplyVec2(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * 
 * @param {number[]} a 
 */


function invert(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.now = now;
exports.Timer = Timer;
exports.timer = timer;
exports.timerFlush = timerFlush;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = (typeof performance === "undefined" ? "undefined" : (0, _typeof2.default)(performance)) === "object" && performance.now ? performance : Date,
    setFrame = (typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function restart(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function stop() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend weve set an alarm, if we havent already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _d3Color = __webpack_require__(61);

var _rgb = _interopRequireDefault(__webpack_require__(389));

var _array = __webpack_require__(392);

var _date = _interopRequireDefault(__webpack_require__(393));

var _number = _interopRequireDefault(__webpack_require__(177));

var _object = _interopRequireDefault(__webpack_require__(394));

var _string = _interopRequireDefault(__webpack_require__(395));

var _constant = _interopRequireDefault(__webpack_require__(391));

var _numberArray = _interopRequireWildcard(__webpack_require__(246));

function _default(a, b) {
  var t = (0, _typeof2.default)(b),
      c;
  return b == null || t === "boolean" ? (0, _constant.default)(b) : (t === "number" ? _number.default : t === "string" ? (c = (0, _d3Color.color)(b)) ? (b = c, _rgb.default) : _string.default : b instanceof _d3Color.color ? _rgb.default : b instanceof Date ? _date.default : (0, _numberArray.isNumberArray)(b) ? _numberArray.default : Array.isArray(b) ? _array.genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object.default : _number.default)(a, b);
}

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = Color;
exports.default = color;
exports.rgbConvert = rgbConvert;
exports.rgb = rgb;
exports.Rgb = Rgb;
exports.hslConvert = hslConvert;
exports.hsl = hsl;
exports.brighter = exports.darker = void 0;

var _define = _interopRequireWildcard(__webpack_require__(244));

function Color() {}

var _darker = 0.7;
exports.darker = _darker;

var _brighter = 1 / _darker;

exports.brighter = _brighter;
var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0, _define.default)(Color, color, {
  copy: function copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
  : l === 3 ? new Rgb(m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
  : l === 4 ? rgba(m >> 12 & 0xf | m >> 8 & 0xf0, m >> 8 & 0xf | m >> 4 & 0xf0, m >> 4 & 0xf | m & 0xf0, ((m & 0xf) << 4 | m & 0xf) / 0xff) // #f000
  : null // invalid hex
  ) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
  : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Rgb, rgb, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function rgb() {
    return this;
  },
  displayable: function displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}

function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Hsl, hsl, (0, _define.extend)(Color, {
  brighter: function brighter(k) {
    k = k == null ? _brighter : Math.pow(_brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _darker : Math.pow(_darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl: function formatHsl() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.extend = extend;

function _default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) {
    prototype[key] = definition[key];
  }

  return prototype;
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basis = basis;
exports.default = _default;

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}

function _default(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.isNumberArray = isNumberArray;

function _default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0,
      c = b.slice(),
      i;
  return function (t) {
    for (i = 0; i < n; ++i) {
      c[i] = a[i] * (1 - t) + b[i] * t;
    }

    return c;
  };
}

function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeBBox = mergeBBox;
exports.mergeArrowBBox = mergeArrowBBox;

// 
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }

  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
} // 


function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get('startArrowShape');
  var endArrowShape = shape.get('endArrowShape');
  var startArrowBBox = null;
  var endArrowBBox = null;

  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }

  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }

  return bbox;
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GAP = exports.DODGE_RATIO = exports.MARGIN_RATIO = exports.DEFAULT_Y = void 0;
var DEFAULT_Y = 0; //  y 
// 

exports.DEFAULT_Y = DEFAULT_Y;
var MARGIN_RATIO = 1 / 2;
exports.MARGIN_RATIO = MARGIN_RATIO;
var DODGE_RATIO = 1 / 2; // 

exports.DODGE_RATIO = DODGE_RATIO;
var GAP = 0.05;
exports.GAP = GAP;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  Attribute: true,
  Color: true,
  Opacity: true,
  Position: true,
  Shape: true,
  Size: true,
  getAttribute: true,
  registerAttribute: true
};
Object.defineProperty(exports, "Attribute", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Color", {
  enumerable: true,
  get: function get() {
    return _color.default;
  }
});
Object.defineProperty(exports, "Opacity", {
  enumerable: true,
  get: function get() {
    return _opacity.default;
  }
});
Object.defineProperty(exports, "Position", {
  enumerable: true,
  get: function get() {
    return _position.default;
  }
});
Object.defineProperty(exports, "Shape", {
  enumerable: true,
  get: function get() {
    return _shape.default;
  }
});
Object.defineProperty(exports, "Size", {
  enumerable: true,
  get: function get() {
    return _size.default;
  }
});
Object.defineProperty(exports, "getAttribute", {
  enumerable: true,
  get: function get() {
    return _factory.getAttribute;
  }
});
Object.defineProperty(exports, "registerAttribute", {
  enumerable: true,
  get: function get() {
    return _factory.registerAttribute;
  }
});

var _base = _interopRequireDefault(__webpack_require__(103));

var _color = _interopRequireDefault(__webpack_require__(771));

var _opacity = _interopRequireDefault(__webpack_require__(772));

var _position = _interopRequireDefault(__webpack_require__(773));

var _shape = _interopRequireDefault(__webpack_require__(774));

var _size = _interopRequireDefault(__webpack_require__(775));

var _factory = __webpack_require__(776);

var _interface = __webpack_require__(411);

Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
(0, _factory.registerAttribute)('Color', _color.default);
(0, _factory.registerAttribute)('Opacity', _opacity.default);
(0, _factory.registerAttribute)('Position', _position.default);
(0, _factory.registerAttribute)('Shape', _shape.default);
(0, _factory.registerAttribute)('Size', _size.default);

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = intervalTicks;

var _util = __webpack_require__(0);

function snapMultiple(v, base, snapType) {
  var div;

  if (snapType === 'ceil') {
    div = Math.ceil(v / base);
  } else if (snapType === 'floor') {
    div = Math.floor(v / base);
  } else {
    div = Math.round(v / base);
  }

  return div * base;
}

function intervalTicks(min, max, interval) {
  //  interval 
  var minTick = snapMultiple(min, interval, 'floor');
  var maxTick = snapMultiple(max, interval, 'ceil'); // 

  minTick = (0, _util.fixedBase)(minTick, interval);
  maxTick = (0, _util.fixedBase)(maxTick, interval);
  var ticks = [];

  for (var i = minTick; i <= maxTick; i = i + interval) {
    var tickValue = (0, _util.fixedBase)(i, interval); // 

    ticks.push(tickValue);
  }

  return {
    min: minTick,
    max: maxTick,
    ticks: ticks
  };
}

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = strictLimit;

var _util = __webpack_require__(0);

/**
 *  minLimit/maxLimit/tickCount  ticks
 *
 * @param cfg Scale 
 * @return ticks
 */
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a;

  var minLimit = cfg.minLimit,
      maxLimit = cfg.maxLimit,
      min = cfg.min,
      max = cfg.max,
      _b = cfg.tickCount,
      tickCount = _b === void 0 ? 5 : _b;
  var tickMin = (0, _util.isNil)(minLimit) ? (0, _util.isNil)(defaultMin) ? min : defaultMin : minLimit;
  var tickMax = (0, _util.isNil)(maxLimit) ? (0, _util.isNil)(defaultMax) ? max : defaultMax : maxLimit;

  if (tickMin > tickMax) {
    _a = [tickMin, tickMax], tickMax = _a[0], tickMin = _a[1];
  }

  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }

  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];

  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }

  return ticks;
}

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _util = __webpack_require__(0);

var LOCATION_FIELD_MAP = {
  none: [],
  point: ['x', 'y'],
  region: ['start', 'end'],
  points: ['points'],
  circle: ['center', 'radius', 'startAngle', 'endAngle']
};

var Component =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Component, _super);

  function Component(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.initCfg();

    return _this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  Component.prototype.getDefaultCfg = function () {
    return {
      id: '',
      name: '',
      type: '',
      locationType: 'none',
      offsetX: 0,
      offsetY: 0,
      animate: false,
      capture: true,
      updateAutoRender: false,
      animateOption: {
        appear: null,
        update: {
          duration: 400,
          easing: 'easeQuadInOut'
        },
        enter: {
          duration: 400,
          easing: 'easeQuadInOut'
        },
        leave: {
          duration: 350,
          easing: 'easeQuadIn'
        }
      },
      events: null,
      defaultCfg: {},
      visible: true
    };
  };
  /**
   *  render 
   * @example
   * axis.clear();
   * axis.render();
   */


  Component.prototype.clear = function () {};
  /**
   * 
   * @param {object} cfg 
   */


  Component.prototype.update = function (cfg) {
    var _this = this;

    var defaultCfg = this.get('defaultCfg');
    (0, _util.each)(cfg, function (value, name) {
      var originCfg = _this.get(name);

      var newCfg = value;

      if (originCfg !== value) {
        //  null 
        if ((0, _util.isObject)(value) && defaultCfg[name]) {
          // 
          newCfg = (0, _util.deepMix)({}, defaultCfg[name], value);
        }

        _this.set(name, newCfg);
      }
    });
    this.updateInner(cfg);
    this.afterUpdate(cfg);
  }; // 


  Component.prototype.updateInner = function (cfg) {};

  Component.prototype.afterUpdate = function (cfg) {
    // 
    if ((0, _util.hasKey)(cfg, 'visible')) {
      if (cfg.visible) {
        this.show();
      } else {
        this.hide();
      }
    } // capture


    if ((0, _util.hasKey)(cfg, 'capture')) {
      this.setCapture(cfg.capture);
    }
  };

  Component.prototype.getLayoutBBox = function () {
    return this.getBBox(); //  getBBox
  };

  Component.prototype.getLocationType = function () {
    return this.get('locationType');
  };

  Component.prototype.getOffset = function () {
    return {
      offsetX: this.get('offsetX'),
      offsetY: this.get('offsetY')
    };
  }; //  update


  Component.prototype.setOffset = function (offsetX, offsetY) {
    this.update({
      offsetX: offsetX,
      offsetY: offsetY
    });
  };

  Component.prototype.setLocation = function (cfg) {
    var location = (0, _tslib.__assign)({}, cfg);
    this.update(location);
  }; //  ILocation  getLocation


  Component.prototype.getLocation = function () {
    var _this = this;

    var location = {};
    var locationType = this.get('locationType');
    var fields = LOCATION_FIELD_MAP[locationType];
    (0, _util.each)(fields, function (field) {
      location[field] = _this.get(field);
    });
    return location;
  };

  Component.prototype.isList = function () {
    return false;
  };

  Component.prototype.isSlider = function () {
    return false;
  };
  /**
   * @protected
   * 
   */


  Component.prototype.init = function () {}; // 


  Component.prototype.initCfg = function () {
    var _this = this;

    var defaultCfg = this.get('defaultCfg');
    (0, _util.each)(defaultCfg, function (value, name) {
      var cfg = _this.get(name);

      if ((0, _util.isObject)(cfg)) {
        var newCfg = (0, _util.deepMix)({}, value, cfg);

        _this.set(name, newCfg);
      }
    });
  };

  return Component;
}(_gBase.Base);

var _default = Component;
exports.default = _default;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _matrixUtil = __webpack_require__(33);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _matrix = __webpack_require__(87);

var _state = __webpack_require__(422);

var _theme = _interopRequireDefault(__webpack_require__(60));

var AxisBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(AxisBase, _super);

  function AxisBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AxisBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'axis',
      ticks: [],
      line: {},
      tickLine: {},
      subTickLine: null,
      title: null,

      /**
       * 
       */
      label: {},

      /**
       * titletickLine 
       */
      verticalFactor: 1,
      // 
      verticalLimitLength: null,
      overlapOrder: ['autoRotate', 'autoEllipsis', 'autoHide'],
      tickStates: {},
      optimize: {},
      defaultCfg: {
        line: {
          // @type {Attrs} ,null
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        },
        tickLine: {
          // @type {Attrs} 
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          },
          alignTick: true,
          length: 5,
          displayWithLabel: true
        },
        subTickLine: {
          // @type {Attrs} 
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          },
          count: 4,
          length: 2
        },
        label: {
          autoRotate: true,
          autoHide: false,
          autoEllipsis: false,
          style: {
            fontSize: 12,
            fill: _theme.default.textColor,
            fontFamily: _theme.default.fontFamily,
            fontWeight: 'normal'
          },
          offset: 10
        },
        title: {
          autoRotate: true,
          spacing: 5,
          position: 'center',
          style: {
            fontSize: 12,
            fill: _theme.default.textColor,
            textBaseline: 'middle',
            fontFamily: _theme.default.fontFamily,
            textAlign: 'center'
          }
        },
        tickStates: {
          active: {
            labelStyle: {
              fontWeight: 500
            },
            tickLineStyle: {
              lineWidth: 2
            }
          },
          inactive: {
            labelStyle: {
              fill: _theme.default.uncheckedColor
            }
          }
        },
        // 
        optimize: {
          enable: true,
          threshold: 400
        }
      },
      theme: {}
    });
  };
  /**
   * 
   */


  AxisBase.prototype.renderInner = function (group) {
    if (this.get('line')) {
      this.drawLine(group);
    } // drawTicks  drawLabels  drawTickLines


    this.drawTicks(group);

    if (this.get('title')) {
      this.drawTitle(group);
    }
  }; //  IList 


  AxisBase.prototype.isList = function () {
    return true;
  };
  /**
   * 
   * @return {ListItem[]} 
   */


  AxisBase.prototype.getItems = function () {
    return this.get('ticks');
  };
  /**
   * 
   * @param {ListItem[]} items 
   */


  AxisBase.prototype.setItems = function (items) {
    this.update({
      ticks: items
    });
  };
  /**
   * 
   * @param {ListItem} item 
   * @param {object}   cfg  
   */


  AxisBase.prototype.updateItem = function (item, cfg) {
    (0, _util.mix)(item, cfg);
    this.clear(); // 

    this.render();
  };
  /**
   * 
   */


  AxisBase.prototype.clearItems = function () {
    var itemGroup = this.getElementByLocalId('label-group');
    itemGroup && itemGroup.clear();
  };
  /**
   * 
   * @param {ListItem} item  
   * @param {string}   state 
   * @param {boolean}  value , true, false
   */


  AxisBase.prototype.setItemState = function (item, state, value) {
    item[state] = value;
    this.updateTickStates(item); // 
  };
  /**
   * 
   * @param {ListItem} item  
   * @param {boolean} state 
   */


  AxisBase.prototype.hasState = function (item, state) {
    return !!item[state];
  };

  AxisBase.prototype.getItemStates = function (item) {
    var tickStates = this.get('tickStates');
    var rst = [];
    (0, _util.each)(tickStates, function (v, k) {
      if (item[k]) {
        // item.selected
        rst.push(k);
      }
    });
    return rst;
  };
  /**
   * 
   * @param {string} state 
   */


  AxisBase.prototype.clearItemsState = function (state) {
    var _this = this;

    var items = this.getItemsByState(state);
    (0, _util.each)(items, function (item) {
      _this.setItemState(item, state, false);
    });
  };
  /**
   * 
   * @param  {string}     state [description]
   * @return {ListItem[]}       [description]
   */


  AxisBase.prototype.getItemsByState = function (state) {
    var _this = this;

    var items = this.getItems();
    return (0, _util.filter)(items, function (item) {
      return _this.hasState(item, state);
    });
  };

  AxisBase.prototype.getSidePoint = function (point, offset) {
    var self = this;
    var vector = self.getSideVector(offset, point);
    return {
      x: point.x + vector[0],
      y: point.y + vector[1]
    };
  };

  AxisBase.prototype.getTextAnchor = function (vector) {
    var align;

    if ((0, _util.isNumberEqual)(vector[0], 0)) {
      align = 'center';
    } else if (vector[0] > 0) {
      align = 'start';
    } else if (vector[0] < 0) {
      align = 'end';
    }

    return align;
  };

  AxisBase.prototype.getTextBaseline = function (vector) {
    var base;

    if ((0, _util.isNumberEqual)(vector[1], 0)) {
      base = 'middle';
    } else if (vector[1] > 0) {
      base = 'top';
    } else if (vector[1] < 0) {
      base = 'bottom';
    }

    return base;
  };

  AxisBase.prototype.processOverlap = function (labelGroup) {}; // 


  AxisBase.prototype.drawLine = function (group) {
    var path = this.getLinePath();
    var line = this.get('line'); // line  drawLine 

    this.addShape(group, {
      type: 'path',
      id: this.getElementId('line'),
      name: 'axis-line',
      attrs: (0, _util.mix)({
        path: path
      }, line.style)
    });
  };

  AxisBase.prototype.getTickLineItems = function (ticks) {
    var _this = this;

    var tickLineItems = [];
    var tickLine = this.get('tickLine');
    var alignTick = tickLine.alignTick;
    var tickLineLength = tickLine.length;
    var tickSegment = 1;
    var tickCount = ticks.length;

    if (tickCount >= 2) {
      tickSegment = ticks[1].value - ticks[0].value;
    }

    (0, _util.each)(ticks, function (tick) {
      var point = tick.point;

      if (!alignTick) {
        // tickLine  tick  point
        point = _this.getTickPoint(tick.value - tickSegment / 2);
      }

      var endPoint = _this.getSidePoint(point, tickLineLength);

      tickLineItems.push({
        startPoint: point,
        tickValue: tick.value,
        endPoint: endPoint,
        tickId: tick.id,
        id: "tickline-" + tick.id
      });
    }); //  tickLine  tickLine
    // if (!alignTick && tickCount > 0) {
    //   const tick = ticks[tickCount - 1];
    //   const point = this.getTickPoint(tick.value + tickSegment / 2);
    // }

    return tickLineItems;
  };

  AxisBase.prototype.getSubTickLineItems = function (tickLineItems) {
    var subTickLineItems = [];
    var subTickLine = this.get('subTickLine');
    var subCount = subTickLine.count;
    var tickLineCount = tickLineItems.length; //  2 

    if (tickLineCount >= 2) {
      for (var i = 0; i < tickLineCount - 1; i++) {
        var pre = tickLineItems[i];
        var next = tickLineItems[i + 1];

        for (var j = 0; j < subCount; j++) {
          var percent = (j + 1) / (subCount + 1);
          var tickValue = (1 - percent) * pre.tickValue + percent * next.tickValue;
          var point = this.getTickPoint(tickValue);
          var endPoint = this.getSidePoint(point, subTickLine.length);
          subTickLineItems.push({
            startPoint: point,
            endPoint: endPoint,
            tickValue: tickValue,
            id: "sub-" + pre.id + "-" + j
          });
        }
      }
    }

    return subTickLineItems;
  };

  AxisBase.prototype.getTickLineAttrs = function (tickItem, type, index, tickItems) {
    var style = this.get(type).style; //  grid 

    var item = {
      points: [tickItem.startPoint, tickItem.endPoint]
    };
    var defaultTickLineStyle = (0, _util.get)(this.get('theme'), ['tickLine', 'style'], {});
    style = (0, _util.isFunction)(style) ? (0, _util.mix)({}, defaultTickLineStyle, style(item, index, tickItems)) : style;
    var startPoint = tickItem.startPoint,
        endPoint = tickItem.endPoint;
    return (0, _tslib.__assign)({
      x1: startPoint.x,
      y1: startPoint.y,
      x2: endPoint.x,
      y2: endPoint.y
    }, style);
  }; // 


  AxisBase.prototype.drawTick = function (tickItem, tickLineGroup, type, index, tickItems) {
    this.addShape(tickLineGroup, {
      type: 'line',
      id: this.getElementId(tickItem.id),
      name: "axis-" + type,
      attrs: this.getTickLineAttrs(tickItem, type, index, tickItems)
    });
  }; // 


  AxisBase.prototype.drawTickLines = function (group) {
    var _this = this;

    var ticks = this.get('ticks');
    var subTickLine = this.get('subTickLine');
    var tickLineItems = this.getTickLineItems(ticks);
    var tickLineGroup = this.addGroup(group, {
      name: 'axis-tickline-group',
      id: this.getElementId('tickline-group')
    });
    var tickCfg = this.get('tickLine');
    (0, _util.each)(tickLineItems, function (item, index) {
      if (tickCfg.displayWithLabel) {
        //  label  label
        var labelId = _this.getElementId("label-" + item.tickId);

        if (group.findById(labelId)) {
          _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
        }
      } else {
        _this.drawTick(item, tickLineGroup, 'tickLine', index, tickLineItems);
      }
    });

    if (subTickLine) {
      var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
      (0, _util.each)(subTickLineItems_1, function (item, index) {
        _this.drawTick(item, tickLineGroup, 'subTickLine', index, subTickLineItems_1);
      });
    }
  }; //  ticks  id


  AxisBase.prototype.processTicks = function () {
    var _this = this;

    var ticks = this.get('ticks');
    (0, _util.each)(ticks, function (tick) {
      tick.point = _this.getTickPoint(tick.value); //  tick  id

      if ((0, _util.isNil)(tick.id)) {
        //  tick.name id
        tick.id = tick.name;
      }
    });
  }; //  ticks  tickLine


  AxisBase.prototype.drawTicks = function (group) {
    var _this = this;

    this.optimizeTicks();
    this.processTicks();

    if (this.get('label')) {
      this.drawLabels(group);
    }

    if (this.get('tickLine')) {
      this.drawTickLines(group);
    }

    var ticks = this.get('ticks');
    (0, _util.each)(ticks, function (tick) {
      _this.applyTickStates(tick, group);
    });
  };
  /**
   *  optimize  ticks  ticks 
   */


  AxisBase.prototype.optimizeTicks = function () {
    var optimize = this.get('optimize');
    var ticks = this.get('ticks');

    if (optimize && optimize.enable && optimize.threshold > 0) {
      var len = (0, _util.size)(ticks);

      if (len > optimize.threshold) {
        var page_1 = Math.ceil(len / optimize.threshold);
        var optimizedTicks = ticks.filter(function (tick, idx) {
          return idx % page_1 === 0;
        });
        this.set('ticks', optimizedTicks);
        this.set('originalTicks', ticks);
      }
    }
  }; //  label 


  AxisBase.prototype.getLabelAttrs = function (tick, index, ticks) {
    var labelCfg = this.get('label');
    var offset = labelCfg.offset,
        rotate = labelCfg.rotate,
        formatter = labelCfg.formatter;
    var point = this.getSidePoint(tick.point, offset);
    var vector = this.getSideVector(offset, point);
    var text = formatter ? formatter(tick.name, tick, index) : tick.name;
    var style = labelCfg.style;
    style = (0, _util.isFunction)(style) ? (0, _util.get)(this.get('theme'), ['label', 'style'], {}) : style;
    var attrs = (0, _util.mix)({
      x: point.x,
      y: point.y,
      text: text,
      textAlign: this.getTextAnchor(vector),
      textBaseline: this.getTextBaseline(vector)
    }, style);

    if (rotate) {
      attrs.matrix = (0, _matrix.getMatrixByAngle)(point, rotate);
    }

    return attrs;
  }; // 


  AxisBase.prototype.drawLabels = function (group) {
    var _this = this;

    var ticks = this.get('ticks');
    var labelGroup = this.addGroup(group, {
      name: 'axis-label-group',
      id: this.getElementId('label-group')
    });
    (0, _util.each)(ticks, function (tick, index) {
      _this.addShape(labelGroup, {
        type: 'text',
        name: 'axis-label',
        id: _this.getElementId("label-" + tick.id),
        attrs: _this.getLabelAttrs(tick, index, ticks),
        delegateObject: {
          tick: tick,
          item: tick,
          index: index
        }
      });
    });
    this.processOverlap(labelGroup); //  style 

    var labels = labelGroup.getChildren();
    var defaultLabelStyle = (0, _util.get)(this.get('theme'), ['label', 'style'], {});

    var _a = this.get('label'),
        style = _a.style,
        formatter = _a.formatter;

    if ((0, _util.isFunction)(style)) {
      var afterProcessTicks_1 = labels.map(function (label) {
        return (0, _util.get)(label.get('delegateObject'), 'tick');
      });
      (0, _util.each)(labels, function (label, index) {
        var tick = label.get('delegateObject').tick;
        var text = formatter ? formatter(tick.name, tick, index) : tick.name;
        var newStyle = (0, _util.mix)({}, defaultLabelStyle, style(text, index, afterProcessTicks_1));
        label.attr(newStyle);
      });
    }
  }; // 


  AxisBase.prototype.getTitleAttrs = function () {
    var titleCfg = this.get('title');
    var style = titleCfg.style,
        position = titleCfg.position,
        offset = titleCfg.offset,
        _a = titleCfg.spacing,
        spacing = _a === void 0 ? 0 : _a,
        autoRotate = titleCfg.autoRotate;
    var titleHeight = style.fontSize;
    var percent = 0.5;

    if (position === 'start') {
      percent = 0;
    } else if (position === 'end') {
      percent = 1;
    }

    var point = this.getTickPoint(percent); // 
    //  titleOffset  label offset

    var titlePoint = this.getSidePoint(point, offset || spacing + titleHeight / 2); // 

    var attrs = (0, _util.mix)({
      x: titlePoint.x,
      y: titlePoint.y,
      text: titleCfg.text
    }, style);
    var rotate = titleCfg.rotate; // rotate 

    var angle = rotate;

    if ((0, _util.isNil)(rotate) && autoRotate) {
      // 
      var vector = this.getAxisVector(point);
      var v1 = [1, 0]; // 

      angle = _matrixUtil.ext.angleTo(vector, v1, true);
    }

    if (angle) {
      var matrix = (0, _matrix.getMatrixByAngle)(titlePoint, angle);
      attrs.matrix = matrix;
    }

    return attrs;
  }; // 


  AxisBase.prototype.drawTitle = function (group) {
    this.addShape(group, {
      type: 'text',
      id: this.getElementId('title'),
      name: 'axis-title',
      attrs: this.getTitleAttrs()
    });
  };

  AxisBase.prototype.applyTickStates = function (tick, group) {
    var states = this.getItemStates(tick);

    if (states.length) {
      var tickStates = this.get('tickStates'); //  label  tickLine

      var labelId = this.getElementId("label-" + tick.id);
      var labelShape = group.findById(labelId);

      if (labelShape) {
        var labelStateStyle = (0, _state.getStatesStyle)(tick, 'label', tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }

      var tickLineId = this.getElementId("tickline-" + tick.id);
      var tickLineShape = group.findById(tickLineId);

      if (tickLineShape) {
        var tickLineStateStyle = (0, _state.getStatesStyle)(tick, 'tickLine', tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    }
  };

  AxisBase.prototype.updateTickStates = function (tick) {
    var states = this.getItemStates(tick);
    var tickStates = this.get('tickStates');
    var labelCfg = this.get('label');
    var labelShape = this.getElementByLocalId("label-" + tick.id);
    var tickLineCfg = this.get('tickLine');
    var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);

    if (states.length) {
      if (labelShape) {
        var labelStateStyle = (0, _state.getStatesStyle)(tick, 'label', tickStates);
        labelStateStyle && labelShape.attr(labelStateStyle);
      }

      if (tickLineShape) {
        var tickLineStateStyle = (0, _state.getStatesStyle)(tick, 'tickLine', tickStates);
        tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
      }
    } else {
      if (labelShape) {
        labelShape.attr(labelCfg.style);
      }

      if (tickLineShape) {
        tickLineShape.attr(tickLineCfg.style);
      }
    }
  };

  return AxisBase;
}(_groupComponent.default);

var _default = AxisBase;
exports.default = _default;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _matrix = __webpack_require__(87);

var _theme = _interopRequireDefault(__webpack_require__(60));

var _util2 = __webpack_require__(44);

var CrosshairBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(CrosshairBase, _super);

  function CrosshairBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CrosshairBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'crosshair',
      type: 'base',
      line: {},
      text: null,
      textBackground: {},
      capture: false,
      defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        },
        text: {
          position: 'start',
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: _theme.default.textColor,
            textAlign: 'center',
            textBaseline: 'middle',
            fontFamily: _theme.default.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: _theme.default.lineColor
          }
        }
      }
    });
  };

  CrosshairBase.prototype.renderInner = function (group) {
    if (this.get('line')) {
      this.renderLine(group);
    }

    if (this.get('text')) {
      this.renderText(group);
      this.renderBackground(group);
    }
  };

  CrosshairBase.prototype.renderText = function (group) {
    var text = this.get('text');
    var style = text.style,
        autoRotate = text.autoRotate,
        content = text.content;

    if (!(0, _util.isNil)(content)) {
      var textPoint = this.getTextPoint();
      var matrix = null;

      if (autoRotate) {
        var angle = this.getRotateAngle();
        matrix = (0, _matrix.getMatrixByAngle)(textPoint, angle);
      }

      this.addShape(group, {
        type: 'text',
        name: 'crosshair-text',
        id: this.getElementId('text'),
        attrs: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, textPoint), {
          text: content,
          matrix: matrix
        }), style)
      });
    }
  };

  CrosshairBase.prototype.renderLine = function (group) {
    var path = this.getLinePath();
    var line = this.get('line');
    var style = line.style;
    this.addShape(group, {
      type: 'path',
      name: 'crosshair-line',
      id: this.getElementId('line'),
      attrs: (0, _tslib.__assign)({
        path: path
      }, style)
    });
  }; // 


  CrosshairBase.prototype.renderBackground = function (group) {
    var textId = this.getElementId('text');
    var textShape = group.findById(textId); // 

    var textBackground = this.get('textBackground');

    if (textBackground && textShape) {
      var textBBox = textShape.getBBox();
      var padding = (0, _util2.formatPadding)(textBackground.padding); //  padding 

      var style = textBackground.style;
      var backgroundShape = this.addShape(group, {
        type: 'rect',
        name: 'crosshair-text-background',
        id: this.getElementId('text-background'),
        attrs: (0, _tslib.__assign)({
          x: textBBox.x - padding[3],
          y: textBBox.y - padding[0],
          width: textBBox.width + padding[1] + padding[3],
          height: textBBox.height + padding[0] + padding[2],
          matrix: textShape.attr('matrix')
        }, style)
      });
      backgroundShape.toBack();
    }
  };

  return CrosshairBase;
}(_groupComponent.default);

var _default = CrosshairBase;
exports.default = _default;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _theme = _interopRequireDefault(__webpack_require__(60));

var GridBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(GridBase, _super);

  function GridBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  GridBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'grid',
      line: {},
      alternateColor: null,
      capture: false,
      items: [],
      closed: false,
      defaultCfg: {
        line: {
          type: 'line',
          style: {
            lineWidth: 1,
            stroke: _theme.default.lineColor
          }
        }
      }
    });
  };
  /**
   * 
   * @return {string} 
   */


  GridBase.prototype.getLineType = function () {
    var line = this.get('line') || this.get('defaultCfg').line;
    return line.type;
  };

  GridBase.prototype.renderInner = function (group) {
    this.drawGrid(group);
  };

  GridBase.prototype.getAlternatePath = function (prePoints, points) {
    var regionPath = this.getGridPath(prePoints);
    var reversePoints = points.slice(0).reverse();
    var nextPath = this.getGridPath(reversePoints, true);
    var closed = this.get('closed');

    if (closed) {
      regionPath = regionPath.concat(nextPath);
    } else {
      nextPath[0][0] = 'L'; // 

      regionPath = regionPath.concat(nextPath);
      regionPath.push(['Z']);
    }

    return regionPath;
  }; // 


  GridBase.prototype.getPathStyle = function () {
    return this.get('line').style;
  }; // 


  GridBase.prototype.drawGrid = function (group) {
    var _this = this;

    var line = this.get('line');
    var items = this.get('items');
    var alternateColor = this.get('alternateColor');
    var preItem = null;
    (0, _util.each)(items, function (item, index) {
      var id = item.id || index; // 

      if (line) {
        var style = _this.getPathStyle();

        style = (0, _util.isFunction)(style) ? style(item, index, items) : style;

        var lineId = _this.getElementId("line-" + id);

        var gridPath = _this.getGridPath(item.points);

        _this.addShape(group, {
          type: 'path',
          name: 'grid-line',
          id: lineId,
          attrs: (0, _util.mix)({
            path: gridPath
          }, style)
        });
      } //  alternateColor 
      // 


      if (alternateColor && index > 0) {
        var regionId = _this.getElementId("region-" + id);

        var isEven = index % 2 === 0;

        if ((0, _util.isString)(alternateColor)) {
          // 
          if (isEven) {
            _this.drawAlternateRegion(regionId, group, preItem.points, item.points, alternateColor);
          }
        } else {
          var color = isEven ? alternateColor[1] : alternateColor[0];

          _this.drawAlternateRegion(regionId, group, preItem.points, item.points, color);
        }
      }

      preItem = item;
    });
  }; // 


  GridBase.prototype.drawAlternateRegion = function (id, group, prePoints, points, color) {
    var regionPath = this.getAlternatePath(prePoints, points);
    this.addShape(group, {
      type: 'path',
      id: id,
      name: 'grid-region',
      attrs: {
        path: regionPath,
        fill: color
      }
    });
  };

  return GridBase;
}(_groupComponent.default);

var _default = GridBase;
exports.default = _default;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _util = __webpack_require__(44);

var LegendBase =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LegendBase, _super);

  function LegendBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  LegendBase.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'legend',

      /**
       *  horizontalvertical
       * @type {String}
       */
      layout: 'horizontal',
      locationType: 'point',
      x: 0,
      y: 0,
      offsetX: 0,
      offsetY: 0,
      title: null,
      background: null
    });
  };

  LegendBase.prototype.getLayoutBBox = function () {
    var bbox = _super.prototype.getLayoutBBox.call(this);

    var maxWidth = this.get('maxWidth');
    var maxHeight = this.get('maxHeight');
    var width = bbox.width,
        height = bbox.height;

    if (maxWidth) {
      width = Math.min(width, maxWidth);
    }

    if (maxHeight) {
      height = Math.min(height, maxHeight);
    }

    return (0, _util.createBBox)(bbox.minX, bbox.minY, width, height);
  };

  LegendBase.prototype.setLocation = function (cfg) {
    this.set('x', cfg.x);
    this.set('y', cfg.y);
    this.resetLocation();
  };

  LegendBase.prototype.resetLocation = function () {
    var x = this.get('x');
    var y = this.get('y');
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    this.moveElementTo(this.get('group'), {
      x: x + offsetX,
      y: y + offsetY
    });
  };

  LegendBase.prototype.applyOffset = function () {
    this.resetLocation();
  }; // 


  LegendBase.prototype.getDrawPoint = function () {
    return this.get('currentPoint');
  };

  LegendBase.prototype.setDrawPoint = function (point) {
    return this.set('currentPoint', point);
  }; // 


  LegendBase.prototype.renderInner = function (group) {
    this.resetDraw();

    if (this.get('title')) {
      this.drawTitle(group);
    }

    this.drawLegendContent(group);

    if (this.get('background')) {
      this.drawBackground(group);
    } // this.resetLocation(); // 

  }; // 


  LegendBase.prototype.drawBackground = function (group) {
    var background = this.get('background');
    var bbox = group.getBBox();
    var padding = (0, _util.formatPadding)(background.padding);
    var attrs = (0, _tslib.__assign)({
      //  (0,0) 
      x: 0,
      y: 0,
      width: bbox.width + padding[1] + padding[3],
      height: bbox.height + padding[0] + padding[2]
    }, background.style);
    var backgroundShape = this.addShape(group, {
      type: 'rect',
      id: this.getElementId('background'),
      name: 'legend-background',
      attrs: attrs
    });
    backgroundShape.toBack();
  }; // 


  LegendBase.prototype.drawTitle = function (group) {
    var currentPoint = this.get('currentPoint');
    var titleCfg = this.get('title');
    var spacing = titleCfg.spacing,
        style = titleCfg.style,
        text = titleCfg.text;
    var shape = this.addShape(group, {
      type: 'text',
      id: this.getElementId('title'),
      name: 'legend-title',
      attrs: (0, _tslib.__assign)({
        text: text,
        x: currentPoint.x,
        y: currentPoint.y
      }, style)
    });
    var bbox = shape.getBBox(); // 

    this.set('currentPoint', {
      x: currentPoint.x,
      y: bbox.maxY + spacing
    });
  }; //  padding


  LegendBase.prototype.resetDraw = function () {
    var background = this.get('background');
    var currentPoint = {
      x: 0,
      y: 0
    };

    if (background) {
      var padding = (0, _util.formatPadding)(background.padding);
      currentPoint.x = padding[3]; //  padding

      currentPoint.y = padding[0]; //  padding
    }

    this.set('currentPoint', currentPoint); // 
  };

  return LegendBase;
}(_groupComponent.default);

var _default = LegendBase;
exports.default = _default;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CROSSHAIR_Y = exports.CROSSHAIR_X = exports.NAME_CLASS = exports.VALUE_CLASS = exports.MARKER_CLASS = exports.LIST_ITEM_CLASS = exports.LIST_CLASS = exports.TITLE_CLASS = exports.CONTAINER_CLASS = void 0;
var CONTAINER_CLASS = 'g2-tooltip';
exports.CONTAINER_CLASS = CONTAINER_CLASS;
var TITLE_CLASS = 'g2-tooltip-title';
exports.TITLE_CLASS = TITLE_CLASS;
var LIST_CLASS = 'g2-tooltip-list';
exports.LIST_CLASS = LIST_CLASS;
var LIST_ITEM_CLASS = 'g2-tooltip-list-item';
exports.LIST_ITEM_CLASS = LIST_ITEM_CLASS;
var MARKER_CLASS = 'g2-tooltip-marker';
exports.MARKER_CLASS = MARKER_CLASS;
var VALUE_CLASS = 'g2-tooltip-value';
exports.VALUE_CLASS = VALUE_CLASS;
var NAME_CLASS = 'g2-tooltip-name';
exports.NAME_CLASS = NAME_CLASS;
var CROSSHAIR_X = 'g2-tooltip-crosshair-x';
exports.CROSSHAIR_X = CROSSHAIR_X;
var CROSSHAIR_Y = 'g2-tooltip-crosshair-y';
exports.CROSSHAIR_Y = CROSSHAIR_Y;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var Shape = __webpack_require__(142);

var draw_1 = __webpack_require__(143);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(52);

var Group =
/** @class */
function (_super) {
  tslib_1.__extends(Group, _super);

  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Group.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };

  Group.prototype.getShapeBase = function () {
    return Shape;
  };

  Group.prototype.getGroupBase = function () {
    return Group;
  }; //  shape 


  Group.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save(); //  clip  context 

      draw_1.applyAttrsToContext(context, clip); //  clip 

      clip.createPath(context);
      context.restore(); // 

      context.clip();

      clip._afterDraw();
    }
  }; //  getCanvasBBox group 
  //  15-20%  10W  5-6 ms 30-40ms


  Group.prototype.cacheCanvasBBox = function () {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    util_1.each(children, function (child) {
      var bbox = child.cfg.cacheCanvasBBox; // isInview 
      //  10W  5-6 ms 

      if (bbox && child.cfg.isInView) {
        xArr.push(bbox.minX, bbox.maxX);
        yArr.push(bbox.minY, bbox.maxY);
      }
    });
    var bbox = null;

    if (xArr.length) {
      var minX = Math.min.apply(null, xArr);
      var maxX = Math.max.apply(null, xArr);
      var minY = Math.min.apply(null, yArr);
      var maxY = Math.max.apply(null, yArr);
      bbox = {
        minX: minX,
        minY: minY,
        x: minX,
        y: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;

      if (canvas) {
        var viewRange = canvas.getViewRange(); //  isInView == false  bbox  false 
        //  10W  2-5ms 

        this.set('isInView', util_2.intersectRect(bbox, viewRange));
      }
    } else {
      this.set('isInView', false);
    }

    this.set('cacheCanvasBBox', bbox);
  };

  Group.prototype.draw = function (context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true; // 
    //  G6  group  transform 
    //  refresh 
    //  refresh 

    if (children.length && allowDraw) {
      context.save(); // group 
      //  attrs  clip clip  matrix 

      draw_1.applyAttrsToContext(context, this);

      this._applyClip(context, this.getClip());

      draw_1.drawChildren(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    } // 
    // this.set('cacheCanvasBBox', this.getCanvasBBox());


    this.cfg.refresh = null; // 

    this.set('hasChanged', false);
  }; // 


  Group.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('hasChanged', false);
  };

  return Group;
}(g_base_1.AbstractGroup);

exports.default = Group;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.refreshElement = exports.drawChildren = void 0;

var svg_1 = __webpack_require__(144);

var dom_1 = __webpack_require__(70);

function drawChildren(context, children) {
  children.forEach(function (child) {
    child.draw(context);
  });
}

exports.drawChildren = drawChildren;
/**
 *  group  shape
 * @param {IElement} element       SVG 
 * @param {ChangeType} changeType  
 */

function refreshElement(element, changeType) {
  // canvas 
  var canvas = element.get('canvas'); // 

  if (canvas && canvas.get('autoDraw')) {
    var context = canvas.get('context');
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get('el');

    if (changeType === 'remove') {
      var isClipShape = element.get('isClipShape'); //  clip clipShape  SVG  clipPath 

      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;

        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === 'show') {
      el.setAttribute('visibility', 'visible');
    } else if (changeType === 'hide') {
      el.setAttribute('visibility', 'hidden');
    } else if (changeType === 'zIndex') {
      dom_1.moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === 'sort') {
      var children_1 = element.get('children');

      if (children_1 && children_1.length) {
        dom_1.sortDom(element, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      // el maybe null for group
      if (el) {
        el.innerHTML = '';
      }
    } else if (changeType === 'matrix') {
      svg_1.setTransform(element);
    } else if (changeType === 'clip') {
      svg_1.setClip(element, context);
    } else if (changeType === 'attr') {//  afterAttrsChange  do nothing
    } else if (changeType === 'add') {
      element.draw(context);
    }
  }
}

exports.refreshElement = refreshElement;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var util_1 = __webpack_require__(0);

var Shape = __webpack_require__(189);

var draw_1 = __webpack_require__(259);

var svg_1 = __webpack_require__(144);

var constant_1 = __webpack_require__(53);

var dom_1 = __webpack_require__(70);

var Group =
/** @class */
function (_super) {
  tslib_1.__extends(Group, _super);

  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // SVG  <g>


  Group.prototype.isEntityGroup = function () {
    return true;
  };

  Group.prototype.createDom = function () {
    var element = dom_1.createSVGElement('g');
    this.set('el', element);
    var parent = this.getParent();

    if (parent) {
      var parentNode = parent.get('el');

      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        // parentNode maybe null for group
        parentNode = parent.createDom();
        parent.set('el', parentNode);
        parentNode.appendChild(element);
      }
    }

    return element;
  }; //  afterAttrsChange 


  Group.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);

    var canvas = this.get('canvas'); // 

    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.createPath(context, targetAttrs);
    }
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Group.prototype.onCanvasChange = function (changeType) {
    draw_1.refreshElement(this, changeType);
  };

  Group.prototype.getShapeBase = function () {
    return Shape;
  };

  Group.prototype.getGroupBase = function () {
    return Group;
  };

  Group.prototype.draw = function (context) {
    var children = this.getChildren();
    var el = this.get('el');

    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }

      svg_1.setClip(this, context);
      this.createPath(context);

      if (children.length) {
        draw_1.drawChildren(context, children);
      }
    }
  };
  /**
   * 
   * @param {Defs} context 
   * @param {ShapeAttrs} targetAttrs 
   */


  Group.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
    svg_1.setTransform(this);
  };

  return Group;
}(g_base_1.AbstractGroup);

exports.default = Group;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var event_emitter_1 = tslib_1.__importDefault(__webpack_require__(125));
/**
 * G2 ChartViewGeometry  Element 
 */


var Base =
/** @class */
function (_super) {
  tslib_1.__extends(Base, _super);

  function Base(cfg) {
    var _this = _super.call(this) || this;
    /**  */


    _this.destroyed = false;
    var _a = cfg.visible,
        visible = _a === void 0 ? true : _a;
    _this.visible = visible;
    return _this;
  }
  /**
   * 
   */


  Base.prototype.show = function () {
    var visible = this.visible;

    if (!visible) {
      this.changeVisible(true);
    }
  };
  /**
   * 
   */


  Base.prototype.hide = function () {
    var visible = this.visible;

    if (visible) {
      this.changeVisible(false);
    }
  };
  /**
   * 
   */


  Base.prototype.destroy = function () {
    this.off();
    this.destroyed = true;
  };
  /**
   * 
   * @param visible
   * @returns
   */


  Base.prototype.changeVisible = function (visible) {
    if (this.visible === visible) {
      return;
    }

    this.visible = visible;
  };

  return Base;
}(event_emitter_1.default);

exports.default = Base;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerFacet = exports.getFacet = void 0;

var util_1 = __webpack_require__(0);

var facet_1 = __webpack_require__(105);

Object.defineProperty(exports, "Facet", {
  enumerable: true,
  get: function get() {
    return facet_1.Facet;
  }
});
/**
 *  Facet 
 */

var Facets = {};
/**
 *  type  facet 
 * @param type 
 */

exports.getFacet = function (type) {
  return Facets[util_1.lowerCase(type)];
};
/**
 *  Facet 
 * @param type 
 * @param ctor 
 */


exports.registerFacet = function (type, ctor) {
  Facets[util_1.lowerCase(type)] = ctor;
};

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAxisTitleText = exports.getAxisDirection = exports.getAxisOption = exports.getCircleAxisCenterRadius = exports.getAxisThemeCfg = exports.getAxisFactorByRegion = exports.isVertical = exports.getAxisFactor = exports.getAxisRegion = exports.getCircleAxisRelativeRegion = exports.getLineAxisRelativeRegion = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var scale_1 = __webpack_require__(145);

var matrix_util_1 = __webpack_require__(33);
/**
 * @ignore
 * get axis relative region ( 0 ~ 1) by direction when coordinate is rect
 * @param direction
 * @returns axis coordinate region
 */


function getLineAxisRelativeRegion(direction) {
  var start;
  var end;

  switch (direction) {
    case constant_1.DIRECTION.TOP:
      start = {
        x: 0,
        y: 1
      };
      end = {
        x: 1,
        y: 1
      };
      break;

    case constant_1.DIRECTION.RIGHT:
      start = {
        x: 1,
        y: 0
      };
      end = {
        x: 1,
        y: 1
      };
      break;

    case constant_1.DIRECTION.BOTTOM:
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 1,
        y: 0
      };
      break;

    case constant_1.DIRECTION.LEFT:
      start = {
        x: 0,
        y: 0
      };
      end = {
        x: 0,
        y: 1
      };
      break;

    default:
      start = end = {
        x: 0,
        y: 0
      };
  }

  return {
    start: start,
    end: end
  };
}

exports.getLineAxisRelativeRegion = getLineAxisRelativeRegion;
/**
 * @ignore
 * get axis relative region ( 0 ~ 1) by direction when coordinate is polar
 * @param coordinate
 * @returns axis coordinate region
 */

function getCircleAxisRelativeRegion(coordinate) {
  var start;
  var end;

  if (coordinate.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }

  return {
    start: start,
    end: end
  };
}

exports.getCircleAxisRelativeRegion = getCircleAxisRelativeRegion;
/**
 * @ignore
 * get the axis region from coordinate
 * @param coordinate
 * @param direction
 * @returns the axis region (start point, end point)
 */

function getAxisRegion(coordinate, direction) {
  var region = {
    start: {
      x: 0,
      y: 0
    },
    end: {
      x: 0,
      y: 0
    }
  };

  if (coordinate.isRect) {
    region = getLineAxisRelativeRegion(direction);
  } else if (coordinate.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate);
  }

  var start = region.start,
      end = region.end;
  return {
    start: coordinate.convert(start),
    end: coordinate.convert(end)
  };
}

exports.getAxisRegion = getAxisRegion;
/**
 * @ignore
 * get axis factor
 * @param coordinate
 * @param direction
 * @returns factor
 */

function getAxisFactor(coordinate, direction) {
  // rect coordinate, by direction
  if (coordinate.isRect) {
    return coordinate.isTransposed ? [constant_1.DIRECTION.RIGHT, constant_1.DIRECTION.BOTTOM].includes(direction) ? 1 : -1 : [constant_1.DIRECTION.BOTTOM, constant_1.DIRECTION.RIGHT].includes(direction) ? -1 : 1;
  } // polar y axis, by angle


  if (coordinate.isPolar) {
    var startAngle = coordinate.x.start;
    return startAngle < 0 ? -1 : 1;
  }

  return 1;
}

exports.getAxisFactor = getAxisFactor;
/**
 * @ignore
 * whether the axis isVertical
 * @param region
 * @returns isVertical
 */

function isVertical(region) {
  var start = region.start,
      end = region.end;
  return start.x === end.x;
}

exports.isVertical = isVertical;
/**
 * @ignore
 * get factor by region (real position)
 * @param region
 * @param center
 * @returns factor
 */

function getAxisFactorByRegion(region, center) {
  var start = region.start,
      end = region.end;
  var isAxisVertical = isVertical(region); // 

  if (isAxisVertical) {
    // ,,
    if ((start.y - end.y) * (center.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    // ,,
    if ((end.x - start.x) * (start.y - center.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}

exports.getAxisFactorByRegion = getAxisFactorByRegion;
/**
 * @ignore
 * get the axis cfg from theme
 * @param theme view theme object
 * @param direction axis direction
 * @returns axis theme cfg
 */

function getAxisThemeCfg(theme, direction) {
  return util_1.get(theme, ['components', 'axis', direction], {});
}

exports.getAxisThemeCfg = getAxisThemeCfg;
/**
 * @ignore
 * get circle axis center and radius
 * @param coordinate
 */

function getCircleAxisCenterRadius(coordinate) {
  // @ts-ignore
  var x = coordinate.x,
      y = coordinate.y,
      center = coordinate.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate.isTransposed ? coordinate.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center.x, start.y - center.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center.y ? matrix_util_1.vec2.angle(startVector, normalVector) : matrix_util_1.vec2.angle(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center.x, 2) + Math.pow(start.y - center.y, 2));
  return {
    center: center,
    radius: radius,
    startAngle: startAngle,
    endAngle: endAngle
  };
}

exports.getCircleAxisCenterRadius = getCircleAxisCenterRadius;
/**
 * @ignore
 *  axis 
 * @param axes
 * @param field
 * @returns the axis option of field
 */

function getAxisOption(axes, field) {
  if (util_1.isBoolean(axes)) {
    return axes === false ? false : {};
  }

  return util_1.get(axes, [field]);
}

exports.getAxisOption = getAxisOption;
/**
 * @ignore
 *  position
 * @param axisOption
 * @param def
 */

function getAxisDirection(axisOption, def) {
  return util_1.get(axisOption, 'position', def);
}

exports.getAxisDirection = getAxisDirection;
/**
 *  axis  title 
 * @param scale
 * @param axisOption
 */

function getAxisTitleText(scale, axisOption) {
  return util_1.get(axisOption, ['title', 'text'], scale_1.getName(scale));
}

exports.getAxisTitleText = getAxisTitleText;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createInteraction = exports.registerInteraction = exports.getInteraction = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var grammar_interaction_1 = tslib_1.__importDefault(__webpack_require__(891));

var Interactions = {};
/**
 * 
 * @param name 
 * @returns 
 */

function getInteraction(name) {
  return Interactions[util_1.lowerCase(name)];
}

exports.getInteraction = getInteraction;
/**
 * 
 * @param name 
 * @param interaction 
 */

function registerInteraction(name, interaction) {
  Interactions[util_1.lowerCase(name)] = interaction;
}

exports.registerInteraction = registerInteraction;
/**
 * 
 * @param name 
 * @param view  View 
 * @param cfg 
 */

function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);

  if (!interaciton) {
    return null;
  }

  if (util_1.isPlainObject(interaciton)) {
    //  clone  interaction  step 
    var steps = util_1.mix(util_1.clone(interaciton), cfg);
    return new grammar_interaction_1.default(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}

exports.createInteraction = createInteraction;

var interaction_1 = __webpack_require__(433);

Object.defineProperty(exports, "Interaction", {
  enumerable: true,
  get: function get() {
    return interaction_1.default;
  }
});

var action_1 = __webpack_require__(265);

Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return action_1.Action;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return action_1.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return action_1.getActionClass;
  }
});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(47); //  Action 


Object.defineProperty(exports, "Action", {
  enumerable: true,
  get: function get() {
    return base_1.default;
  }
});

var register_1 = __webpack_require__(202);

Object.defineProperty(exports, "createAction", {
  enumerable: true,
  get: function get() {
    return register_1.createAction;
  }
});
Object.defineProperty(exports, "registerAction", {
  enumerable: true,
  get: function get() {
    return register_1.registerAction;
  }
});
Object.defineProperty(exports, "getActionClass", {
  enumerable: true,
  get: function get() {
    return register_1.getActionClass;
  }
});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTooltipItems = exports.findDataByPoint = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var scale_1 = __webpack_require__(145);

function snapEqual(v1, v2, scale) {
  var value1 = scale.translate(v1);
  var value2 = scale.translate(v2);
  return util_1.isNumberEqual(value1, value2);
}

function getXValueByPoint(point, geometry) {
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var range = xScale.range;
  var rangeMax = range[range.length - 1];
  var rangeMin = range[0];
  var invertPoint = coordinate.invert(point);
  var xValue = invertPoint.x;

  if (coordinate.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin; // scale  range 
  }

  return xScale.translate(xScale.invert(xValue));
}

function filterYValue(data, point, geometry) {
  var coordinate = geometry.coordinate;
  var yScale = geometry.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate.invert(point);
  var yValue = yScale.invert(invertPoint.y);
  var result = util_1.find(data, function (obj) {
    var originData = obj[constant_1.FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data[data.length - 1];
}

var getXDistance = util_1.memoize(function (scale) {
  if (scale.isCategory) {
    return 1;
  }

  var scaleValues = scale.values; // values 

  var length = scaleValues.length;
  var min = scale.translate(scaleValues[0]);
  var max = min;

  for (var index = 0; index < length; index++) {
    var value = scaleValues[index]; //  translate

    var numericValue = scale.translate(value);

    if (numericValue < min) {
      min = numericValue;
    }

    if (numericValue > max) {
      max = numericValue;
    }
  }

  return (max - min) / (length - 1);
});
/**
 *  tooltip  title
 * @param originData
 * @param geometry
 * @param title
 */

function getTooltipTitle(originData, geometry, title) {
  var positionAttr = geometry.getAttribute('position');
  var fields = positionAttr.getFields();
  var scales = geometry.scales;
  var titleField = util_1.isFunction(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField]; //  scale scale.getText() 
  //  scale title 

  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return util_1.isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;
}

function getAttributesForLegend(geometry) {
  var attributes = util_1.values(geometry.attributes);
  return util_1.filter(attributes, function (attribute) {
    return util_1.contains(constant_1.GROUP_ATTRS, attribute.type);
  });
}

function getTooltipValueScale(geometry) {
  var attributes = getAttributesForLegend(geometry);
  var scale;

  for (var _i = 0, attributes_1 = attributes; _i < attributes_1.length; _i++) {
    var attribute = attributes_1[_i];
    var tmpScale = attribute.getScale(attribute.type);

    if (tmpScale && tmpScale.isLinear) {
      //  position 
      scale = tmpScale;
      break;
    }
  }

  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  return scale || yScale || xScale;
}

function getTooltipValue(originData, valueScale) {
  var field = valueScale.field;
  var value = originData[field];

  if (util_1.isArray(value)) {
    var texts = value.map(function (eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join('-');
  }

  return valueScale.getText(value);
} //  tooltip item  name 


function getTooltipName(originData, geometry) {
  var nameScale;
  var groupScales = geometry.getGroupScales();

  if (groupScales.length) {
    // 
    nameScale = groupScales[0];
  }

  if (nameScale) {
    var field = nameScale.field;
    return nameScale.getText(originData[field]);
  }

  var valueScale = getTooltipValueScale(geometry);
  return scale_1.getName(valueScale);
}
/**
 * @ignore
 * Finds data from geometry by point
 * @param point canvas point
 * @param data an item of geometry.dataArray
 * @param geometry
 * @returns
 */


function findDataByPoint(point, data, geometry) {
  if (data.length === 0) {
    return null;
  }

  var geometryType = geometry.type;
  var xScale = geometry.getXScale();
  var yScale = geometry.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null; //  point 

  if (geometryType === 'heatmap' || geometryType === 'point') {
    //  point 
    var coordinate = geometry.coordinate;
    var invertPoint = coordinate.invert(point); // 

    var x = xScale.invert(invertPoint.x); // 

    var y = yScale.invert(invertPoint.y); // 

    var min = Infinity;

    for (var index = 0; index < data.length; index++) {
      var obj = data[index];
      var originData = obj[constant_1.FIELD_ORIGIN];
      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);

      if (range < min) {
        min = range;
        rst = obj;
      }
    }

    return rst;
  } //  Geometry  x 


  var first = data[0];
  var last = data[data.length - 1];
  var xValue = getXValueByPoint(point, geometry);
  var firstXValue = first[constant_1.FIELD_ORIGIN][xField];
  var firstYValue = first[constant_1.FIELD_ORIGIN][yField];
  var lastXValue = last[constant_1.FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && util_1.isArray(firstYValue); //  x y 
  //  x 

  if (util_1.isArray(firstXValue)) {
    for (var index = 0; index < data.length; index++) {
      var record = data[index];
      var originData = record[constant_1.FIELD_ORIGIN]; // xValue  originData[xField] 

      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          // x  y 
          if (!util_1.isArray(rst)) {
            rst = [];
          }

          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }

    if (util_1.isArray(rst)) {
      rst = filterYValue(rst, point, geometry);
    }
  } else {
    var next = void 0;

    if (!xScale.isLinear && xScale.type !== 'timeCat') {
      // x 
      for (var index = 0; index < data.length; index++) {
        var record = data[index];
        var originData = record[constant_1.FIELD_ORIGIN];

        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!util_1.isArray(rst)) {
              rst = [];
            }

            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last = record;
          next = data[index + 1];
        }
      }

      if (util_1.isArray(rst)) {
        rst = filterYValue(rst, point, geometry);
      }
    } else {
      // x 
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        // 
        return null;
      }

      var firstIdx = 0;
      var lastIdx = data.length - 1;
      var middleIdx = void 0;

      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data[middleIdx][constant_1.FIELD_ORIGIN][xField];

        if (snapEqual(item, xValue, xScale)) {
          return data[middleIdx];
        }

        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last = data[middleIdx];
          next = data[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last = data[0];
          }

          lastIdx = middleIdx - 1;
        }
      }
    }

    if (last && next) {
      // 
      if (Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[constant_1.FIELD_ORIGIN][xField]) - xValue)) {
        last = next;
      }
    }
  }

  var distance = getXDistance(geometry.getXScale()); // 

  if (!rst && Math.abs(xScale.translate(last[constant_1.FIELD_ORIGIN][xField]) - xValue) <= distance / 2) {
    rst = last;
  }

  return rst;
}

exports.findDataByPoint = findDataByPoint;
/**
 * @ignore
 * Gets tooltip items
 * @param data
 * @param geometry
 * @param [title]
 * @returns
 */

function getTooltipItems(data, geometry, title, showNil) {
  if (title === void 0) {
    title = '';
  }

  if (showNil === void 0) {
    showNil = false;
  }

  var originData = data[constant_1.FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry, title);
  var tooltipOption = geometry.tooltipOption;
  var defaultColor = geometry.theme.defaultColor;
  var items = [];
  var name;
  var value;

  function addItem(itemName, itemValue) {
    if (showNil || !util_1.isNil(itemValue) && itemValue !== '') {
      //  null
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data,
        name: itemName,
        value: itemValue,
        color: data.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }

  if (util_1.isObject(tooltipOption)) {
    var fields = tooltipOption.fields,
        callback = tooltipOption.callback;

    if (callback) {
      // 
      var callbackParams = fields.map(function (field) {
        return data[constant_1.FIELD_ORIGIN][field];
      });
      var cfg = callback.apply(void 0, callbackParams);

      var itemCfg = tslib_1.__assign({
        data: data[constant_1.FIELD_ORIGIN],
        mappingData: data,
        title: tooltipTitle,
        color: data.color || defaultColor,
        marker: true
      }, cfg);

      items.push(itemCfg);
    } else {
      var scales = geometry.scales;

      for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
        var field = fields_1[_i];

        if (!util_1.isNil(originData[field])) {
          // null, undefined 
          var scale = scales[field];
          name = scale_1.getName(scale);
          value = scale.getText(originData[field]);
          addItem(name, value);
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry); // null ,undefined

    value = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry);
    addItem(name, value);
  }

  return items;
}

exports.getTooltipItems = getTooltipItems;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePadding = exports.isAutoPadding = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);
/**
 * @ignore
 *  padding
 * @param padding
 */


function isAutoPadding(padding) {
  return !util_1.isNumber(padding) && !util_1.isArray(padding);
}

exports.isAutoPadding = isAutoPadding;
/**
 * @ignore
 * padding 
 * @param padding
 * @return [ top, right, bottom, left ]
 */

function parsePadding(padding) {
  if (padding === void 0) {
    padding = 0;
  }

  var paddingArray = util_1.isArray(padding) ? padding : [padding];

  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;

    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;

    case 2:
      paddingArray = tslib_1.__spreadArrays(paddingArray, paddingArray);
      break;

    case 3:
      paddingArray = tslib_1.__spreadArrays(paddingArray, [paddingArray[1]]);
      break;

    default:
      // 
      paddingArray = paddingArray.slice(0, 4);
      break;
  }

  return paddingArray;
}

exports.parsePadding = parsePadding;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var dependents_1 = __webpack_require__(68);
/**
 * @todo Whether it can(or necessary to) keep consistent with the structure of G.Event or directly use the structure of G.Event
 * G2  G.Event
 */


var Event =
/** @class */
function () {
  function Event(view, gEvent, data) {
    this.view = view;
    this.gEvent = gEvent;
    this.data = data;
    this.type = gEvent.type;
  }
  /**
   * 
   * @param view
   * @param type
   * @param data
   */


  Event.fromData = function (view, type, data) {
    return new Event(view, new dependents_1.Event(type, {}), data);
  };

  Object.defineProperty(Event.prototype, "target", {
    // below props are proxy props of G.event convenient

    /** the real trigger shape of the event */
    get: function get() {
      // @todo G  object  ignore
      // @ts-ignore
      return this.gEvent.target;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "event", {
    /**  dom  */
    get: function get() {
      return this.gEvent.originalEvent;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "x", {
    /** x  */
    get: function get() {
      return this.gEvent.x;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "y", {
    /** y  */
    get: function get() {
      return this.gEvent.y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "clientX", {
    /** x  */
    get: function get() {
      return this.gEvent.clientX;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Event.prototype, "clientY", {
    /** y  */
    get: function get() {
      return this.gEvent.clientY;
    },
    enumerable: false,
    configurable: true
  }); // end for proxy events

  /**
   * event string
   * @returns string
   */

  Event.prototype.toString = function () {
    return "[Event (type=" + this.type + ")]";
  };
  /**
   * clone a new event with same attributes
   * @returns [[Event]]
   */


  Event.prototype.clone = function () {
    return new Event(this.view, this.gEvent, this.data);
  };

  return Event;
}();

exports.default = Event;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0); // 
// @ts-ignore


var component_1 = __webpack_require__(184);

var animate_1 = __webpack_require__(96);

var base_1 = tslib_1.__importDefault(__webpack_require__(261));

var graphics_1 = __webpack_require__(45);

var constant_1 = __webpack_require__(20);

var constant_2 = __webpack_require__(270);
/**
 * Element 
 *  G2 Element / Shape  Shape
 */


var Element =
/** @class */
function (_super) {
  tslib_1.__extends(Element, _super);

  function Element(cfg) {
    var _this = _super.call(this, cfg) || this; // 


    _this.states = [];
    var shapeFactory = cfg.shapeFactory,
        container = cfg.container,
        offscreenGroup = cfg.offscreenGroup,
        _a = cfg.visible,
        visible = _a === void 0 ? true : _a;
    _this.shapeFactory = shapeFactory;
    _this.container = container;
    _this.offscreenGroup = offscreenGroup;
    _this.visible = visible;
    return _this;
  }
  /**
   * 
   * @param model 
   * @param isUpdate 
   */


  Element.prototype.draw = function (model, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    this.model = model;
    this.data = model.data; // 

    this.shapeType = this.getShapeType(model); // 

    this.drawShape(model, isUpdate);

    if (this.visible === false) {
      //  visible: false
      this.changeVisible(false);
    }
  };
  /**
   * 
   * @param model 
   */


  Element.prototype.update = function (model) {
    var _a = this,
        shapeFactory = _a.shapeFactory,
        shape = _a.shape;

    if (!shape) {
      return;
    } // 


    this.model = model;
    this.data = model.data;
    this.shapeType = this.getShapeType(model); // step 1:  shape 

    this.setShapeInfo(shape, model); // step 2:  Group  shape shape

    var offscreenGroup = this.getOffscreenGroup();
    var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup); // @ts-ignore

    newShape.cfg.data = this.data; // @ts-ignore

    newShape.cfg.origin = model; // label 

    newShape.cfg.element = this; // step 3:  shape 

    this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg('update'));
  };
  /**
   *  element 
   */


  Element.prototype.destroy = function () {
    var _a = this,
        shapeFactory = _a.shapeFactory,
        shape = _a.shape;

    if (shape) {
      var animateCfg = this.getAnimateCfg('leave');

      if (animateCfg) {
        // 
        animate_1.doAnimate(shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: tslib_1.__assign({}, shape.attr())
        });
      } else {
        // 
        shape.remove(true);
      }
    } // reset


    this.states = [];
    this.shapeFactory = undefined;
    this.container = undefined;
    this.shape = undefined;
    this.animate = undefined;
    this.geometry = undefined;
    this.labelShape = undefined;
    this.model = undefined;
    this.data = undefined;
    this.offscreenGroup = undefined;
    this.statesStyle = undefined;

    _super.prototype.destroy.call(this);
  };
  /**
   *  element
   * @param visible 
   */


  Element.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);

    if (visible) {
      if (this.shape) {
        this.shape.show();
      }

      if (this.labelShape) {
        this.labelShape.forEach(function (label) {
          label.show();
        });
      }
    } else {
      if (this.shape) {
        this.shape.hide();
      }

      if (this.labelShape) {
        this.labelShape.forEach(function (label) {
          label.hide();
        });
      }
    }
  };
  /**
   *  Element 
   *
   *  Element 
   * 1. active
   * 2. selected
   * 3. inactive
   *
   * 
   *
   *  [[Theme]]  `geometry.state()` 
   *
   * ```ts
   * //  active 
   * setState('active', true);
   * ```
   *
   * @param stateName 
   * @param stateStatus 
   */


  Element.prototype.setState = function (stateName, stateStatus) {
    var _a = this,
        states = _a.states,
        shapeFactory = _a.shapeFactory,
        model = _a.model,
        shape = _a.shape,
        shapeType = _a.shapeType;

    var index = states.indexOf(stateName);

    if (stateStatus) {
      // 
      if (index > -1) {
        // 
        return;
      }

      states.push(stateName);

      if (stateName === 'active' || stateName === 'selected') {
        shape.toFront();
      }
    } else {
      if (index === -1) {
        // 
        return;
      }

      states.splice(index, 1);

      if (stateName === 'active' || stateName === 'selected') {
        shape.toBack();
      }
    } //  group  shape shape  shape


    var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());

    if (states.length) {
      // 
      this.syncShapeStyle(shape, offscreenShape, states, null);
    } else {
      // 
      this.syncShapeStyle(shape, offscreenShape, ['reset'], null);
    }

    offscreenShape.remove(true); // 

    var eventObject = {
      state: stateName,
      stateStatus: stateStatus,
      element: this,
      target: this.container
    };
    this.container.emit('statechange', eventObject); // @ts-ignore

    component_1.propagationDelegate(this.shape, 'statechange', eventObject);
  };
  /**
   * 
   */


  Element.prototype.clearStates = function () {
    var _this = this;

    var states = this.states;
    util_1.each(states, function (state) {
      _this.setState(state, false);
    });
    this.states = [];
  };
  /**
   *  Element  `stateName` 
   * @param stateName 
   * @returns true false 
   */


  Element.prototype.hasState = function (stateName) {
    return this.states.includes(stateName);
  };
  /**
   *  Element 
   * @returns  Element 
   */


  Element.prototype.getStates = function () {
    return this.states;
  };
  /**
   *  Element 
   * @returns 
   */


  Element.prototype.getData = function () {
    return this.data;
  };
  /**
   *  Element 
   * @returns 
   */


  Element.prototype.getModel = function () {
    return this.model;
  };
  /**
   *  Element  bbox
   * @returns 
   */


  Element.prototype.getBBox = function () {
    var _a = this,
        shape = _a.shape,
        labelShape = _a.labelShape;

    var bbox = {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };

    if (shape) {
      bbox = shape.getCanvasBBox();
    }

    if (labelShape) {
      labelShape.forEach(function (label) {
        var labelBBox = label.getCanvasBBox();
        bbox.x = Math.min(labelBBox.x, bbox.x);
        bbox.y = Math.min(labelBBox.y, bbox.y);
        bbox.minX = Math.min(labelBBox.minX, bbox.minX);
        bbox.minY = Math.min(labelBBox.minY, bbox.minY);
        bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
        bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
      });
    }

    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    return bbox;
  };

  Element.prototype.getStatesStyle = function () {
    if (!this.statesStyle) {
      var _a = this,
          shapeType = _a.shapeType,
          geometry = _a.geometry,
          shapeFactory = _a.shapeFactory;

      var stateOption = geometry.stateOption;
      var defaultShapeType = shapeFactory.defaultShapeType;
      var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
      this.statesStyle = util_1.deepMix({}, stateTheme, stateOption);
    }

    return this.statesStyle;
  }; // 


  Element.prototype.getStateStyle = function (stateName, shapeKey) {
    var statesStyle = this.getStatesStyle();
    var stateCfg = util_1.get(statesStyle, [stateName, 'style'], {});
    var shapeStyle = stateCfg[shapeKey] || stateCfg;

    if (util_1.isFunction(shapeStyle)) {
      return shapeStyle(this);
    }

    return shapeStyle;
  }; // 


  Element.prototype.getAnimateCfg = function (animateType) {
    var _this = this;

    var animate = this.animate;

    if (animate) {
      var cfg_1 = animate[animateType];

      if (cfg_1) {
        //  geometry  animate 
        return tslib_1.__assign(tslib_1.__assign({}, cfg_1), {
          callback: function callback() {
            var _a;

            util_1.isFunction(cfg_1.callback) && cfg_1.callback();
            (_a = _this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          }
        });
      }

      return cfg_1;
    }

    return null;
  }; // 


  Element.prototype.drawShape = function (model, isUpdate) {
    var _a;

    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var _b = this,
        shapeFactory = _b.shapeFactory,
        container = _b.container,
        shapeType = _b.shapeType; //  shape  shape


    this.shape = shapeFactory.drawShape(shapeType, model, container);

    if (this.shape) {
      this.setShapeInfo(this.shape, model); // 
      // @ts-ignore

      var name_1 = this.shape.cfg.name; //  element  name, name 

      if (!name_1) {
        //  name,  name  name
        // @ts-ignore
        this.shape.cfg.name = ['element', this.shapeFactory.geometryType];
      } else if (util_1.isString(name_1)) {
        // @ts-ignore
        this.shape.cfg.name = ['element', name_1];
      } // 


      var animateType = isUpdate ? 'enter' : 'appear';
      var animateCfg = this.getAnimateCfg(animateType);

      if (animateCfg) {
        // 
        (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
        animate_1.doAnimate(this.shape, animateCfg, {
          coordinate: shapeFactory.coordinate,
          toAttrs: tslib_1.__assign({}, this.shape.attr())
        });
      }
    }
  }; //  Group


  Element.prototype.getOffscreenGroup = function () {
    if (!this.offscreenGroup) {
      var GroupCtor = this.container.getGroupBase(); // 

      this.offscreenGroup = new GroupCtor({});
    }

    return this.offscreenGroup;
  }; //  shape 


  Element.prototype.setShapeInfo = function (shape, data) {
    var _this = this; // @ts-ignore


    shape.cfg.origin = data; // @ts-ignore

    shape.cfg.element = this;

    if (shape.isGroup()) {
      var children = shape.get('children');
      children.forEach(function (child) {
        _this.setShapeInfo(child, data);
      });
    }
  }; //  shape 


  Element.prototype.syncShapeStyle = function (sourceShape, targetShape, states, animateCfg, index) {
    var _this = this;

    var _a;

    if (states === void 0) {
      states = [];
    }

    if (index === void 0) {
      index = 0;
    }

    if (!sourceShape || !targetShape) {
      return;
    } //  shape  clip


    var clip = sourceShape.get('clipShape');
    var newClip = targetShape.get('clipShape');
    this.syncShapeStyle(clip, newClip, states, animateCfg);

    if (sourceShape.isGroup()) {
      var children = sourceShape.get('children');
      var newChildren = targetShape.get('children');

      for (var i = 0; i < children.length; i++) {
        this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index + i);
      }
    } else {
      if (!util_1.isEmpty(states) && !util_1.isEqual(states, ['reset'])) {
        var name_2 = sourceShape.get('name');

        if (util_1.isArray(name_2)) {
          //  element  name
          name_2 = name_2[1];
        }

        util_1.each(states, function (state) {
          // background shape 
          if (targetShape.get('name') !== constant_2.BACKGROUND_SHAPE) {
            var style = _this.getStateStyle(state, name_2 || index); //  name


            targetShape.attr(style);
          }
        });
      }

      var newAttrs = graphics_1.getReplaceAttrs(sourceShape, targetShape);

      if (this.animate) {
        if (animateCfg) {
          (_a = this.geometry) === null || _a === void 0 ? void 0 : _a.emit(constant_1.GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE); // 

          animate_1.doAnimate(sourceShape, animateCfg, {
            coordinate: this.shapeFactory.coordinate,
            toAttrs: newAttrs,
            shapeModel: this.model
          });
        } else if (util_1.isEmpty(states)) {
          sourceShape.stopAnimate();
          sourceShape.animate(newAttrs, {
            duration: 300
          });
        } else {
          sourceShape.attr(newAttrs);
        }
      } else {
        sourceShape.attr(newAttrs);
      }
    }
  };

  Element.prototype.getShapeType = function (model) {
    var shape = util_1.get(model, 'shape');
    return util_1.isArray(shape) ? shape[0] : shape;
  };

  return Element;
}(base_1.default);

exports.default = Element;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BACKGROUND_SHAPE = void 0;
/**
 * Name of Background Shape
 */

exports.BACKGROUND_SHAPE = 'element-background';

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerGeometryLabelLayout = exports.getGeometryLabelLayout = exports.registerGeometryLabel = exports.getGeometryLabel = void 0;
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
/**
 *  `type`  [[GeometryLabel]] 
 * @param type
 * @returns
 */

function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}

exports.getGeometryLabel = getGeometryLabel;
/**
 *  GeometryLabel 
 * @param type GeometryLabel 
 * @param ctor GeometryLabel 
 */

function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}

exports.registerGeometryLabel = registerGeometryLabel;
/**
 *  `type`  [[GeometryLabelsLayoutFn]] label 
 * @param type 
 * @returns
 */

function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}

exports.getGeometryLabelLayout = getGeometryLabelLayout;
/**
 *  label 
 * @param type label 
 * @param layoutFn label 
 */

function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}

exports.registerGeometryLabelLayout = registerGeometryLabelLayout;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var Shape = _interopRequireWildcard(__webpack_require__(148));

var _draw = __webpack_require__(149);

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(54);

var Group =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Group, _super);

  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Group.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };

  Group.prototype.getShapeBase = function () {
    return Shape;
  };

  Group.prototype.getGroupBase = function () {
    return Group;
  }; //  shape 


  Group.prototype._applyClip = function (context, clip) {
    if (clip) {
      context.save(); //  clip  context 

      (0, _draw.applyAttrsToContext)(context, clip); //  clip 

      clip.createPath(context);
      context.restore(); // 

      context.clip();

      clip._afterDraw();
    }
  }; //  getCanvasBBox group 
  //  15-20%  10W  5-6 ms 30-40ms


  Group.prototype.cacheCanvasBBox = function () {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    (0, _util.each)(children, function (child) {
      var bbox = child.cfg.cacheCanvasBBox; // isInview 
      //  10W  5-6 ms 

      if (bbox && child.cfg.isInView) {
        xArr.push(bbox.minX, bbox.maxX);
        yArr.push(bbox.minY, bbox.maxY);
      }
    });
    var bbox = null;

    if (xArr.length) {
      var minX = Math.min.apply(null, xArr);
      var maxX = Math.max.apply(null, xArr);
      var minY = Math.min.apply(null, yArr);
      var maxY = Math.max.apply(null, yArr);
      bbox = {
        minX: minX,
        minY: minY,
        x: minX,
        y: minY,
        maxX: maxX,
        maxY: maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;

      if (canvas) {
        var viewRange = canvas.getViewRange(); //  isInView == false  bbox  false 
        //  10W  2-5ms 

        this.set('isInView', (0, _util2.intersectRect)(bbox, viewRange));
      }
    } else {
      this.set('isInView', false);
    }

    this.set('cacheCanvasBBox', bbox);
  };

  Group.prototype.draw = function (context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true; // 
    //  G6  group  transform 
    //  refresh 
    //  refresh 

    if (children.length && allowDraw) {
      context.save(); // group 
      //  attrs  clip clip  matrix 

      (0, _draw.applyAttrsToContext)(context, this);

      this._applyClip(context, this.getClip());

      (0, _draw.drawChildren)(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    } // 
    // this.set('cacheCanvasBBox', this.getCanvasBBox());


    this.cfg.refresh = null; // 

    this.set('hasChanged', false);
  }; // 


  Group.prototype.skipDraw = function () {
    this.set('cacheCanvasBBox', null);
    this.set('hasChanged', false);
  };

  return Group;
}(_gBase.AbstractGroup);

var _default = Group;
exports.default = _default;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawChildren = drawChildren;
exports.refreshElement = refreshElement;

var _svg = __webpack_require__(150);

var _dom = __webpack_require__(72);

function drawChildren(context, children) {
  children.forEach(function (child) {
    child.draw(context);
  });
}
/**
 *  group  shape
 * @param {IElement} element       SVG 
 * @param {ChangeType} changeType  
 */


function refreshElement(element, changeType) {
  // canvas 
  var canvas = element.get('canvas'); // 

  if (canvas && canvas.get('autoDraw')) {
    var context = canvas.get('context');
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get('el');

    if (changeType === 'remove') {
      var isClipShape = element.get('isClipShape'); //  clip clipShape  SVG  clipPath 

      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;

        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === 'show') {
      el.setAttribute('visibility', 'visible');
    } else if (changeType === 'hide') {
      el.setAttribute('visibility', 'hidden');
    } else if (changeType === 'zIndex') {
      (0, _dom.moveTo)(el, parentChildren.indexOf(element));
    } else if (changeType === 'sort') {
      var children_1 = element.get('children');

      if (children_1 && children_1.length) {
        (0, _dom.sortDom)(element, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      // el maybe null for group
      if (el) {
        el.innerHTML = '';
      }
    } else if (changeType === 'matrix') {
      (0, _svg.setTransform)(element);
    } else if (changeType === 'clip') {
      (0, _svg.setClip)(element, context);
    } else if (changeType === 'attr') {//  afterAttrsChange  do nothing
    } else if (changeType === 'add') {
      element.draw(context);
    }
  }
}

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _util = __webpack_require__(0);

var Shape = _interopRequireWildcard(__webpack_require__(192));

var _draw = __webpack_require__(274);

var _svg = __webpack_require__(150);

var _constant = __webpack_require__(55);

var _dom = __webpack_require__(72);

var Group =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Group, _super);

  function Group() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // SVG  <g>


  Group.prototype.isEntityGroup = function () {
    return true;
  };

  Group.prototype.createDom = function () {
    var element = (0, _dom.createSVGElement)('g');
    this.set('el', element);
    var parent = this.getParent();

    if (parent) {
      var parentNode = parent.get('el');

      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        // parentNode maybe null for group
        parentNode = parent.createDom();
        parent.set('el', parentNode);
        parentNode.appendChild(element);
      }
    }

    return element;
  }; //  afterAttrsChange 


  Group.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);

    var canvas = this.get('canvas'); // 

    if (canvas && canvas.get('autoDraw')) {
      var context = canvas.get('context');
      this.createPath(context, targetAttrs);
    }
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Group.prototype.onCanvasChange = function (changeType) {
    (0, _draw.refreshElement)(this, changeType);
  };

  Group.prototype.getShapeBase = function () {
    return Shape;
  };

  Group.prototype.getGroupBase = function () {
    return Group;
  };

  Group.prototype.draw = function (context) {
    var children = this.getChildren();
    var el = this.get('el');

    if (this.get('destroyed')) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }

      (0, _svg.setClip)(this, context);
      this.createPath(context);

      if (children.length) {
        (0, _draw.drawChildren)(context, children);
      }
    }
  };
  /**
   * 
   * @param {Defs} context 
   * @param {ShapeAttrs} targetAttrs 
   */


  Group.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
    (0, _svg.setTransform)(this);
  };

  return Group;
}(_gBase.AbstractGroup);

var _default = Group;
exports.default = _default;

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_path_points_1 = __webpack_require__(277);

var get_style_1 = __webpack_require__(40);

var path_1 = __webpack_require__(146);

var split_points_1 = __webpack_require__(278);

var util_2 = __webpack_require__(446);

function getShapeAttrs(cfg, smooth, constraint) {
  var isStack = cfg.isStack,
      connectNulls = cfg.connectNulls,
      isInCircle = cfg.isInCircle,
      showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = get_style_1.getStyle(cfg, true, false, 'lineWidth');
  var points = get_path_points_1.getPathPoints(cfg.points, connectNulls, showSinglePoint); //  connectNulls  points

  var path = [];

  for (var i = 0, len = points.length; i < len; i++) {
    var eachLinePoints = points[i];
    path = path.concat(getPath(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }

  shapeAttrs.path = path;
  return shapeAttrs;
} //  path


function getSinglePath(points, isInCircle, smooth, constraint, style) {
  if (points.length === 1) {
    // 
    return [['M', points[0].x, points[0].y - style.lineWidth / 2], ['L', points[0].x, points[0].y], ['L', points[0].x, points[0].y + style.lineWidth / 2]];
  }

  var path;

  if (!smooth) {
    path = path_1.getLinePath(points, false);

    if (isInCircle) {
      path.push(['Z']);
    }
  } else {
    // 
    if (isInCircle && points.length) {
      points.push({
        x: points[0].x,
        y: points[0].y
      });
    }

    path = path_1.getSplinePath(points, false, constraint);
  }

  return path;
}

function getRangePath(points, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  util_1.each(points, function (point) {
    var result = split_points_1.splitPoints(point);
    topPoints.push(result[1]); // 

    bottomPoints.push(result[0]); // 
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);

  if (isStack) {
    return topPath;
  }

  return topPath.concat(bottomPath);
}

function getPath(points, isInCircle, isStack, smooth, constraint, style) {
  if (points.length) {
    var first = points[0];
    return util_1.isArray(first.y) ? getRangePath(points, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points, isInCircle, smooth, constraint, style);
  }

  return [];
}

var LineShapeFactory = base_1.registerShapeFactory('line', {
  defaultShapeType: 'line'
}); // 
// 'line' 'dot'  'dash'  - - -

util_1.each(['line', 'dot', 'dash', 'smooth'], function (shapeType) {
  base_1.registerShape('line', shapeType, {
    draw: function draw(cfg, container) {
      var smooth = shapeType === 'smooth';
      var constraint;

      if (smooth) {
        var _a = this.coordinate,
            start = _a.start,
            end = _a.end;
        constraint = [[start.x, end.y], [end.x, start.y]];
      }

      var attrs = getShapeAttrs(cfg, smooth, constraint);
      var shape = container.addShape({
        type: 'path',
        attrs: attrs,
        name: 'line',
        capture: !smooth
      });
      return shape;
    },
    getMarker: function getMarker(markerCfg) {
      return util_2.getLineMarker(markerCfg, shapeType);
    }
  });
});
exports.default = LineShapeFactory;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPathPoints = void 0;

var util_1 = __webpack_require__(0);

function isValueEmpty(value) {
  if (value) {
    return false;
  }

  return value === null || value === undefined || isNaN(value);
}

function isYNil(point) {
  if (util_1.isArray(point)) {
    //  area  [{x: 0, y: 1}, {x: 0, y: 2}]
    return isValueEmpty(point[1].y);
  }

  var value = point.y;
  return util_1.isArray(value) ? isValueEmpty(value[0]) : isValueEmpty(value);
}
/**
 * @ignore
 * y  null/undefined/NaN 
 * 
 *
 * ```typescript
 * // return [[{x: 1, y: 2}, {x: 3, y: 3}]]
 * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], true);
 * // return [[{x: 1, y: 2}], [{x: 3, y: 3}]]
 * getPathPoints([{x: 1, y: 2}, {x: 2, y: null}, {x: 3, y: 3}], false);
 * // return [[[{ x: 1, y: 10 }, { x: 2, y: 2 }], [{ x: 9, y: 34 }, { x: 1, y: 1 }]]]
 * getPathPoints([
 *   [{ x: 1, y: 10 }, { x: 2, y: 2 }],
 *   [{ x: 4, y: 2 }, { x: 8, y: NaN }],
 *   [{ x: 9, y: 34 }, { x: 1, y: 1 }],
 * ], true);
 * ```
 *
 * @param points 
 * @param connectNulls 
 * @param showSinglePoint 
 * @returns 
 */


function getPathPoints(points, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }

  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }

  if (!points.length || points.length === 1 && !showSinglePoint) {
    // 
    return [];
  }

  if (connectNulls) {
    //  y 
    var filtered = [];

    for (var i = 0, len = points.length; i < len; i++) {
      var point = points[i];

      if (!isYNil(point)) {
        filtered.push(point);
      }
    }

    return [filtered];
  }

  var result = [];
  var tmp = [];

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isYNil(point)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          // 
          result.push(tmp);
        }

        tmp = [];
      }
    } else {
      tmp.push(point);
    }
  }

  if (tmp.length) {
    result.push(tmp);
  }

  return result;
}

exports.getPathPoints = getPathPoints;

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.splitPoints = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 * 
 * @example
 * // result: [{x: 20, y: 20}, {x: 20, y: 30}]
 * splitPoints({x: 20,y: [20, 30]});
 * @example
 * // result: [{x: 20, y: 20}, {x: 30, y: 30}]
 * splitPoints({x: [20, 30],y: [20, 30]});
 * @param obj
 */


function splitPoints(obj) {
  // y  y  [19, 30] x 
  var x = obj.x;
  var y = util_1.isArray(obj.y) ? obj.y : [obj.y];
  return y.map(function (eachY, index) {
    return {
      x: util_1.isArray(x) ? x[index] : x,
      y: eachY
    };
  });
}

exports.splitPoints = splitPoints;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var util_2 = __webpack_require__(100);

var AreaShapeFactory = base_1.registerShapeFactory('area', {
  defaultShapeType: 'area',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    // area 
    var x = pointInfo.x,
        y0 = pointInfo.y0;
    var y = util_1.isArray(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function (yItem) {
      return {
        x: x,
        y: yItem
      };
    });
  }
}); // Area  shape

base_1.registerShape('area', 'area', {
  draw: function draw(cfg, container) {
    var attrs = util_2.getShapeAttrs(cfg, false, false, this);
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }

        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
      },
      style: {
        r: 5,
        fill: color
      }
    };
  }
});
exports.default = AreaShapeFactory;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawPoints = exports.HOLLOW_SHAPES = exports.SHAPES = void 0;

var tslib_1 = __webpack_require__(1);

var marker_1 = __webpack_require__(147);

var get_style_1 = __webpack_require__(40);

exports.SHAPES = ['circle', 'square', 'bowtie', 'diamond', 'hexagon', 'triangle', 'triangle-down'];
exports.HOLLOW_SHAPES = ['cross', 'tick', 'plus', 'hyphen', 'line'];
/**
 * @ignore
 * Draws points
 * @param shape
 * @param cfg
 * @param container
 * @param shapeName
 * @param isStroke
 * @returns points
 */

function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var style = get_style_1.getStyle(cfg, isStroke, !isStroke, 'r');
  var points = shape.parsePoints(cfg.points);
  var pointPosition = points[0];

  if (cfg.isStack) {
    pointPosition = points[1];
  } else if (points.length > 1) {
    var group = container.addGroup();

    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
      var point = points_1[_i];
      group.addShape({
        type: 'marker',
        attrs: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, style), {
          symbol: marker_1.MarkerSymbols[shapeName] || shapeName
        }), point)
      });
    }

    return group;
  }

  return container.addShape({
    type: 'marker',
    attrs: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, style), {
      symbol: marker_1.MarkerSymbols[shapeName] || shapeName
    }), pointPosition)
  });
}

exports.drawPoints = drawPoints;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_path_points_1 = __webpack_require__(277);

var get_style_1 = __webpack_require__(40);

var util_2 = __webpack_require__(446);

var interpolateCallback = function interpolateCallback(point, nextPoint, shapeType) {
  var x = point.x;
  var y = point.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;

  switch (shapeType) {
    case 'hv':
      result = [{
        x: nextX,
        y: y
      }];
      break;

    case 'vh':
      result = [{
        x: x,
        y: nextY
      }];
      break;

    case 'hvh':
      var middleX = (nextX + x) / 2;
      result = [{
        x: middleX,
        y: y
      }, {
        x: middleX,
        y: nextY
      }];
      break;

    case 'vhv':
      var middleY = (y + nextY) / 2;
      result = [{
        x: x,
        y: middleY
      }, {
        x: nextX,
        y: middleY
      }];
      break;

    default:
      break;
  }

  return result;
};

function getInterpolatePoints(points, shapeType) {
  var result = [];
  util_1.each(points, function (point, index) {
    var nextPoint = points[index + 1];
    result.push(point);

    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
} // pathnull


function getInterpolatePath(points) {
  return points.map(function (point, index) {
    return index === 0 ? ['M', point.x, point.y] : ['L', point.x, point.y];
  });
} // 


function getInterpolateShapeAttrs(cfg, shapeType) {
  var points = get_path_points_1.getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint); //  connectNulls  points

  var path = [];
  util_1.each(points, function (eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path = path.concat(getInterpolatePath(interpolatePoints));
  });
  return tslib_1.__assign(tslib_1.__assign({}, get_style_1.getStyle(cfg, true, false, 'lineWidth')), {
    path: path
  });
} // step line


util_1.each(['hv', 'vh', 'hvh', 'vhv'], function (shapeType) {
  base_1.registerShape('line', shapeType, {
    draw: function draw(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: 'path',
        attrs: attrs,
        name: 'line'
      });
      return shape;
    },
    getMarker: function getMarker(markerCfg) {
      return util_2.getLineMarker(markerCfg, shapeType);
    }
  });
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslateDirection = exports.directionToPosition = void 0;

var constant_1 = __webpack_require__(20);
/**
 * @ignore
 *  bbox 
 * @param parentBBox
 * @param bbox
 * @param direction
 */


function directionToPosition(parentBBox, bbox, direction) {
  if (direction === constant_1.DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }

  if (direction === constant_1.DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }

  if (direction === constant_1.DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }

  if (direction === constant_1.DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }

  if (direction === constant_1.DIRECTION.TOP_LEFT || direction === constant_1.DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }

  if (direction === constant_1.DIRECTION.TOP_RIGHT || direction === constant_1.DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }

  if (direction === constant_1.DIRECTION.BOTTOM_LEFT || direction === constant_1.DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }

  if (direction === constant_1.DIRECTION.BOTTOM_RIGHT || direction === constant_1.DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }

  return [0, 0];
}

exports.directionToPosition = directionToPosition;
/**
 * get direction after coordinate transpose
 * @param direction
 * @param coordinate
 * @returns direction after transpose or not
 */

function getTransposedDirection(direction, coordinate) {
  if (coordinate.isTransposed) {
    switch (direction) {
      case constant_1.DIRECTION.BOTTOM:
        return constant_1.DIRECTION.LEFT;

      case constant_1.DIRECTION.LEFT:
        return constant_1.DIRECTION.BOTTOM;

      case constant_1.DIRECTION.RIGHT:
        return constant_1.DIRECTION.TOP;

      case constant_1.DIRECTION.TOP:
        return constant_1.DIRECTION.RIGHT;
    }
  }

  return direction;
}

function reflectX(direct) {
  if (direct === constant_1.DIRECTION.LEFT) {
    return constant_1.DIRECTION.RIGHT;
  }

  if (direct === constant_1.DIRECTION.RIGHT) {
    return constant_1.DIRECTION.LEFT;
  }

  return direct;
}

function reflectY(direct) {
  if (direct === constant_1.DIRECTION.TOP) {
    return constant_1.DIRECTION.BOTTOM;
  }

  if (direct === constant_1.DIRECTION.BOTTOM) {
    return constant_1.DIRECTION.TOP;
  }

  return direct;
}
/**
 * get direction after coordinate.scale
 * @param direction
 * @param coordinate
 */


function getScaleDirection(direction, coordinate) {
  var x = coordinate.matrix[0];
  var y = coordinate.matrix[4];
  var d = direction;

  if (x < 0) {
    d = reflectX(d);
  }

  if (y < 0) {
    d = reflectY(d);
  }

  return d;
}
/**
 *
 * @param direction
 * @param coordinate
 */


function getReflectDirection(direction, coordinate) {
  var d = direction;

  if (coordinate.isReflect('x')) {
    d = reflectX(d);
  }

  if (coordinate.isReflect('y')) {
    d = reflectY(d);
  }

  return d;
}
/**
 * @ignore
 * get direction after coordinate translate
 * @param direction
 * @param coordinate
 */


function getTranslateDirection(direction, coordinate) {
  var d = direction;
  d = getTransposedDirection(d, coordinate);
  d = getScaleDirection(d, coordinate);
  d = getReflectDirection(d, coordinate);
  return d;
}

exports.getTranslateDirection = getTranslateDirection;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var state_base_1 = tslib_1.__importDefault(__webpack_require__(284));

function getItem(shape) {
  return util_1.get(shape.get('delegateObject'), 'item');
}
/**
 *  Action  Element 
 * @class
 * @ignore
 */


var ElementState =
/** @class */
function (_super) {
  tslib_1.__extends(ElementState, _super);

  function ElementState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.ignoreListItemStates = ['unchecked'];
    return _this;
  } // 


  ElementState.prototype.isItemIgnore = function (item, list) {
    var states = this.ignoreListItemStates;
    var filtered = states.filter(function (state) {
      return list.hasState(item, state);
    });
    return !!filtered.length;
  }; // 


  ElementState.prototype.setStateByComponent = function (component, item, enable) {
    var view = this.context.view;
    var field = component.get('field');
    var elements = util_2.getElements(view);
    this.setElementsStateByItem(elements, field, item, enable);
  }; //  element 


  ElementState.prototype.setStateByElement = function (element, enable) {
    this.setElementState(element, enable);
  };
  /**  element  */


  ElementState.prototype.isMathItem = function (element, field, item) {
    var view = this.context.view;
    var scale = util_2.getScaleByField(view, field);
    var value = util_2.getElementValue(element, field);
    return !util_1.isNil(value) && item.name === scale.getText(value);
  };

  ElementState.prototype.setElementsStateByItem = function (elements, field, item, enable) {
    var _this = this;

    util_1.each(elements, function (el) {
      if (_this.isMathItem(el, field, item)) {
        el.setState(_this.stateName, enable);
      }
    });
  };
  /**  */


  ElementState.prototype.setStateEnable = function (enable) {
    var element = util_2.getCurrentElement(this.context);

    if (element) {
      //  element 
      if (util_2.isElementChange(this.context)) {
        this.setStateByElement(element, enable);
      }
    } else {
      // 
      var delegateObject = util_2.getDelegationObject(this.context); // 

      if (util_2.isList(delegateObject)) {
        var item = delegateObject.item,
            component = delegateObject.component;

        if (item && component && !this.isItemIgnore(item, component)) {
          var event_1 = this.context.event.gEvent; // 

          if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
            return;
          }

          this.setStateByComponent(component, item, enable);
        }
      }
    }
  };
  /**
   * 
   */


  ElementState.prototype.toggle = function () {
    var element = util_2.getCurrentElement(this.context);

    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setElementState(element, !hasState);
    }
  };
  /**
   * 
   */


  ElementState.prototype.reset = function () {
    this.setStateEnable(false);
  };

  return ElementState;
}(state_base_1.default);

exports.default = ElementState;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_2 = __webpack_require__(30);
/**
 *  Action 
 * @abstract
 * @class
 * @ignore
 */


var StateBase =
/** @class */
function (_super) {
  tslib_1.__extends(StateBase, _super);

  function StateBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * 
     */


    _this.stateName = '';
    return _this;
  }
  /**
   * 
   * @param element  Element 
   */


  StateBase.prototype.hasState = function (element) {
    return element.hasState(this.stateName);
  };
  /**
   * 
   * @param enable 
   */


  StateBase.prototype.setElementState = function (element, enable) {
    // 
    element.setState(this.stateName, enable);
  };
  /**
   * 
   */


  StateBase.prototype.setState = function () {
    this.setStateEnable(true);
  };
  /**
   *  Element 
   */


  StateBase.prototype.clear = function () {
    var view = this.context.view;
    this.clearViewState(view);
  };

  StateBase.prototype.clearViewState = function (view) {
    var _this = this;

    var elements = util_2.getElementsByState(view, this.stateName);
    util_1.each(elements, function (el) {
      _this.setElementState(el, false);
    });
  };

  return StateBase;
}(base_1.default);

exports.default = StateBase;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var state_base_1 = tslib_1.__importDefault(__webpack_require__(284));
/**
 * @ignore
 *  Action
 */


var ElementRangeState =
/** @class */
function (_super) {
  tslib_1.__extends(ElementRangeState, _super);

  function ElementRangeState() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.startPoint = null;
    _this.endPoint = null;
    _this.isStarted = false;
    /**
     *  view  siblings false 
     */

    _this.effectSiblings = false;
    /**
     *  element 
     */

    _this.effectByRecord = false;
    return _this;
  } // 


  ElementRangeState.prototype.getCurrentPoint = function () {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  };
  /**
   * 
   */


  ElementRangeState.prototype.start = function () {
    this.clear(); // 

    this.startPoint = this.getCurrentPoint();
    this.isStarted = true;
  };

  ElementRangeState.prototype.getIntersectElements = function () {
    var elements = null;

    if (util_2.isMask(this.context)) {
      elements = util_2.getMaskedElements(this.context, 10);
    } else {
      var startPoint = this.startPoint;
      var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint; // 

      if (!startPoint || !endPoint) {
        return;
      } // 


      var box = {
        minX: Math.min(startPoint.x, endPoint.x),
        minY: Math.min(startPoint.y, endPoint.y),
        maxX: Math.max(startPoint.x, endPoint.x),
        maxY: Math.max(startPoint.y, endPoint.y)
      }; // this.clear(); // 

      var view = this.context.view;
      elements = util_2.getIntersectElements(view, box);
    }

    return elements;
  };
  /**
   * 
   */


  ElementRangeState.prototype.setStateEnable = function (enable) {
    if (this.effectSiblings && !this.effectByRecord) {
      this.setSiblingsState(enable);
    } else {
      var allElements = util_2.getElements(this.context.view);
      var elements = this.getIntersectElements();

      if (elements && elements.length) {
        if (this.effectByRecord) {
          this.setSiblingsStateByRecord(elements, enable);
        } else {
          this.setElementsState(elements, enable, allElements);
        }
      } else {
        this.clear();
      }
    }
  }; //  element 


  ElementRangeState.prototype.setSiblingsStateByRecord = function (elements, enable) {
    var _this = this;

    var view = this.context.view;
    var siblings = util_2.getSilbings(view);
    var records = elements.map(function (el) {
      return el.getModel().data;
    });
    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    util_1.each(siblings, function (sibling) {
      var allElements = util_2.getElements(sibling);
      var effectElements = allElements.filter(function (el) {
        var record = el.getModel().data;
        return util_2.isInRecords(records, record, xFiled, yField);
      });

      _this.setElementsState(effectElements, enable, allElements);
    });
  }; //  view 


  ElementRangeState.prototype.setSiblingsState = function (enable) {
    var _this = this;

    var view = this.context.view;
    var siblings = util_2.getSilbings(view);

    if (util_2.isMask(this.context)) {
      //  mask 
      util_1.each(siblings, function (sibling) {
        var allElements = util_2.getElements(sibling);
        var effectElements = util_2.getSiblingMaskElements(_this.context, sibling, 10);

        if (effectElements && effectElements.length) {
          _this.setElementsState(effectElements, enable, allElements);
        } else {
          _this.clearViewState(sibling);
        }
      });
    }
  };

  ElementRangeState.prototype.setElementsState = function (elements, enable, allElements) {
    var _this = this;

    util_1.each(allElements, function (el) {
      if (!elements.includes(el)) {
        _this.setElementState(el, false);
      } else {
        _this.setElementState(el, enable);
      }
    });
  };
  /**
   * 
   */


  ElementRangeState.prototype.end = function () {
    this.isStarted = false;
    this.endPoint = this.getCurrentPoint();
  }; //  clear


  ElementRangeState.prototype.clear = function () {
    var _this = this;

    var view = this.context.view; //  siblings

    if (this.effectSiblings) {
      var siblings = util_2.getSilbings(view);
      util_1.each(siblings, function (sibling) {
        _this.clearViewState(sibling);
      });
    } else {
      this.clearViewState(view);
    }
  };

  return ElementRangeState;
}(state_base_1.default);

exports.default = ElementRangeState;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(30);

var state_base_1 = tslib_1.__importDefault(__webpack_require__(284));
/**
 *  Action 
 * @class
 * @ignore
 */


var ElementSingleState =
/** @class */
function (_super) {
  tslib_1.__extends(ElementSingleState, _super);

  function ElementSingleState() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ElementSingleState.prototype.setStateEnable = function (enable) {
    var element = util_1.getCurrentElement(this.context);

    if (element) {
      //  element  label  shape 
      if (!util_1.isElementChange(this.context)) {
        return;
      } //  element 


      if (enable) {
        this.clear();
        this.setElementState(element, true);
      } else if (this.hasState(element)) {
        this.setElementState(element, false);
      }
    }
  };
  /**
   * 
   */


  ElementSingleState.prototype.toggle = function () {
    var element = util_1.getCurrentElement(this.context);

    if (element) {
      var hasState = this.hasState(element); // 

      if (!hasState) {
        this.clear();
      }

      this.setElementState(element, !hasState);
    }
  };
  /**
   * 
   */


  ElementSingleState.prototype.reset = function () {
    this.setStateEnable(false);
  };

  return ElementSingleState;
}(state_base_1.default);

exports.default = ElementSingleState;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setHighlightBy = exports.clearHighlight = void 0;

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
/**
 * @ignore
 *  highlight 
 * @param view View  Chart
 */

function clearHighlight(view) {
  var elements = util_2.getElements(view);
  util_1.each(elements, function (el) {
    if (el.hasState(STATUS_ACTIVE)) {
      el.setState(STATUS_ACTIVE, false);
    }

    if (el.hasState(STATUS_UNACTIVE)) {
      el.setState(STATUS_UNACTIVE, false);
    }
  });
}

exports.clearHighlight = clearHighlight;
/**
 * @ignore
 *  highlight
 * @param elements 
 * @param callback 
 * @param enable 
 */

function setHighlightBy(elements, callback, enable) {
  util_1.each(elements, function (el) {
    //  active  unactive 
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE)) {
        el.setState(STATUS_UNACTIVE, false);
      }

      el.setState(STATUS_ACTIVE, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE)) {
        el.setState(STATUS_ACTIVE, false);
      }

      el.setState(STATUS_UNACTIVE, enable);
    }
  });
}

exports.setHighlightBy = setHighlightBy;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));
/**
 * @ignore
 *  Action 
 */


var MaskBase =
/** @class */
function (_super) {
  tslib_1.__extends(MaskBase, _super);

  function MaskBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this; // mask 


    _this.maskShape = null; //  mask 

    _this.points = []; //  mask 

    _this.starting = false; // 

    _this.moving = false;
    _this.preMovePoint = null;
    _this.shapeType = 'path';
    return _this;
  } // 


  MaskBase.prototype.getCurrentPoint = function () {
    var event = this.context.event;
    return {
      x: event.x,
      y: event.y
    };
  }; //  mask 


  MaskBase.prototype.emitEvent = function (type) {
    var eventName = "mask:" + type;
    var view = this.context.view;
    var event = this.context.event;
    view.emit(eventName, {
      target: this.maskShape,
      shape: this.maskShape,
      points: this.points,
      x: event.x,
      y: event.y
    });
  }; //  mask


  MaskBase.prototype.createMask = function () {
    var view = this.context.view;
    var maskAttrs = this.getMaskAttrs();
    var maskShape = view.foregroundGroup.addShape({
      type: this.shapeType,
      name: 'mask',
      draggable: true,
      attrs: tslib_1.__assign({
        fill: '#C5D4EB',
        opacity: 0.3
      }, maskAttrs)
    });
    return maskShape;
  }; //  mask 


  MaskBase.prototype.getMaskPath = function () {
    return [];
  };
  /**
   * 
   */


  MaskBase.prototype.show = function () {
    if (this.maskShape) {
      this.maskShape.show();
      this.emitEvent('show');
    }
  };
  /**
   * 
   */


  MaskBase.prototype.start = function () {
    this.starting = true; // 

    this.moving = false;
    this.points = [this.getCurrentPoint()];

    if (!this.maskShape) {
      this.maskShape = this.createMask(); //  capture: falseresize 

      this.maskShape.set('capture', false);
    }

    this.updateMask();
    this.emitEvent('start');
  };
  /**
   * 
   */


  MaskBase.prototype.moveStart = function () {
    this.moving = true;
    this.preMovePoint = this.getCurrentPoint();
  };
  /**
   *  mask
   */


  MaskBase.prototype.move = function () {
    if (!this.moving || !this.maskShape) {
      return;
    }

    var currentPoint = this.getCurrentPoint();
    var preMovePoint = this.preMovePoint;
    var dx = currentPoint.x - preMovePoint.x;
    var dy = currentPoint.y - preMovePoint.y;
    var points = this.points;
    util_1.each(points, function (point) {
      point.x += dx;
      point.y += dy;
    });
    this.updateMask();
    this.emitEvent('change');
    this.preMovePoint = currentPoint;
  };

  MaskBase.prototype.updateMask = function () {
    var attrs = this.getMaskAttrs();
    this.maskShape.attr(attrs);
  };
  /**
   * 
   */


  MaskBase.prototype.moveEnd = function () {
    this.moving = false;
    this.preMovePoint = null;
  };
  /**
   * 
   */


  MaskBase.prototype.end = function () {
    this.starting = false;
    this.emitEvent('end');

    if (this.maskShape) {
      this.maskShape.set('capture', true);
    }
  };
  /**
   * 
   */


  MaskBase.prototype.hide = function () {
    if (this.maskShape) {
      this.maskShape.hide();
      this.emitEvent('hide');
    }
  };
  /**
   * 
   */


  MaskBase.prototype.resize = function () {
    // 
    if (this.starting && this.maskShape) {
      this.points.push(this.getCurrentPoint());
      this.updateMask();
      this.emitEvent('change');
    }
  };
  /**
   * 
   */


  MaskBase.prototype.destroy = function () {
    this.points = [];

    if (this.maskShape) {
      this.maskShape.remove();
    }

    this.maskShape = null;
    this.preMovePoint = null;

    _super.prototype.destroy.call(this);
  };

  return MaskBase;
}(base_1.default);

exports.default = MaskBase;

/***/ }),
/* 289 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Label; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(99);
/* harmony import */ var _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(168);
/* harmony import */ var _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(169);
/* harmony import */ var _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(212);
/* harmony import */ var _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(324);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(325);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(326);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(223);
/* harmony import */ var _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_10__);
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

 //  Geometry  label




 //  Geometry label 







Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('base', _antv_g2_lib_geometry_label_base__WEBPACK_IMPORTED_MODULE_1___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('interval', _antv_g2_lib_geometry_label_interval__WEBPACK_IMPORTED_MODULE_2___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('pie', _antv_g2_lib_geometry_label_pie__WEBPACK_IMPORTED_MODULE_3___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabel"])('polar', _antv_g2_lib_geometry_label_polar__WEBPACK_IMPORTED_MODULE_4___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('overlap', _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__["overlap"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('distribute', _antv_g2_lib_geometry_label_layout_pie_distribute__WEBPACK_IMPORTED_MODULE_5__["distribute"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('fixed-overlap', _antv_g2_lib_geometry_label_layout_overlap__WEBPACK_IMPORTED_MODULE_8__["fixedOverlap"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('limit-in-shape', _antv_g2_lib_geometry_label_layout_limit_in_shape__WEBPACK_IMPORTED_MODULE_7__["limitInShape"]);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerGeometryLabelLayout"])('limit-in-canvas', _antv_g2_lib_geometry_label_layout_limit_in_canvas__WEBPACK_IMPORTED_MODULE_6__["limitInCanvas"]);
function Label(props) {
  var parentInstance = props.parentInstance,
      content = props.content,
      cfg = __rest(props, ["parentInstance", "content"]);

  warning__WEBPACK_IMPORTED_MODULE_10___default()(false, 'Labellabel');
  parentInstance.label(false);
  parentInstance.label(content, cfg);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null);
}

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_COLORS = exports.AXIS_META_CONFIG_KEYS = void 0;
/**
 *  meta  key 
 */

exports.AXIS_META_CONFIG_KEYS = ['type', 'alias', 'tickCount', 'tickInterval', 'min', 'max', 'nice', 'minLimit', 'maxLimit', // 
'range', 'tickMethod', // type: 'log' 
'base', // type: 'exp' 
'exponent', // time 
'mask'];
/**
 * 
 */

exports.DEFAULT_COLORS = {
  GRADIENT: {
    CONTINUOUS: '#BAE7FF-#1890FF-#0050B3'
  }
};

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProgressData = void 0;

var util_1 = __webpack_require__(0);

var number_1 = __webpack_require__(490);
/**
 * 
 */


function getProgressData(percent) {
  var clampPercent = util_1.clamp(number_1.isRealNumber(percent) ? percent : 0, 0, 1);
  return [{
    type: 'current',
    percent: clampPercent
  }, {
    type: 'target',
    percent: 1 - clampPercent
  }];
}

exports.getProgressData = getProgressData;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cluster", {
  enumerable: true,
  get: function get() {
    return _cluster.default;
  }
});
Object.defineProperty(exports, "hierarchy", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
Object.defineProperty(exports, "pack", {
  enumerable: true,
  get: function get() {
    return _index2.default;
  }
});
Object.defineProperty(exports, "packSiblings", {
  enumerable: true,
  get: function get() {
    return _siblings.default;
  }
});
Object.defineProperty(exports, "packEnclose", {
  enumerable: true,
  get: function get() {
    return _enclose.default;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function get() {
    return _partition.default;
  }
});
Object.defineProperty(exports, "stratify", {
  enumerable: true,
  get: function get() {
    return _stratify.default;
  }
});
Object.defineProperty(exports, "tree", {
  enumerable: true,
  get: function get() {
    return _tree.default;
  }
});
Object.defineProperty(exports, "treemap", {
  enumerable: true,
  get: function get() {
    return _index3.default;
  }
});
Object.defineProperty(exports, "treemapBinary", {
  enumerable: true,
  get: function get() {
    return _binary.default;
  }
});
Object.defineProperty(exports, "treemapDice", {
  enumerable: true,
  get: function get() {
    return _dice.default;
  }
});
Object.defineProperty(exports, "treemapSlice", {
  enumerable: true,
  get: function get() {
    return _slice.default;
  }
});
Object.defineProperty(exports, "treemapSliceDice", {
  enumerable: true,
  get: function get() {
    return _sliceDice.default;
  }
});
Object.defineProperty(exports, "treemapSquarify", {
  enumerable: true,
  get: function get() {
    return _squarify.default;
  }
});
Object.defineProperty(exports, "treemapResquarify", {
  enumerable: true,
  get: function get() {
    return _resquarify.default;
  }
});

var _cluster = _interopRequireDefault(__webpack_require__(1023));

var _index = _interopRequireDefault(__webpack_require__(293));

var _index2 = _interopRequireDefault(__webpack_require__(1038));

var _siblings = _interopRequireDefault(__webpack_require__(493));

var _enclose = _interopRequireDefault(__webpack_require__(495));

var _partition = _interopRequireDefault(__webpack_require__(1039));

var _stratify = _interopRequireDefault(__webpack_require__(1040));

var _tree = _interopRequireDefault(__webpack_require__(1041));

var _index3 = _interopRequireDefault(__webpack_require__(1042));

var _binary = _interopRequireDefault(__webpack_require__(1043));

var _dice = _interopRequireDefault(__webpack_require__(155));

var _slice = _interopRequireDefault(__webpack_require__(195));

var _sliceDice = _interopRequireDefault(__webpack_require__(1044));

var _squarify = _interopRequireDefault(__webpack_require__(295));

var _resquarify = _interopRequireDefault(__webpack_require__(1045));

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hierarchy;
exports.computeHeight = computeHeight;
exports.Node = Node;

var _defineProperty2 = _interopRequireDefault(__webpack_require__(227));

var _count = _interopRequireDefault(__webpack_require__(1024));

var _each = _interopRequireDefault(__webpack_require__(1025));

var _eachBefore = _interopRequireDefault(__webpack_require__(1026));

var _eachAfter = _interopRequireDefault(__webpack_require__(1027));

var _find = _interopRequireDefault(__webpack_require__(1028));

var _sum = _interopRequireDefault(__webpack_require__(1029));

var _sort = _interopRequireDefault(__webpack_require__(1030));

var _path = _interopRequireDefault(__webpack_require__(1031));

var _ancestors = _interopRequireDefault(__webpack_require__(1032));

var _descendants = _interopRequireDefault(__webpack_require__(1033));

var _leaves = _interopRequireDefault(__webpack_require__(1034));

var _links = _interopRequireDefault(__webpack_require__(1035));

var _iterator = _interopRequireDefault(__webpack_require__(1036));

function hierarchy(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }

  var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function objectChildren(d) {
  return d.children;
}

function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}

function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;

  do {
    node.height = height;
  } while ((node = node.parent) && node.height < ++height);
}

function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = (0, _defineProperty2.default)({
  constructor: Node,
  count: _count.default,
  each: _each.default,
  eachAfter: _eachAfter.default,
  eachBefore: _eachBefore.default,
  find: _find.default,
  sum: _sum.default,
  sort: _sort.default,
  path: _path.default,
  ancestors: _ancestors.default,
  descendants: _descendants.default,
  leaves: _leaves.default,
  links: _links.default,
  copy: node_copy
}, Symbol.iterator, _iterator.default);

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optional = optional;
exports.required = required;

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.squarifyRatio = squarifyRatio;
exports.default = exports.phi = void 0;

var _dice = _interopRequireDefault(__webpack_require__(155));

var _slice = _interopRequireDefault(__webpack_require__(195));

var phi = (1 + Math.sqrt(5)) / 2;
exports.phi = phi;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.

    do {
      sumValue = nodes[i1++].value;
    } while (!sumValue && i1 < n);

    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.

    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);

      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }

      minRatio = newRatio;
    } // Position and record the row orientation.


    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var _default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}(phi);

exports.default = _default;

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagComponent = exports.transformData = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(119);
/**
 *  transform
 * @param geometry
 */


function transformData(data, originData, options) {
  var formatData = [];
  var yField = options.yField,
      maxSize = options.maxSize,
      minSize = options.minSize;
  var maxYFieldValue = util_1.maxBy(originData, yField)[yField];
  var max = util_1.isNumber(maxSize) ? maxSize : 1;
  var min = util_1.isNumber(minSize) ? minSize : 0; // format 

  formatData = util_1.map(data, function (row, index) {
    var percent = (row[yField] || 0) / maxYFieldValue;
    row[constant_1.FUNNEL_PERCENT] = percent;
    row[constant_1.FUNNEL_MAPPING_VALUE] = (max - min) * percent + min; // 

    row[constant_1.FUNNEL_CONVERSATION] = [util_1.get(data, [index - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}

exports.transformData = transformData;
/**
 * 
 * @param getLineCoordinate  line 
 */

function conversionTagComponent(getLineCoordinate) {
  return function (params) {
    var chart = params.chart,
        options = params.options;
    var conversionTag = options.conversionTag;
    var data = chart.getOptions().data;

    if (conversionTag) {
      var formatter_1 = conversionTag.formatter;
      data.forEach(function (obj, index) {
        if (index <= 0) return;
        var lineOption = getLineCoordinate(obj, index, data, {
          top: true,
          text: {
            content: util_1.isFunction(formatter_1) ? formatter_1(obj, data) : formatter_1,
            offsetX: conversionTag.offsetX,
            offsetY: conversionTag.offsetY,
            position: 'end',
            autoRotate: false,
            style: tslib_1.__assign({
              textAlign: 'start',
              textBaseline: 'middle'
            }, conversionTag.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }

    return params;
  };
}

exports.conversionTagComponent = conversionTagComponent;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLine = isLine;
exports.isColumn = isColumn;
exports.getGeometryOption = getGeometryOption;
exports.transformObjectToArray = transformObjectToArray;
exports.getYAxisWithDefault = getYAxisWithDefault;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _types = __webpack_require__(526);

var _constant = __webpack_require__(527);

/**
 *  GeometryOption  geometry  line
 */
function isLine(geometryOption) {
  return (0, _util.get)(geometryOption, 'geometry') === _types.DualAxesGeometry.Line;
}
/**
 *  GeometryOption  geometry  Column
 */


function isColumn(geometryOption) {
  return (0, _util.get)(geometryOption, 'geometry') === _types.DualAxesGeometry.Column;
}
/**
 *  GeometryOption
 * @param geometryOption
 * @param axis
 */


function getGeometryOption(xField, yField, geometryOption) {
  // 
  return isColumn(geometryOption) ? (0, _utils.deepAssign)({}, {
    geometry: _types.DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function content(item) {
        var _a;

        return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
      }
    } : undefined
  }, geometryOption) : (0, _tslib.__assign)({
    geometry: _types.DualAxesGeometry.Line
  }, geometryOption);
}
/**
 *   arr  obj   yAxisannotations
 *  yField  object 
 * @param yField
 * @param transformAttribute
 */


function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0],
      y2 = yField[1];

  if ((0, _util.isArray)(transformAttribute)) {
    // 
    var a1_1 = transformAttribute[0],
        a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }

  var a1 = (0, _util.get)(transformAttribute, y1);
  var a2 = (0, _util.get)(transformAttribute, y2);
  return [a1, a2];
}
/**
 * 
 * @param yAxis
 * @param axisType
 */


function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === _types.AxisType.Left) {
    return yAxis === false ? false : (0, _utils.deepAssign)({}, _constant.DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === _types.AxisType.Right) {
    return yAxis === false ? false : (0, _utils.deepAssign)({}, _constant.DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }

  return yAxis;
}

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProgressData = getProgressData;

var _util = __webpack_require__(0);

var _number = __webpack_require__(518);

/**
 * 
 */
function getProgressData(percent) {
  var clampPercent = (0, _util.clamp)((0, _number.isRealNumber)(percent) ? percent : 0, 0, 1);
  return [{
    type: 'current',
    percent: clampPercent
  }, {
    type: 'target',
    percent: 1 - clampPercent
  }];
}

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TOOLTIP_OPTIONS = exports.TREND_COLOR = exports.TREND_DOWN = exports.TREND_UP = exports.TREND_FIELD = exports.Y_FIELD = void 0;
var Y_FIELD = '$$stock-range$$';
exports.Y_FIELD = Y_FIELD;
var TREND_FIELD = 'trend';
exports.TREND_FIELD = TREND_FIELD;
var TREND_UP = 'up';
exports.TREND_UP = TREND_UP;
var TREND_DOWN = 'down';
exports.TREND_DOWN = TREND_DOWN;
var TREND_COLOR = ['#ef5350', '#26a69a'];
/** tooltip  */

exports.TREND_COLOR = TREND_COLOR;
var DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: 'xy',
    follow: true
  },
  itemTpl: '<li class="g2-tooltip-list-item" data-index={index}>' + '<span style="background-color:{color};" class="g2-tooltip-marker"></span>' + '{name}{value}</li>'
};
exports.DEFAULT_TOOLTIP_OPTIONS = DEFAULT_TOOLTIP_OPTIONS;

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = transformData;
exports.conversionTagComponent = conversionTagComponent;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(124);

/**
 *  transform
 * @param geometry
 */
function transformData(data, originData, options) {
  var formatData = [];
  var yField = options.yField,
      maxSize = options.maxSize,
      minSize = options.minSize;
  var maxYFieldValue = (0, _util.maxBy)(originData, yField)[yField];
  var max = (0, _util.isNumber)(maxSize) ? maxSize : 1;
  var min = (0, _util.isNumber)(minSize) ? minSize : 0; // format 

  formatData = (0, _util.map)(data, function (row, index) {
    var percent = (row[yField] || 0) / maxYFieldValue;
    row[_constant.FUNNEL_PERCENT] = percent;
    row[_constant.FUNNEL_MAPPING_VALUE] = (max - min) * percent + min; // 

    row[_constant.FUNNEL_CONVERSATION] = [(0, _util.get)(data, [index - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
/**
 * 
 * @param getLineCoordinate  line 
 */


function conversionTagComponent(getLineCoordinate) {
  return function (params) {
    var chart = params.chart,
        options = params.options;
    var conversionTag = options.conversionTag;
    var data = chart.getOptions().data;

    if (conversionTag) {
      var formatter_1 = conversionTag.formatter;
      data.forEach(function (obj, index) {
        if (index <= 0) return;
        var lineOption = getLineCoordinate(obj, index, data, {
          top: true,
          text: {
            content: (0, _util.isFunction)(formatter_1) ? formatter_1(obj, data) : formatter_1,
            offsetX: conversionTag.offsetX,
            offsetY: conversionTag.offsetY,
            position: 'end',
            autoRotate: false,
            style: (0, _tslib.__assign)({
              textAlign: 'start',
              textBaseline: 'middle'
            }, conversionTag.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }

    return params;
  };
}

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function _default(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    step = -step;
    start = Math.ceil(start * step);
    stop = Math.floor(stop * step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) / step;
    }
  }

  if (reverse) ticks.reverse();
  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantile;
exports.quantileSorted = quantileSorted;

var _max = _interopRequireDefault(__webpack_require__(557));

var _min = _interopRequireDefault(__webpack_require__(303));

var _quickselect = _interopRequireDefault(__webpack_require__(558));

var _number = _interopRequireWildcard(__webpack_require__(546));

function quantile(values, p, valueof) {
  values = Float64Array.from((0, _number.numbers)(values, valueof));
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return (0, _min.default)(values);
  if (p >= 1) return (0, _max.default)(values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = (0, _max.default)((0, _quickselect.default)(values, i0).subarray(0, i0 + 1)),
      value1 = (0, _min.default)(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}

function quantileSorted(values, p) {
  var valueof = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _number.default;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = min;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function min(values, valueof) {
  var min;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null && (min > value || min === undefined && value >= value)) {
          min = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (min > _value || min === undefined && _value >= _value)) {
          min = _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return min;
}

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = __webpack_require__(160);

var _constant = _interopRequireDefault(__webpack_require__(107));

var _linear = _interopRequireDefault(__webpack_require__(198));

var _point = __webpack_require__(305);

function _default() {
  var x = _point.x,
      y = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }

      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : x;
  };

  line.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : y;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = _point;
exports.default = void 0;

var _math = __webpack_require__(161);

var _cardinal = __webpack_require__(201);

function _point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        this.point(this._x2, this._y2);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        _point(this, x, y);

        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal.Cardinal(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.sum = sum;

var _none = _interopRequireDefault(__webpack_require__(163));

function _default(series) {
  var sums = series.map(sum);
  return (0, _none.default)(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
}

function sum(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;

  while (++i < n) {
    if (v = +series[i][1]) s += v;
  }

  return s;
}

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var dependents_1 = __webpack_require__(68);

var animate_1 = __webpack_require__(96);

var constant_1 = __webpack_require__(20);

var coordinate_1 = __webpack_require__(51);

var helper_1 = __webpack_require__(76);

var annotation_1 = __webpack_require__(853);

var base_1 = __webpack_require__(104);
/**  */


var ANNOTATIONS_AFTER_RENDER = ['regionFilter', 'shape'];
/**
 * Annotation controller, :
 * 1.  Annotation: linetextarc ...
 * 2. : initlayoutrendercleardestroy
 */

var Annotation =
/** @class */
function (_super) {
  tslib_1.__extends(Annotation, _super);

  function Annotation(view) {
    var _this = _super.call(this, view) || this;
    /*  cache object :  */


    _this.cache = new Map();
    _this.foregroundContainer = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.backgroundContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    _this.option = [];
    return _this;
  }

  Object.defineProperty(Annotation.prototype, "name", {
    get: function get() {
      return 'annotation';
    },
    enumerable: false,
    configurable: true
  });

  Annotation.prototype.init = function () {};
  /**
   *  annotation  render  layout 
   */


  Annotation.prototype.layout = function () {
    this.update();
  }; //  Annotation  layout() 


  Annotation.prototype.render = function () {};
  /**
   * 
   */


  Annotation.prototype.update = function () {
    var _this = this; // 1.   Geometry 


    this.onAfterRender(function () {
      var updated = new Map(); //  regionFilter/shape 

      util_1.each(_this.option, function (option) {
        if (util_1.includes(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option); // 


          if (co) {
            updated.set(_this.getCacheKey(option), co);
          }
        }
      }); //  cache
      // 

      _this.cache = _this.syncCache(updated);
    }); // 2.  regionFilter

    var updateCache = new Map();
    util_1.each(this.option, function (option) {
      if (!util_1.includes(ANNOTATIONS_AFTER_RENDER, option.type)) {
        var co = _this.updateOrCreate(option); // 


        if (co) {
          updateCache.set(_this.getCacheKey(option), co);
        }
      }
    });
    this.cache = this.syncCache(updateCache);
  };
  /**
   * 
   * @param includeOption  option 
   */


  Annotation.prototype.clear = function (includeOption) {
    if (includeOption === void 0) {
      includeOption = false;
    }

    _super.prototype.clear.call(this);

    this.clearComponents();
    this.foregroundContainer.clear();
    this.backgroundContainer.clear(); // clear all option

    if (includeOption) {
      this.option = [];
    }
  };

  Annotation.prototype.destroy = function () {
    this.clear(true);
    this.foregroundContainer.remove(true);
    this.backgroundContainer.remove(true);
  };
  /**
   * 
   */


  Annotation.prototype.getComponents = function () {
    var co = [];
    this.cache.forEach(function (value) {
      co.push(value);
    });
    return co;
  };
  /**
   * 
   */


  Annotation.prototype.clearComponents = function () {
    this.getComponents().forEach(function (co) {
      co.component.destroy();
    });
    this.cache.clear();
  };
  /**
   * region filter 
   * @param doWhat
   */


  Annotation.prototype.onAfterRender = function (doWhat) {
    if (this.view.getOptions().animate) {
      this.view.geometries.forEach(function (g) {
        //  geometry 
        if (g.animateOption) {
          g.once(constant_1.GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function () {
            doWhat();
          });
        }
      });
    } else {
      this.view.getRootView().once(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, function () {
        doWhat();
      });
    }
  };

  Annotation.prototype.createAnnotation = function (option) {
    var type = option.type;
    var Ctor = dependents_1.Annotation[util_1.upperFirst(type)];

    if (Ctor) {
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme);
      var annotation = new Ctor(cfg);
      return {
        component: annotation,
        layer: this.isTop(cfg) ? constant_1.LAYER.FORE : constant_1.LAYER.BG,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.ANNOTATION,
        extra: option
      };
    }
  }; // APIs for creating annotation component


  Annotation.prototype.annotation = function (option) {
    this.option.push(option);
  };
  /**
   *  Arc
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.arc = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'arc'
    }, option));
    return this;
  };
  /**
   *  image
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.image = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'image'
    }, option));
    return this;
  };
  /**
   *  Line
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.line = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'line'
    }, option));
    return this;
  };
  /**
   *  Region
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.region = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'region'
    }, option));
    return this;
  };
  /**
   *  Text
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.text = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'text'
    }, option));
    return this;
  };
  /**
   *  DataMarker
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.dataMarker = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'dataMarker'
    }, option));
    return this;
  };
  /**
   *  DataRegion
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.dataRegion = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'dataRegion'
    }, option));
  };
  /**
   *  RegionFilter
   * @param option
   * @returns AnnotationController
   */


  Annotation.prototype.regionFilter = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'regionFilter'
    }, option));
  };
  /**
   *  ShapeAnnotation
   * @param option
   */


  Annotation.prototype.shape = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'shape'
    }, option));
  };
  /**
   *  HtmlAnnotation
   * @param option
   */


  Annotation.prototype.html = function (option) {
    this.annotation(tslib_1.__assign({
      type: 'html'
    }, option));
  }; // end API

  /**
   * parse the point position to [x, y]
   * @param p Position
   * @returns { x, y }
   */


  Annotation.prototype.parsePosition = function (p) {
    var xScale = this.view.getXScale(); //  object

    var yScales = this.view.getScalesByDim('y');
    var position = util_1.isFunction(p) ? p.call(null, xScale, yScales) : p;
    var x = 0;
    var y = 0; //  [24, 24] 

    if (util_1.isArray(position)) {
      var xPos = position[0],
          yPos = position[1]; //  ['50%', '50%'] 
      // fix:  'xxx5%xxx'  https://github.com/antvis/f2/issues/590
      // @ts-ignore

      if (util_1.isString(xPos) && xPos.indexOf('%') !== -1 && !isNaN(xPos.slice(0, -1))) {
        return this.parsePercentPosition(position);
      }

      x = annotation_1.getNormalizedValue(xPos, xScale);
      y = annotation_1.getNormalizedValue(yPos, Object.values(yScales)[0]);
    } else if (!util_1.isNil(position)) {
      //  object 
      for (var _i = 0, _a = util_1.keys(position); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = position[key];

        if (key === xScale.field) {
          x = annotation_1.getNormalizedValue(value, xScale);
        }

        if (yScales[key]) {
          y = annotation_1.getNormalizedValue(value, yScales[key]);
        }
      }
    }

    return this.view.getCoordinate().convert({
      x: x,
      y: y
    });
  };
  /**
   * parse all the points between start and end
   * @param start
   * @param end
   * @return Point[]
   */


  Annotation.prototype.getRegionPoints = function (start, end) {
    var _this = this;

    var xScale = this.view.getXScale();
    var yScales = this.view.getScalesByDim('y');
    var yScale = Object.values(yScales)[0];
    var xField = xScale.field;
    var viewData = this.view.getData();
    var startXValue = util_1.isArray(start) ? start[0] : start[xField];
    var endXValue = util_1.isArray(end) ? end[0] : end[xField];
    var arr = [];
    var startIndex;
    util_1.each(viewData, function (item, idx) {
      if (item[xField] === startXValue) {
        startIndex = idx;
      }

      if (idx >= startIndex) {
        var point = _this.parsePosition([item[xField], item[yScale.field]]);

        if (point) {
          arr.push(point);
        }
      }

      if (item[xField] === endXValue) {
        return false;
      }
    });
    return arr;
  };
  /**
   * parse percent position
   * @param position
   */


  Annotation.prototype.parsePercentPosition = function (position) {
    var xPercent = parseFloat(position[0]) / 100;
    var yPercent = parseFloat(position[1]) / 100;
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start,
        end = coordinate.end;
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    var x = coordinate.getWidth() * xPercent + topLeft.x;
    var y = coordinate.getHeight() * yPercent + topLeft.y;
    return {
      x: x,
      y: y
    };
  };
  /**
   * get coordinate bbox
   */


  Annotation.prototype.getCoordinateBBox = function () {
    var coordinate = this.view.getCoordinate();
    var start = coordinate.start,
        end = coordinate.end;
    var width = coordinate.getWidth();
    var height = coordinate.getHeight();
    var topLeft = {
      x: Math.min(start.x, end.x),
      y: Math.min(start.y, end.y)
    };
    return {
      x: topLeft.x,
      y: topLeft.y,
      minX: topLeft.x,
      minY: topLeft.y,
      maxX: topLeft.x + width,
      maxY: topLeft.y + height,
      width: width,
      height: height
    };
  };
  /**
   * get annotation component config by different type
   * @param type
   * @param option 
   * @param theme
   */


  Annotation.prototype.getAnnotationCfg = function (type, option, theme) {
    var _this = this;

    var coordinate = this.view.getCoordinate();
    var canvas = this.view.getCanvas();
    var o = {};

    if (util_1.isNil(option)) {
      return null;
    }

    if (type === 'arc') {
      var _a = option,
          start = _a.start,
          end = _a.end;
      var sp = this.parsePosition(start);
      var ep = this.parsePosition(end);
      var startAngle = coordinate_1.getAngleByPoint(coordinate, sp);
      var endAngle = coordinate_1.getAngleByPoint(coordinate, ep);

      if (startAngle > endAngle) {
        endAngle = Math.PI * 2 + endAngle;
      }

      o = {
        center: coordinate.getCenter(),
        radius: coordinate_1.getDistanceToCenter(coordinate, sp),
        startAngle: startAngle,
        endAngle: endAngle
      };
    } else if (type === 'image') {
      var _b = option,
          start = _b.start,
          end = _b.end;
      o = {
        start: this.parsePosition(start),
        end: this.parsePosition(end),
        src: option.src
      };
    } else if (type === 'line') {
      var _c = option,
          start = _c.start,
          end = _c.end;
      o = {
        start: this.parsePosition(start),
        end: this.parsePosition(end),
        text: util_1.get(option, 'text', null)
      };
    } else if (type === 'region') {
      var _d = option,
          start = _d.start,
          end = _d.end;
      o = {
        start: this.parsePosition(start),
        end: this.parsePosition(end)
      };
    } else if (type === 'text') {
      var filteredData = this.view.getData();

      var _e = option,
          position = _e.position,
          content = _e.content,
          rest = tslib_1.__rest(_e, ["position", "content"]);

      var textContent = content;

      if (util_1.isFunction(content)) {
        textContent = content(filteredData);
      }

      o = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, this.parsePosition(position)), rest), {
        content: textContent
      });
    } else if (type === 'dataMarker') {
      var _f = option,
          position = _f.position,
          point = _f.point,
          line = _f.line,
          text = _f.text,
          autoAdjust = _f.autoAdjust,
          direction = _f.direction;
      o = tslib_1.__assign(tslib_1.__assign({}, this.parsePosition(position)), {
        coordinateBBox: this.getCoordinateBBox(),
        point: point,
        line: line,
        text: text,
        autoAdjust: autoAdjust,
        direction: direction
      });
    } else if (type === 'dataRegion') {
      var _g = option,
          start = _g.start,
          end = _g.end,
          region = _g.region,
          text = _g.text,
          lineLength = _g.lineLength;
      o = {
        points: this.getRegionPoints(start, end),
        region: region,
        text: text,
        lineLength: lineLength
      };
    } else if (type === 'regionFilter') {
      var _h = option,
          start = _h.start,
          end = _h.end,
          apply_1 = _h.apply,
          color = _h.color;
      var geometries = this.view.geometries;
      var shapes_1 = [];

      var addShapes_1 = function addShapes_1(item) {
        if (!item) {
          return;
        }

        if (item.isGroup()) {
          item.getChildren().forEach(function (child) {
            return addShapes_1(child);
          });
        } else {
          shapes_1.push(item);
        }
      };

      util_1.each(geometries, function (geom) {
        if (apply_1) {
          if (util_1.contains(apply_1, geom.type)) {
            util_1.each(geom.elements, function (elem) {
              addShapes_1(elem.shape);
            });
          }
        } else {
          util_1.each(geom.elements, function (elem) {
            addShapes_1(elem.shape);
          });
        }
      });
      o = {
        color: color,
        shapes: shapes_1,
        start: this.parsePosition(start),
        end: this.parsePosition(end)
      };
    } else if (type === 'shape') {
      var _j = option,
          render_1 = _j.render,
          restOptions = tslib_1.__rest(_j, ["render"]);

      var wrappedRender = function wrappedRender(container) {
        if (util_1.isFunction(option.render)) {
          return render_1(container, _this.view, {
            parsePosition: _this.parsePosition.bind(_this)
          });
        }
      };

      o = tslib_1.__assign(tslib_1.__assign({}, restOptions), {
        render: wrappedRender
      });
    } else if (type === 'html') {
      var _k = option,
          html_1 = _k.html,
          position = _k.position,
          restOptions = tslib_1.__rest(_k, ["html", "position"]);

      var wrappedHtml = function wrappedHtml(container) {
        if (util_1.isFunction(html_1)) {
          return html_1(container, _this.view);
        }

        return html_1;
      };

      o = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, restOptions), this.parsePosition(position)), {
        // html  parent
        parent: canvas.get('el').parentNode,
        html: wrappedHtml
      });
    } // 


    var cfg = util_1.deepMix({}, theme, tslib_1.__assign(tslib_1.__assign({}, o), {
      top: option.top,
      style: option.style,
      offsetX: option.offsetX,
      offsetY: option.offsetY
    }));

    if (type !== 'html') {
      // html  G container
      cfg.container = this.getComponentContainer(cfg);
    }

    cfg.animate = this.view.getOptions().animate && cfg.animate && util_1.get(option, 'animate', cfg.animate); //  view 

    cfg.animateOption = util_1.deepMix({}, animate_1.DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
    return cfg;
  };
  /**
   * is annotation render on top
   * @param option
   * @return whethe on top
   */


  Annotation.prototype.isTop = function (option) {
    return util_1.get(option, 'top', true);
  };
  /**
   * get the container by option.top
   * default is on top
   * @param option
   * @returns the container
   */


  Annotation.prototype.getComponentContainer = function (option) {
    return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
  };

  Annotation.prototype.getAnnotationTheme = function (type) {
    return util_1.get(this.view.getTheme(), ['components', 'annotation', type], {});
  };
  /**
   *  annotation
   * @param option
   */


  Annotation.prototype.updateOrCreate = function (option) {
    // 
    var co = this.cache.get(this.getCacheKey(option)); // 

    if (co) {
      var type = option.type;
      var theme = this.getAnnotationTheme(type);
      var cfg = this.getAnnotationCfg(type, option, theme); // 

      helper_1.omit(cfg, ['container']);
      co.component.update(cfg); //  regionFilter/shape render

      if (util_1.includes(ANNOTATIONS_AFTER_RENDER, option.type)) {
        co.component.render();
      }
    } else {
      // 
      co = this.createAnnotation(option);

      if (co) {
        co.component.init(); // NoteregionFilter/shape regionFilter/shape  Geometry  Shape view render 
        //  render 

        if (util_1.includes(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      }
    }

    return co;
  };
  /**
   * 
   * @param updated 
   */


  Annotation.prototype.syncCache = function (updated) {
    var _this = this;

    var newCache = new Map(this.cache); // clone 
    //  update  cache

    updated.forEach(function (co, key) {
      newCache.set(key, co);
    }); //  options 

    newCache.forEach(function (co, key) {
      // option 
      if (!util_1.find(_this.option, function (option) {
        return key === _this.getCacheKey(option);
      })) {
        co.component.destroy();
        newCache.delete(key);
      }
    });
    return newCache;
  };
  /**
   *  key
   * @param option
   */


  Annotation.prototype.getCacheKey = function (option) {
    //  id id string option  key
    return option; //  id 
    // const id = get(option, 'id');
    // return id ? id : option;
  };

  return Annotation;
}(base_1.Controller);

exports.default = Annotation;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeDom = exports.getChartSize = void 0;

var constant_1 = __webpack_require__(20);
/**
 * get the element's bounding size
 * @param ele dom element
 * @returns the element width and height
 */


function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
/**
 * is value a valid number
 * @param v the input value
 * @returns whether it is a number
 */


function isNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}
/**
 * @ignore
 * calculate the chart size
 * @param ele DOM element
 * @param autoFit should auto fit
 * @param width chart width which is set by user
 * @param height chart height which is set by user
 * @returns the chart width and height
 */


function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;

  if (autoFit) {
    var size = getElementSize(ele);
    w = size.width ? size.width : w;
    h = size.height ? size.height : h;
  }

  return {
    width: Math.max(isNumber(w) ? w : constant_1.MIN_CHART_WIDTH, constant_1.MIN_CHART_WIDTH),
    height: Math.max(isNumber(h) ? h : constant_1.MIN_CHART_HEIGHT, constant_1.MIN_CHART_HEIGHT)
  };
}

exports.getChartSize = getChartSize;
/**
 * @ignore
 * remove html element from its parent
 * @param dom
 */

function removeDom(dom) {
  var parent = dom.parentNode;

  if (parent) {
    parent.removeChild(dom);
  }
}

exports.removeDom = removeDom;
/** @ignore */

var dom_util_1 = __webpack_require__(112);

Object.defineProperty(exports, "createDom", {
  enumerable: true,
  get: function get() {
    return dom_util_1.createDom;
  }
});
Object.defineProperty(exports, "modifyCSS", {
  enumerable: true,
  get: function get() {
    return dom_util_1.modifyCSS;
  }
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.positionUpdate = void 0;
/**
 * @ignore
 * 
 * @param shape 
 * @param animateCfg
 * @param cfg
 */

function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs; // @ts-ignore

  var x = toAttrs.x; // @ts-ignore

  var y = toAttrs.y; // @ts-ignore

  delete toAttrs.x; // @ts-ignore

  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x: x,
    y: y
  }, animateCfg);
}

exports.positionUpdate = positionUpdate;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sectorPathUpdate = void 0;

var tslib_1 = __webpack_require__(1);

var g_canvas_1 = __webpack_require__(204);

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);

function getAngle(startPoint, arcPath) {
  var _a;

  var _b = g_canvas_1.getArcParams(startPoint, arcPath),
      startAngle = _b.startAngle,
      endAngle = _b.endAngle;

  if (!util_1.isNumberEqual(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }

  if (!util_1.isNumberEqual(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }

  if (arcPath[5] === 0) {
    //  startAngle  endAngle  G2 
    _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];
  }

  if (util_1.isNumberEqual(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }

  if (util_1.isNumberEqual(endAngle, Math.PI * -0.5)) {
    endAngle = Math.PI * 1.5;
  }

  return {
    startAngle: startAngle,
    endAngle: endAngle
  };
}

function getArcStartPoint(path) {
  var startPoint;

  if (path[0] === 'M' || path[0] === 'L') {
    startPoint = [path[1], path[2]];
  } else if (path[0] === 'a' || path[0] === 'A') {
    startPoint = [path[path.length - 2], path[path.length - 1]];
  }

  return startPoint;
}
/**
 * path 
 * 1.  path M, L, A, L, Z
 * 2.  path M, M, A, A, M, Z
 * 3.  path M, A, L, A, L, Z
 * 4.  path M, A, A, M, A, A, M, Z
 * 5. radial-line,  path,  M, A, A, Z
 * 6. radial-line,  path M, A, A, A, A, Z
 * @param path theta  path 
 */


function getArcInfo(path) {
  var _a;

  var startAngle;
  var endAngle;
  var arcPaths = path.filter(function (command) {
    return command[0] === 'A' || command[0] === 'a';
  });
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path.indexOf(firstArcPathCommand);
  var lastIndex = path.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path[lastIndex - 1]);

  var _b = getAngle(firstStartPoint, firstArcPathCommand),
      firstStartAngle = _b.startAngle,
      firstEndAngle = _b.endAngle;

  var _c = getAngle(lastStartPoint, lastArcPathCommand),
      lastStartAngle = _c.startAngle,
      lastEndAngle = _c.endAngle;

  if (util_1.isNumberEqual(firstStartAngle, lastStartAngle) && util_1.isNumberEqual(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }

  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];

  if (radius < innerRadius) {
    _a = [innerRadius, radius], radius = _a[0], innerRadius = _a[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }

  return {
    startAngle: startAngle,
    endAngle: endAngle,
    radius: radius,
    innerRadius: innerRadius
  };
}
/**
 * @ignore
 * 
 * @param shape 
 * @param animateCfg
 * @param cfg
 */


function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs,
      coordinate = cfg.coordinate;
  var path = toAttrs.path || [];
  var pathCommands = path.map(function (command) {
    return command[0];
  });
  if (path.length < 1) return;

  var _a = getArcInfo(path),
      curStartAngle = _a.startAngle,
      curEndAngle = _a.endAngle,
      radius = _a.radius,
      innerRadius = _a.innerRadius;

  var _b = getArcInfo(shape.attr('path')),
      preStartAngle = _b.startAngle,
      preEndAngle = _b.endAngle;

  var center = coordinate.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  shape.animate(function (ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return tslib_1.__assign(tslib_1.__assign({}, toAttrs), {
      path: // hack,  /examples/bar/basic/demo/radial-line.ts 
      util_1.isEqual(pathCommands, ['M', 'A', 'A', 'Z']) ? graphics_1.getArcPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle) : graphics_1.getSectorPath(center.x, center.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)
    });
  }, tslib_1.__assign(tslib_1.__assign({}, animateCfg), {
    callback: function callback() {
      //  path  setState() 
      shape.attr('path', path);
    }
  }));
}

exports.sectorPathUpdate = sectorPathUpdate;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waveIn = void 0;

var tslib_1 = __webpack_require__(1);

var coordinate_1 = __webpack_require__(51);
/**
 * @ignore
 * 
 * 
 * @todo 
 * @param element 
 * @param animateCfg 
 * @param cfg 
 */


function waveIn(element, animateCfg, cfg) {
  var _a = coordinate_1.getCoordinateClipCfg(cfg.coordinate, 20),
      type = _a.type,
      startState = _a.startState,
      endState = _a.endState; // 


  var clipShape = element.setClip({
    type: type,
    attrs: startState
  }); //  shape 
  // 

  clipShape.animate(endState, tslib_1.__assign(tslib_1.__assign({}, animateCfg), {
    callback: function callback() {
      if (element && !element.get('destroyed')) {
        element.set('clipShape', null);
      }

      clipShape.remove(true); // 
    }
  }));
}

exports.waveIn = waveIn;

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

(function (global, factory) {
  ( false ? undefined : (0, _typeof2.default)(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports, __webpack_require__(3)) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (undefined);
})(void 0, function (exports, React) {
  'use strict';

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  var changedArray = function changedArray(a, b) {
    if (a === void 0) {
      a = [];
    }

    if (b === void 0) {
      b = [];
    }

    return a.length !== b.length || a.some(function (item, index) {
      return !Object.is(item, b[index]);
    });
  };

  var initialState = {
    error: null
  };

  var ErrorBoundary = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(ErrorBoundary, _React$Component);

    function ErrorBoundary() {
      var _this;

      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
        _args[_key] = arguments[_key];
      }

      _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
      _this.state = initialState;
      _this.updatedWithError = false;

      _this.resetErrorBoundary = function () {
        var _this$props;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);

        _this.reset();
      };

      return _this;
    }

    ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
      return {
        error: error
      };
    };

    var _proto = ErrorBoundary.prototype;

    _proto.reset = function reset() {
      this.updatedWithError = false;
      this.setState(initialState);
    };

    _proto.componentDidCatch = function componentDidCatch(error, info) {
      var _this$props$onError, _this$props2;

      (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var error = this.state.error;
      var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error
      // happens to *also* be in the resetKeys array, we'd end up resetting
      // the error boundary immediately. This would likely trigger a second
      // error to be thrown.
      // So we make sure that we don't check the resetKeys on the first call
      // of cDU after the error is set

      if (error !== null && !this.updatedWithError) {
        this.updatedWithError = true;
        return;
      }

      if (error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
        var _this$props$onResetKe, _this$props3;

        (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
        this.reset();
      }
    };

    _proto.render = function render() {
      var error = this.state.error; // @ts-expect-error ts(2339) (at least one of these will be defined though, and we check for their existance)

      var _this$props4 = this.props,
          fallbackRender = _this$props4.fallbackRender,
          FallbackComponent = _this$props4.FallbackComponent,
          fallback = _this$props4.fallback;

      if (error !== null) {
        var _props = {
          error: error,
          resetErrorBoundary: this.resetErrorBoundary
        };

        if ( /*#__PURE__*/React.isValidElement(fallback)) {
          return fallback;
        } else if (typeof fallbackRender === 'function') {
          return fallbackRender(_props);
        } else if (FallbackComponent) {
          return /*#__PURE__*/React.createElement(FallbackComponent, _props);
        } else {
          throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');
        }
      }

      return this.props.children;
    };

    return ErrorBoundary;
  }(React.Component);

  function withErrorBoundary(Component, errorBoundaryProps) {
    var Wrapped = function Wrapped(props) {
      return /*#__PURE__*/React.createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/React.createElement(Component, props));
    }; // Format for display in DevTools


    var name = Component.displayName || Component.name || 'Unknown';
    Wrapped.displayName = "withErrorBoundary(" + name + ")";
    return Wrapped;
  }

  function useErrorHandler(givenError) {
    var _React$useState = React.useState(null),
        error = _React$useState[0],
        setError = _React$useState[1];

    if (givenError) throw givenError;
    if (error) throw error;
    return setError;
  }
  /*
  eslint
    @typescript-eslint/no-throw-literal: "off",
    @typescript-eslint/prefer-nullish-coalescing: "off"
  */


  exports.ErrorBoundary = ErrorBoundary;
  exports.useErrorHandler = useErrorHandler;
  exports.withErrorBoundary = withErrorBoundary;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),
/* 314 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__) if(["default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _antv_g2_lib__WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  Shape: true,
  Canvas: true,
  Group: true
};
Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return _canvas.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
exports.Shape = exports.version = void 0;

var Shape = _interopRequireWildcard(__webpack_require__(192));

exports.Shape = Shape;

var _gBase = __webpack_require__(27);

Object.keys(_gBase).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _gBase[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _gBase[key];
    }
  });
});

var _canvas = _interopRequireDefault(__webpack_require__(936));

var _group = _interopRequireDefault(__webpack_require__(275));

var version = '0.5.6';
exports.version = version;

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var constant_1 = __webpack_require__(20);

var path_1 = tslib_1.__importDefault(__webpack_require__(164));

__webpack_require__(279);
/**
 * Area 
 * 
 */


var Area =
/** @class */
function (_super) {
  tslib_1.__extends(Area, _super);

  function Area(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'area';
    _this.shapeType = 'area';
    /**  */

    _this.generatePoints = true;
    /**
     *  0 
     * 1.  `true`
     * ![image](https://gw.alipayobjects.com/zos/rmsportal/ZQqwUCczalrKqGgagOVp.png)
     * 2.  `false` 
     * ![image](https://gw.alipayobjects.com/zos/rmsportal/yPswkaXvUpCYOdhocGwB.png)
     */

    _this.startOnZero = true;
    var _a = cfg.startOnZero,
        startOnZero = _a === void 0 ? true : _a,
        _b = cfg.sortable,
        sortable = _b === void 0 ? false : _b,
        _c = cfg.showSinglePoint,
        showSinglePoint = _c === void 0 ? false : _c;
    _this.startOnZero = startOnZero; //  true

    _this.sortable = sortable; //  X 

    _this.showSinglePoint = showSinglePoint;
    return _this;
  }
  /**
   * 
   * @param mappingData 
   */


  Area.prototype.getPointsAndData = function (mappingData) {
    var points = [];
    var data = [];

    for (var i = 0, len = mappingData.length; i < len; i++) {
      var obj = mappingData[i];
      points.push(obj.points);
      data.push(obj[constant_1.FIELD_ORIGIN]);
    }

    return {
      points: points,
      data: data
    };
  };
  /**
   *  Y 
   * @returns y 
   */


  Area.prototype.getYMinValue = function () {
    if (this.startOnZero) {
      return _super.prototype.getYMinValue.call(this);
    }

    var yScale = this.getYScale();
    return yScale.min;
  };

  return Area;
}(path_1.default);

exports.default = Area;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));

__webpack_require__(447);
/**
 * Edge ****
 * 1. 
 * 2. 
 * 3. 
 * 4. 
 * 5. 
 */


var Edge =
/** @class */
function (_super) {
  tslib_1.__extends(Edge, _super);

  function Edge() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'edge';
    _this.shapeType = 'edge';
    _this.generatePoints = true;
    return _this;
  }

  return Edge;
}(base_1.default);

exports.default = Edge;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var color_util_1 = tslib_1.__importDefault(__webpack_require__(179));

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));
/**
 * 
 */


var Heatmap =
/** @class */
function (_super) {
  tslib_1.__extends(Heatmap, _super);

  function Heatmap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'heatmap';
    _this.paletteCache = {};
    return _this;
  }

  Heatmap.prototype.createElements = function (mappingData, index, isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    var range = this.prepareRange(mappingData);
    var radius = this.prepareSize();
    var blur = util_1.get(this.styleOption, ['style', 'shadowBlur']);

    if (!util_1.isNumber(blur)) {
      blur = radius / 2;
    }

    this.prepareGreyScaleBlurredCircle(radius, blur);
    this.drawWithRange(mappingData, range, radius, blur);
    return null;
  };
  /**
   * clear
   */


  Heatmap.prototype.clear = function () {
    _super.prototype.clear.call(this);

    this.clearShadowCanvasCtx();
    this.paletteCache = {};
  };

  Heatmap.prototype.prepareRange = function (data) {
    var colorAttr = this.getAttribute('color');
    var colorField = colorAttr.getFields()[0];
    var min = Infinity;
    var max = -Infinity;
    data.forEach(function (row) {
      var value = row[constant_1.FIELD_ORIGIN][colorField];

      if (value > max) {
        max = value;
      }

      if (value < min) {
        min = value;
      }
    });

    if (min === max) {
      min = max - 1;
    }

    return [min, max];
  };

  Heatmap.prototype.prepareSize = function () {
    var radius = this.getDefaultValue('size');

    if (!util_1.isNumber(radius)) {
      radius = this.getDefaultSize();
    }

    return radius;
  };

  Heatmap.prototype.prepareGreyScaleBlurredCircle = function (radius, blur) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    var r2 = radius + blur;
    var ctx = grayScaleBlurredCanvas.getContext('2d');
    grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
    ctx.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
    ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
    ctx.shadowBlur = blur;
    ctx.shadowColor = 'black';
    ctx.beginPath();
    ctx.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
  };

  Heatmap.prototype.drawWithRange = function (data, range, radius, blur) {
    // canvas size
    var _a = this.coordinate,
        start = _a.start,
        end = _a.end;
    var width = this.coordinate.getWidth();
    var height = this.coordinate.getHeight(); // value, range, etc

    var colorAttr = this.getAttribute('color');
    var valueField = colorAttr.getFields()[0]; // prepare shadow canvas context

    this.clearShadowCanvasCtx();
    var ctx = this.getShadowCanvasCtx(); // filter data

    if (range) {
      data = data.filter(function (row) {
        return row[constant_1.FIELD_ORIGIN][valueField] <= range[1] && row[constant_1.FIELD_ORIGIN][valueField] >= range[0];
      });
    } // step1. draw points with shadow


    var scale = this.scales[valueField];

    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
      var obj = data_1[_i];

      var _b = this.getDrawCfg(obj),
          x = _b.x,
          y = _b.y;

      var alpha = scale.scale(obj[constant_1.FIELD_ORIGIN][valueField]);
      this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx);
    } // step2. convert pixels


    var colored = ctx.getImageData(0, 0, width, height);
    this.clearShadowCanvasCtx();
    this.colorize(colored);
    ctx.putImageData(colored, 0, 0);
    var imageShape = this.getImageShape();
    imageShape.attr('x', start.x);
    imageShape.attr('y', end.y);
    imageShape.attr('width', width);
    imageShape.attr('height', height);
    imageShape.attr('img', ctx.canvas);
    imageShape.set('origin', this.getShapeInfo(data)); // 
  };

  Heatmap.prototype.getDefaultSize = function () {
    var position = this.getAttribute('position');
    var coordinate = this.coordinate;
    return Math.min(coordinate.getWidth() / (position.scales[0].ticks.length * 4), coordinate.getHeight() / (position.scales[1].ticks.length * 4));
  };

  Heatmap.prototype.clearShadowCanvasCtx = function () {
    var ctx = this.getShadowCanvasCtx();
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
  };

  Heatmap.prototype.getShadowCanvasCtx = function () {
    var canvas = this.shadowCanvas;

    if (!canvas) {
      canvas = document.createElement('canvas');
      this.shadowCanvas = canvas;
    }

    canvas.width = this.coordinate.getWidth();
    canvas.height = this.coordinate.getHeight();
    return canvas.getContext('2d');
  };

  Heatmap.prototype.getGrayScaleBlurredCanvas = function () {
    if (!this.grayScaleBlurredCanvas) {
      this.grayScaleBlurredCanvas = document.createElement('canvas');
    }

    return this.grayScaleBlurredCanvas;
  };

  Heatmap.prototype.drawGrayScaleBlurredCircle = function (x, y, r, alpha, ctx) {
    var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
    ctx.globalAlpha = alpha;
    ctx.drawImage(grayScaleBlurredCanvas, x - r, y - r);
  };

  Heatmap.prototype.colorize = function (img) {
    var colorAttr = this.getAttribute('color');
    var pixels = img.data;
    var paletteCache = this.paletteCache;

    for (var i = 3; i < pixels.length; i += 4) {
      var alpha = pixels[i]; // get gradient color from opacity value

      if (util_1.isNumber(alpha)) {
        var palette = paletteCache[alpha] ? paletteCache[alpha] : color_util_1.default.rgb2arr(colorAttr.gradient(alpha / 256));
        pixels[i - 3] = palette[0];
        pixels[i - 2] = palette[1];
        pixels[i - 1] = palette[2];
        pixels[i] = alpha;
      }
    }
  };

  Heatmap.prototype.getImageShape = function () {
    var imageShape = this.imageShape;

    if (imageShape) {
      return imageShape;
    }

    var container = this.container;
    imageShape = container.addShape({
      type: 'image',
      attrs: {}
    });
    this.imageShape = imageShape;
    return imageShape;
  };

  Heatmap.prototype.getShapeInfo = function (mappingData) {
    var shapeCfg = this.getDrawCfg(mappingData[0]);
    return tslib_1.__assign(tslib_1.__assign({}, shapeCfg), {
      mappingData: mappingData,
      data: this.getData(mappingData)
    });
  };

  Heatmap.prototype.getData = function (mappingData) {
    return mappingData.map(function (obj) {
      return obj[constant_1.FIELD_ORIGIN];
    });
  };

  return Heatmap;
}(base_1.default);

exports.default = Heatmap;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));
/**  ShapeFactory */


__webpack_require__(943);

var shape_size_1 = __webpack_require__(448);
/**
 * Interval 
 * 
 */


var Interval =
/** @class */
function (_super) {
  tslib_1.__extends(Interval, _super);

  function Interval(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'interval';
    _this.shapeType = 'interval';
    _this.generatePoints = true;
    var background = cfg.background;
    _this.background = background;
    return _this;
  }
  /**
   *  Shape 
   * @param obj  ->  -> adjust 
   * @returns
   */


  Interval.prototype.createShapePointsCfg = function (obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj); //  shape  size


    var size;
    var sizeAttr = this.getAttribute('size');

    if (sizeAttr) {
      size = this.getAttributeValues(sizeAttr, obj)[0]; // 

      var coordinate = this.coordinate;
      var coordinateWidth = coordinate_1.getXDimensionLength(coordinate);
      size = size / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = shape_size_1.getDefaultSize(this);
      }

      size = this.defaultSize;
    }

    cfg.size = size;
    return cfg;
  };
  /**
   *  y  scale 
   *  Y  0  
   */


  Interval.prototype.adjustScale = function () {
    _super.prototype.adjustScale.call(this);

    var yScale = this.getYScale(); // 

    if (this.coordinate.type === 'theta') {
      yScale.change({
        nice: false,
        min: 0,
        //  stack yScale  max this.updateStackRange()
        max: Math.max(Math.max.apply(null, yScale.values), yScale.max)
      });
    } else {
      //  0 
      var scaleDefs = this.scaleDefs;
      var field = yScale.field,
          min = yScale.min,
          max = yScale.max,
          type = yScale.type;

      if (type !== 'time') {
        // time 
        //  Y  0 
        if (min > 0 && !util_1.get(scaleDefs, [field, 'min'])) {
          yScale.change({
            min: 0
          });
        } //  0 


        if (max <= 0 && !util_1.get(scaleDefs, [field, 'max'])) {
          yScale.change({
            max: 0
          });
        }
      }
    }
  };
  /**
   * @override
   */


  Interval.prototype.getDrawCfg = function (mappingData) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);

    shapeCfg.background = this.background;
    return shapeCfg;
  };

  return Interval;
}(base_1.default);

exports.default = Interval;

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var path_1 = tslib_1.__importDefault(__webpack_require__(164));
/**  Path  ShapeFactory */


__webpack_require__(276);
/**
 * Line 
 * 
 */


var Line =
/** @class */
function (_super) {
  tslib_1.__extends(Line, _super);

  function Line(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'line';
    var _a = cfg.sortable,
        sortable = _a === void 0 ? false : _a; //  X 

    _this.sortable = sortable;
    return _this;
  }

  return Line;
}(path_1.default);

exports.default = Line;

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));
/**  Point  ShapeFactory */


__webpack_require__(944);
/**
 * Point 
 * 
 */


var Point =
/** @class */
function (_super) {
  tslib_1.__extends(Point, _super);

  function Point() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'point';
    _this.shapeType = 'point';
    _this.generatePoints = true;
    return _this;
  }
  /**
   * 
   * @param mappingDatum
   * @returns draw cfg
   */


  Point.prototype.getDrawCfg = function (mappingDatum) {
    var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);

    return tslib_1.__assign(tslib_1.__assign({}, shapeCfg), {
      isStack: !!this.getAdjust('stack')
    });
  };

  return Point;
}(base_1.default);

exports.default = Point;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));
/**  Path  ShapeFactory */


__webpack_require__(449);
/**
 * Polygon 
 * 
 */


var Polygon =
/** @class */
function (_super) {
  tslib_1.__extends(Polygon, _super);

  function Polygon() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'polygon';
    _this.shapeType = 'polygon';
    _this.generatePoints = true;
    return _this;
  }
  /**
   *  Shape 
   * @param obj
   * @returns
   */


  Polygon.prototype.createShapePointsCfg = function (obj) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, obj);

    var x = cfg.x;
    var y = cfg.y;
    var temp; // x y 

    if (!(util_1.isArray(x) && util_1.isArray(y))) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xCount = xScale.values.length;
      var yCount = yScale.values.length;
      var xOffset = 0.5 * 1 / xCount;
      var yOffset = 0.5 * 1 / yCount;

      if (xScale.isCategory && yScale.isCategory) {
        // x,y
        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
      } else if (util_1.isArray(x)) {
        // x 
        temp = x;
        x = [temp[0], temp[0], temp[1], temp[1]];
        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
      } else if (util_1.isArray(y)) {
        // y 
        temp = y;
        y = [temp[0], temp[1], temp[1], temp[0]];
        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
      }

      cfg.x = x;
      cfg.y = y;
    }

    return cfg;
  };

  return Polygon;
}(base_1.default);

exports.default = Polygon;

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var coordinate_1 = __webpack_require__(51);

var base_1 = tslib_1.__importDefault(__webpack_require__(97));
/**  ShapeFactory */


__webpack_require__(450);

var shape_size_1 = __webpack_require__(448);
/**
 * Schema 
 */


var Schema =
/** @class */
function (_super) {
  tslib_1.__extends(Schema, _super);

  function Schema() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'schema';
    _this.shapeType = 'schema';
    _this.generatePoints = true;
    return _this;
  }
  /**
   *  Shape 
   * @param record
   * @returns
   */


  Schema.prototype.createShapePointsCfg = function (record) {
    var cfg = _super.prototype.createShapePointsCfg.call(this, record); //  shape  size


    var size;
    var sizeAttr = this.getAttribute('size');

    if (sizeAttr) {
      size = this.getAttributeValues(sizeAttr, record)[0]; // 

      var coordinate = this.coordinate;
      var coordinateWidth = coordinate_1.getXDimensionLength(coordinate);
      size = size / coordinateWidth;
    } else {
      if (!this.defaultSize) {
        this.defaultSize = shape_size_1.getDefaultSize(this);
      }

      size = this.defaultSize;
    }

    cfg.size = size;
    return cfg;
  };

  return Schema;
}(base_1.default);

exports.default = Schema;

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.distribute = void 0;

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);
/** label textline 4px */


var MARGIN = 4;

function antiCollision(labelShapes, labels, lineHeight, plotRange, center, isRight) {
  // adjust y position of labels to avoid overlapping
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function (label) {
    if (label.y > maxY) {
      maxY = label.y;
    }

    if (label.y < minY) {
      minY = label.y;
    }

    return {
      size: lineHeight,
      targets: [label.y - startY]
    };
  });
  minY -= startY;

  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }

  while (overlapping) {
    /* eslint no-loop-func: 0 */
    boxes.forEach(function (box) {
      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size); // box.pos = Math.max(0, target - box.size / 2);
    }); // detect overlapping and join boxes

    overlapping = false;
    i = boxes.length;

    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box = boxes[i];

        if (previousBox.pos + previousBox.size > box.pos) {
          // overlapping
          previousBox.size += box.size;
          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up

          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }

          boxes.splice(i, 1); // removing box

          overlapping = true;
        }
      }
    }
  }

  i = 0; // step 4: normalize y and adjust x

  boxes.forEach(function (b) {
    var posInCompositeBox = startY + lineHeight / 2; // middle of the label

    b.targets.forEach(function () {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};

  for (var _i = 0, labelShapes_1 = labelShapes; _i < labelShapes_1.length; _i++) {
    var labelShape = labelShapes_1[_i];
    labelsMap[labelShape.get('id')] = labelShape;
  } // (x - cx)^2 + (y - cy)^2 = totalR^2


  labels.forEach(function (label) {
    var rPow2 = label.r * label.r;
    var dyPow2 = Math.pow(Math.abs(label.y - center.y), 2);

    if (rPow2 < dyPow2) {
      label.x = center.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);

      if (!isRight) {
        // left
        label.x = center.x - dx;
      } else {
        // right
        label.x = center.x + dx;
      }
    } // adjust labelShape


    var labelShape = labelsMap[label.id];
    labelShape.attr('x', label.x);
    labelShape.attr('y', label.y); // because group could not effect text-shape, should set text-shape position manually

    var textShape = util_1.find(labelShape.getChildren(), function (ele) {
      return ele.get('type') === 'text';
    }); // @ts-ignore

    if (textShape) {
      textShape.attr('y', label.y);
      textShape.attr('x', label.x);
    }
  });
}

function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }

  var offset = items[0] ? items[0].offset : 0;
  var coordinate = labels[0].get('coordinate');
  var radius = coordinate.getRadius();
  var center = coordinate.getCenter();

  if (offset > 0) {
    // const lineHeight = get(this.geometry.theme, ['pieLabels', 'labelHeight'], 14);
    var lineHeight_1 = 14; // TODO

    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate.start,
      end: coordinate.end
    }; // step 1: separate labels

    var halves_1 = [[], []];
    items.forEach(function (labelItem) {
      if (!labelItem) {
        return;
      }

      if (labelItem.textAlign === 'right') {
        // left
        halves_1[0].push(labelItem);
      } else {
        // right or center will be put on the right side
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function (half, index) {
      // step 2: reduce labels
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;

      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function (a, b) {
          // sort by percentage DESC
          return b['..percent'] - a['..percent'];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      } // step 3: distribute position (x and y)


      half.sort(function (a, b) {
        // sort by y ASC
        return a.y - b.y;
      });
      antiCollision(labels, half, lineHeight_1, plotRange_1, center, index);
    });
  } //  labelLine


  util_1.each(items, function (item) {
    if (item && item.labelLine) {
      var distance = item.offset;
      var angle = item.angle; // 

      var startPoint = graphics_1.polarToCartesian(center.x, center.y, radius, angle);
      var innerPoint = graphics_1.polarToCartesian(center.x, center.y, radius + distance / 2, angle);
      var itemX = item.x + util_1.get(item, 'offsetX', 0);
      var itemY = item.y + util_1.get(item, 'offsetY', 0);
      var endPoint = {
        x: itemX - Math.cos(angle) * MARGIN,
        y: itemY - Math.sin(angle) * MARGIN
      };

      if (!util_1.isObject(item.labelLine)) {
        // labelLine: true
        item.labelLine = {};
      }

      item.labelLine.path = ["M " + startPoint.x, startPoint.y + " Q" + innerPoint.x, innerPoint.y + " " + endPoint.x, endPoint.y].join(',');
    }
  });
}

exports.distribute = distribute;

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInCanvas = void 0;

var util_1 = __webpack_require__(0);

var transform_1 = __webpack_require__(115);
/**
 * @ignore
 *  label  label 
 * @param labels
 * @param cfg
 */


function limitInCanvas(items, labels, shapes, region) {
  util_1.each(labels, function (label) {
    var regionMinX = region.minX,
        regionMinY = region.minY,
        regionMaxX = region.maxX,
        regionMaxY = region.maxY;

    var _a = label.getCanvasBBox(),
        minX = _a.minX,
        minY = _a.minY,
        maxX = _a.maxX,
        maxY = _a.maxY,
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;

    var finalX = x;
    var finalY = y;

    if (minX < regionMinX || maxX < regionMinX) {
      // 
      finalX = regionMinX;
    }

    if (minY < regionMinY || maxY < regionMinY) {
      // 
      finalY = regionMinY;
    }

    if (minX > regionMaxX) {
      // 
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      // 
      finalX = finalX - (maxX - regionMaxX);
    }

    if (minY > regionMaxY) {
      // 
      finalY = regionMaxY - height;
    } else if (maxY > regionMaxY) {
      // 
      finalY = finalY - (maxY - regionMaxY);
    }

    if (finalX !== x || finalY !== y) {
      transform_1.translate(label, finalX - x, finalY - y);
    }
  });
}

exports.limitInCanvas = limitInCanvas;

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInShape = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 *  label  bbox  label  shape  bbox 
 */


function limitInShape(items, labels, shapes, region) {
  util_1.each(labels, function (label, index) {
    var labelBBox = label.getCanvasBBox(); // 

    var shapeBBox = shapes[index].getBBox();

    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label.remove(true); // 
    }
  });
}

exports.limitInShape = limitInShape;

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * 
 */


var Circle =
/** @class */
function (_super) {
  tslib_1.__extends(Circle, _super);

  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Circle.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'circle',
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };

  Circle.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  /**
   *  region
   * @param count
   * @param index
   */


  Circle.prototype.getRegion = function (count, index) {
    var r = 1 / 2; // 
    // 

    var center = {
      x: 0.5,
      y: 0.5
    }; // 

    var avgAngle = Math.PI * 2 / count; // 

    var angle = -1 * Math.PI / 2 + avgAngle * index; // TODO 

    var facetR = r / (1 + 1 / Math.sin(avgAngle / 2)); // 

    var middle = facet_1.getAnglePoint(center, r - facetR, angle);
    var startAngle = Math.PI * 5 / 4; // 

    var endAngle = Math.PI * 1 / 4; // 

    return {
      start: facet_1.getAnglePoint(middle, facetR, startAngle),
      end: facet_1.getAnglePoint(middle, facetR, endAngle)
    };
  };

  Circle.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  Circle.prototype.beforeEachView = function (view, facet) {};

  Circle.prototype.generateFacets = function (data) {
    var _this = this;

    var _a = this.cfg,
        fields = _a.fields,
        type = _a.type;
    var field = fields[0];

    if (!field) {
      throw new Error('No `fields` specified!');
    }

    var values = this.getFieldValues(data, field);
    var count = values.length;
    var rst = [];
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var facetData = util_1.filter(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type: type,
        data: facetData,
        region: _this.getRegion(count, index),
        columnValue: value,
        columnField: field,
        columnIndex: index,
        columnValuesLength: count,
        rowValue: null,
        rowField: null,
        rowIndex: 0,
        rowValuesLength: 1
      };
      rst.push(facet);
    });
    return rst;
  };

  Circle.prototype.getXAxisOption = function (x, axes, option, facet) {
    // 
    return option;
  };
  /**
   *  y title 
   * @param y
   * @param axes
   * @param option
   * @param facet
   */


  Circle.prototype.getYAxisOption = function (y, axes, option, facet) {
    // 
    return option;
  };
  /**
   * facet title
   */


  Circle.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet) {
      var columnValue = facet.columnValue,
          view = facet.view;
      var formatter = util_1.get(_this.cfg.title, 'formatter');
      var config = util_1.deepMix({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };

  return Circle;
}(facet_2.Facet);

exports.default = Circle;

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * 
 */


var List =
/** @class */
function (_super) {
  tslib_1.__extends(List, _super);

  function List() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  List.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'list',
      cols: null,
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };

  List.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };

  List.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  List.prototype.beforeEachView = function (view, facet) {};

  List.prototype.generateFacets = function (data) {
    var _this = this;

    var fields = this.cfg.fields;
    var cols = this.cfg.cols;
    var columnField = fields[0];

    if (!columnField) {
      throw new Error('No `fields` specified!');
    }

    var colValues = this.getFieldValues(data, columnField);
    var count = colValues.length;
    cols = cols || count; // 
    // 

    var rows = this.getPageCount(count, cols);
    var rst = [];
    colValues.forEach(function (val, index) {
      //  index 
      var _a = _this.getRowCol(index, cols),
          row = _a.row,
          col = _a.col;

      var conditions = [{
        field: columnField,
        value: val,
        values: colValues
      }];
      var facetData = util_1.filter(data, _this.getFacetDataFilter(conditions));
      var facet = {
        type: _this.cfg.type,
        data: facetData,
        region: _this.getRegion(rows, cols, col, row),
        columnValue: val,
        rowValue: val,
        columnField: columnField,
        rowField: null,
        columnIndex: col,
        rowIndex: row,
        columnValuesLength: cols,
        rowValuesLength: rows,
        total: count
      };
      rst.push(facet);
    });
    return rst;
  };
  /**
   *  x title 
   * @param x
   * @param axes
   * @param option
   * @param facet
   */


  List.prototype.getXAxisOption = function (x, axes, option, facet) {
    //  view 
    if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        label: null,
        title: null
      });
    }

    return option;
  };
  /**
   *  y title 
   * @param y
   * @param axes
   * @param option
   * @param facet
   */


  List.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    }

    return option;
  };
  /**
   * facet title
   */


  List.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet) {
      var columnValue = facet.columnValue,
          view = facet.view;
      var formatter = util_1.get(_this.cfg.title, 'formatter');
      var config = util_1.deepMix({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };
  /**
   * 
   * @param total
   * @param pageSize
   */


  List.prototype.getPageCount = function (total, pageSize) {
    return Math.floor((total + pageSize - 1) / pageSize);
  };
  /**
   * 
   * @param index
   * @param pageSize
   */


  List.prototype.getRowCol = function (index, pageSize) {
    var row = Math.floor(index / pageSize);
    var col = index % pageSize;
    return {
      row: row,
      col: col
    };
  };

  return List;
}(facet_2.Facet);

exports.default = List;

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * 
 */


var Matrix =
/** @class */
function (_super) {
  tslib_1.__extends(Matrix, _super);

  function Matrix() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Matrix.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'matrix',
      showTitle: false,
      columnTitle: tslib_1.__assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: tslib_1.__assign({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };

  Matrix.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };

  Matrix.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  Matrix.prototype.beforeEachView = function (view, facet) {};

  Matrix.prototype.generateFacets = function (data) {
    var _a = this.cfg,
        fields = _a.fields,
        type = _a.type; // 

    var rowValuesLength = fields.length;
    var columnValuesLength = rowValuesLength;
    var rst = [];

    for (var i = 0; i < columnValuesLength; i++) {
      var columnField = fields[i];

      for (var j = 0; j < rowValuesLength; j++) {
        var rowField = fields[j];
        var facet = {
          type: type,
          data: data,
          region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
          columnValue: columnField,
          rowValue: rowField,
          columnField: columnField,
          rowField: rowField,
          columnIndex: i,
          rowIndex: j,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      }
    }

    return rst;
  };
  /**
   *  x title 
   * @param x
   * @param axes
   * @param option
   * @param facet
   */


  Matrix.prototype.getXAxisOption = function (x, axes, option, facet) {
    // 
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        label: null,
        title: null
      });
    }

    return option;
  };
  /**
   *  y title 
   * @param y
   * @param axes
   * @param option
   * @param facet
   */


  Matrix.prototype.getYAxisOption = function (y, axes, option, facet) {
    // 
    if (facet.columnIndex !== 0) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    }

    return option;
  };
  /**
   * facet title
   */


  Matrix.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet, facetIndex) {
      var columnIndex = facet.columnIndex,
          rowIndex = facet.rowIndex,
          columnValuesLength = facet.columnValuesLength,
          rowValuesLength = facet.rowValuesLength,
          columnValue = facet.columnValue,
          rowValue = facet.rowValue,
          view = facet.view; // top

      if (rowIndex === 0) {
        var formatter = util_1.get(_this.cfg.columnTitle, 'formatter');
        var config = util_1.deepMix({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      } // right


      if (columnIndex === columnValuesLength - 1) {
        var formatter = util_1.get(_this.cfg.rowTitle, 'formatter');
        var config = util_1.deepMix({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };

  return Matrix;
}(facet_2.Facet);

exports.default = Matrix;

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * 
 */


var Mirror =
/** @class */
function (_super) {
  tslib_1.__extends(Mirror, _super);

  function Mirror() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Mirror.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'mirror',
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this),
      transpose: false
    });
  };

  Mirror.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };

  Mirror.prototype.beforeEachView = function (view, facet) {
    // 
    if (this.cfg.transpose) {
      if (facet.columnIndex % 2 === 0) {
        view.coordinate().transpose().reflect('x');
      } else {
        view.coordinate().transpose();
      }
    } else {
      if (facet.rowIndex % 2 !== 0) {
        view.coordinate().reflect('y');
      }
    }
  };

  Mirror.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  Mirror.prototype.generateFacets = function (data) {
    var _this = this;

    var f = this.cfg.fields[0];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [''];
    var rowValues = [''];
    var columnField;
    var rowField;

    if (this.cfg.transpose) {
      columnField = f;
      columnValues = this.getFieldValues(data, columnField).slice(0, 2); // 

      columnValuesLength = columnValues.length;
    } else {
      rowField = f;
      rowValues = this.getFieldValues(data, rowField).slice(0, 2); // 

      rowValuesLength = rowValues.length;
    } // 


    columnValues.forEach(function (xVal, xIndex) {
      rowValues.forEach(function (yVal, yIndex) {
        var conditions = [{
          field: columnField,
          value: xVal,
          values: columnValues
        }, {
          field: rowField,
          value: yVal,
          values: rowValues
        }];
        var facetData = util_1.filter(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField: columnField,
          rowField: rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };
  /**
   *  x title 
   * @param x
   * @param axes
   * @param option
   * @param facet
   */


  Mirror.prototype.getXAxisOption = function (x, axes, option, facet) {
    // 
    //  view 
    if (facet.columnIndex === 1 || facet.rowIndex === 1) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        label: null,
        title: null
      });
    }

    return option;
  };
  /**
   *  y title 
   * @param y
   * @param axes
   * @param option
   * @param facet
   */


  Mirror.prototype.getYAxisOption = function (y, axes, option, facet) {
    // do nothing
    return option;
  };

  Mirror.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet, facetIndex) {
      var columnValue = facet.columnValue,
          rowValue = facet.rowValue,
          view = facet.view;
      var formatter = util_1.get(_this.cfg.title, 'formatter');

      if (_this.cfg.transpose) {
        var config = util_1.deepMix({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      } else {
        var config = util_1.deepMix({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.RIGHT), _this.cfg.title);
        view.annotation().text(config);
      }
    });
  };

  return Mirror;
}(facet_2.Facet);

exports.default = Mirror;

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * 
 */


var Rect =
/** @class */
function (_super) {
  tslib_1.__extends(Rect, _super);

  function Rect() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Rect.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  Rect.prototype.beforeEachView = function (view, facet) {// do nothing
  };

  Rect.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'rect',
      columnTitle: tslib_1.__assign({}, _super.prototype.getDefaultTitleCfg.call(this)),
      rowTitle: tslib_1.__assign({}, _super.prototype.getDefaultTitleCfg.call(this))
    });
  };

  Rect.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };
  /**
   * 
   * @param data
   */


  Rect.prototype.generateFacets = function (data) {
    var _this = this;

    var _a = this.cfg.fields,
        columnField = _a[0],
        rowField = _a[1];
    var rst = [];
    var columnValuesLength = 1;
    var rowValuesLength = 1;
    var columnValues = [''];
    var rowValues = [''];

    if (columnField) {
      columnValues = this.getFieldValues(data, columnField);
      columnValuesLength = columnValues.length;
    }

    if (rowField) {
      rowValues = this.getFieldValues(data, rowField);
      rowValuesLength = rowValues.length;
    } // 


    columnValues.forEach(function (xVal, xIndex) {
      rowValues.forEach(function (yVal, yIndex) {
        var conditions = [{
          field: columnField,
          value: xVal,
          values: columnValues
        }, {
          field: rowField,
          value: yVal,
          values: rowValues
        }];
        var facetData = util_1.filter(data, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
          columnValue: xVal,
          rowValue: yVal,
          columnField: columnField,
          rowField: rowField,
          columnIndex: xIndex,
          rowIndex: yIndex,
          columnValuesLength: columnValuesLength,
          rowValuesLength: rowValuesLength
        };
        rst.push(facet);
      });
    });
    return rst;
  };

  Rect.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet, facetIndex) {
      var columnIndex = facet.columnIndex,
          rowIndex = facet.rowIndex,
          columnValuesLength = facet.columnValuesLength,
          columnValue = facet.columnValue,
          rowValue = facet.rowValue,
          view = facet.view; // top

      if (rowIndex === 0) {
        var formatter = util_1.get(_this.cfg.columnTitle, 'formatter');
        var config = util_1.deepMix({
          position: ['50%', '0%'],
          content: formatter ? formatter(columnValue) : columnValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.columnTitle);
        view.annotation().text(config);
      } // right


      if (columnIndex === columnValuesLength - 1) {
        var formatter = util_1.get(_this.cfg.rowTitle, 'formatter');
        var config = util_1.deepMix({
          position: ['100%', '50%'],
          content: formatter ? formatter(rowValue) : rowValue
        }, facet_1.getFactTitleConfig(constant_1.DIRECTION.RIGHT), _this.cfg.rowTitle);
        view.annotation().text(config);
      }
    });
  };
  /**
   *  x title 
   * @param x
   * @param axes
   * @param option
   * @param facet
   */


  Rect.prototype.getXAxisOption = function (x, axes, option, facet) {
    // 
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
      // 
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null
      });
    }

    return option;
  };
  /**
   *  y title 
   * @param y
   * @param axes
   * @param option
   * @param facet
   */


  Rect.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.columnIndex !== 0) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null
      });
    }

    return option;
  };

  return Rect;
}(facet_2.Facet);

exports.default = Rect;

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * Create By Bruce Too
 * On 2020-02-10
 */


var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var facet_1 = __webpack_require__(116);

var facet_2 = __webpack_require__(105);
/**
 * @ignore
 * Tree Facet
 */


var Tree =
/** @class */
function (_super) {
  tslib_1.__extends(Tree, _super);

  function Tree() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.afterChartRender = function () {
      if (_this.facets && _this.cfg.line) {
        _this.container.clear();

        _this.drawLines(_this.facets);
      }
    };

    return _this;
  }

  Tree.prototype.afterEachView = function (view, facet) {
    this.processAxis(view, facet);
  };

  Tree.prototype.beforeEachView = function (view, facet) {};

  Tree.prototype.init = function () {
    _super.prototype.init.call(this);

    this.view.on(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
  };

  Tree.prototype.getDefaultCfg = function () {
    return util_1.deepMix({}, _super.prototype.getDefaultCfg.call(this), {
      type: 'tree',
      line: {
        style: {
          lineWidth: 1,
          stroke: '#ddd'
        },
        smooth: false
      },
      showTitle: true,
      title: _super.prototype.getDefaultTitleCfg.call(this)
    });
  };

  Tree.prototype.generateFacets = function (data) {
    var fields = this.cfg.fields;

    if (!fields.length) {
      throw new Error('Please specify for the fields for rootFacet!');
    }

    var rst = [];
    var rootFacet = {
      type: this.cfg.type,
      data: data,
      region: null,
      rowValuesLength: this.getRows(),
      columnValuesLength: 1,
      rowIndex: 0,
      columnIndex: 0,
      rowField: '',
      columnField: '',
      rowValue: '',
      columnValue: ''
    };
    rst.push(rootFacet);
    rootFacet.children = this.getChildFacets(data, 1, rst);
    this.setRegion(rst);
    return rst;
  };

  Tree.prototype.setRegion = function (facets) {
    var _this = this;

    this.forceColIndex(facets);
    facets.forEach(function (facet) {
      // @ts-ignore 
      facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
    });
  };

  Tree.prototype.getRegion = function (rows, cols, xIndex, yIndex) {
    var xWidth = 1 / cols; // x

    var yWidth = 1 / rows; // y

    var start = {
      x: xWidth * xIndex,
      y: yWidth * yIndex
    };
    var end = {
      x: start.x + xWidth,
      y: start.y + yWidth * 2 / 3
    };
    return {
      start: start,
      end: end
    };
  };

  Tree.prototype.forceColIndex = function (facets) {
    var _this = this;

    var leafs = [];
    var index = 0;
    facets.forEach(function (facet) {
      if (_this.isLeaf(facet)) {
        leafs.push(facet); // @ts-ignore 

        facet.columnIndex = index;
        index++;
      }
    });
    leafs.forEach(function (facet) {
      // @ts-ignore
      facet.columnValuesLength = leafs.length;
    });
    var maxLevel = this.cfg.fields.length;

    for (var i = maxLevel - 1; i >= 0; i--) {
      var levelFacets = this.getFacetsByLevel(facets, i); // var yIndex = maxLevel - i;

      for (var _i = 0, levelFacets_1 = levelFacets; _i < levelFacets_1.length; _i++) {
        var facet = levelFacets_1[_i];

        if (!this.isLeaf(facet)) {
          facet.originColIndex = facet.columnIndex; // @ts-ignore

          facet.columnIndex = this.getRegionIndex(facet.children); // @ts-ignore

          facet.columnValuesLength = leafs.length;
        }
      }
    }
  }; // get facet use level


  Tree.prototype.getFacetsByLevel = function (facets, level) {
    var rst = [];
    facets.forEach(function (facet) {
      if (facet.rowIndex === level) {
        rst.push(facet);
      }
    });
    return rst;
  }; // if the facet has children , make it's column index in the middle of it's children


  Tree.prototype.getRegionIndex = function (children) {
    var first = children[0];
    var last = children[children.length - 1];
    return (last.columnIndex - first.columnIndex) / 2 + first.columnIndex;
  }; // is  a leaf without children


  Tree.prototype.isLeaf = function (facet) {
    return !facet.children || !facet.children.length;
  };

  Tree.prototype.getRows = function () {
    return this.cfg.fields.length + 1;
  }; // get child


  Tree.prototype.getChildFacets = function (data, level, arr) {
    var _this = this; // [ 'grade', 'class' ]


    var fields = this.cfg.fields;
    var length = fields.length;

    if (length < level) {
      return;
    }

    var rst = []; // get fist level except root node

    var field = fields[level - 1]; // get field value

    var values = this.getFieldValues(data, field);
    values.forEach(function (value, index) {
      var conditions = [{
        field: field,
        value: value,
        values: values
      }];
      var subData = data.filter(_this.getFacetDataFilter(conditions));

      if (subData.length) {
        var facet = {
          type: _this.cfg.type,
          data: subData,
          region: null,
          columnValue: value,
          rowValue: '',
          columnField: field,
          rowField: '',
          columnIndex: index,
          rowValuesLength: _this.getRows(),
          columnValuesLength: 1,
          rowIndex: level,
          children: _this.getChildFacets(subData, level + 1, arr)
        };
        rst.push(facet);
        arr.push(facet);
      }
    });
    return rst;
  };

  Tree.prototype.render = function () {
    _super.prototype.render.call(this);

    if (this.cfg.showTitle) {
      this.renderTitle();
    }
  };

  Tree.prototype.renderTitle = function () {
    var _this = this;

    util_1.each(this.facets, function (facet) {
      var columnValue = facet.columnValue,
          view = facet.view;
      var formatter = util_1.get(_this.cfg.title, 'formatter');
      var config = util_1.deepMix({
        position: ['50%', '0%'],
        content: formatter ? formatter(columnValue) : columnValue
      }, facet_1.getFactTitleConfig(constant_1.DIRECTION.TOP), _this.cfg.title);
      view.annotation().text(config);
    });
  };

  Tree.prototype.drawLines = function (facets) {
    var _this = this;

    facets.forEach(function (facet) {
      if (!_this.isLeaf(facet)) {
        var children = facet.children;

        _this.addFacetLines(facet, children);
      }
    });
  }; // add lines with it's children


  Tree.prototype.addFacetLines = function (facet, children) {
    var _this = this;

    var view = facet.view;
    var region = view.coordinateBBox; // top, right, bottom, left

    var start = {
      x: region.x + region.width / 2,
      y: region.y + region.height
    };
    children.forEach(function (subFacet) {
      var subRegion = subFacet.view.coordinateBBox;
      var end = {
        x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
        y: subRegion.tr.y
      };
      var middle1 = {
        x: start.x,
        y: start.y + (end.y - start.y) / 2
      };
      var middle2 = {
        x: end.x,
        y: middle1.y
      };

      _this.drawLine([start, middle1, middle2, end]);
    });
  };

  Tree.prototype.getPath = function (points) {
    var path = [];
    var smooth = this.cfg.line.smooth;

    if (smooth) {
      path.push(['M', points[0].x, points[0].y]);
      path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    } else {
      points.forEach(function (point, index) {
        if (index === 0) {
          path.push(['M', point.x, point.y]);
        } else {
          path.push(['L', point.x, point.y]);
        }
      });
    }

    return path;
  }; // draw line width points


  Tree.prototype.drawLine = function (points) {
    var path = this.getPath(points);
    var line = this.cfg.line.style;
    this.container.addShape('path', {
      attrs: util_1.assign({
        // @ts-ignore
        path: path
      }, line)
    });
  };

  Tree.prototype.getXAxisOption = function (x, axes, option, facet) {
    if (facet.rowIndex !== facet.rowValuesLength - 1) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    }

    return option;
  };

  Tree.prototype.getYAxisOption = function (y, axes, option, facet) {
    if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
      return tslib_1.__assign(tslib_1.__assign({}, option), {
        title: null,
        label: null
      });
    }

    return option;
  };

  return Tree;
}(facet_2.Facet);

exports.default = Tree;

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var dependents_1 = __webpack_require__(68);

var animate_1 = __webpack_require__(96);

var axis_1 = __webpack_require__(263);

var axis_2 = __webpack_require__(263);

var grid_1 = __webpack_require__(964);

var helper_1 = __webpack_require__(76);

var base_1 = __webpack_require__(104); // update 


var OMIT_CFG = ['container']; // 

var AXIS_DEFAULT_ANIMATE_CFG = tslib_1.__assign(tslib_1.__assign({}, animate_1.DEFAULT_ANIMATE_CFG), {
  appear: null
});
/**
 * @ignore
 * G2 Axis controller, will:
 *  - create component
 *    - axis
 *    - grid
 *  - life circle
 */


var Axis =
/** @class */
function (_super) {
  tslib_1.__extends(Axis, _super);

  function Axis(view) {
    var _this = _super.call(this, view) || this;
    /**  object  */


    _this.cache = new Map(); //  gridContainer grid  axis 

    _this.gridContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    _this.axisContainer = _this.view.getLayer(constant_1.LAYER.BG).addGroup();
    return _this;
  }

  Object.defineProperty(Axis.prototype, "name", {
    get: function get() {
      return 'axis';
    },
    enumerable: false,
    configurable: true
  });

  Axis.prototype.init = function () {};

  Axis.prototype.render = function () {
    this.update();
  };
  /**
   * 
   */


  Axis.prototype.layout = function () {
    var _this = this;

    var coordinate = this.view.getCoordinate();
    util_1.each(this.getComponents(), function (co) {
      var component = co.component,
          direction = co.direction,
          type = co.type,
          extra = co.extra;
      var dim = extra.dim,
          scale = extra.scale,
          alignTick = extra.alignTick;
      var updated;

      if (type === constant_1.COMPONENT_TYPE.AXIS) {
        if (coordinate.isPolar) {
          if (dim === 'x') {
            updated = coordinate.isTransposed ? axis_1.getAxisRegion(coordinate, direction) : axis_1.getCircleAxisCenterRadius(coordinate);
          } else if (dim === 'y') {
            updated = coordinate.isTransposed ? axis_1.getCircleAxisCenterRadius(coordinate) : axis_1.getAxisRegion(coordinate, direction);
          }
        } else {
          updated = axis_1.getAxisRegion(coordinate, direction);
        }
      } else if (type === constant_1.COMPONENT_TYPE.GRID) {
        if (coordinate.isPolar) {
          var items = void 0;

          if (coordinate.isTransposed) {
            items = dim === 'x' ? grid_1.getCircleGridItems(coordinate, _this.view.getYScales()[0], scale, alignTick, dim) : grid_1.getLineGridItems(coordinate, scale, dim, alignTick);
          } else {
            items = dim === 'x' ? grid_1.getLineGridItems(coordinate, scale, dim, alignTick) : grid_1.getCircleGridItems(coordinate, _this.view.getXScale(), scale, alignTick, dim);
          }

          updated = {
            items: items,
            // coordinate center 
            center: _this.view.getCoordinate().getCenter()
          };
        } else {
          updated = {
            items: grid_1.getLineGridItems(coordinate, scale, dim, alignTick)
          };
        }
      }

      component.update(updated);
    });
  };
  /**
   *  axis 
   */


  Axis.prototype.update = function () {
    this.option = this.view.getOptions().axes;
    var updatedCache = new Map();
    this.updateXAxes(updatedCache);
    this.updateYAxes(updatedCache); // 
    // 

    var newCache = new Map();
    this.cache.forEach(function (co, key) {
      if (updatedCache.has(key)) {
        newCache.set(key, co);
      } else {
        // 
        co.component.destroy();
      }
    }); // 

    this.cache = newCache;
  };

  Axis.prototype.clear = function () {
    _super.prototype.clear.call(this);

    this.cache.clear();
    this.gridContainer.clear();
    this.axisContainer.clear();
  };

  Axis.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.gridContainer.remove(true);
    this.axisContainer.remove(true);
  };
  /**
   * @override
   */


  Axis.prototype.getComponents = function () {
    var co = [];
    this.cache.forEach(function (value) {
      co.push(value);
    });
    return co;
  };
  /**
   *  x axis
   * @param updatedCache
   */


  Axis.prototype.updateXAxes = function (updatedCache) {
    // x axis
    var scale = this.view.getXScale();

    if (!scale || scale.isIdentity) {
      return;
    }

    var xAxisOption = axis_2.getAxisOption(this.option, scale.field);

    if (xAxisOption === false) {
      return;
    }

    var direction = axis_1.getAxisDirection(xAxisOption, constant_1.DIRECTION.BOTTOM);
    var layer = constant_1.LAYER.BG;
    var dim = 'x';
    var coordinate = this.view.getCoordinate();
    var axisId = this.getId('axis', scale.field);
    var gridId = this.getId('grid', scale.field);

    if (coordinate.isRect) {
      // 1. do axis update
      var axis = this.cache.get(axisId); // 

      if (axis) {
        var cfg = this.getLineAxisCfg(scale, xAxisOption, direction);
        helper_1.omit(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        // 
        axis = this.createLineAxis(scale, xAxisOption, layer, direction, dim);
        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      } // 2. do grid update


      var grid = this.cache.get(gridId); // 

      if (grid) {
        var cfg = this.getLineGridCfg(scale, xAxisOption, direction, dim);
        helper_1.omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        // 
        grid = this.createLineGrid(scale, xAxisOption, layer, direction, dim);

        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else if (coordinate.isPolar) {
      // 1. do axis update
      var axis = this.cache.get(axisId); // 

      if (axis) {
        var cfg = coordinate.isTransposed ? this.getLineAxisCfg(scale, xAxisOption, constant_1.DIRECTION.RADIUS) : this.getCircleAxisCfg(scale, xAxisOption, direction);
        helper_1.omit(cfg, OMIT_CFG);
        axis.component.update(cfg);
        updatedCache.set(axisId, axis);
      } else {
        // 
        if (coordinate.isTransposed) {
          if (util_1.isUndefined(xAxisOption)) {
            // 
            return;
          } else {
            //  chart.axis(true)/chart.axis('x', true)
            //  x 
            axis = this.createLineAxis(scale, xAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
          }
        } else {
          axis = this.createCircleAxis(scale, xAxisOption, layer, direction, dim);
        }

        this.cache.set(axisId, axis);
        updatedCache.set(axisId, axis);
      } // 2. do grid update


      var grid = this.cache.get(gridId); // 

      if (grid) {
        var cfg = coordinate.isTransposed ? this.getCircleGridCfg(scale, xAxisOption, constant_1.DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale, xAxisOption, constant_1.DIRECTION.CIRCLE, dim);
        helper_1.omit(cfg, OMIT_CFG);
        grid.component.update(cfg);
        updatedCache.set(gridId, grid);
      } else {
        // 
        if (coordinate.isTransposed) {
          if (util_1.isUndefined(xAxisOption)) {
            return;
          } else {
            grid = this.createCircleGrid(scale, xAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
          }
        } else {
          // grid x 
          grid = this.createLineGrid(scale, xAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
        }

        if (grid) {
          this.cache.set(gridId, grid);
          updatedCache.set(gridId, grid);
        }
      }
    } else {// helix and other, do not draw axis
    }
  };

  Axis.prototype.updateYAxes = function (updatedCache) {
    var _this = this; // y axes


    var yScales = this.view.getYScales();
    util_1.each(yScales, function (scale, idx) {
      // @ts-ignore
      if (!scale || scale.isIdentity) {
        return;
      }

      var field = scale.field;
      var yAxisOption = axis_2.getAxisOption(_this.option, field);

      if (yAxisOption !== false) {
        var layer = constant_1.LAYER.BG;
        var dim = 'y';

        var axisId = _this.getId('axis', field);

        var gridId = _this.getId('grid', field);

        var coordinate = _this.view.getCoordinate();

        if (coordinate.isRect) {
          var direction = axis_1.getAxisDirection(yAxisOption, idx === 0 ? constant_1.DIRECTION.LEFT : constant_1.DIRECTION.RIGHT); // 1. do axis update

          var axis = _this.cache.get(axisId); // 


          if (axis) {
            var cfg = _this.getLineAxisCfg(scale, yAxisOption, direction);

            helper_1.omit(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            // 
            axis = _this.createLineAxis(scale, yAxisOption, layer, direction, dim);

            _this.cache.set(axisId, axis);

            updatedCache.set(axisId, axis);
          } // 2. do grid update


          var grid = _this.cache.get(gridId); // 


          if (grid) {
            var cfg = _this.getLineGridCfg(scale, yAxisOption, direction, dim);

            helper_1.omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            // 
            grid = _this.createLineGrid(scale, yAxisOption, layer, direction, dim);

            if (grid) {
              _this.cache.set(gridId, grid);

              updatedCache.set(gridId, grid);
            }
          }
        } else if (coordinate.isPolar) {
          // 1. do axis update
          var axis = _this.cache.get(axisId); // 


          if (axis) {
            var cfg = coordinate.isTransposed ? _this.getCircleAxisCfg(scale, yAxisOption, constant_1.DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale, yAxisOption, constant_1.DIRECTION.RADIUS); // @ts-ignore

            helper_1.omit(cfg, OMIT_CFG);
            axis.component.update(cfg);
            updatedCache.set(axisId, axis);
          } else {
            // 
            if (coordinate.isTransposed) {
              if (util_1.isUndefined(yAxisOption)) {
                return;
              } else {
                axis = _this.createCircleAxis(scale, yAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
              }
            } else {
              axis = _this.createLineAxis(scale, yAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
            }

            _this.cache.set(axisId, axis);

            updatedCache.set(axisId, axis);
          } // 2. do grid update


          var grid = _this.cache.get(gridId); // 


          if (grid) {
            var cfg = coordinate.isTransposed ? _this.getLineGridCfg(scale, yAxisOption, constant_1.DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale, yAxisOption, constant_1.DIRECTION.RADIUS, dim);
            helper_1.omit(cfg, OMIT_CFG);
            grid.component.update(cfg);
            updatedCache.set(gridId, grid);
          } else {
            // 
            if (coordinate.isTransposed) {
              if (util_1.isUndefined(yAxisOption)) {
                return;
              } else {
                grid = _this.createLineGrid(scale, yAxisOption, layer, constant_1.DIRECTION.CIRCLE, dim);
              }
            } else {
              grid = _this.createCircleGrid(scale, yAxisOption, layer, constant_1.DIRECTION.RADIUS, dim);
            }

            if (grid) {
              _this.cache.set(gridId, grid);

              updatedCache.set(gridId, grid);
            }
          }
        } else {// helix and other, do not draw axis
        }
      }
    });
  };
  /**
   *  line axis
   * @param scale
   * @param option
   * @param layer
   * @param direction
   * @param dim
   */


  Axis.prototype.createLineAxis = function (scale, option, layer, direction, dim) {
    // axis
    var axis = {
      component: new dependents_1.LineAxis(this.getLineAxisCfg(scale, option, direction)),
      layer: layer,
      direction: direction === constant_1.DIRECTION.RADIUS ? constant_1.DIRECTION.NONE : direction,
      type: constant_1.COMPONENT_TYPE.AXIS,
      extra: {
        dim: dim,
        scale: scale
      }
    };
    axis.component.set('field', scale.field);
    axis.component.init();
    return axis;
  };

  Axis.prototype.createLineGrid = function (scale, option, layer, direction, dim) {
    var cfg = this.getLineGridCfg(scale, option, direction, dim);

    if (cfg) {
      var grid = {
        component: new dependents_1.LineGrid(cfg),
        layer: layer,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.GRID,
        extra: {
          dim: dim,
          scale: scale,
          alignTick: util_1.get(cfg, 'alignTick', true)
        }
      };
      grid.component.init();
      return grid;
    }
  };

  Axis.prototype.createCircleAxis = function (scale, option, layer, direction, dim) {
    var axis = {
      component: new dependents_1.CircleAxis(this.getCircleAxisCfg(scale, option, direction)),
      layer: layer,
      direction: direction,
      type: constant_1.COMPONENT_TYPE.AXIS,
      extra: {
        dim: dim,
        scale: scale
      }
    };
    axis.component.set('field', scale.field);
    axis.component.init();
    return axis;
  };

  Axis.prototype.createCircleGrid = function (scale, option, layer, direction, dim) {
    var cfg = this.getCircleGridCfg(scale, option, direction, dim);

    if (cfg) {
      var grid = {
        component: new dependents_1.CircleGrid(cfg),
        layer: layer,
        direction: constant_1.DIRECTION.NONE,
        type: constant_1.COMPONENT_TYPE.GRID,
        extra: {
          dim: dim,
          scale: scale,
          alignTick: util_1.get(cfg, 'alignTick', true)
        }
      };
      grid.component.init();
      return grid;
    }
  };
  /**
   * generate line axis cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @return line axis cfg
   */


  Axis.prototype.getLineAxisCfg = function (scale, axisOption, direction) {
    var container = this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var region = axis_1.getAxisRegion(coordinate, direction);
    var titleText = axis_1.getAxisTitleText(scale, axisOption);
    var axisThemeCfg = axis_1.getAxisThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure

    var optionWithTitle = util_1.get(axisOption, ['title']) ? util_1.deepMix({
      title: {
        style: {
          text: titleText
        }
      }
    }, {
      title: util_1.get(axis_1.getAxisThemeCfg(this.view.getTheme(), 'common'), 'title')
    }, axisOption) : axisOption;
    var cfg = util_1.deepMix(tslib_1.__assign(tslib_1.__assign({
      container: container
    }, region), {
      ticks: scale.getTicks().map(function (tick) {
        return {
          id: "" + tick.tickValue,
          name: tick.text,
          value: tick.value
        };
      }),
      verticalFactor: coordinate.isPolar ? axis_1.getAxisFactorByRegion(region, coordinate.getCenter()) * -1 : axis_1.getAxisFactorByRegion(region, coordinate.getCenter()),
      theme: axisThemeCfg
    }), axisThemeCfg, optionWithTitle);

    var _a = this.getAnimateCfg(cfg),
        animate = _a.animate,
        animateOption = _a.animateOption;

    cfg.animateOption = animateOption;
    cfg.animate = animate; //  verticalLimitLength

    var isAxisVertical = axis_1.isVertical(region); // TODO: 1 / 3 

    var verticalLimitLength = util_1.get(cfg, 'verticalLimitLength', isAxisVertical ? 1 / 3 : 1 / 2);

    if (verticalLimitLength <= 1) {
      // 
      var canvasWidth = this.view.getCanvas().get('width');
      var canvasHeight = this.view.getCanvas().get('height');
      cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
    }

    return cfg;
  };
  /**
   * generate line grid cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @param dim
   * @return line grid cfg
   */


  Axis.prototype.getLineGridCfg = function (scale, axisOption, direction, dim) {
    if (!grid_1.showGrid(axis_1.getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
      return undefined;
    }

    var gridThemeCfg = grid_1.getGridThemeCfg(this.view.getTheme(), direction); // the cfg order should be ensure
    // grid  axis 

    var gridCfg = util_1.deepMix({
      container: this.gridContainer
    }, gridThemeCfg, util_1.get(axisOption, 'grid'), this.getAnimateCfg(axisOption));
    gridCfg.items = grid_1.getLineGridItems(this.view.getCoordinate(), scale, dim, util_1.get(gridCfg, 'alignTick', true));
    return gridCfg;
  };
  /**
   * generate circle axis cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @return circle axis cfg
   */


  Axis.prototype.getCircleAxisCfg = function (scale, axisOption, direction) {
    var container = this.axisContainer;
    var coordinate = this.view.getCoordinate();
    var ticks = scale.getTicks().map(function (tick) {
      return {
        id: "" + tick.tickValue,
        name: tick.text,
        value: tick.value
      };
    });

    if (!scale.isCategory && Math.abs(coordinate.endAngle - coordinate.startAngle) === Math.PI * 2) {
      // x  cat 
      ticks.pop();
    }

    var titleText = axis_1.getAxisTitleText(scale, axisOption);
    var axisThemeCfg = axis_1.getAxisThemeCfg(this.view.getTheme(), constant_1.DIRECTION.CIRCLE); // the cfg order should be ensure

    var optionWithTitle = util_1.get(axisOption, ['title']) ? util_1.deepMix({
      title: {
        style: {
          text: titleText
        }
      }
    }, {
      title: util_1.get(axis_1.getAxisThemeCfg(this.view.getTheme(), 'common'), 'title')
    }, axisOption) : axisOption;
    var cfg = util_1.deepMix(tslib_1.__assign(tslib_1.__assign({
      container: container
    }, axis_1.getCircleAxisCenterRadius(this.view.getCoordinate())), {
      ticks: ticks,
      verticalFactor: 1,
      theme: axisThemeCfg
    }), axisThemeCfg, optionWithTitle);

    var _a = this.getAnimateCfg(cfg),
        animate = _a.animate,
        animateOption = _a.animateOption;

    cfg.animate = animate;
    cfg.animateOption = animateOption;
    return cfg;
  };
  /**
   * generate circle grid cfg
   * @param scale
   * @param axisOption
   * @param direction
   * @return circle grid cfg
   */


  Axis.prototype.getCircleGridCfg = function (scale, axisOption, direction, dim) {
    if (!grid_1.showGrid(axis_1.getAxisThemeCfg(this.view.getTheme(), direction), axisOption)) {
      return undefined;
    } // the cfg order should be ensure
    // grid  axis 


    var gridThemeCfg = grid_1.getGridThemeCfg(this.view.getTheme(), constant_1.DIRECTION.RADIUS);
    var gridCfg = util_1.deepMix({
      container: this.gridContainer,
      center: this.view.getCoordinate().getCenter()
    }, gridThemeCfg, util_1.get(axisOption, 'grid'), this.getAnimateCfg(axisOption));
    var alignTick = util_1.get(gridCfg, 'alignTick', true);
    var verticalScale = dim === 'x' ? this.view.getYScales()[0] : this.view.getXScale();
    gridCfg.items = grid_1.getCircleGridItems(this.view.getCoordinate(), verticalScale, scale, alignTick, dim); // the cfg order should be ensure
    // grid  axis 

    return gridCfg;
  };

  Axis.prototype.getId = function (name, key) {
    var coordinate = this.view.getCoordinate(); //  key

    return name + "-" + key + "-" + coordinate.type;
  };

  Axis.prototype.getAnimateCfg = function (cfg) {
    return {
      animate: this.view.getOptions().animate && util_1.get(cfg, 'animate'),
      animateOption: cfg && cfg.animateOption ? util_1.deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
    };
  };

  return Axis;
}(base_1.Controller);

exports.default = Axis;

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var dependents_1 = __webpack_require__(68);

var animate_1 = __webpack_require__(96);

var bbox_1 = __webpack_require__(77);

var direction_1 = __webpack_require__(282);

var helper_1 = __webpack_require__(76);

var legend_1 = __webpack_require__(438);

var scale_1 = __webpack_require__(145);

var base_1 = __webpack_require__(104);
/**
 *  legend 
 * @param legends
 * @param field
 * @returns the option of one legend field
 */


function getLegendOption(legends, field) {
  if (util_1.isBoolean(legends)) {
    return legends === false ? false : {};
  }

  return util_1.get(legends, [field], legends);
}

function getDirection(legendOption) {
  return util_1.get(legendOption, 'position', constant_1.DIRECTION.BOTTOM);
}
/**
 * @ignore
 * legend Controller
 */


var Legend =
/** @class */
function (_super) {
  tslib_1.__extends(Legend, _super);

  function Legend(view) {
    var _this = _super.call(this, view) || this;

    _this.container = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    return _this;
  }

  Object.defineProperty(Legend.prototype, "name", {
    get: function get() {
      return 'legend';
    },
    enumerable: false,
    configurable: true
  });

  Legend.prototype.init = function () {};
  /**
   * render the legend component by legend options
   */


  Legend.prototype.render = function () {
    //  update 
    this.update();
  };
  /**
   * layout legend
   *  legend  direction  x, y
   */


  Legend.prototype.layout = function () {
    var _this = this;

    this.layoutBBox = this.view.viewBBox;
    util_1.each(this.components, function (co) {
      var component = co.component,
          direction = co.direction;
      var layout = legend_1.getLegendLayout(direction);

      var maxSize = _this.getCategoryLegendSizeCfg(layout);

      var maxWidth = component.get('maxWidth');
      var maxHeight = component.get('maxHeight'); //  maxSize layoutBBox x y

      component.update({
        maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
        maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
      });
      var padding = component.get('padding');
      var bboxObject = component.getLayoutBBox(); //  widthheight 

      var bbox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding);

      var _a = direction_1.directionToPosition(_this.view.viewBBox, bbox, direction),
          x1 = _a[0],
          y1 = _a[1];

      var _b = direction_1.directionToPosition(_this.layoutBBox, bbox, direction),
          x2 = _b[0],
          y2 = _b[1];

      var x = 0;
      var y = 0; //  legend x y  coordinateBBox 

      if (direction.startsWith('top') || direction.startsWith('bottom')) {
        x = x1;
        y = y2;
      } else {
        x = x2;
        y = y1;
      } // 


      component.setLocation({
        x: x + padding[3],
        y: y + padding[0]
      });
      _this.layoutBBox = _this.layoutBBox.cut(bbox, direction);
    });
  };
  /**
   * legend 
   */


  Legend.prototype.update = function () {
    var _this = this;

    this.option = this.view.getOptions().legends; //  legend

    var updated = {};

    var eachLegend = function eachLegend(geometry, attr, scale) {
      var id = _this.getId(scale.field);

      var existCo = _this.getComponentById(id); //  update


      if (existCo) {
        var cfg = void 0;
        var legendOption = getLegendOption(_this.option, scale.field); // if the legend option is not false, means legend should be created.

        if (legendOption !== false) {
          if (util_1.get(legendOption, 'custom')) {
            cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption, true);
          } else {
            if (scale.isLinear) {
              // linear field, create continuous legend
              cfg = _this.getContinuousCfg(geometry, attr, scale, legendOption);
            } else if (scale.isCategory) {
              // category field, create category legend
              cfg = _this.getCategoryCfg(geometry, attr, scale, legendOption);
            }
          }
        } //  cfg  updated 


        if (cfg) {
          // omit  container 
          helper_1.omit(cfg, ['container']);
          existCo.direction = getDirection(legendOption);
          existCo.component.update(cfg); // 

          updated[id] = true;
        }
      } else {
        //  create
        var legend = _this.createFieldLegend(geometry, attr, scale);

        if (legend) {
          legend.component.init();

          _this.components.push(legend); // 


          updated[id] = true;
        }
      }
    }; // 


    if (util_1.get(this.option, 'custom')) {
      var id = 'global-custom';
      var existCo = this.getComponentById(id);

      if (existCo) {
        var customCfg = this.getCategoryCfg(undefined, undefined, undefined, this.option, true);
        helper_1.omit(customCfg, ['container']);
        existCo.component.update(customCfg);
        updated[id] = true;
      } else {
        var component = this.createCustomLegend(undefined, undefined, undefined, this.option);

        if (component) {
          component.init();
          var layer = constant_1.LAYER.FORE;
          var direction = getDirection(this.option);
          this.components.push({
            id: id,
            component: component,
            layer: layer,
            direction: direction,
            type: constant_1.COMPONENT_TYPE.LEGEND,
            extra: undefined
          }); // 

          updated[id] = true;
        }
      }
    } else {
      // 
      this.loopLegends(eachLegend);
    } // 
    // 


    var components = [];
    util_1.each(this.getComponents(), function (co) {
      if (updated[co.id]) {
        components.push(co);
      } else {
        co.component.destroy();
      }
    }); //  components

    this.components = components;
  };

  Legend.prototype.clear = function () {
    _super.prototype.clear.call(this);

    this.container.clear();
  };

  Legend.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.container.remove(true);
  };
  /**
   *  Geometry
   */


  Legend.prototype.getGeometries = function (view) {
    var _this = this;

    var geometries = view.geometries;
    util_1.each(view.views, function (v) {
      geometries = geometries.concat(_this.getGeometries(v));
    });
    return geometries;
  };
  /**
   *  Geometry legend 
   * @param doEach  loop 
   */


  Legend.prototype.loopLegends = function (doEach) {
    var isRootView = this.view.getRootView() === this.view; //  view legend

    if (!isRootView) {
      return;
    } //  view  Geometry legend


    var geometries = this.getGeometries(this.view);
    var looped = {}; //  legend

    util_1.each(geometries, function (geometry) {
      var attributes = geometry.getGroupAttributes();
      util_1.each(attributes, function (attr) {
        var scale = attr.getScale(attr.type); //  size(2) shape('circle')  legend

        if (!scale || scale.type === 'identity' || looped[scale.field]) {
          return;
        }

        doEach(geometry, attr, scale);
        looped[scale.field] = true;
      });
    });
  };
  /**
   *  legend
   * @param geometry
   * @param attr
   * @param scale
   */


  Legend.prototype.createFieldLegend = function (geometry, attr, scale) {
    var component;
    var legendOption = getLegendOption(this.option, scale.field);
    var layer = constant_1.LAYER.FORE;
    var direction = getDirection(legendOption); // if the legend option is not false, means legend should be created.

    if (legendOption !== false) {
      if (util_1.get(legendOption, 'custom')) {
        component = this.createCustomLegend(geometry, attr, scale, legendOption);
      } else {
        if (scale.isLinear) {
          // linear field, create continuous legend
          component = this.createContinuousLegend(geometry, attr, scale, legendOption);
        } else if (scale.isCategory) {
          // category field, create category legend
          component = this.createCategoryLegend(geometry, attr, scale, legendOption);
        }
      }
    }

    if (component) {
      component.set('field', scale.field);
      return {
        id: this.getId(scale.field),
        component: component,
        layer: layer,
        direction: direction,
        type: constant_1.COMPONENT_TYPE.LEGEND,
        extra: {
          scale: scale
        }
      };
    }
  };
  /**
   *  category 
   * @param geometry
   * @param attr
   * @param scale
   * @param legendOption
   */


  Legend.prototype.createCustomLegend = function (geometry, attr, scale, legendOption) {
    //  
    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption, true);
    return new dependents_1.CategoryLegend(cfg);
  };
  /**
   * 
   * @param geometry
   * @param attr
   * @param scale
   * @param legendOption
   */


  Legend.prototype.createContinuousLegend = function (geometry, attr, scale, legendOption) {
    var cfg = this.getContinuousCfg(geometry, attr, scale, legendOption);
    return new dependents_1.ContinuousLegend(cfg);
  };
  /**
   * 
   * @param geometry
   * @param attr
   * @param scale
   * @param legendOption
   */


  Legend.prototype.createCategoryLegend = function (geometry, attr, scale, legendOption) {
    var cfg = this.getCategoryCfg(geometry, attr, scale, legendOption);
    return new dependents_1.CategoryLegend(cfg);
  };
  /**
   * 
   * @param geometry
   * @param attr
   * @param scale
   * @param legendOption
   */


  Legend.prototype.getContinuousCfg = function (geometry, attr, scale, legendOption) {
    var ticks = scale.getTicks();
    var containMin = util_1.find(ticks, function (tick) {
      return tick.value === 0;
    });
    var containMax = util_1.find(ticks, function (tick) {
      return tick.value === 1;
    });
    var items = ticks.map(function (tick) {
      var value = tick.value,
          tickValue = tick.tickValue;
      var attrValue = attr.mapping(scale.invert(value)).join('');
      return {
        value: tickValue,
        attrValue: attrValue,
        color: attrValue,
        scaleValue: value
      };
    });

    if (!containMin) {
      items.push({
        value: scale.min,
        attrValue: attr.mapping(scale.invert(0)).join(''),
        color: attr.mapping(scale.invert(0)).join(''),
        scaleValue: 0
      });
    }

    if (!containMax) {
      items.push({
        value: scale.max,
        attrValue: attr.mapping(scale.invert(1)).join(''),
        color: attr.mapping(scale.invert(1)).join(''),
        scaleValue: 1
      });
    } // 


    items.sort(function (a, b) {
      return a.value - b.value;
    }); //  attr 
    // size color 

    var attrLegendCfg = {
      min: util_1.head(items).value,
      max: util_1.last(items).value,
      colors: [],
      rail: {
        type: attr.type
      },
      track: {}
    };

    if (attr.type === 'size') {
      attrLegendCfg.track = {
        style: {
          // size  color color 
          // @ts-ignore
          fill: attr.type === 'size' ? this.view.getTheme().defaultColor : undefined
        }
      };
    }

    if (attr.type === 'color') {
      attrLegendCfg.colors = items.map(function (item) {
        return item.attrValue;
      });
    }

    var container = this.container; // if position is not set, use top as default

    var direction = getDirection(legendOption);
    var layout = legend_1.getLegendLayout(direction);
    var title = util_1.get(legendOption, 'title');

    if (title) {
      title = util_1.deepMix({
        text: scale_1.getName(scale)
      }, title);
    } // 


    attrLegendCfg.container = container;
    attrLegendCfg.layout = layout;
    attrLegendCfg.title = title;
    attrLegendCfg.animateOption = animate_1.DEFAULT_ANIMATE_CFG; // @ts-ignore

    return this.mergeLegendCfg(attrLegendCfg, legendOption, 'continuous');
  };
  /**
   * 
   * @param geometry
   * @param attr
   * @param scale
   * @param custom
   * @param legendOption
   */


  Legend.prototype.getCategoryCfg = function (geometry, attr, scale, legendOption, custom) {
    var container = this.container; // if position is not set, use top as default

    var direction = util_1.get(legendOption, 'position', constant_1.DIRECTION.BOTTOM); // the default marker style

    var themeMarker = util_1.get(this.view.getTheme(), ['components', 'legend', direction, 'marker']);
    var userMarker = util_1.get(legendOption, 'marker');
    var layout = legend_1.getLegendLayout(direction);
    var items = custom ? legend_1.getCustomLegendItems(themeMarker, userMarker, legendOption.items) : legend_1.getLegendItems(this.view, geometry, attr, themeMarker, userMarker);
    var title = util_1.get(legendOption, 'title');

    if (title) {
      title = util_1.deepMix({
        text: scale ? scale_1.getName(scale) : ''
      }, title);
    }

    var baseCfg = this.getCategoryLegendSizeCfg(layout);
    baseCfg.container = container;
    baseCfg.layout = layout;
    baseCfg.items = items;
    baseCfg.title = title;
    baseCfg.animateOption = animate_1.DEFAULT_ANIMATE_CFG;
    var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction);

    if (categoryCfg.reversed) {
      // 
      categoryCfg.items.reverse();
    }

    var maxItemWidth = util_1.get(categoryCfg, 'maxItemWidth');

    if (maxItemWidth && maxItemWidth <= 1) {
      // 
      categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
    }

    return categoryCfg;
  };
  /**
   * get legend config, use option > suggestion > theme
   * @param baseCfg
   * @param legendOption
   * @param direction
   */


  Legend.prototype.mergeLegendCfg = function (baseCfg, legendOption, direction) {
    var position = direction.split('-')[0];
    var themeObject = util_1.get(this.view.getTheme(), ['components', 'legend', position], {});
    return util_1.deepMix({}, themeObject, baseCfg, legendOption);
  };
  /**
   *  id
   * @param key
   */


  Legend.prototype.getId = function (key) {
    return this.name + "-" + key;
  };
  /**
   *  id 
   * @param id
   */


  Legend.prototype.getComponentById = function (id) {
    return util_1.find(this.components, function (co) {
      return co.id === id;
    });
  };

  Legend.prototype.getCategoryLegendSizeCfg = function (layout) {
    var _a = this.view.viewBBox,
        vw = _a.width,
        vh = _a.height; //  legend  viewBBox 
    // const { width: cw, height: ch } = this.view.coordinateBBox;

    return layout === 'vertical' ? {
      maxWidth: vw * constant_1.COMPONENT_MAX_VIEW_PERCENTAGE,
      maxHeight: vh
    } : {
      maxWidth: vw,
      maxHeight: vh * constant_1.COMPONENT_MAX_VIEW_PERCENTAGE
    };
  };

  return Legend;
}(base_1.Controller);

exports.default = Legend;

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var dependents_1 = __webpack_require__(68);

var bbox_1 = __webpack_require__(77);

var direction_1 = __webpack_require__(282);

var helper_1 = __webpack_require__(76);

var base_1 = __webpack_require__(104);
/**
 * @ignore
 * slider Controller
 */


var Slider =
/** @class */
function (_super) {
  tslib_1.__extends(Slider, _super);

  function Slider(view) {
    var _this = _super.call(this, view) || this;

    _this.onChangeFn = util_1.noop;
    /**
     * 
     */

    _this.resetMeasure = function () {
      _this.clear();
    };
    /**
     * 
     * @param v
     */


    _this.onValueChange = function (v) {
      var min = v[0],
          max = v[1];
      _this.start = min;
      _this.end = max;

      _this.changeViewData(min, max);
    };

    _this.container = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.onChangeFn = util_1.throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.width = 0;

    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);

    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);

    return _this;
  }

  Object.defineProperty(Slider.prototype, "name", {
    get: function get() {
      return 'slider';
    },
    enumerable: false,
    configurable: true
  });

  Slider.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };
  /**
   * 
   */


  Slider.prototype.init = function () {};
  /**
   * 
   */


  Slider.prototype.render = function () {
    this.option = this.view.getOptions().slider;

    var _a = this.getSliderCfg(),
        start = _a.start,
        end = _a.end;

    if (util_1.isNil(this.start)) {
      this.start = start;
      this.end = end;
    }

    var viewData = this.view.getOptions().data;

    if (this.option && !util_1.isEmpty(viewData)) {
      if (this.slider) {
        // exist, update
        this.slider = this.updateSlider();
      } else {
        // not exist, create
        this.slider = this.createSlider(); // 

        this.slider.component.on('sliderchange', this.onChangeFn);
      }
    } else {
      if (this.slider) {
        // exist, destroy
        this.slider.component.destroy();
        this.slider = undefined;
      } else {// do nothing
      }
    }
  };
  /**
   * 
   */


  Slider.prototype.layout = function () {
    var _this = this;

    if (this.option && !this.width) {
      this.measureSlider();
      setTimeout(function () {
        //  view 
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.start, _this.end);
        }
      }, 0);
    }

    if (this.slider) {
      var width = this.view.coordinateBBox.width; //  layout bbox

      var padding = this.slider.component.get('padding');
      var paddingTop = padding[0],
          paddingRight = padding[1],
          paddingBottom = padding[2],
          paddingLeft = padding[3];
      var bboxObject = this.slider.component.getLayoutBBox();
      var bbox = new bbox_1.BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);

      var _a = this.getMinMaxText(this.start, this.end),
          minText = _a.minText,
          maxText = _a.maxText;

      var _b = direction_1.directionToPosition(this.view.viewBBox, bbox, constant_1.DIRECTION.BOTTOM),
          x1 = _b[0],
          y1 = _b[1];

      var _c = direction_1.directionToPosition(this.view.coordinateBBox, bbox, constant_1.DIRECTION.BOTTOM),
          x2 = _c[0],
          y2 = _c[1]; //  bottom


      this.slider.component.update(tslib_1.__assign(tslib_1.__assign({}, this.getSliderCfg()), {
        x: x2 + paddingLeft,
        y: y1 + paddingTop,
        width: this.width,
        start: this.start,
        end: this.end,
        minText: minText,
        maxText: maxText
      }));
      this.view.viewBBox = this.view.viewBBox.cut(bbox, constant_1.DIRECTION.BOTTOM);
    }
  };
  /**
   * 
   */


  Slider.prototype.update = function () {
    //  render 
    this.render();
  };
  /**
   *  slider 
   */


  Slider.prototype.createSlider = function () {
    var cfg = this.getSliderCfg(); //  slider 

    var component = new dependents_1.Slider(tslib_1.__assign({
      container: this.container
    }, cfg));
    component.init();
    return {
      component: component,
      layer: constant_1.LAYER.FORE,
      direction: constant_1.DIRECTION.BOTTOM,
      type: constant_1.COMPONENT_TYPE.SLIDER
    };
  };
  /**
   * 
   */


  Slider.prototype.updateSlider = function () {
    var cfg = this.getSliderCfg();

    if (this.width) {
      var _a = this.getMinMaxText(this.start, this.end),
          minText = _a.minText,
          maxText = _a.maxText;

      cfg = tslib_1.__assign(tslib_1.__assign({}, cfg), {
        width: this.width,
        start: this.start,
        end: this.end,
        minText: minText,
        maxText: maxText
      });
    }

    this.slider.component.update(cfg);
    return this.slider;
  };
  /**
   * 
   */


  Slider.prototype.measureSlider = function () {
    var width = this.getSliderCfg().width;
    this.width = width;
  };
  /**
   *  slider 
   */


  Slider.prototype.getSliderCfg = function () {
    var cfg = {
      height: 16,
      start: 0,
      end: 1,
      minText: '',
      maxText: '',
      x: 0,
      y: 0,
      width: this.view.coordinateBBox.width
    };

    if (util_1.isObject(this.option)) {
      // 
      var trendCfg = tslib_1.__assign({
        data: this.getData()
      }, util_1.get(this.option, 'trendCfg', {})); // 


      cfg = util_1.deepMix({}, cfg, this.getThemeOptions(), this.option); // trendCfg 

      cfg = tslib_1.__assign(tslib_1.__assign({}, cfg), {
        trendCfg: trendCfg
      });
    }

    cfg.start = util_1.clamp(Math.min(util_1.isNil(cfg.start) ? 0 : cfg.start, util_1.isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    cfg.end = util_1.clamp(Math.max(util_1.isNil(cfg.start) ? 0 : cfg.start, util_1.isNil(cfg.end) ? 1 : cfg.end), 0, 1);
    return cfg;
  };
  /**
   *  view 
   */


  Slider.prototype.getData = function () {
    var data = this.view.getOptions().data;
    var yScale = this.view.getYScales()[0];
    var groupScales = this.view.getGroupScales();

    if (groupScales.length) {
      var _a = groupScales[0],
          field_1 = _a.field,
          ticks_1 = _a.ticks;
      return data.reduce(function (pre, cur) {
        if (cur[field_1] === ticks_1[0]) {
          pre.push(cur[yScale.field]);
        }

        return pre;
      }, []);
    }

    return data.map(function (datum) {
      return datum[yScale.field] || 0;
    });
  };
  /**
   *  slider 
   */


  Slider.prototype.getThemeOptions = function () {
    var theme = this.view.getTheme();
    return util_1.get(theme, ['components', 'slider', 'common'], {});
  };
  /**
   *  start/end  minText/maxText
   * @param min
   * @param max
   */


  Slider.prototype.getMinMaxText = function (min, max) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var isHorizontal = true;
    var values = util_1.valuesOfKey(data, xScale.field);
    var xValues = isHorizontal ? values : values.reverse();
    var dataSize = util_1.size(data);

    if (!xScale || !dataSize) {
      return {}; // fix: 
    }

    var xTickCount = util_1.size(xValues);
    var minIndex = Math.floor(min * (xTickCount - 1));
    var maxIndex = Math.floor(max * (xTickCount - 1));
    var minText = util_1.get(xValues, [minIndex]);
    var maxText = util_1.get(xValues, [maxIndex]);
    var formatter = this.getSliderCfg().formatter;

    if (formatter) {
      minText = formatter(minText, data[minIndex], minIndex);
      maxText = formatter(maxText, data[maxIndex], maxIndex);
    }

    return {
      minText: minText,
      maxText: maxText
    };
  };
  /**
   *  view 
   * @param min
   * @param max
   */


  Slider.prototype.changeViewData = function (min, max) {
    var data = this.view.getOptions().data;
    var xScale = this.view.getXScale();
    var isHorizontal = true;
    var values = util_1.valuesOfKey(data, xScale.field);
    var xValues = isHorizontal ? values : values.reverse();
    var dataSize = util_1.size(data);

    if (!xScale || !dataSize) {
      return;
    }

    var xTickCount = util_1.size(xValues);
    var minIndex = Math.floor(min * (xTickCount - 1));
    var maxIndex = Math.floor(max * (xTickCount - 1)); //  x 

    this.view.filter(xScale.field, function (value, datum) {
      var idx = xValues.indexOf(value);
      return idx > -1 ? helper_1.isBetween(idx, minIndex, maxIndex) : true;
    });
    this.view.render(true);
  };
  /**
   * 
   */


  Slider.prototype.getComponents = function () {
    return this.slider ? [this.slider] : [];
  };
  /**
   * 
   */


  Slider.prototype.clear = function () {
    if (this.slider) {
      this.slider.component.destroy();
      this.slider = undefined;
    }

    this.width = 0;
    this.start = undefined;
    this.end = undefined;
  };

  return Slider;
}(base_1.Controller);

exports.default = Slider;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));
/**
 *  Action
 * @ignore
 */


var ActiveRegion =
/** @class */
function (_super) {
  tslib_1.__extends(ActiveRegion, _super);

  function ActiveRegion() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   */


  ActiveRegion.prototype.show = function () {
    var view = this.context.view;
    var ev = this.context.event;
    var tooltipItems = view.getTooltipItems({
      x: ev.x,
      y: ev.y
    });

    if (util_1.isEqual(tooltipItems, this.items)) {
      // 
      return;
    }

    this.items = tooltipItems;

    if (tooltipItems.length) {
      var xField_1 = view.getXScale().field;
      var xValue_1 = tooltipItems[0].data[xField_1]; //  x  elements

      var elements_1 = [];
      var geometries = view.geometries;
      util_1.each(geometries, function (geometry) {
        if (geometry.type === 'interval' || geometry.type === 'schema') {
          var result = geometry.getElementsBy(function (ele) {
            var eleData = ele.getData();
            return eleData[xField_1] === xValue_1;
          });
          elements_1 = elements_1.concat(result);
        }
      }); //  bbox 

      if (elements_1.length) {
        var coordinate_1 = view.getCoordinate();
        var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
        var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
        var groupBBox_1 = firstBBox_1;
        util_1.each(elements_1, function (ele) {
          var bbox = ele.shape.getCanvasBBox();

          if (coordinate_1.isTransposed) {
            if (bbox.minY < firstBBox_1.minY) {
              firstBBox_1 = bbox;
            }

            if (bbox.maxY > lastBBox_1.maxY) {
              lastBBox_1 = bbox;
            }
          } else {
            if (bbox.minX < firstBBox_1.minX) {
              firstBBox_1 = bbox;
            }

            if (bbox.maxX > lastBBox_1.maxX) {
              lastBBox_1 = bbox;
            }
          }

          groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
          groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
          groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
          groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
        });
        var backgroundGroup = view.backgroundGroup,
            coordinateBBox = view.coordinateBBox;
        var path = void 0;

        if (coordinate_1.isRect) {
          var xScale = view.getXScale();
          var appendRatio = xScale.isLinear ? 0 : 0.25; //  x 

          var minX = void 0;
          var minY = void 0;
          var width = void 0;
          var height = void 0;

          if (coordinate_1.isTransposed) {
            minX = coordinateBBox.minX;
            minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendRatio * lastBBox_1.height;
            width = coordinateBBox.width;
            height = groupBBox_1.height + appendRatio * 2 * lastBBox_1.height;
          } else {
            minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendRatio * firstBBox_1.width;
            minY = Math.min(coordinateBBox.minY, firstBBox_1.minY);
            width = groupBBox_1.width + appendRatio * 2 * firstBBox_1.width;
            height = coordinateBBox.height;
          }

          path = [['M', minX, minY], ['L', minX + width, minY], ['L', minX + width, minY + height], ['L', minX, minY + height], ['Z']];
        } else {
          var firstElement = util_1.head(elements_1);
          var lastElement = util_1.last(elements_1);
          var startAngle = graphics_1.getAngle(firstElement.getModel(), coordinate_1).startAngle;
          var endAngle = graphics_1.getAngle(lastElement.getModel(), coordinate_1).endAngle;
          var center = coordinate_1.getCenter();
          var radius = coordinate_1.getRadius();
          var innterRadius = coordinate_1.innerRadius * radius;
          path = graphics_1.getSectorPath(center.x, center.y, radius, startAngle, endAngle, innterRadius);
        }

        if (this.regionPath) {
          this.regionPath.attr('path', path);
          this.regionPath.show();
        } else {
          this.regionPath = backgroundGroup.addShape({
            type: 'path',
            name: 'active-region',
            capture: false,
            attrs: {
              path: path,
              fill: '#CCD6EC',
              opacity: 0.3
            }
          });
        }
      }
    }
  };
  /**
   * 
   */


  ActiveRegion.prototype.hide = function () {
    if (this.regionPath) {
      this.regionPath.hide();
    } // this.regionPath = null;


    this.items = null;
  };
  /**
   * 
   */


  ActiveRegion.prototype.destroy = function () {
    this.hide();

    if (this.regionPath) {
      this.regionPath.remove(true);
    }

    _super.prototype.destroy.call(this);
  };

  return ActiveRegion;
}(base_1.default);

exports.default = ActiveRegion;

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var geometry_1 = tslib_1.__importDefault(__webpack_require__(127));
/**
 *  view  view  tooltip 
 * @ignore
 */


var SiblingTooltip =
/** @class */
function (_super) {
  tslib_1.__extends(SiblingTooltip, _super);

  function SiblingTooltip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   *  tooltip 
   * @param view
   * @param point
   */


  SiblingTooltip.prototype.showTooltip = function (view, point) {
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      var siblingPoint = util_2.getSiblingPoint(view, sibling, point);
      sibling.showTooltip(siblingPoint);
    });
  };
  /**
   *  tooltip
   * @param view
   */


  SiblingTooltip.prototype.hideTooltip = function (view) {
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      sibling.hideTooltip();
    });
  };

  return SiblingTooltip;
}(geometry_1.default);

exports.default = SiblingTooltip;

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var component_1 = __webpack_require__(184);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var dependents_1 = __webpack_require__(68);
/**
 *  Tooltip Action
 * @ignore
 */


var EllipsisText =
/** @class */
function (_super) {
  tslib_1.__extends(EllipsisText, _super);

  function EllipsisText() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.timeStamp = 0;
    return _this;
  }

  EllipsisText.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.tooltip && this.tooltip.destroy();
  };
  /**
   *  Tooltip
   * @returns
   */


  EllipsisText.prototype.show = function () {
    var context = this.context;
    var ev = context.event;
    var lastTimeStamp = this.timeStamp;
    var timeStamp = +new Date();

    if (timeStamp - lastTimeStamp > 16) {
      var preLoc = this.location;
      var curLoc = {
        x: ev.x,
        y: ev.y
      };

      if (!preLoc || !util_1.isEqual(preLoc, curLoc)) {
        this.showTooltip(curLoc);
      }

      this.timeStamp = timeStamp;
      this.location = curLoc;
    }
  };
  /**
   *  Tooltip
   * @returns
   */


  EllipsisText.prototype.hide = function () {
    this.hideTooltip();
    this.location = null;
  };

  EllipsisText.prototype.showTooltip = function (curLoc) {
    var context = this.context;
    var ev = context.event;
    var target = ev.target;

    if (target && target.get('tip')) {
      if (!this.tooltip) {
        this.renderTooltip(); // 
      }

      var tipContent = target.get('tip'); //  tooltip

      this.tooltip.update(tslib_1.__assign({
        title: tipContent
      }, curLoc));
      this.tooltip.show();
    }
  };

  EllipsisText.prototype.hideTooltip = function () {
    this.tooltip && this.tooltip.hide();
  };

  EllipsisText.prototype.renderTooltip = function () {
    var _a;

    var view = this.context.view;
    var canvas = view.canvas;
    var region = {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: canvas.get('width'),
        y: canvas.get('height')
      }
    };
    var theme = view.getTheme();
    var tooltipStyles = util_1.get(theme, ['components', 'tooltip', 'domStyles'], {}); //  tooltip 

    var tooltip = new dependents_1.HtmlTooltip({
      parent: canvas.get('el').parentNode,
      region: region,
      visible: false,
      crosshairs: null,
      domStyles: tslib_1.__assign({}, util_1.deepMix({}, tooltipStyles, (_a = {}, // tooltip tip  50%
      _a[component_1.TOOLTIP_CSS_CONST.CONTAINER_CLASS] = {
        'max-width': '50%'
      }, _a[component_1.TOOLTIP_CSS_CONST.TITLE_CLASS] = {
        'word-break': 'break-all'
      }, _a)))
    });
    tooltip.init();
    tooltip.setCapture(false); // 

    this.tooltip = tooltip;
  };

  return EllipsisText;
}(base_1.default);

exports.default = EllipsisText;

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var state_1 = tslib_1.__importDefault(__webpack_require__(283));
/**
 *  active  Action active
 * @class
 * @ignore
 */


var ElementActive =
/** @class */
function (_super) {
  tslib_1.__extends(ElementActive, _super);

  function ElementActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  }
  /**
   * Active Element
   */


  ElementActive.prototype.active = function () {
    this.setState();
  };

  return ElementActive;
}(state_1.default);

exports.default = ElementActive;

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_1 = __webpack_require__(30);

var util_2 = __webpack_require__(0);
/**
 * Link Elements by color
 * @ignore
 */


var LinkByColor =
/** @class */
function (_super) {
  tslib_1.__extends(LinkByColor, _super);

  function LinkByColor() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.cache = {};
    return _this;
  } //  scale


  LinkByColor.prototype.getColorScale = function (view, element) {
    var colorAttr = element.geometry.getAttribute('color');

    if (!colorAttr) {
      return null;
    }

    var scale = view.getScaleByField(colorAttr.getFields()[0]);
    return scale;
  }; //  path


  LinkByColor.prototype.getLinkPath = function (element, nextElement) {
    var view = this.context.view;
    var isTransposed = view.getCoordinate().isTransposed;
    var bbox = element.shape.getCanvasBBox();
    var nextBBox = nextElement.shape.getCanvasBBox();
    var path = isTransposed ? [['M', bbox.minX, bbox.minY], ['L', nextBBox.minX, nextBBox.maxY], ['L', nextBBox.maxX, nextBBox.maxY], ['L', bbox.maxX, bbox.minY], ['Z']] : [['M', bbox.maxX, bbox.minY], ['L', nextBBox.minX, nextBBox.minY], ['L', nextBBox.minX, nextBBox.maxY], ['L', bbox.maxX, bbox.maxY], ['Z']];
    return path;
  }; // 


  LinkByColor.prototype.addLinkShape = function (group, element, nextElement) {
    group.addShape({
      type: 'path',
      attrs: {
        opacity: 0.4,
        fill: element.shape.attr('fill'),
        path: this.getLinkPath(element, nextElement)
      }
    });
  }; // 


  LinkByColor.prototype.linkByElement = function (element) {
    var _this = this;

    var view = this.context.view;
    var scale = this.getColorScale(view, element);

    if (!scale) {
      return;
    }

    var value = util_1.getElementValue(element, scale.field);

    if (!this.cache[value]) {
      var elements_1 = util_1.getElementsByField(view, scale.field, value);
      var linkGroup = this.linkGroup;
      var group_1 = linkGroup.addGroup();
      this.cache[value] = group_1; // 

      var count_1 = elements_1.length;
      util_2.each(elements_1, function (el, index) {
        if (index < count_1 - 1) {
          var nextEl = elements_1[index + 1];

          _this.addLinkShape(group_1, el, nextEl);
        }
      });
    }
  }; // 


  LinkByColor.prototype.removeLink = function (element) {
    var scale = this.getColorScale(this.context.view, element);

    if (!scale) {
      return;
    }

    var value = util_1.getElementValue(element, scale.field);

    if (this.cache[value]) {
      this.cache[value].remove();
      this.cache[value] = null;
    }
  };
  /**
   *  elements
   */


  LinkByColor.prototype.link = function () {
    var context = this.context;

    if (!this.linkGroup) {
      // 
      this.linkGroup = context.view.foregroundGroup.addGroup({
        capture: false
      });
    }

    var element = util_1.getCurrentElement(context);

    if (element) {
      this.linkByElement(element);
    }
  };
  /**
   *  elements
   */


  LinkByColor.prototype.unlink = function () {
    var element = util_1.getCurrentElement(this.context);

    if (element) {
      this.removeLink(element);
    }
  };
  /**
   * 
   */


  LinkByColor.prototype.clear = function () {
    if (this.linkGroup) {
      this.linkGroup.clear();
    }

    this.cache = {};
  };
  /**
   * 
   */


  LinkByColor.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    if (this.linkGroup) {
      this.linkGroup.remove();
    }
  };

  return LinkByColor;
}(base_1.default);

exports.default = LinkByColor;

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var range_state_1 = tslib_1.__importDefault(__webpack_require__(285));
/**
 * @ignore
 *  Active  Action
 */


var ElementRangeActive =
/** @class */
function (_super) {
  tslib_1.__extends(ElementRangeActive, _super);

  function ElementRangeActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  }
  /**
   *  Active
   */


  ElementRangeActive.prototype.active = function () {
    this.setState();
  };

  return ElementRangeActive;
}(range_state_1.default);

exports.default = ElementRangeActive;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var single_state_1 = tslib_1.__importDefault(__webpack_require__(286));
/**
 * @ignore
 *  Element Active  Action
 */


var ElementSingleActive =
/** @class */
function (_super) {
  tslib_1.__extends(ElementSingleActive, _super);

  function ElementSingleActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  }
  /**
   *  Element Active
   */


  ElementSingleActive.prototype.active = function () {
    this.setState();
  };

  return ElementSingleActive;
}(single_state_1.default);

exports.default = ElementSingleActive;

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(30);

var highlight_1 = tslib_1.__importDefault(__webpack_require__(165));
/**
 * Highlight color
 * @ignore
 */


var HighlightColor =
/** @class */
function (_super) {
  tslib_1.__extends(HighlightColor, _super);

  function HighlightColor() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  HighlightColor.prototype.setStateByElement = function (element, enable) {
    var view = this.context.view;
    var colorAttr = element.geometry.getAttribute('color');

    if (!colorAttr) {
      return;
    }

    var scale = view.getScaleByField(colorAttr.getFields()[0]);
    var value = util_1.getElementValue(element, scale.field);
    var elements = util_1.getElements(view);
    var highlightElements = elements.filter(function (el) {
      return util_1.getElementValue(el, scale.field) === value;
    });
    this.setHighlightBy(elements, function (el) {
      return highlightElements.includes(el);
    }, enable);
  };

  return HighlightColor;
}(highlight_1.default);

exports.default = HighlightColor;

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(30);

var highlight_1 = tslib_1.__importStar(__webpack_require__(165));
/**
 * Highlight x
 * @ignore
 */


var HighlightX =
/** @class */
function (_super) {
  tslib_1.__extends(HighlightX, _super);

  function HighlightX() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // 


  HighlightX.prototype.setElementHighlight = function (el, callback) {
    if (callback(el)) {
      if (el.hasState(highlight_1.STATUS_UNACTIVE)) {
        el.setState(highlight_1.STATUS_UNACTIVE, false);
      }

      el.setState(highlight_1.STATUS_ACTIVE, true);
    } else {
      el.setState(highlight_1.STATUS_UNACTIVE, true);

      if (el.hasState(highlight_1.STATUS_ACTIVE)) {
        el.setState(highlight_1.STATUS_ACTIVE, false);
      }
    }
  };

  HighlightX.prototype.setStateByElement = function (element, enable) {
    var view = this.context.view;
    var scale = view.getXScale();
    var value = util_1.getElementValue(element, scale.field);
    var elements = util_1.getElements(view);
    var highlightElements = elements.filter(function (el) {
      return util_1.getElementValue(el, scale.field) === value;
    });
    this.setHighlightBy(elements, function (el) {
      return highlightElements.includes(el);
    }, enable);
  };
  /**
   * 
   */


  HighlightX.prototype.toggle = function () {
    var element = util_1.getCurrentElement(this.context);

    if (element) {
      var hasState = element.hasState(this.stateName);
      this.setStateByElement(element, !hasState);
    }
  };

  return HighlightX;
}(highlight_1.default);

exports.default = HighlightX;

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(30);

var highlight_util_1 = __webpack_require__(287);

var single_state_1 = tslib_1.__importDefault(__webpack_require__(286));
/**
 * @ignore
 *  Element Highlight  Action
 */


var ElementSingleHighlight =
/** @class */
function (_super) {
  tslib_1.__extends(ElementSingleHighlight, _super);

  function ElementSingleHighlight() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  }
  /**
   * Element Highlight
   */


  ElementSingleHighlight.prototype.highlight = function () {
    this.setState();
  };

  ElementSingleHighlight.prototype.setElementState = function (element, enable) {
    var view = this.context.view;
    var elements = util_1.getElements(view);
    highlight_util_1.setHighlightBy(elements, function (el) {
      return element === el;
    }, enable);
  }; //  active unactive 


  ElementSingleHighlight.prototype.clear = function () {
    var view = this.context.view;
    highlight_util_1.clearHighlight(view);
  };

  return ElementSingleHighlight;
}(single_state_1.default);

exports.default = ElementSingleHighlight;

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var range_state_1 = tslib_1.__importDefault(__webpack_require__(285));
/**
 * @ignore
 *  Action
 */


var ElementRangeSelected =
/** @class */
function (_super) {
  tslib_1.__extends(ElementRangeSelected, _super);

  function ElementRangeSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'selected';
    return _this;
  }
  /**
   * 
   */


  ElementRangeSelected.prototype.selected = function () {
    this.setState();
  };

  return ElementRangeSelected;
}(range_state_1.default);

exports.default = ElementRangeSelected;

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var state_1 = tslib_1.__importDefault(__webpack_require__(283));
/**
 * @ignore
 *  Action
 * @class
 */


var ElementMultipleSelected =
/** @class */
function (_super) {
  tslib_1.__extends(ElementMultipleSelected, _super);

  function ElementMultipleSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'selected';
    return _this;
  }
  /**
   * 
   */


  ElementMultipleSelected.prototype.selected = function () {
    this.setState();
  };

  return ElementMultipleSelected;
}(state_1.default);

exports.default = ElementMultipleSelected;

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var single_state_1 = tslib_1.__importDefault(__webpack_require__(286));
/**
 * @ignore
 *  Action
 */


var ElementSingleSelected =
/** @class */
function (_super) {
  tslib_1.__extends(ElementSingleSelected, _super);

  function ElementSingleSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'selected';
    return _this;
  }
  /**
   * 
   */


  ElementSingleSelected.prototype.selected = function () {
    this.setState();
  };

  return ElementSingleSelected;
}(single_state_1.default);

exports.default = ElementSingleSelected;

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var list_state_1 = tslib_1.__importDefault(__webpack_require__(193));
/**
 *  Action
 * @class
 * @ignore
 */


var ListActive =
/** @class */
function (_super) {
  tslib_1.__extends(ListActive, _super);

  function ListActive() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'active';
    return _this;
  }
  /**
   * 
   */


  ListActive.prototype.active = function () {
    this.setState();
  };

  return ListActive;
}(list_state_1.default);

exports.default = ListActive;

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var list_state_1 = tslib_1.__importDefault(__webpack_require__(193));
/**
 *  Action
 * @ignore
 */


var ListSelected =
/** @class */
function (_super) {
  tslib_1.__extends(ListSelected, _super);

  function ListSelected() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'selected';
    return _this;
  }

  ListSelected.prototype.selected = function () {
    this.setState();
  };

  return ListSelected;
}(list_state_1.default);

exports.default = ListSelected;

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var list_state_1 = tslib_1.__importDefault(__webpack_require__(193));
/**
 *  Action
 * @ignore
 */


var ListUnchecked =
/** @class */
function (_super) {
  tslib_1.__extends(ListUnchecked, _super);

  function ListUnchecked() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.stateName = 'unchecked';
    return _this;
  }
  /**
   * 
   */


  ListUnchecked.prototype.unchecked = function () {
    this.setState();
  };

  return ListUnchecked;
}(list_state_1.default);

exports.default = ListUnchecked;

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * @fileoverview https://www.w3school.com.cn/jsref/prop_style_cursor.asp
 * @author dxq613
 */


var base_1 = tslib_1.__importDefault(__webpack_require__(47));
/**
 *  Action
 * @ignore
 */


var CursorAction =
/** @class */
function (_super) {
  tslib_1.__extends(CursorAction, _super);

  function CursorAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  CursorAction.prototype.setCursor = function (cursor) {
    var view = this.context.view;
    view.getCanvas().setCursor(cursor);
  };
  /**
   * 
   */


  CursorAction.prototype.default = function () {
    this.setCursor('default');
  };
  /**  */


  CursorAction.prototype.pointer = function () {
    this.setCursor('pointer');
  };
  /**  */


  CursorAction.prototype.move = function () {
    this.setCursor('move');
  };
  /**  */


  CursorAction.prototype.crosshair = function () {
    this.setCursor('crosshair');
  };
  /**  */


  CursorAction.prototype.wait = function () {
    this.setCursor('wait');
  };
  /**  */


  CursorAction.prototype.help = function () {
    this.setCursor('help');
  };
  /**  */


  CursorAction.prototype.text = function () {
    this.setCursor('text');
  };
  /**
   * 
   */


  CursorAction.prototype.eResize = function () {
    this.setCursor('e-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.wResize = function () {
    this.setCursor('w-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.nResize = function () {
    this.setCursor('n-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.sResize = function () {
    this.setCursor('s-resize');
  };
  /**
   *  
   */


  CursorAction.prototype.neResize = function () {
    this.setCursor('ne-resize');
  };
  /**
   *  
   */


  CursorAction.prototype.nwResize = function () {
    this.setCursor('nw-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.seResize = function () {
    this.setCursor('se-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.swResize = function () {
    this.setCursor('sw-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.nsResize = function () {
    this.setCursor('ns-resize');
  };
  /**
   * 
   */


  CursorAction.prototype.ewResize = function () {
    this.setCursor('ew-resize');
  };

  return CursorAction;
}(base_1.default);

exports.default = CursorAction;

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_2 = __webpack_require__(30);
/**
 * 
 * @ignore
 */


var DataFilter =
/** @class */
function (_super) {
  tslib_1.__extends(DataFilter, _super);

  function DataFilter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  DataFilter.prototype.filterView = function (view, field, filter) {
    var _this = this; //  scale 


    if (view.getScaleByField(field)) {
      view.filter(field, filter);
    }

    if (view.views && view.views.length) {
      util_1.each(view.views, function (subView) {
        _this.filterView(subView, field, filter);
      });
    }
  };
  /**
   * 
   */


  DataFilter.prototype.filter = function () {
    var delegateObject = util_2.getDelegationObject(this.context);

    if (delegateObject) {
      var view = this.context.view;
      var component = delegateObject.component;
      var field = component.get('field'); // 

      if (util_2.isList(delegateObject)) {
        if (field) {
          var unCheckedItems = component.getItemsByState('unchecked');
          var scale_1 = util_2.getScaleByField(view, field);
          var names_1 = unCheckedItems.map(function (item) {
            return item.name;
          });

          if (names_1.length) {
            this.filterView(view, field, function (value) {
              var text = scale_1.getText(value);
              return !names_1.includes(text);
            });
          } else {
            this.filterView(view, field, null);
          }

          view.render(true);
        }
      } else if (util_2.isSlider(delegateObject)) {
        var range = component.getValue();
        var min_1 = range[0],
            max_1 = range[1];
        this.filterView(view, field, function (value) {
          return value >= min_1 && value <= max_1;
        });
        view.render(true);
      }
    }
  };

  return DataFilter;
}(base_1.default);

exports.default = DataFilter;

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var keys = __webpack_require__(355);

var hasSymbols = typeof Symbol === 'function' && (0, _typeof2.default)(Symbol('foo')) === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function isFunction(fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function arePropertyDescriptorsSupported() {
  var obj = {};

  try {
    origDefineProperty(obj, 'x', {
      enumerable: false,
      value: obj
    }); // eslint-disable-next-line no-unused-vars, no-restricted-syntax

    for (var _ in obj) {
      // jscs:ignore disallowUnusedVariables
      return false;
    }

    return obj.x === obj;
  } catch (e) {
    /* this is IE 8. */
    return false;
  }
};

var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();

var defineProperty = function defineProperty(object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }

  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value;
  }
};

var defineProperties = function defineProperties(object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);

  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }

  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;

var isArgs = __webpack_require__(356);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(615);
var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);

    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }

        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }

  return Object.keys || keysShim;
};

module.exports = keysShim;

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';

  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && (0, _typeof2.default)(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }

  return isArgs;
};

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(235);

var GetIntrinsic = __webpack_require__(358);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}

module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);

  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');

    if (desc.configurable) {
      // original length, plus the receiver, minus any additional arguments (after the receiver)
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }

  return func;
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals
	AggregateError,
	SharedArrayBuffer,
*/

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = __webpack_require__(617)();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : (0, _typeof2.default)(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(235);

var hasOwn = __webpack_require__(618);

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : (0, _typeof2.default)(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint complexity: [2, 18], max-statements: [2, 33] */

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if ((0, _typeof2.default)(Symbol.iterator) === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // modified from https://github.com/es-shims/es6-shim

var keys = __webpack_require__(355);

var canBeObject = function canBeObject(obj) {
  return typeof obj !== 'undefined' && obj !== null;
};

var hasSymbols = __webpack_require__(360)();

var callBound = __webpack_require__(619);

var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null; // eslint-disable-next-line no-unused-vars

module.exports = function assign(target, source1) {
  if (!canBeObject(target)) {
    throw new TypeError('target must be an object');
  }

  var objTarget = toObject(target);
  var s, source, i, props, syms, value, key;

  for (s = 1; s < arguments.length; ++s) {
    source = toObject(arguments[s]);
    props = keys(source);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);

    if (getSymbols) {
      syms = getSymbols(source);

      for (i = 0; i < syms.length; ++i) {
        key = syms[i];

        if ($propIsEnumerable(source, key)) {
          $push(props, key);
        }
      }
    }

    for (i = 0; i < props.length; ++i) {
      key = props[i];
      value = source[key];

      if ($propIsEnumerable(source, key)) {
        objTarget[key] = value;
      }
    }
  }

  return objTarget;
};

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(361);

var lacksProperEnumerationOrder = function lacksProperEnumerationOrder() {
  if (!Object.assign) {
    return false;
  }
  /*
   * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
   * note: this does not detect the bug unless there's 20 characters
   */


  var str = 'abcdefghijklmnopqrst';
  var letters = str.split('');
  var map = {};

  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }

  var obj = Object.assign({}, map);
  var actual = '';

  for (var k in obj) {
    actual += k;
  }

  return str !== actual;
};

var assignHasPendingExceptions = function assignHasPendingExceptions() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  /*
   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
   * which is 72% slower than our shim, and Firefox 40's native implementation.
   */


  var thrower = Object.preventExtensions({
    1: 2
  });

  try {
    Object.assign(thrower, 'xy');
  } catch (e) {
    return thrower[1] === 'y';
  }

  return false;
};

module.exports = function getPolyfill() {
  if (!Object.assign) {
    return implementation;
  }

  if (lacksProperEnumerationOrder()) {
    return implementation;
  }

  if (assignHasPendingExceptions()) {
    return implementation;
  }

  return Object.assign;
};

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var filter = function filter(arr, func) {
  if (!(0, _isArrayLike.default)(arr)) {
    return arr;
  }

  var result = [];

  for (var index = 0; index < arr.length; index++) {
    var value = arr[index];

    if (func(value, index)) {
      result.push(value);
    }
  }

  return result;
};

var _default = filter;
exports.default = _default;

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _keys2 = _interopRequireDefault(__webpack_require__(365));

function isMatch(obj, attrs) {
  var _keys = (0, _keys2.default)(attrs);

  var length = _keys.length;
  if ((0, _isNil.default)(obj)) return !length;

  for (var i = 0; i < length; i += 1) {
    var key = _keys[i];

    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }

  return true;
}

var _default = isMatch;
exports.default = _default;

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var keys = Object.keys ? function (obj) {
  return Object.keys(obj);
} : function (obj) {
  var result = [];
  (0, _each.default)(obj, function (value, key) {
    if (!((0, _isFunction.default)(obj) && key === 'prototype')) {
      result.push(key);
    }
  });
  return result;
};
var _default = keys;
exports.default = _default;

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var splice = Array.prototype.splice;

var pullAt = function pullAt(arr, indexes) {
  if (!(0, _isArrayLike.default)(arr)) {
    return [];
  }

  var length = arr ? indexes.length : 0;
  var last = length - 1;

  while (length--) {
    var previous = void 0;
    var index = indexes[length];

    if (length === last || index !== previous) {
      previous = index;
      splice.call(arr, index, 1);
    }
  }

  return arr;
};

var _default = pullAt;
exports.default = _default;

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _contains = _interopRequireDefault(__webpack_require__(174));

var _each = _interopRequireDefault(__webpack_require__(84));

var uniq = function uniq(arr) {
  var resultArr = [];
  (0, _each.default)(arr, function (item) {
    if (!(0, _contains.default)(resultArr, item)) {
      resultArr.push(item);
    }
  });
  return resultArr;
};

var _default = uniq;
exports.default = _default;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var _groupBy = _interopRequireDefault(__webpack_require__(369));

var groupToMap = function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }

  if (!(0, _isFunction.default)(condition)) {
    var paramsCondition_1 = (0, _isArray.default)(condition) ? condition : condition.replace(/\s+/g, '').split('*');

    condition = function condition(row) {
      var unique = '_'; // Key

      for (var i = 0, l = paramsCondition_1.length; i < l; i++) {
        unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();
      }

      return unique;
    };
  }

  var groups = (0, _groupBy.default)(data, condition);
  return groups;
};

var _default = groupToMap;
exports.default = _default;

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var hasOwnProperty = Object.prototype.hasOwnProperty;

function groupBy(data, condition) {
  if (!condition || !(0, _isArray.default)(data)) {
    return {};
  }

  var result = {}; //  

  var predicate = (0, _isFunction.default)(condition) ? condition : function (item) {
    return item[condition];
  };
  var key;

  for (var i = 0; i < data.length; i++) {
    var item = data[i];
    key = predicate(item);

    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }

  return result;
}

var _default = groupBy;
exports.default = _default;

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default(obj, key) {
  return obj.hasOwnProperty(key);
};

exports.default = _default;

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

// @ts-ignore
var values = Object.values ? function (obj) {
  return Object.values(obj);
} : function (obj) {
  var result = [];
  (0, _each.default)(obj, function (value, key) {
    if (!((0, _isFunction.default)(obj) && key === 'prototype')) {
      result.push(value);
    }
  });
  return result;
};
var _default = values;
exports.default = _default;

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var toString = {}.toString;

var getType = function getType(value) {
  return toString.call(value).replace(/^\[object /, '').replace(/]$/, '');
};

var _default = getType;
exports.default = _default;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var objectProto = Object.prototype;

var isPrototype = function isPrototype(value) {
  var Ctor = value && value.constructor;
  var proto = typeof Ctor === 'function' && Ctor.prototype || objectProto;
  return value === proto;
};

var _default = isPrototype;
exports.default = _default;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObjectLike = _interopRequireDefault(__webpack_require__(236));

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var _isString = _interopRequireDefault(__webpack_require__(101));

var isEqual = function isEqual(value, other) {
  if (value === other) {
    return true;
  }

  if (!value || !other) {
    return false;
  }

  if ((0, _isString.default)(value) || (0, _isString.default)(other)) {
    return false;
  }

  if ((0, _isArrayLike.default)(value) || (0, _isArrayLike.default)(other)) {
    if (value.length !== other.length) {
      return false;
    }

    var rst = true;

    for (var i = 0; i < value.length; i++) {
      rst = isEqual(value[i], other[i]);

      if (!rst) {
        break;
      }
    }

    return rst;
  }

  if ((0, _isObjectLike.default)(value) || (0, _isObjectLike.default)(other)) {
    var valueKeys = Object.keys(value);
    var otherKeys = Object.keys(other);

    if (valueKeys.length !== otherKeys.length) {
      return false;
    }

    var rst = true;

    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);

      if (!rst) {
        break;
      }
    }

    return rst;
  }

  return false;
};

var _default = isEqual;
exports.default = _default;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rectPath = exports.pathToCurve = exports.pathToAbsolute = exports.parsePathString = exports.parsePathArray = exports.intersection = exports.formatPath = exports.fillPathByDiff = exports.fillPath = exports.catmullRomToBezier = void 0;

var _util = __webpack_require__(0);

var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", 'ig');
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", 'ig'); // Parse given path string into an array of arrays of path segments

var parsePathString = function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }

  if ((0, _util.isArray)(pathString)) {
    return pathString;
  }

  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });

    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }

    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }

    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));

        if (!paramCounts[name]) {
          break;
        }
      }
    }

    return pathString;
  });
  return data;
}; // http://schepers.cc/getting-to-the-point


exports.parsePathString = parsePathString;

var catmullRomToBezier = function catmullRomToBezier(crp, z) {
  var d = []; // @ts-ignore

  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [{
      x: +crp[i - 2],
      y: +crp[i - 1]
    }, {
      x: +crp[i],
      y: +crp[i + 1]
    }, {
      x: +crp[i + 2],
      y: +crp[i + 3]
    }, {
      x: +crp[i + 4],
      y: +crp[i + 5]
    }];

    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }

    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
  }

  return d;
};

exports.catmullRomToBezier = catmullRomToBezier;

var ellipsePath = function ellipsePath(x, y, rx, ry, a) {
  var res = [];

  if (a === null && ry === null) {
    ry = rx;
  }

  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;

  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [['M', x1, y1], ['A', rx, rx, 0, +(a - ry > 180), 0, x2, y2]];
  } else {
    res = [['M', x, y], ['m', 0, -ry], ['a', rx, ry, 0, 1, 1, 0, 2 * ry], ['a', rx, ry, 0, 1, 1, 0, -2 * ry], ['z']];
  }

  return res;
};

var pathToAbsolute = function pathToAbsolute(pathArray) {
  pathArray = parsePathString(pathArray);

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;

  if (pathArray[0][0] === 'M') {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  var crz = pathArray.length === 3 && pathArray[0][0] === 'M' && pathArray[1][0].toUpperCase() === 'R' && pathArray[2][0].toUpperCase() === 'Z';

  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];

    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();

      switch (r[0]) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;

        case 'V':
          r[1] = +pa[1] + y;
          break;

        case 'H':
          r[1] = +pa[1] + x;
          break;

        case 'R':
          dots = [x, y].concat(pa.slice(1));

          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }

          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;

        case 'O':
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;

        case 'U':
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ['U'].concat(res[res.length - 1].slice(-2));
          break;

        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        // for lint

        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }

      }
    } else if (pa0 === 'R') {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ['R'].concat(pa.slice(-2));
    } else if (pa0 === 'O') {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === 'U') {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ['U'].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }

    pa0 = pa0.toUpperCase();

    if (pa0 !== 'O') {
      switch (r[0]) {
        case 'Z':
          x = +mx;
          y = +my;
          break;

        case 'H':
          x = r[1];
          break;

        case 'V':
          y = r[1];
          break;

        case 'M':
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        // for lint

        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }

  return res;
};

exports.pathToAbsolute = pathToAbsolute;

var l2c = function l2c(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};

var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;

  var _23 = 2 / 3;

  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};

var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  if (rx === ry) {
    rx += 1;
  }

  var _120 = Math.PI * 120 / 180;

  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;

  var rotate = function rotate(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return {
      x: X,
      y: Y
    };
  };

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    if (x1 === x2 && y1 === y2) {
      // 
      x2 += 1;
      y2 += 1;
    } // const cos = Math.cos(Math.PI / 180 * angle);
    // const sin = Math.sin(Math.PI / 180 * angle);


    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);

    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2; // @ts-ignore

    f1 = Math.asin(((y1 - cy) / ry).toFixed(9)); // @ts-ignore

    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }

    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  }

  res = [m2, m3, m4].concat(res).join().split(',');
  var newres = [];

  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
  }

  return newres;
};

var pathToCurve = function pathToCurve(path, path2) {
  var p = pathToAbsolute(path);
  var p2 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = []; // path commands of original path p

  var pcoms2 = []; // path commands of original path p2

  var pfirst = ''; // temporary holder for original path command

  var pcom = ''; // holder for previous path command of original path

  var ii;

  var processPath = function processPath(path, d, pcom) {
    var nx;
    var ny;

    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }

    !(path[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);

    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;

      case 'A':
        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
        break;

      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In "S" case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous

          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }

        path = ['C', nx, ny].concat(path.slice(1));
        break;

      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In "T" case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar

          d.qy = d.y * 2 - d.qy; // to case "S".
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }

        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
        break;

      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
        break;

      case 'L':
        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
        break;

      case 'H':
        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
        break;

      case 'V':
        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
        break;

      case 'Z':
        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
        break;

      default:
        break;
    }

    return path;
  };

  var fixArc = function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];

      while (pi.length) {
        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

        p2 && (pcoms2[i] = 'A'); // the same as above

        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
      }

      pp.splice(i, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  var fixM = function fixM(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
      path2.splice(i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  ii = Math.max(p.length, p2 && p2.length || 0);

  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]); // save current path command

    if (pfirst !== 'C') {
      // C is not saved yet, because it may be result of conversion
      pcoms1[i] = pfirst; // Save current path command

      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
    }

    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

    if (p2) {
      // the same procedures is done to p2
      p2[i] && (pfirst = p2[i][0]);

      if (pfirst !== 'C') {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }

      p2[i] = processPath(p2[i], attrs2, pcom);

      if (pcoms2[i] !== 'A' && pfirst === 'C') {
        pcoms2[i] = 'C';
      }

      fixArc(p2, i);
    }

    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }

  return p2 ? [p, p2] : p;
};

exports.pathToCurve = pathToCurve;
var p2s = /,?([a-z]),?/gi;

var parsePathArray = function parsePathArray(path) {
  return path.join(',').replace(p2s, '$1');
};

exports.parsePathArray = parsePathArray;

var base3 = function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};

var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }

  return z2 * sum;
};

var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;

  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (t > 0 && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    var t1 = (-b + sqrtb2ac) / (2 * a);

    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }

    var t2 = (-b - sqrtb2ac) / (2 * a);

    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length;
  var jlen = j;
  var mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};

var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);

  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }

  return {
    x: px,
    y: py
  };
};

var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};

var rectPath = function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }

  var res = [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']]; // @ts-ignore

  res.parsePathArray = parsePathArray;
  return res;
};

exports.rectPath = rectPath;

var box = function box(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }

  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    w: width,
    height: height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(' ')
  };
};

var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};

var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!(0, _util.isArray)(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }

  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};

var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

  return {
    x: x,
    y: y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha: alpha
  };
};

var interHelper = function interHelper(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }

  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }

  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }

        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            // @ts-ignore
            res += 1;
          } else {
            // @ts-ignore
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
};

var interPathHelper = function interPathHelper(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] === 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] === 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = interHelper(bez1, bez2, justCount);

          if (justCount) {
            // @ts-ignore
            res += intr;
          } else {
            // @ts-ignore
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            } // @ts-ignore


            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
};

var intersection = function intersection(path1, path2) {
  return interPathHelper(path1, path2);
};

exports.intersection = intersection;

function decasteljau(points, t) {
  var left = [];
  var right = [];

  function recurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var middlePoints = [];

      for (var i = 0; i < points.length - 1; i++) {
        if (i === 0) {
          left.push(points[0]);
        }

        if (i === points.length - 2) {
          right.push(points[i + 1]);
        }

        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }

      recurse(middlePoints, t);
    }
  }

  if (points.length) {
    recurse(points, t);
  }

  return {
    left: left,
    right: right.reverse()
  };
}

function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];

  if (end[0] === 'A') {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === 'C') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === 'S' || end[0] === 'Q') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }

  var leftSegments = points;
  var t = 1 / count;

  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }

  segments.push(leftSegments);
  var result = segments.map(function (segment) {
    var cmd = [];

    if (segment.length === 4) {
      cmd.push('C');
      cmd = cmd.concat(segment[2]);
    }

    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push('Q');
      }

      cmd = cmd.concat(segment[1]);
    }

    if (segment.length === 2) {
      cmd.push('L');
    }

    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}

var splitSegment = function splitSegment(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }

  var segments = [];

  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);

    if (temp[0] === 'M') {
      temp[0] = 'L';
    }

    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }

  return segments;
};

var fillPath = function fillPath(source, target) {
  if (source.length === 1) {
    return source;
  }

  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];

  if (source.length === 1 && source[0][0] === 'M') {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }

    return source;
  }

  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }

  var filled = segmentsToFill.reduce(function (filled, count, i) {
    if (i === sourceLen) {
      return filled.concat(source[sourceLen]);
    }

    return filled.concat(splitSegment(source[i], source[i + 1], count));
  }, []);
  filled.unshift(source[0]);

  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
    filled.push('Z');
  }

  return filled;
};

exports.fillPath = fillPath;

var isEqual = function isEqual(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }

  var result = true;
  (0, _util.each)(obj1, function (item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};

function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;

  if (add < min) {
    min = add;
    type = 'add';
  }

  if (del < min) {
    min = del;
    type = 'del';
  }

  return {
    type: type,
    min: min
  };
}
/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * path
 */


var levenshteinDistance = function levenshteinDistance(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;

  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }

  var dist = [];

  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = {
      min: i
    };
  }

  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = {
      min: j
    };
  }

  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];

    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];

      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }

      var del = dist[i - 1][j].min + 1;
      var add = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add, modify);
    }
  }

  return dist;
};

var fillPathByDiff = function fillPathByDiff(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1; // sourcetarget

  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    // sourcetarget
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;

      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }

      index = minPos;

      if (diffMatrix[i][index].type) {
        changes.push({
          index: i - 1,
          type: diffMatrix[i][index].type
        });
      }
    } // sourcepath


    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;

      if (changes[i].type === 'add') {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  } // source


  sourceLen = source.length;
  var diff = targetLen - sourceLen;

  if (sourceLen < targetLen) {
    for (var i = 0; i < diff; i++) {
      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }

      sourceLen += 1;
    }
  }

  return source;
}; // count


exports.fillPathByDiff = fillPathByDiff;

function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);

  var formerEnd = _getSegmentPoints(former)[0];

  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);

    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    }
  }

  return result;
}
/*
 * pathSegment
 * M,L,A,Q,H,V
 * Q, S
 * C
 */


function _getSegmentPoints(segment) {
  var points = [];

  switch (segment[0]) {
    case 'M':
      points.push([segment[1], segment[2]]);
      break;

    case 'L':
      points.push([segment[1], segment[2]]);
      break;

    case 'A':
      points.push([segment[6], segment[7]]);
      break;

    case 'Q':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'T':
      points.push([segment[1], segment[2]]);
      break;

    case 'C':
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;

    case 'S':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'H':
      points.push([segment[1], segment[1]]);
      break;

    case 'V':
      points.push([segment[1], segment[1]]);
      break;

    default:
  }

  return points;
}

var formatPath = function formatPath(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }

  var points;

  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      // fromPathpathSegmenttoPath
      points = _getSegmentPoints(fromPath[i]);

      switch (toPath[i][0]) {
        case 'M':
          fromPath[i] = ['M'].concat(points[0]);
          break;

        case 'L':
          fromPath[i] = ['L'].concat(points[0]);
          break;

        case 'A':
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;

        case 'Q':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'T':
          fromPath[i] = ['T'].concat(points[0]);
          break;

        case 'C':
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'S':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        default:
          fromPath[i] = toPath[i];
      }
    }
  }

  return fromPath;
};

exports.formatPath = formatPath;

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var GraphEvent =
/** @class */
function () {
  function GraphEvent(type, event) {
    /**
     * 
     * @type {boolean}
     */
    this.bubbles = true;
    /**
     * 
     * @type {object}
     */

    this.target = null;
    /**
     * 
     * @type {object}
     */

    this.currentTarget = null;
    /**
     * 
     * @type {object}
     */

    this.delegateTarget = null;
    /**
     *  ev.delegateObject = ev.currentTarget.get('delegateObject')
     * @type {object}
     */

    this.delegateObject = null;
    /**
     * 
     * @type {boolean}
     */

    this.defaultPrevented = false;
    /**
     * 
     * @type {boolean}
     */

    this.propagationStopped = false;
    /**
     * 
     * @type {IShape}
     */

    this.shape = null;
    /**
     * 
     * @type {IShape}
     */

    this.fromShape = null;
    /**
     * 
     * @type {IShape}
     */

    this.toShape = null; // 

    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  /**
   * 
   */


  GraphEvent.prototype.preventDefault = function () {
    this.defaultPrevented = true;

    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  /**
   * 
   */


  GraphEvent.prototype.stopPropagation = function () {
    this.propagationStopped = true;
  };

  GraphEvent.prototype.toString = function () {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };

  GraphEvent.prototype.save = function () {};

  GraphEvent.prototype.restore = function () {};

  return GraphEvent;
}();

var _default = GraphEvent;
exports.default = _default;

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _eventEmitter = _interopRequireDefault(__webpack_require__(125));

var _util = __webpack_require__(102);

var Base =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Base, _super);

  function Base(cfg) {
    var _this = _super.call(this) || this;
    /**
     * 
     * @type {boolean}
     */


    _this.destroyed = false;

    var defaultCfg = _this.getDefaultCfg();

    _this.cfg = (0, _util.mix)(defaultCfg, cfg);
    return _this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  Base.prototype.getDefaultCfg = function () {
    return {};
  }; // 


  Base.prototype.get = function (name) {
    return this.cfg[name];
  }; // 


  Base.prototype.set = function (name, value) {
    this.cfg[name] = value;
  }; // 


  Base.prototype.destroy = function () {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };

  return Base;
}(_eventEmitter.default);

var _default = Base;
exports.default = _default;

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _element = _interopRequireDefault(__webpack_require__(380));

var _util = __webpack_require__(102);

var SHAPE_MAP = {};
var INDEX = '_INDEX';
/**
 *  canvas
 * @param {IElement} element 
 * @param {ICanvas}  canvas  
 */

function setCanvas(element, canvas) {
  element.set('canvas', canvas);

  if (element.isGroup()) {
    var children = element.get('children');

    if (children.length) {
      children.forEach(function (child) {
        setCanvas(child, canvas);
      });
    }
  }
}
/**
 *  timeline
 * @param {IElement} element  
 * @param {Timeline} timeline 
 */


function setTimeline(element, timeline) {
  element.set('timeline', timeline);

  if (element.isGroup()) {
    var children = element.get('children');

    if (children.length) {
      children.forEach(function (child) {
        setTimeline(child, timeline);
      });
    }
  }
}

function contains(container, element) {
  var children = container.getChildren();
  return children.indexOf(element) >= 0;
}

function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  } //  element.remove() 


  if (destroy) {
    element.destroy();
  } else {
    element.set('parent', null);
    element.set('canvas', null);
  }

  (0, _util.removeFromArray)(container.getChildren(), element);
}

function getComparer(compare) {
  return function (left, right) {
    var result = compare(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}

var Container =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Container, _super);

  function Container() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Container.prototype.isCanvas = function () {
    return false;
  }; //  BBox


  Container.prototype.getBBox = function () {
    // 
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = []; // 

    var children = this.getChildren().filter(function (child) {
      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });

    if (children.length > 0) {
      (0, _util.each)(children, function (child) {
        var box = child.getBBox();
        xArr.push(box.minX, box.maxX);
        yArr.push(box.minY, box.maxY);
      });
      minX = Math.min.apply(null, xArr);
      maxX = Math.max.apply(null, xArr);
      minY = Math.min.apply(null, yArr);
      maxY = Math.max.apply(null, yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }

    var box = {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box;
  }; // 


  Container.prototype.getCanvasBBox = function () {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = []; // 

    var children = this.getChildren().filter(function (child) {
      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });

    if (children.length > 0) {
      (0, _util.each)(children, function (child) {
        var box = child.getCanvasBBox();
        xArr.push(box.minX, box.maxX);
        yArr.push(box.minY, box.maxY);
      });
      minX = Math.min.apply(null, xArr);
      maxX = Math.max.apply(null, xArr);
      minY = Math.min.apply(null, yArr);
      maxY = Math.max.apply(null, yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }

    var box = {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box;
  };

  Container.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    cfg['children'] = [];
    return cfg;
  };

  Container.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (name === 'matrix') {
      var totalMatrix = this.getTotalMatrix();

      this._applyChildrenMarix(totalMatrix);
    }
  }; // 


  Container.prototype.applyMatrix = function (matrix) {
    var preTotalMatrix = this.getTotalMatrix();

    _super.prototype.applyMatrix.call(this, matrix);

    var totalMatrix = this.getTotalMatrix(); // totalMatrix  null 
    // 

    if (totalMatrix === preTotalMatrix) {
      return;
    }

    this._applyChildrenMarix(totalMatrix);
  }; // 


  Container.prototype._applyChildrenMarix = function (totalMatrix) {
    var children = this.getChildren();
    (0, _util.each)(children, function (child) {
      child.applyMatrix(totalMatrix);
    });
  }; // 


  Container.prototype.addShape = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var type = args[0];
    var cfg = args[1];

    if ((0, _util.isObject)(type)) {
      cfg = type;
    } else {
      cfg['type'] = type;
    }

    var shapeType = SHAPE_MAP[cfg.type];

    if (!shapeType) {
      shapeType = (0, _util.upperFirst)(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }

    var ShapeBase = this.getShapeBase();
    var shape = new ShapeBase[shapeType](cfg);
    this.add(shape);
    return shape;
  };

  Container.prototype.addGroup = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var groupClass = args[0],
        cfg = args[1];
    var group;

    if ((0, _util.isFunction)(groupClass)) {
      if (cfg) {
        group = new groupClass(cfg);
      } else {
        group = new groupClass({
          // canvas,
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group = new TmpGroupClass(tmpCfg);
    }

    this.add(group);
    return group;
  };

  Container.prototype.getCanvas = function () {
    var canvas;

    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get('canvas');
    }

    return canvas;
  };

  Container.prototype.getShape = function (x, y, ev) {
    // 
    if (!(0, _util.isAllowCapture)(this)) {
      return null;
    }

    var children = this.getChildren();
    var shape; //  group

    if (!this.isCanvas()) {
      var v = [x, y, 1]; //  x, y  group 

      v = this.invertFromMatrix(v);

      if (!this.isClipped(v[0], v[1])) {
        shape = this._findShape(children, v[0], v[1], ev);
      }
    } else {
      shape = this._findShape(children, x, y, ev);
    }

    return shape;
  };

  Container.prototype._findShape = function (children, x, y, ev) {
    var shape = null;

    for (var i = children.length - 1; i >= 0; i--) {
      var child = children[i];

      if ((0, _util.isAllowCapture)(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x, y, ev);
        } else if (child.isHit(x, y)) {
          shape = child;
        }
      }

      if (shape) {
        break;
      }
    }

    return shape;
  };

  Container.prototype.add = function (element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get('timeline');
    var preParent = element.getParent();

    if (preParent) {
      removeChild(preParent, element, false);
    }

    element.set('parent', this);

    if (canvas) {
      setCanvas(element, canvas);
    }

    if (timeline) {
      setTimeline(element, timeline);
    }

    children.push(element);
    element.onCanvasChange('add');

    this._applyElementMatrix(element);
  }; // 


  Container.prototype._applyElementMatrix = function (element) {
    var totalMatrix = this.getTotalMatrix(); // 

    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };

  Container.prototype.getChildren = function () {
    return this.get('children');
  };

  Container.prototype.sort = function () {
    var children = this.getChildren(); // 

    (0, _util.each)(children, function (child, index) {
      child[INDEX] = index;
      return child;
    });
    children.sort(getComparer(function (obj1, obj2) {
      return obj1.get('zIndex') - obj2.get('zIndex');
    }));
    this.onCanvasChange('sort');
  };

  Container.prototype.clear = function () {
    this.set('clearing', true);

    if (this.destroyed) {
      return;
    }

    var children = this.getChildren();

    for (var i = children.length - 1; i >= 0; i--) {
      children[i].destroy(); // 
    }

    this.set('children', []);
    this.onCanvasChange('clear');
    this.set('clearing', false);
  };

  Container.prototype.destroy = function () {
    if (this.get('destroyed')) {
      return;
    }

    this.clear();

    _super.prototype.destroy.call(this);
  };
  /**
   * 
   * @return {IElement} 
   */


  Container.prototype.getFirst = function () {
    return this.getChildByIndex(0);
  };
  /**
   * 
   * @return {IElement} 
   */


  Container.prototype.getLast = function () {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  /**
   * 
   * @return {IElement} 
   */


  Container.prototype.getChildByIndex = function (index) {
    var children = this.getChildren();
    return children[index];
  };
  /**
   * 
   * @return {number} 
   */


  Container.prototype.getCount = function () {
    var children = this.getChildren();
    return children.length;
  };
  /**
   * 
   * @param {IElement} element 
   * @return {boolean}
   */


  Container.prototype.contain = function (element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  /**
   * 
   * @param {IElement} element 
   * @param {boolean} destroy  true
   */


  Container.prototype.removeChild = function (element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }

    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
  /**
   * 
   * @param  {ElementFilterFn}   fn  
   * @return {IElement[]} 
   */


  Container.prototype.findAll = function (fn) {
    var rst = [];
    var children = this.getChildren();
    (0, _util.each)(children, function (element) {
      if (fn(element)) {
        rst.push(element);
      }

      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn));
      }
    });
    return rst;
  };
  /**
   * 
   * @param  {ElementFilterFn} fn    
   * @return {IElement|null} 
   */


  Container.prototype.find = function (fn) {
    var rst = null;
    var children = this.getChildren();
    (0, _util.each)(children, function (element) {
      if (fn(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn);
      }

      if (rst) {
        return false;
      }
    });
    return rst;
  };
  /**
   *  ID 
   * @param {string} id  id
   * @return {IElement|null} 
   */


  Container.prototype.findById = function (id) {
    return this.find(function (element) {
      return element.get('id') === id;
    });
  };
  /**
   * 
   *  className 
   * TODO:  G6 3.3  G6  findByClassName G 
   * @param {string} className  className
   * @return {IElement | null} 
   */


  Container.prototype.findByClassName = function (className) {
    return this.find(function (element) {
      return element.get('className') === className;
    });
  };
  /**
   *  name 
   * @param {string}      name 
   * @return {IElement[]} 
   */


  Container.prototype.findAllByName = function (name) {
    return this.findAll(function (element) {
      return element.get('name') === name;
    });
  };

  return Container;
}(_element.default);

var _default = Container;
exports.default = _default;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _matrixUtil = __webpack_require__(33);

var _util2 = __webpack_require__(102);

var _matrix = __webpack_require__(240);

var _base = _interopRequireDefault(__webpack_require__(378));

var transform = _matrixUtil.ext.transform;
var MATRIX = 'matrix';
var CLONE_CFGS = ['zIndex', 'capture', 'visible', 'type']; //  toAttrs 

var RESERVED_PORPS = ['repeat'];
var DELEGATION_SPLIT = ':';
var WILDCARD = '*'; // 
// 

function _cloneArrayAttr(arr) {
  var result = [];

  for (var i = 0; i < arr.length; i++) {
    if ((0, _util.isArray)(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }

  return result;
}

function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;

  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }

  return fromAttrs;
}

function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  (0, _util.each)(props, function (v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !(0, _util.isEqual)(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}

function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }

  var startTime = animation.startTime,
      delay = animation.delay,
      duration = animation.duration;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  (0, _util.each)(animations, function (item) {
    //  <  &&  > 
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      (0, _util.each)(animation.toAttrs, function (v, k) {
        if (hasOwnProperty.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}

var Element =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Element, _super);

  function Element(cfg) {
    var _this = _super.call(this, cfg) || this;
    /**
     * @protected
     * 
     * @type {ShapeAttrs}
     */


    _this.attrs = {};

    var attrs = _this.getDefaultAttrs();

    (0, _util.mix)(attrs, cfg.attrs);
    _this.attrs = attrs;

    _this.initAttrs(attrs);

    _this.initAnimate(); // 


    return _this;
  } // override


  Element.prototype.getDefaultCfg = function () {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  /**
   * @protected
   * 
   */


  Element.prototype.getDefaultAttrs = function () {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  /**
   * @protected
   * 
   * @param {ChangeType} changeType 
   */


  Element.prototype.onCanvasChange = function (changeType) {};
  /**
   * @protected
   * 
   * @param {object} attrs 
   */


  Element.prototype.initAttrs = function (attrs) {};
  /**
   * @protected
   * 
   */


  Element.prototype.initAnimate = function () {
    this.set('animable', true);
    this.set('animating', false);
  };

  Element.prototype.isGroup = function () {
    return false;
  };

  Element.prototype.getParent = function () {
    return this.get('parent');
  };

  Element.prototype.getCanvas = function () {
    return this.get('canvas');
  };

  Element.prototype.attr = function () {
    var _a;

    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var name = args[0],
        value = args[1];
    if (!name) return this.attrs;

    if ((0, _util.isObject)(name)) {
      for (var k in name) {
        this.setAttr(k, name[k]);
      }

      this.afterAttrsChange(name);
      return this;
    }

    if (args.length === 2) {
      this.setAttr(name, value);
      this.afterAttrsChange((_a = {}, _a[name] = value, _a));
      return this;
    }

    return this.attrs[name];
  }; // 


  Element.prototype.isClipped = function (refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  /**
   * 
   * @param {string} name 
   * @param {any} value 
   */


  Element.prototype.setAttr = function (name, value) {
    var originValue = this.attrs[name];

    if (originValue !== value) {
      this.attrs[name] = value;
      this.onAttrChange(name, value, originValue);
    }
  };
  /**
   * @protected
   * 
   * @param {string} name 
   * @param {any} value 
   * @param {any} originValue 
   */


  Element.prototype.onAttrChange = function (name, value, originValue) {
    if (name === 'matrix') {
      this.set('totalMatrix', null);
    }
  };
  /**
   * 
   * @protected
   */


  Element.prototype.afterAttrsChange = function (targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;

      if (applyTo) {
        applyTo.onCanvasChange('clip');
      }
    } else {
      this.onCanvasChange('attr');
    }
  };

  Element.prototype.show = function () {
    //  set
    this.set('visible', true);
    this.onCanvasChange('show');
    return this;
  };

  Element.prototype.hide = function () {
    //  set
    this.set('visible', false);
    this.onCanvasChange('hide');
    return this;
  };

  Element.prototype.setZIndex = function (zIndex) {
    this.set('zIndex', zIndex);
    var parent = this.getParent();

    if (parent) {
      //  zIndex  ( onCanvasChange('zIndex')) sort 
      parent.sort();
    }

    return this;
  };

  Element.prototype.toFront = function () {
    var parent = this.getParent();

    if (!parent) {
      return;
    }

    var children = parent.getChildren();
    var el = this.get('el');
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.push(this);
    this.onCanvasChange('zIndex');
  };

  Element.prototype.toBack = function () {
    var parent = this.getParent();

    if (!parent) {
      return;
    }

    var children = parent.getChildren();
    var el = this.get('el');
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.unshift(this);
    this.onCanvasChange('zIndex');
  };

  Element.prototype.remove = function (destroy) {
    if (destroy === void 0) {
      destroy = true;
    }

    var parent = this.getParent();

    if (parent) {
      (0, _util2.removeFromArray)(parent.getChildren(), this);

      if (!parent.get('clearing')) {
        //  remove
        this.onCanvasChange('remove');
      }
    } else {
      this.onCanvasChange('remove');
    }

    if (destroy) {
      this.destroy();
    }
  };

  Element.prototype.resetMatrix = function () {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange('matrix');
  };

  Element.prototype.getMatrix = function () {
    return this.attr(MATRIX);
  };

  Element.prototype.setMatrix = function (m) {
    this.attr(MATRIX, m);
    this.onCanvasChange('matrix');
  }; //  matrix


  Element.prototype.getTotalMatrix = function () {
    var totalMatrix = this.cfg.totalMatrix;

    if (!totalMatrix) {
      var currentMatrix = this.attr('matrix');
      var parentMatrix = this.cfg.parentMatrix;

      if (parentMatrix && currentMatrix) {
        totalMatrix = (0, _matrix.multiplyMatrix)(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }

      this.set('totalMatrix', totalMatrix);
    }

    return totalMatrix;
  }; //  matrix


  Element.prototype.applyMatrix = function (matrix) {
    var currentMatrix = this.attr('matrix');
    var totalMatrix = null;

    if (matrix && currentMatrix) {
      totalMatrix = (0, _matrix.multiplyMatrix)(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }

    this.set('totalMatrix', totalMatrix);
    this.set('parentMatrix', matrix);
  };
  /**
   * @protected
   * 
   * @returns {number[]|null} 
   */


  Element.prototype.getDefaultMatrix = function () {
    return null;
  }; // 


  Element.prototype.applyToMatrix = function (v) {
    var matrix = this.attr('matrix');

    if (matrix) {
      return (0, _matrix.multiplyVec2)(matrix, v);
    }

    return v;
  }; // /


  Element.prototype.invertFromMatrix = function (v) {
    var matrix = this.attr('matrix');

    if (matrix) {
      var invertMatrix = (0, _matrix.invert)(matrix);

      if (invertMatrix) {
        return (0, _matrix.multiplyVec2)(invertMatrix, v);
      }
    }

    return v;
  }; //  clip


  Element.prototype.setClip = function (clipCfg) {
    var canvas = this.getCanvas(); //  clip clip  clip 
    // TODO: setClip  shape  shape 
    // const preShape = this.get('clipShape');
    // if (preShape) {
    //   //  clipShape 
    //   preShape.destroy();
    // }

    var clipShape = null; //  null clipShape

    if (clipCfg) {
      var ShapeBase = this.getShapeBase();
      var shapeType = (0, _util.upperFirst)(clipCfg.type);
      var Cons = ShapeBase[shapeType];

      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas: canvas
        });
      }
    }

    this.set('clipShape', clipShape);
    this.onCanvasChange('clip');
    return clipShape;
  };

  Element.prototype.getClip = function () {
    //  this.cfg.xxx
    var clipShape = this.cfg.clipShape; //  Null

    if (!clipShape) {
      return null;
    }

    return clipShape;
  };

  Element.prototype.clone = function () {
    var _this = this;

    var originAttrs = this.attrs;
    var attrs = {};
    (0, _util.each)(originAttrs, function (i, k) {
      if ((0, _util.isArray)(originAttrs[k])) {
        attrs[k] = _cloneArrayAttr(originAttrs[k]);
      } else {
        attrs[k] = originAttrs[k];
      }
    });
    var cons = this.constructor; // @ts-ignore

    var clone = new cons({
      attrs: attrs
    });
    (0, _util.each)(CLONE_CFGS, function (cfgName) {
      clone.set(cfgName, _this.get(cfgName));
    });
    return clone;
  };

  Element.prototype.destroy = function () {
    var destroyed = this.destroyed;

    if (destroyed) {
      return;
    }

    this.attrs = {};

    _super.prototype.destroy.call(this); // this.onCanvasChange('destroy');

  };
  /**
   * 
   * @return {boolean} 
   */


  Element.prototype.isAnimatePaused = function () {
    return this.get('_pause').isPaused;
  };
  /**
   * 
   * 1. animate(toAttrs: ElementAttrs, duration: number, easing?: string, callback?: () => void, delay?: number)
   * 2. animate(onFrame: OnFrame, duration: number, easing?: string, callback?: () => void, delay?: number)
   * 3. animate(toAttrs: ElementAttrs, cfg: AnimateCfg)
   * 4. animate(onFrame: OnFrame, cfg: AnimateCfg)
   * :
   *   toAttrs  
   *   onFrame  
   *   duration 
   *   easing   
   *   callback 
   *   delay    
   */


  Element.prototype.animate = function () {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var isCanvas = this.isCanvas && this.isCanvas();

    if (!isCanvas && !this.get('canvas')) {
      return;
    }

    this.set('animating', true);
    var timeline = this.get('timeline');

    if (!timeline) {
      timeline = this.get('canvas').get('timeline');
      this.set('timeline', timeline);
    }

    var animations = this.get('animations') || []; //  tick

    if (!timeline.timer) {
      timeline.initTimer();
    }

    var toAttrs = args[0],
        duration = args[1],
        _a = args[2],
        easing = _a === void 0 ? 'easeLinear' : _a,
        _b = args[3],
        callback = _b === void 0 ? _util.noop : _b,
        _c = args[4],
        delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg; //  toAttrs onFrame

    if ((0, _util.isFunction)(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if ((0, _util.isObject)(toAttrs) && toAttrs.onFrame) {
      //  3.0 onFrame  repeat  toAttrs 
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    } //  duration animateCfg


    if ((0, _util.isObject)(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || 'easeLinear';
      delay = animateCfg.delay || 0; // animateCfg 

      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || _util.noop;
      pauseCallback = animateCfg.pauseCallback || _util.noop;
      resumeCallback = animateCfg.resumeCallback || _util.noop;
    } else {
      //  callback delay
      if ((0, _util.isNumber)(callback)) {
        delay = callback;
        callback = null;
      } //  easing callback


      if ((0, _util.isFunction)(easing)) {
        callback = easing;
        easing = 'easeLinear';
      } else {
        easing = easing || 'easeLinear';
      }
    }

    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration: duration,
      easing: easing,
      repeat: repeat,
      callback: callback,
      pauseCallback: pauseCallback,
      resumeCallback: resumeCallback,
      delay: delay,
      startTime: timeline.getTime(),
      id: (0, _util.uniqueId)(),
      onFrame: onFrame,
      pathFormatted: false
    }; // 

    if (animations.length > 0) {
      // ,
      animations = checkExistedAttrs(animations, animation);
    } else {
      // 
      timeline.addAnimator(this);
    }

    animations.push(animation);
    this.set('animations', animations);
    this.set('_pause', {
      isPaused: false
    });
  };
  /**
   * 
   * @param {boolean} toEnd 
   */


  Element.prototype.stopAnimate = function (toEnd) {
    var _this = this;

    if (toEnd === void 0) {
      toEnd = true;
    }

    var animations = this.get('animations');
    (0, _util.each)(animations, function (animation) {
      // 
      if (toEnd) {
        if (animation.onFrame) {
          _this.attr(animation.onFrame(1));
        } else {
          _this.attr(animation.toAttrs);
        }
      }

      if (animation.callback) {
        // 
        animation.callback();
      }
    });
    this.set('animating', false);
    this.set('animations', []);
  };
  /**
   * 
   */


  Element.prototype.pauseAnimate = function () {
    var timeline = this.get('timeline');
    var animations = this.get('animations');
    var pauseTime = timeline.getTime();
    (0, _util.each)(animations, function (animation) {
      animation._paused = true;
      animation._pauseTime = pauseTime;

      if (animation.pauseCallback) {
        // 
        animation.pauseCallback();
      }
    }); // 

    this.set('_pause', {
      isPaused: true,
      pauseTime: pauseTime
    });
    return this;
  };
  /**
   * 
   */


  Element.prototype.resumeAnimate = function () {
    var timeline = this.get('timeline');
    var current = timeline.getTime();
    var animations = this.get('animations');
    var pauseTime = this.get('_pause').pauseTime; // 

    (0, _util.each)(animations, function (animation) {
      animation.startTime = animation.startTime + (current - pauseTime);
      animation._paused = false;
      animation._pauseTime = null;

      if (animation.resumeCallback) {
        animation.resumeCallback();
      }
    });
    this.set('_pause', {
      isPaused: false
    });
    this.set('animations', animations);
    return this;
  };
  /**
   * 
   * @param  {string}     type 
   * @param  {GraphEvent} eventObj 
   */


  Element.prototype.emitDelegation = function (type, eventObj) {
    var _this = this;

    var paths = eventObj.propagationPath;
    var events = this.getEvents();
    var relativeShape;

    if (type === 'mouseenter') {
      relativeShape = eventObj.fromShape;
    } else if (type === 'mouseleave') {
      relativeShape = eventObj.toShape;
    }

    var _loop_1 = function _loop_1(i) {
      var element = paths[i]; //  name 

      var name_1 = element.get('name');

      if (name_1) {
        //  mouseenter  mouseleave  Parent
        if ( //  element  Group  Canvas  isParent
        (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && (0, _util2.isParent)(element, relativeShape)) {
          return "break";
        }

        if ((0, _util.isArray)(name_1)) {
          (0, _util.each)(name_1, function (subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };

    var this_1 = this; //  shape

    for (var i = 0; i < paths.length; i++) {
      var state_1 = _loop_1(i);

      if (state_1 === "break") break;
    }
  };

  Element.prototype.emitDelegateEvent = function (element, name, eventObj) {
    var events = this.getEvents(); //  name:type

    var eventName = name + DELEGATION_SPLIT + eventObj.type;

    if (events[eventName] || events[WILDCARD]) {
      //  * = 
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this; //  delegateObject 

      eventObj.delegateObject = element.get('delegateObject');
      this.emit(eventName, eventObj);
    }
  };
  /**
   * 
   * @param {number} translateX 
   * @param {number} translateY 
   * @return {IElement} 
   */


  Element.prototype.translate = function (translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }

    if (translateY === void 0) {
      translateY = 0;
    }

    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  /**
   * 
   * @param {number} targetX 
   * @param {number} targetX 
   * @return {IElement} 
   */


  Element.prototype.move = function (targetX, targetY) {
    var x = this.attr('x') || 0;
    var y = this.attr('y') || 0;
    this.translate(targetX - x, targetY - y);
    return this;
  };
  /**
   *  move  moveTo  moveTo 
   * @param {number} targetX  x 
   * @param {number} targetY  y 
   * @return {IElement} 
   */


  Element.prototype.moveTo = function (targetX, targetY) {
    return this.move(targetX, targetY);
  };
  /**
   * 
   * @param {number} ratioX 
   * @param {number} ratioY 
   * @return {IElement} 
   */


  Element.prototype.scale = function (ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['s', ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  /**
   *  (0, 0) 
   * @param {number} radian ()
   * @return {IElement} 
   */


  Element.prototype.rotate = function (radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['r', radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  /**
   * 
   * @param {number} radian ()
   * @return {IElement} 
   */


  Element.prototype.rotateAtStart = function (rotate) {
    var _a = this.attr(),
        x = _a.x,
        y = _a.y;

    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);
    this.setMatrix(newMatrix);
    return this;
  };
  /**
   *  (x, y) 
   * @param {number} radian ()
   * @return {IElement} 
   */


  Element.prototype.rotateAtPoint = function (x, y, rotate) {
    var matrix = this.getMatrix();
    var newMatrix = transform(matrix, [['t', -x, -y], ['r', rotate], ['t', x, y]]);
    this.setMatrix(newMatrix);
    return this;
  };

  return Element;
}(_base.default);

var _default = Element;
exports.default = _default;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vec4 = exports.vec3 = exports.vec2 = exports.quat2 = exports.quat = exports.mat4 = exports.mat3 = exports.mat2d = exports.mat2 = exports.glMatrix = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

exports.glMatrix = glMatrix;

var mat2 = _interopRequireWildcard(__webpack_require__(704));

exports.mat2 = mat2;

var mat2d = _interopRequireWildcard(__webpack_require__(705));

exports.mat2d = mat2d;

var mat3 = _interopRequireWildcard(__webpack_require__(382));

exports.mat3 = mat3;

var mat4 = _interopRequireWildcard(__webpack_require__(383));

exports.mat4 = mat4;

var quat = _interopRequireWildcard(__webpack_require__(384));

exports.quat = quat;

var quat2 = _interopRequireWildcard(__webpack_require__(706));

exports.quat2 = quat2;

var vec2 = _interopRequireWildcard(__webpack_require__(386));

exports.vec2 = vec2;

var vec3 = _interopRequireWildcard(__webpack_require__(176));

exports.vec3 = vec3;

var vec4 = _interopRequireWildcard(__webpack_require__(385));

exports.vec4 = vec4;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.fromMat4 = fromMat4;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.rotate = rotate;
exports.scale = scale;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromMat2d = fromMat2d;
exports.fromQuat = fromQuat;
exports.normalFromMat4 = normalFromMat4;
exports.projection = projection;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(9);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */


function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */


function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new glMatrix.ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */


function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */


function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/


function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */


function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */


function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.fromValues = fromValues;
exports.set = set;
exports.identity = identity;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.translate = translate;
exports.scale = scale;
exports.rotate = rotate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.fromTranslation = fromTranslation;
exports.fromScaling = fromScaling;
exports.fromRotation = fromRotation;
exports.fromXRotation = fromXRotation;
exports.fromYRotation = fromYRotation;
exports.fromZRotation = fromZRotation;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromQuat2 = fromQuat2;
exports.getTranslation = getTranslation;
exports.getScaling = getScaling;
exports.getRotation = getRotation;
exports.fromRotationTranslationScale = fromRotationTranslationScale;
exports.fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin;
exports.fromQuat = fromQuat;
exports.frustum = frustum;
exports.perspective = perspective;
exports.perspectiveFromFieldOfView = perspectiveFromFieldOfView;
exports.ortho = ortho;
exports.lookAt = lookAt;
exports.targetTo = targetTo;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(16);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */


function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new glMatrix.ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */


function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */


function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */


function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/


function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */


function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < glMatrix.EPSILON) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */


function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */


function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */


function fromQuat2(out, a) {
  var translation = new glMatrix.ARRAY_TYPE(3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */


function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */


function getRotation(out, mat) {
  var scaling = new glMatrix.ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */


function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */


function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */


function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */


function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */


function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */


function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < glMatrix.EPSILON && Math.abs(eyey - centery) < glMatrix.EPSILON && Math.abs(eyez - centerz) < glMatrix.EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */


function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.identity = identity;
exports.setAxisAngle = setAxisAngle;
exports.getAxisAngle = getAxisAngle;
exports.getAngle = getAngle;
exports.multiply = multiply;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.calculateW = calculateW;
exports.exp = exp;
exports.ln = ln;
exports.pow = pow;
exports.slerp = slerp;
exports.random = random;
exports.invert = invert;
exports.conjugate = conjugate;
exports.fromMat3 = fromMat3;
exports.fromEuler = fromEuler;
exports.str = str;
exports.setAxes = exports.sqlerp = exports.rotationTo = exports.equals = exports.exactEquals = exports.normalize = exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.lerp = exports.dot = exports.scale = exports.mul = exports.add = exports.set = exports.copy = exports.fromValues = exports.clone = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

var mat3 = _interopRequireWildcard(__webpack_require__(382));

var vec3 = _interopRequireWildcard(__webpack_require__(176));

var vec4 = _interopRequireWildcard(__webpack_require__(385));

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/


function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */


function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > glMatrix.EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */


function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */


function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */


function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */


function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */


function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */


function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > glMatrix.EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */


function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = glMatrix.RANDOM();
  var u2 = glMatrix.RANDOM();
  var u3 = glMatrix.RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */


function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */


function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */


var clone = vec4.clone;
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

exports.clone = clone;
var fromValues = vec4.fromValues;
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

exports.fromValues = fromValues;
var copy = vec4.copy;
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

exports.copy = copy;
var set = vec4.set;
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

exports.set = set;
var add = vec4.add;
/**
 * Alias for {@link quat.multiply}
 * @function
 */

exports.add = add;
var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

exports.mul = mul;
var scale = vec4.scale;
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

exports.scale = scale;
var dot = vec4.dot;
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

exports.dot = dot;
var lerp = vec4.lerp;
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

exports.lerp = lerp;
var length = vec4.length;
/**
 * Alias for {@link quat.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = vec4.squaredLength;
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

exports.sqrLen = sqrLen;
var normalize = vec4.normalize;
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.normalize = normalize;
var exactEquals = vec4.exactEquals;
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

exports.exactEquals = exactEquals;
var equals = vec4.equals;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

exports.equals = equals;

var rotationTo = function () {
  var tmpvec3 = vec3.create();
  var xUnitVec3 = vec3.fromValues(1, 0, 0);
  var yUnitVec3 = vec3.fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot = vec3.dot(a, b);

    if (dot < -0.999999) {
      vec3.cross(tmpvec3, xUnitVec3, a);
      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);
      vec3.normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      vec3.cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */


exports.rotationTo = rotationTo;

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */


exports.sqlerp = sqlerp;

var setAxes = function () {
  var matr = mat3.create();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

exports.setAxes = setAxes;

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat4 = transformMat4;
exports.transformQuat = transformQuat;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.len = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */


function fromValues(x, y, z, w) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */


function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */


function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */


function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */


function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */


function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = glMatrix.RANDOM() * 2 - 1;
    v2 = glMatrix.RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = glMatrix.RANDOM() * 2 - 1;
    v4 = glMatrix.RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */


function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */


function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */


var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

exports.sqrDist = sqrDist;
var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

exports.len = len;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

exports.forEach = forEach;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.copy = copy;
exports.set = set;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.ceil = ceil;
exports.floor = floor;
exports.min = min;
exports.max = max;
exports.round = round;
exports.scale = scale;
exports.scaleAndAdd = scaleAndAdd;
exports.distance = distance;
exports.squaredDistance = squaredDistance;
exports.length = length;
exports.squaredLength = squaredLength;
exports.negate = negate;
exports.inverse = inverse;
exports.normalize = normalize;
exports.dot = dot;
exports.cross = cross;
exports.lerp = lerp;
exports.random = random;
exports.transformMat2 = transformMat2;
exports.transformMat2d = transformMat2d;
exports.transformMat3 = transformMat3;
exports.transformMat4 = transformMat4;
exports.rotate = rotate;
exports.angle = angle;
exports.zero = zero;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.forEach = exports.sqrLen = exports.sqrDist = exports.dist = exports.div = exports.mul = exports.sub = exports.len = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(2);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */


function fromValues(x, y) {
  var out = new glMatrix.ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */


function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */


function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */


function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */


function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */


function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */


function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */


function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */


function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */


function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */


function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */


function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */


function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */


function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */


function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */


function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */


function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */


function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */


function random(out, scale) {
  scale = scale || 1.0;
  var r = glMatrix.RANDOM() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */


function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */


function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */


function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */


function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */


function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */


var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

exports.len = len;
var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

exports.sub = sub;
var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

exports.mul = mul;
var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

exports.div = div;
var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

exports.dist = dist;
var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

exports.sqrDist = sqrDist;
var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

exports.sqrLen = sqrLen;

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

exports.forEach = forEach;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tpmt = tpmt;

// tpmt is two power minus ten times t scaled to [0,1]
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
}

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rad2deg = exports.deg2rad = void 0;
var deg2rad = Math.PI / 180;
exports.deg2rad = deg2rad;
var rad2deg = 180 / Math.PI;
exports.rad2deg = rad2deg;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbBasisClosed = exports.rgbBasis = exports.default = void 0;

var _d3Color = __webpack_require__(61);

var _basis = _interopRequireDefault(__webpack_require__(245));

var _basisClosed = _interopRequireDefault(__webpack_require__(390));

var _color = _interopRequireWildcard(__webpack_require__(110));

var _default = function rgbGamma(y) {
  var color = (0, _color.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0, _d3Color.rgb)(start)).r, (end = (0, _d3Color.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;
  return rgb;
}(1);

exports.default = _default;

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = (0, _d3Color.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis.default);
exports.rgbBasis = rgbBasis;
var rgbBasisClosed = rgbSpline(_basisClosed.default);
exports.rgbBasisClosed = rgbBasisClosed;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = __webpack_require__(245);

function _default(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0, _basis.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function () {
    return x;
  };
}

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.genericArray = genericArray;

var _value = _interopRequireDefault(__webpack_require__(242));

var _numberArray = _interopRequireWildcard(__webpack_require__(246));

function _default(a, b) {
  return ((0, _numberArray.isNumberArray)(b) ? _numberArray.default : genericArray)(a, b);
}

function genericArray(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) {
    x[i] = (0, _value.default)(a[i], b[i]);
  }

  for (; i < nb; ++i) {
    c[i] = b[i];
  }

  return function (t) {
    for (i = 0; i < na; ++i) {
      c[i] = x[i](t);
    }

    return c;
  };
}

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  var d = new Date();
  return a = +a, b = +b, function (t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _value = _interopRequireDefault(__webpack_require__(242));

function _default(a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || (0, _typeof2.default)(a) !== "object") a = {};
  if (b === null || (0, _typeof2.default)(b) !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0, _value.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) {
      c[k] = i[k](t);
    }

    return c;
  };
}

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(__webpack_require__(177));

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

function _default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0, _number.default)(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) {
      s[(o = q[i]).i] = o.x(t);
    }

    return s.join("");
  });
}

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nearestPoint = nearestPoint;
exports.snapLength = snapLength;

var _util = __webpack_require__(86);

var EPSILON = 0.0001;
/**
 * 
 * @param {number[]} xArr       x 
 * @param {number[]} yArr       y 
 * @param {number}   x          x
 * @param {number}   y          y
 * @param {Function} tCallback 
 */

function nearestPoint(xArr, yArr, x, y, tCallback, length) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;

  if (length && length > 200) {
    segNum = length / 10;
  }

  var increaseRate = 1 / segNum;
  var interval = increaseRate / 10;

  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;

    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = (0, _util.distance)(v0[0], v0[1], v1[0], v1[1]);

    if (d1 < d) {
      t = _t;
      d = d1;
    }
  } // 


  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }

  if (t === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }

  d = Infinity;

  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON) {
      break;
    }

    var prev = t - interval;
    var next = t + interval;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = (0, _util.distance)(v0[0], v0[1], v1[0], v1[1]);

    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = (0, _util.distance)(v0[0], v0[1], v2[0], v2[1]);

      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }

  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
} //  https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2


function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;

  for (var i = 0; i < count; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count];
    var nextY = yArr[(i + 1) % count];
    totalLength += (0, _util.distance)(x, y, nextX, nextY);
  }

  return totalLength / 2;
}

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lengthOfSegment = lengthOfSegment;
exports.pointAtSegments = pointAtSegments;
exports.angleAtSegments = angleAtSegments;
exports.distanceAtSegment = distanceAtSegment;

var _line = _interopRequireDefault(__webpack_require__(178));

var _util = __webpack_require__(86);

function analyzePoints(points) {
  // 
  var totalLength = 0;
  var segments = [];

  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    var length_1 = (0, _util.distance)(from[0], from[1], to[0], to[1]);
    var seg = {
      from: from,
      to: to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }

  return {
    segments: segments,
    totalLength: totalLength
  };
}

function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }

  var totalLength = 0;

  for (var i = 0; i < points.length - 1; i++) {
    var from = points[i];
    var to = points[i + 1];
    totalLength += (0, _util.distance)(from[0], from[1], to[0], to[1]);
  }

  return totalLength;
}
/**
 * 
 * @param {array} points 
 * @param {number} t  0-1
 * @return {object} 
 */


function pointAtSegments(points, t) {
  // 
  if (t > 1 || t < 0 || points.length < 2) {
    return null;
  }

  var _a = analyzePoints(points),
      segments = _a.segments,
      totalLength = _a.totalLength; // 


  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  } // 


  var startRatio = 0;
  var point = null;

  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from,
        to = seg.to;
    var currentRatio = seg.length / totalLength;

    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point = _line.default.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }

    startRatio += currentRatio;
  }

  return point;
}
/**
 * 
 * @param {array} points 
 * @param {number} t  0-1
 */


function angleAtSegments(points, t) {
  // 
  if (t > 1 || t < 0 || points.length < 2) {
    return 0;
  }

  var _a = analyzePoints(points),
      segments = _a.segments,
      totalLength = _a.totalLength; // 


  var startRatio = 0;
  var angle = 0;

  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from,
        to = seg.to;
    var currentRatio = seg.length / totalLength;

    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }

    startRatio += currentRatio;
  }

  return angle;
}

function distanceAtSegment(points, x, y) {
  var minDistance = Infinity;

  for (var i = 0; i < points.length - 1; i++) {
    var point = points[i];
    var nextPoint = points[i + 1];

    var distance_1 = _line.default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x, y);

    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }

  return minDistance;
}

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _segments = __webpack_require__(397);

var _util = __webpack_require__(86);

var _default = {
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  box: function box(points) {
    var xArr = [];
    var yArr = [];

    for (var i = 0; i < points.length; i++) {
      var point = points[i];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }

    return (0, _util.getBBoxByArray)(xArr, yArr);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  length: function length(points) {
    return (0, _segments.lengthOfSegment)(points);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  pointAt: function pointAt(points, t) {
    return (0, _segments.pointAtSegments)(points, t);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} x  x
   * @param {number} y  y
   * @return {number} 
   */
  pointDistance: function pointDistance(points, x, y) {
    return (0, _segments.distanceAtSegment)(points, x, y);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  tangentAngle: function tangentAngle(points, t) {
    return (0, _segments.angleAtSegments)(points, t);
  }
};
exports.default = _default;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTextHeight = getTextHeight;
exports.getLineSpaceing = getLineSpaceing;
exports.getTextWidth = getTextWidth;
exports.assembleFont = assembleFont;

var _util = __webpack_require__(102);

var _offscreen = __webpack_require__(400);

/**
 * 
 * @param text 
 * @param fontSize 
 * @param lineHeight 
 */
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;

  if ((0, _util.isString)(text)) {
    lineCount = text.split('\n').length;
  }

  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }

  return fontSize;
}
/**
 * 
 * @param fontSize 
 * @param lineHeight 
 */


function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
/**
 * 
 * @param text 
 * @param font 
 */


function getTextWidth(text, font) {
  var context = (0, _offscreen.getOffScreenContext)(); //  ctx 

  var width = 0; // null  undefined  0

  if ((0, _util.isNil)(text) || text === '') {
    return width;
  }

  context.save();
  context.font = font;

  if ((0, _util.isString)(text) && text.includes('\n')) {
    var textArr = text.split('\n');
    (0, _util.each)(textArr, function (subText) {
      var measureWidth = context.measureText(subText).width;

      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }

  context.restore();
  return width;
}

function assembleFont(attrs) {
  var fontSize = attrs.fontSize,
      fontFamily = attrs.fontFamily,
      fontWeight = attrs.fontWeight,
      fontStyle = attrs.fontStyle,
      fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ').trim();
}

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOffScreenContext = getOffScreenContext;
//  ctx isPointInPath
var offScreenCtx = null;

function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext('2d');
  }

  return offScreenCtx;
}

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;

function parsePath(p) {
  var path = p || [];

  if ((0, _util.isArray)(path)) {
    return path;
  }

  if ((0, _util.isString)(path)) {
    path = path.match(regexTags);
    (0, _util.each)(path, function (item, index) {
      // @ts-ignore
      item = item.match(regexDot);

      if (item[0].length > 1) {
        var tag = item[0].charAt(0); // @ts-ignore

        item.splice(1, 0, item[0].substr(1)); // @ts-ignore

        item[0] = tag;
      } // @ts-ignore


      (0, _util.each)(item, function (sub, i) {
        if (!isNaN(sub)) {
          // @ts-ignore
          item[i] = +sub;
        }
      }); // @ts-ignore

      path[index] = item;
    });
    return path;
  }
}

var _default = parsePath;
exports.default = _default;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rectPath;

function rectPath(x, y, w, h, r) {
  if (r) {
    return [['M', +x + +r, y], ['l', w - r * 2, 0], ['a', r, r, 0, 0, 1, r, r], ['l', 0, h - r * 2], ['a', r, r, 0, 0, 1, -r, r], ['l', r * 2 - w, 0], ['a', r, r, 0, 0, 1, -r, -r], ['l', 0, r * 2 - h], ['a', r, r, 0, 0, 1, r, -r], ['z']];
  }

  return [['M', x, y], ['l', w, 0], ['l', 0, h], ['l', -w, 0], ['z']]; // res.parsePathArray = parsePathArray;
}

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathTocurve;

var _path2Absolute = _interopRequireDefault(__webpack_require__(404));

var a2c = function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  // for more information of where this math came from visit:
  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
  if (rx === ry) {
    rx += 1;
  }

  var _120 = Math.PI * 120 / 180;

  var rad = Math.PI / 180 * (+angle || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;

  var rotate = function rotate(x, y, rad) {
    var X = x * Math.cos(rad) - y * Math.sin(rad);
    var Y = x * Math.sin(rad) + y * Math.cos(rad);
    return {
      x: X,
      y: Y
    };
  };

  if (!recursive) {
    xy = rotate(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;

    if (x1 === x2 && y1 === y2) {
      // 
      x2 += 1;
      y2 += 1;
    } // const cos = Math.cos(Math.PI / 180 * angle);
    // const sin = Math.sin(Math.PI / 180 * angle);


    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);

    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }

    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
    f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);

    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }

    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }

  var df = f2 - f1;

  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }

  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];

  if (recursive) {
    return [m2, m3, m4].concat(res);
  }

  res = [m2, m3, m4].concat(res).join().split(',');
  var newres = [];

  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
  }

  return newres;
};

var l2c = function l2c(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};

var q2c = function q2c(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;

  var _23 = 2 / 3;

  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};

function pathTocurve(path, path2) {
  var p = (0, _path2Absolute.default)(path);
  var p2 = path2 && (0, _path2Absolute.default)(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = []; // path commands of original path p

  var pcoms2 = []; // path commands of original path p2

  var pfirst = ''; // temporary holder for original path command

  var pcom = ''; // holder for previous path command of original path

  var ii;

  var processPath = function processPath(path, d, pcom) {
    var nx, ny;

    if (!path) {
      return ['C', d.x, d.y, d.x, d.y, d.x, d.y];
    }

    !(path[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);

    switch (path[0]) {
      case 'M':
        d.X = path[1];
        d.Y = path[2];
        break;

      case 'A':
        path = ['C'].concat(a2c.apply(0, [d.x, d.y].concat(path.slice(1))));
        break;

      case 'S':
        if (pcom === 'C' || pcom === 'S') {
          // In "S" case we have to take into account, if the previous command is C/S.
          nx = d.x * 2 - d.bx; // And reflect the previous

          ny = d.y * 2 - d.by; // command's control point relative to the current point.
        } else {
          // or some else or nothing
          nx = d.x;
          ny = d.y;
        }

        path = ['C', nx, ny].concat(path.slice(1));
        break;

      case 'T':
        if (pcom === 'Q' || pcom === 'T') {
          // In "T" case we have to take into account, if the previous command is Q/T.
          d.qx = d.x * 2 - d.qx; // And make a reflection similar

          d.qy = d.y * 2 - d.qy; // to case "S".
        } else {
          // or something else or nothing
          d.qx = d.x;
          d.qy = d.y;
        }

        path = ['C'].concat(q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
        break;

      case 'Q':
        d.qx = path[1];
        d.qy = path[2];
        path = ['C'].concat(q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
        break;

      case 'L':
        path = ['C'].concat(l2c(d.x, d.y, path[1], path[2]));
        break;

      case 'H':
        path = ['C'].concat(l2c(d.x, d.y, path[1], d.y));
        break;

      case 'V':
        path = ['C'].concat(l2c(d.x, d.y, d.x, path[1]));
        break;

      case 'Z':
        path = ['C'].concat(l2c(d.x, d.y, d.X, d.Y));
        break;

      default:
        break;
    }

    return path;
  };

  var fixArc = function fixArc(pp, i) {
    if (pp[i].length > 7) {
      pp[i].shift();
      var pi = pp[i];

      while (pi.length) {
        pcoms1[i] = 'A'; // if created multiple C:s, their original seg is saved

        p2 && (pcoms2[i] = 'A'); // the same as above

        pp.splice(i++, 0, ['C'].concat(pi.splice(0, 6)));
      }

      pp.splice(i, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  var fixM = function fixM(path1, path2, a1, a2, i) {
    if (path1 && path2 && path1[i][0] === 'M' && path2[i][0] !== 'M') {
      path2.splice(i, 0, ['M', a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i][1];
      a1.y = path1[i][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };

  ii = Math.max(p.length, p2 && p2.length || 0);

  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]); // save current path command

    if (pfirst !== 'C') {
      // C is not saved yet, because it may be result of conversion
      pcoms1[i] = pfirst; // Save current path command

      i && (pcom = pcoms1[i - 1]); // Get previous path command pcom
    }

    p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath

    if (pcoms1[i] !== 'A' && pfirst === 'C') pcoms1[i] = 'C'; // A is the only command
    // which may produce multiple C:s
    // so we have to make sure that C is also C in original path

    fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1

    if (p2) {
      // the same procedures is done to p2
      p2[i] && (pfirst = p2[i][0]);

      if (pfirst !== 'C') {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }

      p2[i] = processPath(p2[i], attrs2, pcom);

      if (pcoms2[i] !== 'A' && pfirst === 'C') {
        pcoms2[i] = 'C';
      }

      fixArc(p2, i);
    }

    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }

  return p2 ? [p, p2] : p;
}

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathToAbsolute;

var _parsePathString = _interopRequireDefault(__webpack_require__(405));

var REGEX_MD = /[a-z]/;

function toSymmetry(p, c) {
  return [c[0] + (c[0] - p[0]), c[1] + (c[1] - p[1])];
}

function pathToAbsolute(pathString) {
  var pathArray = (0, _parsePathString.default)(pathString);

  if (!pathArray || !pathArray.length) {
    return [['M', 0, 0]];
  }

  var needProcess = false; //  V,H,T,S 

  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0]; // 

    if (REGEX_MD.test(cmd) || ['V', 'H', 'T', 'S'].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  } // 
  // 


  if (!needProcess) {
    return pathArray;
  }

  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];

  if (first[0] === 'M' || first[0] === 'm') {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ['M', x, y];
  }

  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1]; // 

    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();

    if (cmd !== upCmd) {
      r[0] = upCmd;

      switch (upCmd) {
        case 'A':
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;

        case 'V':
          r[1] = +pa[1] + y;
          break;

        case 'H':
          r[1] = +pa[1] + x;
          break;

        case 'M':
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        // for lint

        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }

      }
    } else {
      // 
      r = pathArray[i];
    } //  V,H,S,T 


    switch (upCmd) {
      case 'Z':
        x = +mx;
        y = +my;
        break;

      case 'H':
        x = r[1];
        r = ['L', x, y];
        break;

      case 'V':
        y = r[1];
        r = ['L', x, y];
        break;

      case 'T':
        x = r[1];
        y = r[2]; //  x, y 
        //  Q

        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ['Q', symetricT[0], symetricT[1], x, y];
        break;

      case 'S':
        x = r[r.length - 2];
        y = r[r.length - 1]; //  x,y 
        //  C  S

        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ['C', symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;

      case 'M':
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      // for lint

      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }

    res.push(r);
  }

  return res;
}

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parsePathString;

var _util = __webpack_require__(0);

var SPACES = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp('([a-z])[' + SPACES + ',]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[' + SPACES + ']*,?[' + SPACES + ']*)+)', 'ig');
var PATH_VALUES = new RegExp('(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[' + SPACES + ']*,?[' + SPACES + ']*', 'ig'); // Parses given path string into an array of arrays of path segments

function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }

  if ((0, _util.isArray)(pathString)) {
    return pathString;
  }

  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function (a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function (a, b) {
      b && params.push(+b);
    });

    if (name === 'm' && params.length > 2) {
      data.push([b].concat(params.splice(0, 2)));
      name = 'l';
      b = b === 'm' ? 'l' : 'L';
    }

    if (name === 'o' && params.length === 1) {
      data.push([b, params[0]]);
    }

    if (name === 'r') {
      data.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b].concat(params.splice(0, paramCounts[name])));

        if (!paramCounts[name]) {
          break;
        }
      }
    }

    return '';
  });
  return data;
}

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSamePoint = isSamePoint;
exports.default = getArcParams;

var _util = __webpack_require__(0);

// 
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
} // u.v/|u||v|


function vRatio(u, v) {
  //  0  0 1
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
} // 


function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
/**
 *  [x, y]
 * @param {Array} point1 
 * @param {Array} point2 
 */


function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
} // A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y


function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = (0, _util.mod)((0, _util.toRadian)(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5]; // 

  var x1 = startPoint[0];
  var y1 = startPoint[1]; // 

  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;

  if (arcFlag === sweepFlag) {
    f *= -1;
  }

  if (isNaN(f)) {
    f = 0;
  } //  0  (0, 0) 


  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0; // 

  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp; // 

  var u = [(xp - cxp) / rx, (yp - cyp) / ry]; // 

  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry]; //  x 

  var theta = vAngle([1, 0], u); // 

  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }

  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }

  return {
    cx: cx,
    cy: cy,
    //  0 
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getLineIntersect;

var isBetween = function isBetween(value, min, max) {
  return value >= min && value <= max;
};

function getLineIntersect(p0, p1, p2, p3) {
  var tolerance = 0.001;
  var E = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point = null;

  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {
    var s = (E.x * D1.y - E.y * D1.x) / kross;
    var t = (E.x * D0.y - E.y * D0.x) / kross;

    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {
      point = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }

  return point;
}

;

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isInPolygon;

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
// https://blog.csdn.net/WilliamSun0122/article/details/77994526
var tolerance = 1e-6; // doubleeps

function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }

  return x < 0 ? -1 : 1;
} // Qp1p2


function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }

  return false;
} // P-


function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;

  if (n <= 2) {
    // svg  3 
    return false;
  }

  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];

    if (onSegment(p1, p2, [x, y])) {
      // 
      return true;
    } // min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
    //    


    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }

  return isHit;
}

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  getAdjust: true,
  registerAdjust: true,
  Adjust: true
};
Object.defineProperty(exports, "getAdjust", {
  enumerable: true,
  get: function get() {
    return _factory.getAdjust;
  }
});
Object.defineProperty(exports, "registerAdjust", {
  enumerable: true,
  get: function get() {
    return _factory.registerAdjust;
  }
});
Object.defineProperty(exports, "Adjust", {
  enumerable: true,
  get: function get() {
    return _adjust.default;
  }
});

var _factory = __webpack_require__(766);

var _adjust = _interopRequireDefault(__webpack_require__(111));

var _dodge = _interopRequireDefault(__webpack_require__(767));

var _jitter = _interopRequireDefault(__webpack_require__(768));

var _stack = _interopRequireDefault(__webpack_require__(769));

var _symmetric = _interopRequireDefault(__webpack_require__(770));

var _interface = __webpack_require__(410);

Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
//  adjust
(0, _factory.registerAdjust)('Dodge', _dodge.default);
(0, _factory.registerAdjust)('Jitter', _jitter.default);
(0, _factory.registerAdjust)('Stack', _stack.default);
(0, _factory.registerAdjust)('Symmetric', _symmetric.default); // 

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return _scale.Scale;
  }
});

var _scale = __webpack_require__(108);

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTickMethod = getTickMethod;
exports.registerTickMethod = registerTickMethod;
var methodCache = {};
/**
 *  ticks 
 * @param key 
 * @returns  ticks 
 */

function getTickMethod(key) {
  return methodCache[key];
}
/**
 *  ticks 
 * @param key 
 * @param method 
 */


function registerTickMethod(key, method) {
  methodCache[key] = method;
}

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(139));

/**
 * 
 * @class
 */
var Category =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Category, _super);

  function Category() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'cat';
    _this.isCategory = true; //  translate 

    _this.cache = new Map();
    return _this;
  }

  Category.prototype.translate = function (value) {
    if (this.cache.has(value)) {
      return this.cache.get(value);
    }

    var index = (0, _util.indexOf)(this.values, value);

    if (index === -1) {
      index = (0, _util.isNumber)(value) ? value : NaN;
    }

    this.cache.set(value, index);
    return index;
  };

  Category.prototype.scale = function (value) {
    var order = this.translate(value); //  0.5 
    // if (order < this.min - 0.5 || order > this.max + 0.5) {
    //   return NaN;
    // }

    var percent = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent, this.rangeMin(), this.rangeMax());
  };

  Category.prototype.invert = function (scaledValue) {
    var domainRange = this.max - this.min;
    var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent) + this.min;

    if (idx < this.min || idx > this.max) {
      return NaN;
    }

    return this.values[idx];
  };

  Category.prototype.getText = function (value) {
    var args = [];

    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }

    var v = value; // valueindex

    if ((0, _util.isNumber)(value) && !this.values.includes(value)) {
      v = this.values[v];
    }

    return _super.prototype.getText.apply(this, (0, _tslib.__spreadArrays)([v], args));
  }; // 


  Category.prototype.initCfg = function () {
    this.tickMethod = 'cat';
  }; //  min, max


  Category.prototype.setDomain = function () {
    //  min
    if ((0, _util.isNil)(this.getConfig('min'))) {
      this.min = 0;
    }

    if ((0, _util.isNil)(this.getConfig('max'))) {
      var size = this.values.length;
      this.max = size > 1 ? size - 1 : size;
    } // domain 


    if (this.cache) {
      this.cache.clear();
    }
  };

  return Category;
}(_base.default);

var _default = Category;
exports.default = _default;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(181));

/**
 * 
 * @class
 */
var Linear =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Linear, _super);

  function Linear() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'linear';
    _this.isLinear = true;
    return _this;
  }

  Linear.prototype.invert = function (value) {
    var percent = this.getInvertPercent(value);
    return this.min + percent * (this.max - this.min);
  };

  Linear.prototype.initCfg = function () {
    this.tickMethod = 'wilkinson-extended';
    this.nice = false;
  };

  return Linear;
}(_base.default);

var _default = Linear;
exports.default = _default;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(181));

/**
 * 
 */
var Quantize =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Quantize, _super);

  function Quantize() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'quantize';
    return _this;
  }

  Quantize.prototype.invert = function (value) {
    var ticks = this.ticks;
    var length = ticks.length;
    var percent = this.getInvertPercent(value);
    var minIndex = Math.floor(percent * (length - 1)); // 

    if (minIndex >= length - 1) {
      return (0, _util.last)(ticks);
    } //  


    if (minIndex < 0) {
      return (0, _util.head)(ticks);
    }

    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1]; //  tick 

    var minIndexPercent = minIndex / (length - 1);
    var maxIndexPercent = (minIndex + 1) / (length - 1);
    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };

  Quantize.prototype.initCfg = function () {
    this.tickMethod = 'r-pretty';
    this.tickCount = 5;
    this.nice = true;
  };

  Quantize.prototype.calculateTicks = function () {
    var ticks = _super.prototype.calculateTicks.call(this);

    if (!this.nice) {
      //  nice = false , min, max
      if ((0, _util.last)(ticks) !== this.max) {
        ticks.push(this.max);
      }

      if ((0, _util.head)(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }

    return ticks;
  }; // 


  Quantize.prototype.getScalePercent = function (value) {
    var ticks = this.ticks; // 

    if (value < (0, _util.head)(ticks)) {
      return 0;
    } // 


    if (value > (0, _util.last)(ticks)) {
      return 1;
    }

    var minIndex = 0;
    (0, _util.each)(ticks, function (tick, index) {
      if (value >= tick) {
        minIndex = index;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };

  return Quantize;
}(_base.default);

var _default = Quantize;
exports.default = _default;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateCatTicks;

var _util = __webpack_require__(0);

var _extended = _interopRequireDefault(__webpack_require__(417));

/**
 *  ticks
 * @param cfg 
 * @returns  ticks
 */
function calculateCatTicks(cfg) {
  var values = cfg.values,
      tickInterval = cfg.tickInterval,
      tickCount = cfg.tickCount;
  var ticks = values;

  if ((0, _util.isNumber)(tickInterval)) {
    return (0, _util.filter)(ticks, function (__, i) {
      return i % tickInterval === 0;
    });
  }

  var min = cfg.min,
      max = cfg.max;

  if ((0, _util.isNil)(min)) {
    min = 0;
  }

  if ((0, _util.isNil)(max)) {
    max = values.length - 1;
  }

  if ((0, _util.isNumber)(tickCount) && tickCount < max - min) {
    // 
    // tslint:disable-next-line: no-shadowed-variable
    var ticks_1 = (0, _extended.default)(min, max, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;
    var valid = (0, _util.filter)(ticks_1, function (tick) {
      return tick >= min && tick <= max;
    });
    return valid.map(function (index) {
      return values[index];
    });
  }

  return values.slice(min, max + 1);
}

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extended;
exports.ALL_Q = exports.DEFAULT_Q = void 0;

var _util = __webpack_require__(0);

var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
exports.DEFAULT_Q = DEFAULT_Q;
var ALL_Q = [1, 5, 2, 2.5, 4, 3, 1.5, 7, 6, 8, 9];
exports.ALL_Q = ALL_Q;
var eps = Number.EPSILON * 100; // https://stackoverflow.com/questions/4467539/javascript-modulo-gives-a-negative-result-for-negative-numbers

function mod(n, m) {
  return (n % m + m) % m;
}

function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = (0, _util.size)(Q);
  var i = (0, _util.indexOf)(Q, q);
  var v = 0;
  var m = mod(lmin, lstep);

  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }

  return 1 - i / (n - 1) - j + v;
}

function simplicityMax(q, Q, j) {
  var n = (0, _util.size)(Q);
  var i = (0, _util.indexOf)(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}

function density(k, m, dmin, dmax, lmin, lmax) {
  var r = (k - 1) / (lmax - lmin);
  var rt = (m - 1) / (Math.max(lmax, dmax) - Math.min(dmin, lmin));
  return 2 - Math.max(r / rt, rt / r);
}

function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }

  return 1;
}

function coverage(dmin, dmax, lmin, lmax) {
  var range = dmax - dmin;
  return 1 - 0.5 * (Math.pow(dmax - lmax, 2) + Math.pow(dmin - lmin, 2)) / Math.pow(0.1 * range, 2);
}

function coverageMax(dmin, dmax, span) {
  var range = dmax - dmin;

  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }

  return 1;
}

function legibility() {
  return 1;
}
/**
 * An Extension of Wilkinson's Algorithm for Position Tick Labels on Axes
 * https://www.yuque.com/preview/yuque/0/2019/pdf/185317/1546999150858-45c3b9c2-4e86-4223-bf1a-8a732e8195ed.pdf
 * @param dmin 
 * @param dmax 
 * @param m tick
 * @param onlyLoose minmax[3, 97]
 * @param Q nice numbers
 * @param w 
 */


function extended(dmin, dmax, m, onlyLoose, Q, w) {
  if (m === void 0) {
    m = 5;
  }

  if (onlyLoose === void 0) {
    onlyLoose = true;
  }

  if (Q === void 0) {
    Q = DEFAULT_Q;
  }

  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  } //  oom


  if (typeof dmin !== 'number' || typeof dmax !== 'number') {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }

  if (dmin === dmax || m === 1) {
    return {
      min: dmin,
      max: dmax,
      ticks: [dmin]
    };
  }

  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;

  while (j < Infinity) {
    for (var _i = 0, Q_1 = Q; _i < Q_1.length; _i++) {
      var q = Q_1[_i];
      var sm = simplicityMax(q, Q, j);

      if (Number.isNaN(sm)) {
        throw new Error('NaN');
      }

      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }

      var k = 2;

      while (k < Infinity) {
        var dm = densityMax(k, m);

        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }

        var delta = (dmax - dmin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));

        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dmin, dmax, step * (k - 1));

          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }

          var minStart = Math.floor(dmax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dmin / step) * j;

          if (minStart > maxStart) {
            z = z + 1;
            continue;
          }

          for (var start = minStart; start <= maxStart; start = start + 1) {
            var lmin = start * (step / j);
            var lmax = lmin + step * (k - 1);
            var lstep = step;
            var s = simplicity(q, Q, j, lmin, lmax, lstep);
            var c = coverage(dmin, dmax, lmin, lmax);
            var g = density(k, m, dmin, dmax, lmin, lmax);
            var l = legibility();
            var score = w[0] * s + w[1] * c + w[2] * g + w[3] * l;

            if (score > best.score && (!onlyLoose || lmin <= dmin && lmax >= dmax)) {
              best.lmin = lmin;
              best.lmax = lmax;
              best.lstep = lstep;
              best.score = score;
            }
          }

          z = z + 1;
        }

        k = k + 1;
      }
    }

    j = j + 1;
  } // 


  var toFixed = Number.isInteger(best.lstep) ? 0 : Math.ceil(Math.abs(Math.log10(best.lstep)));
  var range = [];

  for (var tick = best.lmin; tick <= best.lmax; tick += best.lstep) {
    range.push(tick);
  }

  var ticks = toFixed ? (0, _util.map)(range, function (x) {
    return Number.parseFloat(x.toFixed(toFixed));
  }) : range;
  return {
    min: Math.min(dmin, (0, _util.head)(ticks)),
    max: Math.max(dmax, (0, _util.last)(ticks)),
    ticks: ticks
  };
}

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pretty;

function pretty(min, max, n) {
  if (n === void 0) {
    n = 5;
  }

  var res = {
    max: 0,
    min: 0,
    ticks: []
  };

  if (min === max) {
    return {
      max: max,
      min: min,
      ticks: [min]
    };
  }
  /*
    R pretty:
    https://svn.r-project.org/R/trunk/src/appl/pretty.c
    https://www.rdocumentation.org/packages/base/versions/3.5.2/topics/pretty
    */


  var h = 1.5; // high.u.bias

  var h5 = 0.5 + 1.5 * h; // u5.bias
  // 

  var d = max - min;
  var c = d / n; // d
  // const min_n = Math.floor(n / 3);
  // const shrink_sml = Math.pow(2, 5);
  // if (Math.log10(d) < -2) {
  //   c = (_.max([ Math.abs(max), Math.abs(min) ]) * shrink_sml) / min_n;
  // }

  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var toFixed = base < 1 ? Math.ceil(Math.abs(Math.log10(base))) : 0;
  var unit = base;

  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;

    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;

      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }

  var nu = Math.ceil(max / unit);
  var ns = Math.floor(min / unit);
  res.max = Math.max(nu * unit, max);
  res.min = Math.min(ns * unit, min);
  var x = Number.parseFloat((ns * unit).toFixed(toFixed));

  while (x < max) {
    res.ticks.push(x);
    x += unit;

    if (toFixed) {
      x = Number.parseFloat(x.toFixed(toFixed));
    }
  }

  res.ticks.push(x);
  return res;
}

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.propagationDelegate = propagationDelegate;

var _gBase = __webpack_require__(27);

/**
 *
 * @param group 
 * @param eventName 
 * @param eventObject 
 */
function propagationDelegate(group, eventName, eventObject) {
  var event = new _gBase.Event(eventName, eventObject);
  event.target = group;
  event.propagationPath.push(group); //  group  delegation

  group.emitDelegation(eventName, event);
  var parent = group.getParent(); // 

  while (parent) {
    // 
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHeight;

var _getStyle = _interopRequireDefault(__webpack_require__(141));

function getHeight(el, defaultValue) {
  var height = (0, _getStyle.default)(el, 'height', defaultValue);

  if (height === 'auto') {
    height = el.offsetHeight;
  }

  return parseFloat(height);
}

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getHeight;

var _getStyle = _interopRequireDefault(__webpack_require__(141));

function getHeight(el, defaultValue) {
  var width = (0, _getStyle.default)(el, 'width', defaultValue);

  if (width === 'auto') {
    width = el.offsetWidth;
  }

  return parseFloat(width);
}

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStatesStyle = getStatesStyle;

var _util = __webpack_require__(0);

// 
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style"; // activeStyle

  var styles = null;
  (0, _util.each)(stateStyles, function (v, state) {
    if (item[state] && v[styleName]) {
      if (!styles) {
        styles = {};
      }

      (0, _util.mix)(styles, v[styleName]); // 
    }
  });
  return styles;
}

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CROSSHAIR_TEXT = exports.CROSSHAIR_LINE = exports.CONTAINER_CLASS = void 0;
var CONTAINER_CLASS = 'g2-crosshair';
exports.CONTAINER_CLASS = CONTAINER_CLASS;
var CROSSHAIR_LINE = CONTAINER_CLASS + "-line";
exports.CROSSHAIR_LINE = CROSSHAIR_LINE;
var CROSSHAIR_TEXT = CONTAINER_CLASS + "-text";
exports.CROSSHAIR_TEXT = CROSSHAIR_TEXT;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerAnimation = exports.getAnimation = void 0;
var ANIMATIONS_MAP = {};
/**
 * 
 * @param type 
 */

function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}

exports.getAnimation = getAnimation;
/**
 * 
 * @param type 
 * @param animation 
 */

function registerAnimation(type, animation) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation;
}

exports.registerAnimation = registerAnimation;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRadius = exports.parseStyle = exports.parsePattern = exports.parseRadialGradient = exports.parseLineGradient = void 0;

var util_1 = __webpack_require__(52);

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;

function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  util_1.each(arr, function (item) {
    var itemArr = item.split(':');
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
/**
 * 
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   gradientStr   
 * @returns {any} 
 */


function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box = element.getBBox();
  var start;
  var end;

  if (angle >= 0 && angle < 1 / 2 * Math.PI) {
    start = {
      x: box.minX,
      y: box.minY
    };
    end = {
      x: box.maxX,
      y: box.maxY
    };
  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box.maxX,
      y: box.minY
    };
    end = {
      x: box.minX,
      y: box.maxY
    };
  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
    start = {
      x: box.maxX,
      y: box.maxY
    };
    end = {
      x: box.minX,
      y: box.minY
    };
  } else {
    start = {
      x: box.minX,
      y: box.maxY
    };
    end = {
      x: box.maxX,
      y: box.minY
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}

exports.parseLineGradient = parseLineGradient;
/**
 * 
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   gradientStr   
 * @returns {any} 
 */

function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4]; // 0

  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(':')[1];
  }

  var box = element.getBBox();
  var width = box.maxX - box.minX;
  var height = box.maxY - box.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);
  addStop(steps, gradient);
  return gradient;
}

exports.parseRadialGradient = parseRadialGradient;
/**
 *  pattern
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   patternStr    pattern 
 */

function parsePattern(context, element, patternStr) {
  // 
  if (element.get('patternSource') && element.get('patternSource') === patternStr) {
    return element.get('pattern');
  }

  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2]; // Function to be called when pattern loads

  function onload() {
    // Create pattern
    pattern = context.createPattern(img, repeat);
    element.set('pattern', pattern); // be a cache

    element.set('patternSource', patternStr);
  }

  switch (repeat) {
    case 'a':
      repeat = 'repeat';
      break;

    case 'x':
      repeat = 'repeat-x';
      break;

    case 'y':
      repeat = 'repeat-y';
      break;

    case 'n':
      repeat = 'no-repeat';
      break;

    default:
      repeat = 'no-repeat';
  }

  img = new Image(); // If source URL is not a data URL

  if (!source.match(/^data:/i)) {
    // Set crossOrigin for this image
    img.crossOrigin = 'Anonymous';
  }

  img.src = source;

  if (img.complete) {
    onload();
  } else {
    img.onload = onload; // Fix onload() bug in IE9

    img.src = img.src;
  }

  return pattern;
}

exports.parsePattern = parsePattern;

function parseStyle(context, element, color) {
  if (util_1.isString(color)) {
    if (color[1] === '(' || color[2] === '(') {
      if (color[0] === 'l') {
        // regexLG.test(color)
        return parseLineGradient(context, element, color);
      }

      if (color[0] === 'r') {
        // regexRG.test(color)
        return parseRadialGradient(context, element, color);
      }

      if (color[0] === 'p') {
        // regexPR.test(color)
        return parsePattern(context, element, color);
      }
    }

    return color;
  }
}

exports.parseStyle = parseStyle;

function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;

  if (util_1.isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }

  return [r1, r2, r3, r4];
}

exports.parseRadius = parseRadius;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(52); // 


function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
} // u.v/|u||v|


function vRatio(u, v) {
  //  0  0 1
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
} // 


function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
} // A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y


function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = util_1.mod(util_1.toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5]; // 

  var x1 = startPoint[0];
  var y1 = startPoint[1]; // 

  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;

  if (arcFlag === sweepFlag) {
    f *= -1;
  }

  if (isNaN(f)) {
    f = 0;
  } //  0  (0, 0) 


  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0; // 

  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp; // 

  var u = [(xp - cxp) / rx, (yp - cyp) / ry]; // 

  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry]; //  x 

  var theta = vAngle([1, 0], u); // 

  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }

  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }

  return {
    cx: cx,
    cy: cy,
    //  0 
    rx: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: util_1.isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}

exports.default = getArcParams;

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g_base_1 = __webpack_require__(27);

function isPointInPath(shape, x, y) {
  var ctx = g_base_1.getOffScreenContext();
  shape.createPath(ctx);
  return ctx.isPointInPath(x, y);
}

exports.default = isPointInPath;

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
}); // https://blog.csdn.net/WilliamSun0122/article/details/77994526

var tolerance = 1e-6; // doubleeps

function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }

  return x < 0 ? -1 : 1;
} // Qp1p2


function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }

  return false;
} // P-


function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;

  if (n <= 2) {
    // svg  3 
    return false;
  }

  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];

    if (onSegment(p1, p2, [x, y])) {
      // 
      return true;
    } // min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
    //    


    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }

  return isHit;
}

exports.default = isInPolygon;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(52);

function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); //  0 - 2 * Math.PI 

  if (angle < startAngle || angle > endAngle) {
    return false;
  }

  var point = {
    x: cx + r * Math.cos(angle),
    y: cy + r * Math.sin(angle)
  };
  return util_1.distance(point.x, point.y, x, y) <= lineWidth / 2;
}

exports.default = arc;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var line_1 = __webpack_require__(188);

function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;

  if (count < 2) {
    return false;
  }

  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];

    if (line_1.default(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  } // 


  if (isClose) {
    var first = points[0];
    var last = points[count - 1];

    if (line_1.default(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
      return true;
    }
  }

  return false;
}

exports.default = inPolyline;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerEngine = exports.getEngine = void 0;
var ENGINES = {};
/**
 *  engine
 * @param name 
 * @returns G engine
 */

function getEngine(name) {
  var G = ENGINES[name];

  if (!G) {
    throw new Error("G engine '" + name + "' is not exist, please register it at first.");
  }

  return G;
}

exports.getEngine = getEngine;
/**
 * 
 * @param name
 * @param engine
 */

function registerEngine(name, engine) {
  ENGINES[name] = engine;
}

exports.registerEngine = registerEngine;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerGeometry = exports.View = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var base_1 = tslib_1.__importDefault(__webpack_require__(261));

var facet_1 = __webpack_require__(262);

var interaction_1 = __webpack_require__(264);

var theme_1 = __webpack_require__(91);

var bbox_1 = __webpack_require__(77);

var coordinate_1 = __webpack_require__(51);

var helper_1 = __webpack_require__(76);

var tooltip_1 = __webpack_require__(266);

var padding_1 = __webpack_require__(267);

var scale_1 = __webpack_require__(145);

var util_2 = __webpack_require__(434);

var controller_1 = __webpack_require__(435);

var coordinate_2 = tslib_1.__importDefault(__webpack_require__(895));

var event_1 = tslib_1.__importDefault(__webpack_require__(268));

var layout_1 = tslib_1.__importDefault(__webpack_require__(896));

var scale_pool_1 = __webpack_require__(897);

var padding_cal_1 = __webpack_require__(436);

var auto_1 = __webpack_require__(898);

var sync_view_padding_1 = __webpack_require__(899);
/**
 * G2  View 
 */


var View =
/** @class */
function (_super) {
  tslib_1.__extends(View, _super);

  function View(props) {
    var _this = _super.call(this, {
      visible: props.visible
    }) || this;
    /**  view */


    _this.views = [];
    /**  geometry  */

    _this.geometries = [];
    /**  controllers */

    _this.controllers = [];
    /**  Interaction  */

    _this.interactions = {};
    /**  Geometry  */

    _this.limitInPlot = false; // 

    _this.options = {
      data: [],
      animate: true
    }; // 

    /**  */

    _this.usedControllers = controller_1.getComponentControllerNames();
    /**  scales */

    _this.scalePool = new scale_pool_1.ScalePool();
    /**  */

    _this.layoutFunc = layout_1.default;
    /**  plot CoordinateBBox */

    _this.isPreMouseInPlot = false;
    /**  */

    _this.isDataChanged = false;
    /**  */

    _this.isCoordinateChanged = false;
    /**  view  scale key */

    _this.createdScaleKeys = new Map();

    _this.onCanvasEvent = function (evt) {
      var name = evt.name;

      if (!name.includes(':')) {
        // 
        var e = _this.createViewEvent(evt); //  plot 


        _this.doPlotEvent(e);

        _this.emit(name, e);
      }
    };
    /**
     * 
     * @param evt
     */


    _this.onDelegateEvents = function (evt) {
      // 
      // evt.preventDefault();
      var name = evt.name;

      if (!name.includes(':')) {
        return;
      } //  view 


      var e = _this.createViewEvent(evt); // 


      _this.emit(name, e); // const currentTarget = evt.currentTarget as IShape;
      // const inheritNames = currentTarget.get('inheritNames');
      // if (evt.delegateObject || inheritNames) {
      //   const events = this.getEvents();
      //   each(inheritNames, (subName) => {
      //     const eventName = `${subName}:${type}`;
      //     if (events[eventName]) {
      //       this.emit(eventName, e);
      //     }
      //   });
      // }

    };

    var _a = props.id,
        id = _a === void 0 ? util_1.uniqueId('view') : _a,
        parent = props.parent,
        canvas = props.canvas,
        backgroundGroup = props.backgroundGroup,
        middleGroup = props.middleGroup,
        foregroundGroup = props.foregroundGroup,
        _b = props.region,
        region = _b === void 0 ? {
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 1,
        y: 1
      }
    } : _b,
        padding = props.padding,
        appendPadding = props.appendPadding,
        theme = props.theme,
        options = props.options,
        limitInPlot = props.limitInPlot,
        syncViewPadding = props.syncViewPadding;
    _this.parent = parent;
    _this.canvas = canvas;
    _this.backgroundGroup = backgroundGroup;
    _this.middleGroup = middleGroup;
    _this.foregroundGroup = foregroundGroup;
    _this.region = region;
    _this.padding = padding;
    _this.appendPadding = appendPadding; //  view 

    _this.options = tslib_1.__assign(tslib_1.__assign({}, _this.options), options);
    _this.limitInPlot = limitInPlot;
    _this.id = id;
    _this.syncViewPadding = syncViewPadding; //  theme

    _this.themeObject = util_1.isObject(theme) ? util_1.deepMix({}, theme_1.getTheme('default'), util_2.createTheme(theme)) : theme_1.getTheme(theme);

    _this.init();

    return _this;
  }
  /**
   *  layout 
   * @param layout 
   * @returns void
   */


  View.prototype.setLayout = function (layout) {
    this.layoutFunc = layout;
  };
  /**
   * 
   * @returns voids
   */


  View.prototype.init = function () {
    //  viewBBox
    this.calculateViewBBox(); // 

    this.initEvents(); //  controller

    this.initComponentController();
    this.initOptions();
  };
  /**
   * 
   * render  view  view
   * @param isUpdate 
   */


  View.prototype.render = function (isUpdate) {
    if (isUpdate === void 0) {
      isUpdate = false;
    }

    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_RENDER); // 

    this.paint(isUpdate);
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_RENDER);

    if (this.visible === false) {
      //  visible: false
      this.changeVisible(false);
    }
  };
  /**
   * chart 
   * @returns void
   */


  View.prototype.clear = function () {
    var _this = this;

    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CLEAR); // 1. 

    this.filteredData = [];
    this.coordinateInstance = undefined;
    this.isDataChanged = false; // 

    this.isCoordinateChanged = false; // 
    // 2.  geometries

    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      geometries[i].clear(); // view  geometry  chart.geometry()  #2799

      geometries[i].container.remove(true);
    }

    this.geometries = []; // 3.  controllers

    var controllers = this.controllers;

    for (var i = 0; i < controllers.length; i++) {
      if (controllers[i].name === 'annotation') {
        // 
        controllers[i].clear(true);
      } else {
        controllers[i].clear();
      }
    } // 4.  scale 


    this.createdScaleKeys.forEach(function (v, k) {
      _this.getRootView().scalePool.deleteScale(k);
    });
    this.createdScaleKeys.clear(); //  view

    var views = this.views;

    for (var i = 0; i < views.length; i++) {
      views[i].clear();
    }

    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_CLEAR);
  };
  /**
   * 
   * @returns void
   */


  View.prototype.destroy = function () {
    // 
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
    var interactions = this.interactions; //  interactions

    util_1.each(interactions, function (interaction) {
      if (interaction) {
        //  undefined
        interaction.destroy();
      }
    });
    this.clear(); //  controller 

    var controllers = this.controllers;

    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.destroy();
    }

    this.backgroundGroup.remove(true);
    this.middleGroup.remove(true);
    this.foregroundGroup.remove(true);

    _super.prototype.destroy.call(this);
  };
  /* end  */

  /**
   *  view
   * @param visible 
   * @returns View
   */


  View.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible);

    var geometries = this.geometries;

    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i];
      geometry.changeVisible(visible);
    }

    var controllers = this.controllers;

    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      controller.changeVisible(visible);
    }

    this.foregroundGroup.set('visible', visible);
    this.middleGroup.set('visible', visible);
    this.backgroundGroup.set('visible', visible); // group.set('visible', visible) 

    this.getCanvas().draw();
    return this;
  };
  /**
   * 
   *
   * ```ts
   * view.data([{ city: '', sale: 100 }, { city: '', sale: 110 } ]);
   * ```
   *
   * @param data json 
   * @returns View
   */


  View.prototype.data = function (data) {
    util_1.set(this.options, 'data', data);
    this.isDataChanged = true;
    return this;
  };
  /**
   * @deprecated
   * This method will be removed at G2 V4.1. Replaced by {@link #data(data)}
   */


  View.prototype.source = function (data) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.data() instead.');
    return this.data(data);
  };
  /**
   * 
   *
   * ```ts
   * view.filter('city', (value: any, datum: Datum) => value !== '');
   *
   * //  'city' 
   * view.filter('city', null);
   * ```
   *
   * @param field 
   * @param condition 
   * @returns View
   */


  View.prototype.filter = function (field, condition) {
    if (util_1.isFunction(condition)) {
      util_1.set(this.options, ['filters', field], condition);
      return this;
    } // condition 


    if (!condition && util_1.get(this.options, ['filters', field])) {
      delete this.options.filters[field];
    }

    return this;
  };

  View.prototype.axis = function (field, axisOption) {
    if (util_1.isBoolean(field)) {
      util_1.set(this.options, ['axes'], field);
    } else {
      util_1.set(this.options, ['axes', field], axisOption);
    }

    return this;
  };

  View.prototype.legend = function (field, legendOption) {
    if (util_1.isBoolean(field)) {
      util_1.set(this.options, ['legends'], field);
    } else if (util_1.isString(field)) {
      util_1.set(this.options, ['legends', field], legendOption);
    } else {
      //  legend 
      util_1.set(this.options, ['legends'], field);
    }

    return this;
  };

  View.prototype.scale = function (field, scaleOption) {
    var _this = this;

    if (util_1.isString(field)) {
      util_1.set(this.options, ['scales', field], scaleOption);
    } else if (util_1.isObject(field)) {
      util_1.each(field, function (v, k) {
        util_1.set(_this.options, ['scales', k], v);
      });
    }

    return this;
  };
  /**
   * tooltip 
   *
   * ```ts
   * view.tooltip(false); //  tooltip
   *
   * view.tooltip({
   *   shared: true
   * });
   * ```
   *
   * @param cfg Tooltip https://github.com/antvis/component#tooltip
   * @returns View
   */


  View.prototype.tooltip = function (cfg) {
    util_1.set(this.options, 'tooltip', cfg);
    return this;
  };
  /**
   * 
   *
   * ```ts
   * view.annotation().line({
   *   start: ['min', 85],
   *   end: ['max', 85],
   *   style: {
   *     stroke: '#595959',
   *     lineWidth: 1,
   *     lineDash: [3, 3],
   *   },
   * });
   * ```
   * https://github.com/antvis/component#annotation
   * @returns [[Annotation]]
   */


  View.prototype.annotation = function () {
    return this.getController('annotation');
  };
  /**
   * @deprecated
   * This method will be removed at G2 V4.1. Replaced by {@link #guide()}
   */


  View.prototype.guide = function () {
    console.warn('This method will be removed at G2 V4.1. Please use chart.annotation() instead.');
    return this.annotation();
  };

  View.prototype.coordinate = function (type, coordinateCfg) {
    // 
    if (util_1.isString(type)) {
      util_1.set(this.options, 'coordinate', {
        type: type,
        cfg: coordinateCfg
      });
    } else {
      util_1.set(this.options, 'coordinate', type);
    } //  coordinate 


    this.coordinateController.update(this.options.coordinate);
    return this.coordinateController;
  };
  /**
   * @deprecated
   * This method will be removed at G2 V4.1. Replaced by {@link #coordinate()}
   */


  View.prototype.coord = function (type, coordinateCfg) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.coordinate() instead.'); // @ts-ignore

    return this.coordinate(type, coordinateCfg);
  };
  /**
   * view 
   *
   * ```ts
   * view.facet('rect', {
   *   rowField: 'province',
   *   columnField: 'category',
   *   eachView: (innerView: View, facet?: FacetData) => {
   *     innerView.line().position('city*sale');
   *   },
   * });
   * ```
   *
   * @param type 
   * @param cfg  [[FacetCfgMap]]
   * @returns View
   */


  View.prototype.facet = function (type, cfg) {
    // 
    if (this.facetInstance) {
      this.facetInstance.destroy();
    } // 


    var Ctor = facet_1.getFacet(type);

    if (!Ctor) {
      throw new Error("facet '" + type + "' is not exist!");
    }

    this.facetInstance = new Ctor(this, tslib_1.__assign(tslib_1.__assign({}, cfg), {
      type: type
    }));
    return this;
  };
  /*
   * 
   *
   * ```ts
   * view.animate(false);
   * ```
   *
   * @param status true false 
   * @returns View
   */


  View.prototype.animate = function (status) {
    util_1.set(this.options, 'animate', status);
    return this;
  };
  /**
   * 
   * @param options 
   */


  View.prototype.updateOptions = function (options) {
    this.clear(); // 

    util_1.mix(this.options, options); //  view 
    //  view 

    this.views.forEach(function (view) {
      return view.destroy();
    });
    this.views = [];
    this.initOptions(); //  padding 

    this.coordinateBBox = this.viewBBox;
    return this;
  };
  /**
   *  `view.options` 
   * @param name 
   * @param opt 
   * @returns view
   */


  View.prototype.option = function (name, opt) {
    //  option
    // name  API option 
    if (View.prototype[name]) {
      throw new Error("Can't use built in variable name \"" + name + "\", please change another one.");
    } //  option 


    util_1.set(this.options, name, opt);
    return this;
  };
  /**
   * 
   *
   * ```ts
   * view.theme('dark'); // 'dark'  `registerTheme()` 
   *
   * view.theme({ defaultColor: 'red' });
   * ```
   *
   * @param theme 
   * @returns View
   */


  View.prototype.theme = function (theme) {
    this.themeObject = util_1.isObject(theme) ? util_1.deepMix({}, this.themeObject, util_2.createTheme(theme)) : theme_1.getTheme(theme);
    return this;
  };
  /* end  API */

  /**
   * Call the interaction based on the interaction name
   *
   * ```ts
   * view.interaction('my-interaction', { extra: 'hello world' });
   * ```
   * https://g2.antv.vision/zh/docs/manual/tutorial/interaction
   * @param name interaction name
   * @param cfg interaction config
   * @returns
   */


  View.prototype.interaction = function (name, cfg) {
    var existInteraction = this.interactions[name]; // 

    if (existInteraction) {
      existInteraction.destroy();
    } // 


    var interaction = interaction_1.createInteraction(name, this, cfg);

    if (interaction) {
      interaction.init();
      this.interactions[name] = interaction;
    }

    return this;
  };
  /**
   *  View  interaction
   * ```ts
   * view.removeInteraction('my-interaction');
   * ```
   * @param name interaction name
   */


  View.prototype.removeInteraction = function (name) {
    var existInteraction = this.interactions[name]; // 

    if (existInteraction) {
      existInteraction.destroy();
      this.interactions[name] = undefined;
    }
  };
  /**
   *  view
   *
   * ```ts
   * view.changeData([{ city: '', sale: '200' }]);
   * ```
   *
   * @param data
   * @returns void
   */


  View.prototype.changeData = function (data) {
    this.isDataChanged = true;
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA); // 1. 

    this.data(data); // 2. 

    this.paint(true); // 3.  view  change data

    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i]; // FIXME  view 

      view.changeData(data);
    }

    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA);
  };
  /* View  API */

  /**
   *  view
   *
   * ```ts
   * const innerView = view.createView({
   *   start: { x: 0, y: 0 },
   *   end: { x: 0.5, y: 0.5 },
   *   padding: 8,
   * });
   * ```
   *
   * @param cfg
   * @returns View
   */


  View.prototype.createView = function (cfg) {
    //  4.1  view chart - view 
    //  API  warning
    if (this.parent && this.parent.parent) {
      //  3  
      console.warn('The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.');
    } //  view  options 


    var sharedOptions = {
      data: this.options.data,
      scales: util_1.clone(this.options.scales),
      axes: util_1.clone(this.options.axes),
      coordinate: util_1.clone(this.coordinateController.getOption()),
      tooltip: util_1.clone(this.options.tooltip),
      legends: util_1.clone(this.options.legends),
      animate: this.options.animate,
      visible: this.visible
    };
    var v = new View(tslib_1.__assign(tslib_1.__assign({
      parent: this,
      canvas: this.canvas,
      //  view  group
      backgroundGroup: this.backgroundGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.BG
      }),
      middleGroup: this.middleGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.MID
      }),
      foregroundGroup: this.foregroundGroup.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.FORE
      }),
      theme: this.themeObject,
      padding: this.padding
    }, cfg), {
      options: tslib_1.__assign(tslib_1.__assign({}, sharedOptions), util_1.get(cfg, 'options', {}))
    }));
    this.views.push(v);
    return v;
  };
  /**
   * @deprecated
   * This method will be removed at G2 V4.1. Replaced by {@link #createView()}
   */


  View.prototype.view = function (cfg) {
    console.warn('This method will be removed at G2 V4.1. Please use chart.createView() instead.');
    return this.createView(cfg);
  };
  /**
   *  view
   * @param view
   * @return removedView
   */


  View.prototype.removeView = function (view) {
    var removedView = util_1.remove(this.views, function (v) {
      return v === view;
    })[0];

    if (removedView) {
      removedView.destroy();
    }

    return removedView;
  };
  /* end View  API */
  //  get 

  /**
   * 
   * @returns [[Coordinate]]
   */


  View.prototype.getCoordinate = function () {
    return this.coordinateInstance;
  };
  /**
   *  view 
   * @returns themeObject
   */


  View.prototype.getTheme = function () {
    return this.themeObject;
  };
  /**
   *  x  scale 
   * @returns view  Geometry  x scale
   */


  View.prototype.getXScale = function () {
    //  Geometry  X scale
    //  view  Geometry  x 
    var g = this.geometries[0];
    return g ? g.getXScale() : null;
  };
  /**
   *  y  scales 
   * @returns view  Geometry  y scale 
   */


  View.prototype.getYScales = function () {
    //  Geometry  Y scale
    var tmpMap = {};
    return this.geometries.map(function (g) {
      var yScale = g.getYScale();
      var field = yScale.field;

      if (!tmpMap[field]) {
        tmpMap[field] = true;
        return yScale;
      }
    });
  };
  /**
   *  x  y  scale 
   * @param dimType x | y
   * @returns x  y  scale 
   */


  View.prototype.getScalesByDim = function (dimType) {
    var geometries = this.geometries;
    var scales = {};

    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i];
      var scale = dimType === 'x' ? geometry.getXScale() : geometry.getYScale();

      if (scale && !scales[scale.field]) {
        scales[scale.field] = scale;
      }
    }

    return scales;
  };
  /**
   *  scale 
   * @param field 
   * @param key id
   */


  View.prototype.getScaleByField = function (field, key) {
    var defaultKey = key ? key : this.getScaleKey(field); //  view 

    return this.getRootView().scalePool.getScale(defaultKey);
  };
  /**
   * 
   * @returns  view API 
   */


  View.prototype.getOptions = function () {
    return this.options;
  };
  /**
   *  view 
   * @returns 
   */


  View.prototype.getData = function () {
    return this.filteredData;
  };
  /**
   *  group
   * @param layer 
   * @returns  Group
   */


  View.prototype.getLayer = function (layer) {
    return layer === constant_1.LAYER.BG ? this.backgroundGroup : layer === constant_1.LAYER.MID ? this.middleGroup : layer === constant_1.LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
  };
  /**
   * 
   * @param point 
   */


  View.prototype.isPointInPlot = function (point) {
    return coordinate_1.isPointInCoordinate(this.getCoordinate(), point);
  };
  /**
   *  legend  attribute 
   * @returns  Attribute 
   */


  View.prototype.getLegendAttributes = function () {
    return util_1.flatten(this.geometries.map(function (g) {
      return g.getGroupAttributes();
    }));
  };
  /**
   *  scale 
   * @returns  scale 
   */


  View.prototype.getGroupScales = function () {
    //  Geometry   scale
    var scales = this.geometries.map(function (g) {
      return g.getGroupScales();
    });
    return helper_1.uniq(util_1.flatten(scales));
  };
  /**
   *  G.Canvas 
   * @returns G.Canvas 
   */


  View.prototype.getCanvas = function () {
    return this.getRootView().canvas;
  };
  /**
   *  view
   */


  View.prototype.getRootView = function () {
    var v = this;

    while (true) {
      if (v.parent) {
        v = v.parent;
        continue;
      }

      break;
    }

    return v;
  };
  /**
   * 
   * @param data 
   * @returns 
   */


  View.prototype.getXY = function (data) {
    var coordinate = this.getCoordinate();
    var xScales = this.getScalesByDim('x');
    var yScales = this.getScalesByDim('y');
    var x;
    var y;
    util_1.each(data, function (value, key) {
      if (xScales[key]) {
        x = xScales[key].scale(value);
      }

      if (yScales[key]) {
        y = yScales[key].scale(value);
      }
    });

    if (!util_1.isNil(x) && !util_1.isNil(y)) {
      return coordinate.convert({
        x: x,
        y: y
      });
    }
  };
  /**
   *  name  controller 
   * @param name
   */


  View.prototype.getController = function (name) {
    return util_1.find(this.controllers, function (c) {
      return c.name === name;
    });
  };
  /**
   *  point  tooltip
   * @param point 
   * @returns View
   */


  View.prototype.showTooltip = function (point) {
    var tooltip = this.getController('tooltip');

    if (tooltip) {
      tooltip.showTooltip(point);
    }

    return this;
  };
  /**
   *  tooltip
   * @returns View
   */


  View.prototype.hideTooltip = function () {
    var tooltip = this.getController('tooltip');

    if (tooltip) {
      tooltip.hideTooltip();
    }

    return this;
  };
  /**
   *  tooltip 
   * @returns View
   */


  View.prototype.lockTooltip = function () {
    var tooltip = this.getController('tooltip');

    if (tooltip) {
      tooltip.lockTooltip();
    }

    return this;
  };
  /**
   *  tooltip 
   * @returns View
   */


  View.prototype.unlockTooltip = function () {
    var tooltip = this.getController('tooltip');

    if (tooltip) {
      tooltip.unlockTooltip();
    }

    return this;
  };
  /**
   *  tooltip
   * @returns 
   */


  View.prototype.isTooltipLocked = function () {
    var tooltip = this.getController('tooltip');
    return tooltip && tooltip.isTooltipLocked();
  };
  /**
   *  point  tooltip 
   * @param point 
   * @returns tooltip 
   */


  View.prototype.getTooltipItems = function (point) {
    var tooltip = this.getController('tooltip');
    return tooltip ? tooltip.getTooltipItems(point) : [];
  };
  /**
   * 
   * @param point 
   * @returns  
   */


  View.prototype.getSnapRecords = function (point) {
    var geometries = this.geometries;
    var rst = [];

    for (var i = 0, len = geometries.length; i < len; i++) {
      var geom = geometries[i];
      var dataArray = geom.dataArray;
      geom.sort(dataArray); //  tooltip 

      var record = void 0;

      for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
        var data = dataArray[j];
        record = tooltip_1.findDataByPoint(point, data, geom);

        if (record) {
          rst.push(record);
        }
      }
    } //  views


    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      var snapRecords = view.getSnapRecords(point);
      rst = rst.concat(snapRecords);
    }

    return rst;
  };
  /**
   *  pure component 
   */


  View.prototype.getComponents = function () {
    var components = [];
    var controllers = this.controllers;

    for (var i = 0, len = controllers.length; i < len; i++) {
      var controller = controllers[i];
      components = components.concat(controller.getComponents());
    }

    return components;
  };
  /**
   *  data 
   * @param data
   * @returns 
   */


  View.prototype.filterData = function (data) {
    var filters = this.options.filters; //  filters

    if (util_1.size(filters) === 0) {
      return data;
    } //   


    return util_1.filter(data, function (datum, idx) {
      //  filter 
      var fields = Object.keys(filters); // 

      return fields.every(function (field) {
        var condition = filters[field]; // condition  true

        return condition(datum[field], datum, idx);
      });
    });
  };
  /**
   * 
   * @param field
   * @param data
   */


  View.prototype.filterFieldData = function (field, data) {
    var filters = this.options.filters;
    var condition = util_1.get(filters, field);

    if (util_1.isUndefined(condition)) {
      return data;
    }

    return data.filter(function (datum, idx) {
      return condition(datum[field], datum, idx);
    });
  };
  /**
   *  coordinate 
   */


  View.prototype.adjustCoordinate = function () {
    var _a = this.getCoordinate(),
        curStart = _a.start,
        curEnd = _a.end;

    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr; //  defaultLayoutFn  coordinateBBox  adjustCoordinate()

    if (util_1.isEqual(curStart, start) && util_1.isEqual(curEnd, end)) {
      this.isCoordinateChanged = false; // 

      return;
    }

    this.isCoordinateChanged = true;
    this.coordinateInstance = this.coordinateController.adjust(start, end);
  };

  View.prototype.paint = function (isUpdate) {
    this.renderDataRecursive(isUpdate); //  sync scale 

    this.syncScale();
    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_PAINT); //  padding

    this.renderPaddingRecursive(isUpdate); // 

    this.renderLayoutRecursive(isUpdate); //  shape

    this.renderBackgroundStyleShape(); //  render

    this.renderPaintRecursive(isUpdate);
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_PAINT);
    this.isDataChanged = false; // 
  };
  /**
   *  shape
   *  view  view 
   */


  View.prototype.renderBackgroundStyleShape = function () {
    // 
    if (this.parent) {
      return;
    }

    var background = util_1.get(this.themeObject, 'background'); // 

    if (background) {
      // 1. 
      if (!this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape = this.backgroundGroup.addShape('rect', {
          attrs: {},
          zIndex: -1,
          //  shape 
          capture: false
        });
        this.backgroundStyleRectShape.toBack();
      } // 2.  shape 


      var _a = this.viewBBox,
          x = _a.x,
          y = _a.y,
          width = _a.width,
          height = _a.height;
      this.backgroundStyleRectShape.attr({
        fill: background,
        x: x,
        y: y,
        width: width,
        height: height
      });
    } else {
      // 
      if (this.backgroundStyleRectShape) {
        this.backgroundStyleRectShape.remove(true);
        this.backgroundStyleRectShape = undefined;
      }
    }
  };
  /**
   *  view  padding coordinateBBox  coordinateInstance
   * @param isUpdate
   */


  View.prototype.renderPaddingRecursive = function (isUpdate) {
    // 1.  view  coordinateBBoxchangeSize 
    this.calculateViewBBox(); // 2.  coordinate

    this.adjustCoordinate(); // 3.  component

    this.initComponents(isUpdate); // 4.  view  padding 
    // 4.1.  auto padding -> absolute padding appendPadding

    this.autoPadding = auto_1.calculatePadding(this).shrink(padding_1.parsePadding(this.appendPadding)); // 4.2.  coordinateBBox Coordinate
    //  view  viewBBox  parent  coordinateBBox

    this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
    this.adjustCoordinate(); //  views

    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaddingRecursive(isUpdate);
    }
  };
  /**
   *  view  view  coordinateBBox  coordinateInstance
   * @param isUpdate
   */


  View.prototype.renderLayoutRecursive = function (isUpdate) {
    // 1.  view padding
    //  padding
    var syncViewPaddingFn = this.syncViewPadding === true ? sync_view_padding_1.defaultSyncViewPadding : util_1.isFunction(this.syncViewPadding) ? this.syncViewPadding : undefined;

    if (syncViewPaddingFn) {
      syncViewPaddingFn(this, this.views, padding_cal_1.PaddingCal); //  padding  coordinate

      this.views.forEach(function (v) {
        v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
        v.adjustCoordinate();
      });
    } // 3.  view  view padding 


    this.doLayout(); //  views

    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderLayoutRecursive(isUpdate);
    }
  };
  /**
   * 
   * @param isUpdate
   */


  View.prototype.renderPaintRecursive = function (isUpdate) {
    var middleGroup = this.middleGroup;

    if (this.limitInPlot) {
      var _a = coordinate_1.getCoordinateClipCfg(this.coordinateInstance),
          type = _a.type,
          attrs = _a.attrs;

      middleGroup.setClip({
        type: type,
        attrs: attrs
      });
    } else {
      //  clip
      middleGroup.setClip(undefined);
    } // 1. 


    this.paintGeometries(isUpdate); // 2. 

    this.renderComponents(isUpdate); //  views

    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderPaintRecursive(isUpdate);
    }
  }; // end Get 

  /**
   *  scale view  scale
   * @param field
   * @param data
   * @param scaleDef
   * @param key
   */


  View.prototype.createScale = function (field, data, scaleDef, key) {
    // 1.  field  scaleDef
    var currentScaleDef = util_1.get(this.options.scales, [field]);

    var mergedScaleDef = tslib_1.__assign(tslib_1.__assign({}, currentScaleDef), scaleDef); // 2.  view


    if (this.parent) {
      return this.parent.createScale(field, data, mergedScaleDef, key);
    } // 3.  view  scalePool 


    return this.scalePool.createScale(field, data, mergedScaleDef, key);
  };
  /**
   * 
   * @param isUpdate
   */


  View.prototype.renderDataRecursive = function (isUpdate) {
    // 1. 
    this.doFilterData(); // 2. 

    this.createCoordinate(); // 3.  Geometry

    this.initGeometries(isUpdate); // 4.  view  geometry

    this.renderFacet(isUpdate); //  views

    var views = this.views;

    for (var i = 0, len = views.length; i < len; i++) {
      var view = views[i];
      view.renderDataRecursive(isUpdate);
    }
  };
  /**
   *  region
   * @private
   */


  View.prototype.calculateViewBBox = function () {
    var x;
    var y;
    var width;
    var height;

    if (this.parent) {
      var bbox = this.parent.coordinateBBox; //  parent 

      x = bbox.x;
      y = bbox.y;
      width = bbox.width;
      height = bbox.height;
    } else {
      //  canvas  
      x = 0;
      y = 0;
      width = this.canvas.get('width');
      height = this.canvas.get('height');
    }

    var _a = this.region,
        start = _a.start,
        end = _a.end; //  region  view  bbox 

    var viewBBox = new bbox_1.BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));

    if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
      // viewBBox 
      this.viewBBox = new bbox_1.BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
    } //  coordinate bbox 


    this.coordinateBBox = this.viewBBox;
  };
  /**
   * G 4.0  name:event  name 
   *
   * G2  view 
   *  view  view  Component  Geometry 
   * @private
   */


  View.prototype.initEvents = function () {
    //  group  shape  G 
    this.foregroundGroup.on('*', this.onDelegateEvents);
    this.middleGroup.on('*', this.onDelegateEvents);
    this.backgroundGroup.on('*', this.onDelegateEvents);
    this.canvas.on('*', this.onCanvasEvent);
  };
  /**
   * 
   */


  View.prototype.initComponentController = function () {
    var usedControllers = this.usedControllers;

    for (var i = 0, len = usedControllers.length; i < len; i++) {
      var controllerName = usedControllers[i];
      var Ctor = controller_1.getComponentController(controllerName);

      if (Ctor) {
        this.controllers.push(new Ctor(this));
      }
    }
  };

  View.prototype.createViewEvent = function (evt) {
    var shape = evt.shape,
        name = evt.name;
    var data = shape ? shape.get('origin') : null; //  view 

    var e = new event_1.default(this, evt, data);
    e.type = name;
    return e;
  };
  /**
   *  PLOT_EVENTS
   * plot event  emit
   *  mouseentermouseleave 
   * @param e
   */


  View.prototype.doPlotEvent = function (e) {
    var type = e.type,
        x = e.x,
        y = e.y;
    var point = {
      x: x,
      y: y
    };
    var ALL_EVENTS = ['mousedown', 'mouseup', 'mousemove', 'mouseleave', 'mousewheel', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'click', 'dblclick', 'contextmenu'];

    if (ALL_EVENTS.includes(type)) {
      var currentInPlot = this.isPointInPlot(point);

      if (currentInPlot) {
        var TYPE = "plot:" + type; //  plot 

        e.type = TYPE;
        this.emit(TYPE, e);

        if (type === 'mouseleave' || type === 'touchend') {
          // plot 
          this.isPreMouseInPlot = false;
        }
      } //  mouseenter, mouseleave 


      if (type === 'mousemove' || type === 'touchmove') {
        if (this.isPreMouseInPlot && !currentInPlot) {
          if (type === 'mousemove') {
            e.type = constant_1.PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_LEAVE, e);
          }

          e.type = constant_1.PLOT_EVENTS.LEAVE;
          this.emit(constant_1.PLOT_EVENTS.LEAVE, e);
        } else if (!this.isPreMouseInPlot && currentInPlot) {
          if (type === 'mousemove') {
            e.type = constant_1.PLOT_EVENTS.MOUSE_ENTER;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_ENTER, e);
          }

          e.type = constant_1.PLOT_EVENTS.ENTER;
          this.emit(constant_1.PLOT_EVENTS.ENTER, e);
        } // 


        this.isPreMouseInPlot = currentInPlot;
      } else if (type === 'mouseleave' || type === 'touchend') {
        //  currentInPlot 
        if (this.isPreMouseInPlot) {
          if (type === 'mouseleave') {
            e.type = constant_1.PLOT_EVENTS.MOUSE_LEAVE;
            this.emit(constant_1.PLOT_EVENTS.MOUSE_LEAVE, e);
          }

          e.type = constant_1.PLOT_EVENTS.LEAVE;
          this.emit(constant_1.PLOT_EVENTS.LEAVE, e);
          this.isPreMouseInPlot = false;
        }
      }
    }
  }; // view   

  /**
   * 
   * @private
   */


  View.prototype.doFilterData = function () {
    var data = this.options.data;
    this.filteredData = this.filterData(data);
  };
  /**
   *  Geometries
   * @private
   */


  View.prototype.initGeometries = function (isUpdate) {
    //  /  scales
    this.createOrUpdateScales(); //  Geometry view  scale 

    var coordinate = this.getCoordinate();
    var scaleDefs = util_1.get(this.options, 'scales', {});
    var geometries = this.geometries;

    for (var i = 0, len = geometries.length; i < len; i++) {
      var geometry = geometries[i]; //  scales 

      geometry.scales = this.getGeometryScales();
      var cfg = {
        coordinate: coordinate,
        scaleDefs: scaleDefs,
        data: this.filteredData,
        theme: this.themeObject,
        isDataChanged: this.isDataChanged,
        isCoordinateChanged: this.isCoordinateChanged
      };

      if (isUpdate) {
        // 
        geometry.update(cfg);
      } else {
        geometry.init(cfg);
      }
    } // Geometry  scale scale 


    this.adjustScales();
  };
  /**
   *  Geometry  scales
   * 
   */


  View.prototype.createOrUpdateScales = function () {
    var fields = this.getScaleFields();
    var groupedFields = this.getGroupedFields();

    var _a = this.getOptions(),
        data = _a.data,
        _b = _a.scales,
        scales = _b === void 0 ? {} : _b;

    var filteredData = this.filteredData;

    for (var i = 0, len = fields.length; i < len; i++) {
      var field = fields[i];
      var scaleDef = scales[field]; // 

      var key = this.getScaleKey(field);
      this.createScale(field, //  scale 
      groupedFields.includes(field) ? data : filteredData, scaleDef, key); //  view  scale key

      this.createdScaleKeys.set(key, true);
    }
  };
  /**
   *  scale 
   */


  View.prototype.syncScale = function () {
    //  root view 
    this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
  };
  /**
   *  Geometry  scale 
   */


  View.prototype.getGeometryScales = function () {
    var fields = this.getScaleFields();
    var scales = {};

    for (var i = 0; i < fields.length; i++) {
      var field = fields[i];
      scales[field] = this.getScaleByField(field);
    }

    return scales;
  };

  View.prototype.getScaleFields = function () {
    var fields = [];
    var tmpMap = {};
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var geometryScales = geometry.getScaleFields();
      helper_1.uniq(geometryScales, fields, tmpMap);
    }

    return fields;
  };

  View.prototype.getGroupedFields = function () {
    var fields = [];
    var tmpMap = {};
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      var groupFields = geometry.getGroupFields();
      helper_1.uniq(groupFields, fields, tmpMap);
    }

    return fields;
  };
  /**
   *  scale 
   * @private
   */


  View.prototype.adjustScales = function () {
    // 
    //  scale range 
    this.adjustCategoryScaleRange();
  };
  /**
   *  scale  range
   * @private
   */


  View.prototype.adjustCategoryScaleRange = function () {
    var _this = this;

    var xyScales = tslib_1.__spreadArrays([this.getXScale()], this.getYScales()).filter(function (e) {
      return !!e;
    });

    var coordinate = this.getCoordinate();
    var scaleOptions = this.options.scales;
    util_1.each(xyScales, function (scale) {
      var field = scale.field,
          values = scale.values,
          isCategory = scale.isCategory,
          isIdentity = scale.isIdentity; //  identity  scale 

      if (isCategory || isIdentity) {
        //  value  range 
        if (values && !util_1.get(scaleOptions, [field, 'range'])) {
          //  range
          scale.range = scale_1.getDefaultCategoryScaleRange(scale, coordinate, _this.theme);
        }
      }
    });
  };
  /**
   *  options Geometry  components
   * @param isUpdate 
   * @private
   */


  View.prototype.initComponents = function (isUpdate) {
    //  render
    var controllers = this.controllers;

    for (var i = 0; i < controllers.length; i++) {
      var controller = controllers[i]; // 

      if (isUpdate) {
        controller.update();
      } else {
        controller.clear();
        controller.render();
      }
    }
  };

  View.prototype.doLayout = function () {
    this.layoutFunc(this);
  };
  /**
   * 
   * @private
   */


  View.prototype.createCoordinate = function () {
    var start = this.coordinateBBox.bl;
    var end = this.coordinateBBox.tr;
    this.coordinateInstance = this.coordinateController.create(start, end);
  };
  /**
   *  options  geometry
   * @private
   */


  View.prototype.paintGeometries = function (isUpdate) {
    var doAnimation = this.options.animate; // geometry  paint 

    var coordinate = this.getCoordinate();
    var canvasRegion = {
      x: this.viewBBox.x,
      y: this.viewBBox.y,
      minX: this.viewBBox.minX,
      minY: this.viewBBox.minY,
      maxX: this.viewBBox.maxX,
      maxY: this.viewBBox.maxY,
      width: this.viewBBox.width,
      height: this.viewBBox.height
    };
    var geometries = this.geometries;

    for (var i = 0; i < geometries.length; i++) {
      var geometry = geometries[i];
      geometry.coordinate = coordinate;
      geometry.canvasRegion = canvasRegion;

      if (!doAnimation) {
        //  view  view  geometry 
        geometry.animate(false);
      }

      geometry.paint(isUpdate);
    }
  };
  /**
   * 
   * @param isUpdate
   */


  View.prototype.renderComponents = function (isUpdate) {
    //  render
    for (var i = 0; i < this.getComponents().length; i++) {
      var co = this.getComponents()[i];
      co.component.render();
    }
  };
  /**
   *  view 
   * @param isUpdate
   */


  View.prototype.renderFacet = function (isUpdate) {
    if (this.facetInstance) {
      if (isUpdate) {
        this.facetInstance.update();
      } else {
        this.facetInstance.clear(); // 

        this.facetInstance.init(); //  views

        this.facetInstance.render();
      }
    }
  };

  View.prototype.initOptions = function () {
    var _this = this;

    var _a = this.options,
        _b = _a.geometries,
        geometries = _b === void 0 ? [] : _b,
        _c = _a.interactions,
        interactions = _c === void 0 ? [] : _c,
        _d = _a.views,
        views = _d === void 0 ? [] : _d,
        _e = _a.annotations,
        annotations = _e === void 0 ? [] : _e,
        coordinate = _a.coordinate,
        events = _a.events,
        facets = _a.facets; // 

    if (this.coordinateController) {
      //  coordinate controller
      coordinate && this.coordinateController.update(coordinate);
    } else {
      //  coordinate controller
      this.coordinateController = new coordinate_2.default(coordinate);
    } //  geometry 


    for (var i = 0; i < geometries.length; i++) {
      var geometryOption = geometries[i];
      this.createGeometry(geometryOption);
    } //  interactions 


    for (var j = 0; j < interactions.length; j++) {
      var interactionOption = interactions[j];
      var type = interactionOption.type,
          cfg = interactionOption.cfg;
      this.interaction(type, cfg);
    } //  view 


    for (var k = 0; k < views.length; k++) {
      var viewOption = views[k];
      this.createView(viewOption);
    } //  annotation


    var annotationComponent = this.getController('annotation');

    for (var l = 0; l < annotations.length; l++) {
      var annotationOption = annotations[l];
      annotationComponent.annotation(annotationOption);
    } //  events


    if (events) {
      util_1.each(events, function (eventCallback, eventName) {
        _this.on(eventName, eventCallback);
      });
    }

    if (facets) {
      util_1.each(facets, function (facet) {
        var type = facet.type,
            rest = tslib_1.__rest(facet, ["type"]);

        _this.facet(type, rest);
      });
    }
  };

  View.prototype.createGeometry = function (geometryOption) {
    var type = geometryOption.type,
        _a = geometryOption.cfg,
        cfg = _a === void 0 ? {} : _a;

    if (this[type]) {
      var geometry_1 = this[type](cfg);
      util_1.each(geometryOption, function (v, k) {
        if (util_1.isFunction(geometry_1[k])) {
          geometry_1[k](v);
        }
      });
    }
  };
  /**
   * scale key 
   * @param field
   */


  View.prototype.getScaleKey = function (field) {
    return this.id + "-" + field;
  };

  return View;
}(base_1.default);

exports.View = View;
/**
 *  geometry 
 * @param name
 * @param Ctor
 * @returns Geometry
 */

function registerGeometry(name, Ctor) {
  //  view API 
  View.prototype[name.toLowerCase()] = function (cfg) {
    if (cfg === void 0) {
      cfg = {};
    }

    var props = tslib_1.__assign({
      /**  */
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);

    var geometry = new Ctor(props);
    this.geometries.push(geometry);
    return geometry;
  };
}

exports.registerGeometry = registerGeometry;
exports.default = View;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 
 */

var Interaction =
/** @class */
function () {
  function Interaction(view, cfg) {
    this.view = view;
    this.cfg = cfg;
  }
  /**
   * 
   */


  Interaction.prototype.init = function () {
    this.initEvents();
  };
  /**
   * 
   */


  Interaction.prototype.initEvents = function () {};
  /**
   * 
   */


  Interaction.prototype.clearEvents = function () {};
  /**
   * 
   */


  Interaction.prototype.destroy = function () {
    this.clearEvents();
  };

  return Interaction;
}();

exports.default = Interaction;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var create_theme_1 = __webpack_require__(894);

Object.defineProperty(exports, "createTheme", {
  enumerable: true,
  get: function get() {
    return create_theme_1.createTheme;
  }
});

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getComponentController = exports.getComponentControllerNames = exports.unregisterComponentController = exports.registerComponentController = void 0;
var LOAD_COMPONENT_CONTROLLERS = {};
/**
 * 
 * @param name 
 * @param plugin 
 * @returns void
 */

function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}

exports.registerComponentController = registerComponentController;
/**
 * 
 * @param name 
 * @returns void
 */

function unregisterComponentController(name) {
  delete LOAD_COMPONENT_CONTROLLERS[name];
}

exports.unregisterComponentController = unregisterComponentController;
/**
 * 
 * @returns string[] 
 */

function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}

exports.getComponentControllerNames = getComponentControllerNames;
/**
 * 
 * @param name 
 * @returns 
 */

function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}

exports.getComponentController = getComponentController;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PaddingCal = void 0;

var tslib_1 = __webpack_require__(1);

var constant_1 = __webpack_require__(20);
/** @ignore */


var PaddingCal =
/** @class */
function () {
  /**
   *  padding 
   * @param top
   * @param right
   * @param bottom
   * @param left
   */
  function PaddingCal(top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }

    if (right === void 0) {
      right = 0;
    }

    if (bottom === void 0) {
      bottom = 0;
    }

    if (left === void 0) {
      left = 0;
    }

    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left;
  }
  /**
   * 
   * @param top
   * @param right
   * @param bottom
   * @param left
   */


  PaddingCal.instance = function (top, right, bottom, left) {
    if (top === void 0) {
      top = 0;
    }

    if (right === void 0) {
      right = 0;
    }

    if (bottom === void 0) {
      bottom = 0;
    }

    if (left === void 0) {
      left = 0;
    }

    return new PaddingCal(top, right, bottom, left);
  };
  /**
   * 
   * @param padding
   */


  PaddingCal.prototype.max = function (padding) {
    var top = padding[0],
        right = padding[1],
        bottom = padding[2],
        left = padding[3];
    this.top = Math.max(this.top, top);
    this.right = Math.max(this.right, right);
    this.bottom = Math.max(this.bottom, bottom);
    this.left = Math.max(this.left, left);
    return this;
  };
  /**
   *  padding
   * @param padding
   */


  PaddingCal.prototype.shrink = function (padding) {
    var top = padding[0],
        right = padding[1],
        bottom = padding[2],
        left = padding[3];
    this.top += top;
    this.right += right;
    this.bottom += bottom;
    this.left += left;
    return this;
  };
  /**
   *  padding
   * @param bbox
   * @param direction
   */


  PaddingCal.prototype.inc = function (bbox, direction) {
    var width = bbox.width,
        height = bbox.height;

    switch (direction) {
      case constant_1.DIRECTION.TOP:
      case constant_1.DIRECTION.TOP_LEFT:
      case constant_1.DIRECTION.TOP_RIGHT:
        this.top += height;
        break;

      case constant_1.DIRECTION.RIGHT:
      case constant_1.DIRECTION.RIGHT_TOP:
      case constant_1.DIRECTION.RIGHT_BOTTOM:
        this.right += width;
        break;

      case constant_1.DIRECTION.BOTTOM:
      case constant_1.DIRECTION.BOTTOM_LEFT:
      case constant_1.DIRECTION.BOTTOM_RIGHT:
        this.bottom += height;
        break;

      case constant_1.DIRECTION.LEFT:
      case constant_1.DIRECTION.LEFT_TOP:
      case constant_1.DIRECTION.LEFT_BOTTOM:
        this.left += width;
        break;

      default:
        break;
    }

    return this;
  };
  /**
   *  padding
   */


  PaddingCal.prototype.getPadding = function () {
    return [this.top, this.right, this.bottom, this.left];
  };
  /**
   * clone  padding cal
   */


  PaddingCal.prototype.clone = function () {
    return new (PaddingCal.bind.apply(PaddingCal, tslib_1.__spreadArrays([void 0], this.getPadding())))();
  };

  return PaddingCal;
}();

exports.PaddingCal = PaddingCal;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isModelChange = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 * Determines whether model is change
 * @param currentModel
 * @param preModel
 * @returns
 */


function isModelChange(currentModel, preModel) {
  return util_1.some(['color', 'shape', 'size', 'x', 'y', 'isInCircle', 'data', 'style', 'defaultStyle', 'points', 'mappingData'], function (key) {
    return !util_1.isEqual(currentModel[key], preModel[key]);
  });
}

exports.isModelChange = isModelChange;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCustomLegendItems = exports.getLegendItems = exports.getLegendLayout = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var attr_1 = __webpack_require__(904);

var marker_1 = __webpack_require__(147);
/**  marker symbol */


var STROKES_SYMBOLS = ['line', 'cross', 'tick', 'plus', 'hyphen'];

function adpatorMarkerStyle(marker, color) {
  var symbol = marker.symbol;

  if (util_1.isString(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    marker.style = util_1.deepMix({}, marker.style, {
      lineWidth: 1,
      stroke: color,
      fill: null
    });
  }
}

function setMarkerSymbol(marker) {
  var symbol = marker.symbol;

  if (util_1.isString(symbol) && marker_1.MarkerSymbols[symbol]) {
    marker.symbol = marker_1.MarkerSymbols[symbol];
  }
}
/**
 * @ignore
 * get the legend layout from direction
 * @param direction
 * @returns layout 'horizontal' | 'vertical'
 */


function getLegendLayout(direction) {
  return direction.startsWith(constant_1.DIRECTION.LEFT) || direction.startsWith(constant_1.DIRECTION.RIGHT) ? 'vertical' : 'horizontal';
}

exports.getLegendLayout = getLegendLayout;
/**
 * @ignore
 * get the legend items
 * @param view
 * @param geometry
 * @param attr
 * @param themeMarker
 * @param userMarker
 * @returns legend items
 */

function getLegendItems(view, geometry, attr, themeMarker, userMarker) {
  var scale = attr.getScale(attr.type);

  if (scale.isCategory) {
    var field_1 = scale.field;
    var colorAttr_1 = geometry.getAttribute('color');
    var shapeAttr_1 = geometry.getAttribute('shape');
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry.coordinate.isPolar;
    return scale.getTicks().map(function (tick) {
      var _a;

      var text = tick.text,
          scaleValue = tick.value;
      var name = text;
      var value = scale.invert(scaleValue); //  unchecked

      var unchecked = view.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length === 0;
      util_1.each(view.views, function (subView) {
        var _a;

        if (!subView.filterFieldData(field_1, [(_a = {}, _a[field_1] = value, _a)]).length) {
          unchecked = true;
        }
      }); // @ts-ignore

      var color = attr_1.getMappingValue(colorAttr_1, value, defaultColor_1);
      var shape = attr_1.getMappingValue(shapeAttr_1, value, 'point');
      var marker = geometry.getShapeMarker(shape, {
        color: color,
        isInPolar: isInPolar_1
      }); // the marker configure order should be ensure

      marker = util_1.deepMix({}, themeMarker, marker, userMarker);
      adpatorMarkerStyle(marker, color);
      setMarkerSymbol(marker);
      return {
        id: value,
        name: name,
        value: value,
        marker: marker,
        unchecked: unchecked
      };
    });
  }

  return [];
}

exports.getLegendItems = getLegendItems;
/**
 * @ignore
 * custom legend  items 
 * @param themeMarker
 * @param userMarker
 * @param customItems
 */

function getCustomLegendItems(themeMarker, userMarker, customItems) {
  //  item marker 
  return customItems.map(function (item) {
    var marker = util_1.deepMix({}, themeMarker, userMarker, item.marker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}

exports.getCustomLegendItems = getCustomLegendItems;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseLineGradient = parseLineGradient;
exports.parseRadialGradient = parseRadialGradient;
exports.parsePattern = parsePattern;
exports.parseStyle = parseStyle;
exports.parseRadius = parseRadius;

var _util = __webpack_require__(54);

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;

function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  (0, _util.each)(arr, function (item) {
    var itemArr = item.split(':');
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
/**
 * 
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   gradientStr   
 * @returns {any} 
 */


function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box = element.getBBox();
  var start;
  var end;

  if (angle >= 0 && angle < 1 / 2 * Math.PI) {
    start = {
      x: box.minX,
      y: box.minY
    };
    end = {
      x: box.maxX,
      y: box.maxY
    };
  } else if (1 / 2 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: box.maxX,
      y: box.minY
    };
    end = {
      x: box.minX,
      y: box.maxY
    };
  } else if (Math.PI <= angle && angle < 3 / 2 * Math.PI) {
    start = {
      x: box.maxX,
      y: box.maxY
    };
    end = {
      x: box.minX,
      y: box.minY
    };
  } else {
    start = {
      x: box.minX,
      y: box.maxY
    };
    end = {
      x: box.maxX,
      y: box.minY
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x, y);
  addStop(steps, gradient);
  return gradient;
}
/**
 * 
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   gradientStr   
 * @returns {any} 
 */


function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4]; // 0

  if (fr === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(':')[1];
  }

  var box = element.getBBox();
  var width = box.maxX - box.minX;
  var height = box.maxY - box.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box.minX + width * fx, box.minY + height * fy, 0, box.minX + width / 2, box.minY + height / 2, fr * r);
  addStop(steps, gradient);
  return gradient;
}
/**
 *  pattern
 * @param {CanvasRenderingContext2D} context canvas 
 * @param {IElement}                 element  
 * @param {string}                   patternStr    pattern 
 */


function parsePattern(context, element, patternStr) {
  // 
  if (element.get('patternSource') && element.get('patternSource') === patternStr) {
    return element.get('pattern');
  }

  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2]; // Function to be called when pattern loads

  function onload() {
    // Create pattern
    pattern = context.createPattern(img, repeat);
    element.set('pattern', pattern); // be a cache

    element.set('patternSource', patternStr);
  }

  switch (repeat) {
    case 'a':
      repeat = 'repeat';
      break;

    case 'x':
      repeat = 'repeat-x';
      break;

    case 'y':
      repeat = 'repeat-y';
      break;

    case 'n':
      repeat = 'no-repeat';
      break;

    default:
      repeat = 'no-repeat';
  }

  img = new Image(); // If source URL is not a data URL

  if (!source.match(/^data:/i)) {
    // Set crossOrigin for this image
    img.crossOrigin = 'Anonymous';
  }

  img.src = source;

  if (img.complete) {
    onload();
  } else {
    img.onload = onload; // Fix onload() bug in IE9

    img.src = img.src;
  }

  return pattern;
}

function parseStyle(context, element, color) {
  if ((0, _util.isString)(color)) {
    if (color[1] === '(' || color[2] === '(') {
      if (color[0] === 'l') {
        // regexLG.test(color)
        return parseLineGradient(context, element, color);
      }

      if (color[0] === 'r') {
        // regexRG.test(color)
        return parseRadialGradient(context, element, color);
      }

      if (color[0] === 'p') {
        // regexPR.test(color)
        return parsePattern(context, element, color);
      }
    }

    return color;
  }
}

function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;

  if ((0, _util.isArray)(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }

  return [r1, r2, r3, r4];
}

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getArcParams;

var _util = __webpack_require__(54);

// 
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
} // u.v/|u||v|


function vRatio(u, v) {
  //  0  0 1
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
} // 


function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
} // A 0:rx 1:ry 2:x-axis-rotation 3:large-arc-flag 4:sweep-flag 5: x 6: y


function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = (0, _util.mod)((0, _util.toRadian)(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5]; // 

  var x1 = startPoint[0];
  var y1 = startPoint[1]; // 

  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2.0 + Math.sin(xRotation) * (y1 - y2) / 2.0;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2.0 + Math.cos(xRotation) * (y1 - y2) / 2.0;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }

  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;

  if (arcFlag === sweepFlag) {
    f *= -1;
  }

  if (isNaN(f)) {
    f = 0;
  } //  0  (0, 0) 


  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0; // 

  var cx = (x1 + x2) / 2.0 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2.0 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp; // 

  var u = [(xp - cxp) / rx, (yp - cyp) / ry]; // 

  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry]; //  x 

  var theta = vAngle([1, 0], u); // 

  var dTheta = vAngle(u, v);

  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }

  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }

  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }

  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }

  return {
    cx: cx,
    cy: cy,
    //  0 
    rx: (0, _util.isSamePoint)(startPoint, [x2, y2]) ? 0 : rx,
    ry: (0, _util.isSamePoint)(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation: xRotation,
    arcFlag: arcFlag,
    sweepFlag: sweepFlag
  };
}

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPointInPath;

var _gBase = __webpack_require__(27);

function isPointInPath(shape, x, y) {
  var ctx = (0, _gBase.getOffScreenContext)();
  shape.createPath(ctx);
  return ctx.isPointInPath(x, y);
}

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isInPolygon;

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
// https://blog.csdn.net/WilliamSun0122/article/details/77994526
var tolerance = 1e-6; // doubleeps

function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }

  return x < 0 ? -1 : 1;
} // Qp1p2


function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }

  return false;
} // P-


function isInPolygon(points, x, y) {
  var isHit = false;
  var n = points.length;

  if (n <= 2) {
    // svg  3 
    return false;
  }

  for (var i = 0; i < n; i++) {
    var p1 = points[i];
    var p2 = points[(i + 1) % n];

    if (onSegment(p1, p2, [x, y])) {
      // 
      return true;
    } // min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])
    //    


    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }

  return isHit;
}

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = arc;

var _util = __webpack_require__(54);

function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2); //  0 - 2 * Math.PI 

  if (angle < startAngle || angle > endAngle) {
    return false;
  }

  var point = {
    x: cx + r * Math.cos(angle),
    y: cy + r * Math.sin(angle)
  };
  return (0, _util.distance)(point.x, point.y, x, y) <= lineWidth / 2;
}

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inPolyline;

var _line = _interopRequireDefault(__webpack_require__(191));

function inPolyline(points, lineWidth, x, y, isClose) {
  var count = points.length;

  if (count < 2) {
    return false;
  }

  for (var i = 0; i < count - 1; i++) {
    var x1 = points[i][0];
    var y1 = points[i][1];
    var x2 = points[i + 1][0];
    var y2 = points[i + 1][1];

    if ((0, _line.default)(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  } // 


  if (isClose) {
    var first = points[0];
    var last = points[count - 1];

    if ((0, _line.default)(first[0], first[1], last[0], last[1], lineWidth, x, y)) {
      return true;
    }
  }

  return false;
}

/***/ }),
/* 445 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(167);
/* harmony import */ var _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__["antvDark"]; });

/* harmony import */ var _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);
/* harmony import */ var _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "b", function() { return _antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]; });

/* harmony import */ var _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(109);
/* harmony import */ var _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "c", function() { return _antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"]; });

/* harmony import */ var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(91);
/* harmony import */ var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__);
// 




 // fixme: Roboto antv 

_antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__["antvDark"].fontFamily = "\"-apple-system\", \"Segoe UI\", \"Helvetica Neue\", Arial,\n\"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n\"Noto Color Emoji\", Roboto";
_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"].fontFamily = "\"-apple-system\", \"Segoe UI\", \"Helvetica Neue\", Arial,\n\"Noto Sans\", sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\",\n\"Noto Color Emoji\", Roboto";
Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('dark', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_dark__WEBPACK_IMPORTED_MODULE_0__["antvDark"]));
Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('default', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]));
Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_3__["registerTheme"])('ligtht', Object(_antv_g2_lib_theme_util_create_by_style_sheet__WEBPACK_IMPORTED_MODULE_2__["createThemeByStyleSheet"])(_antv_g2_lib_theme_style_sheet_light__WEBPACK_IMPORTED_MODULE_1__["antvLight"]));

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLineMarker = void 0;
var LineSymbols = {
  line: function line(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  dot: function dot(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  dash: function dash(x, y, r) {
    return [['M', x - r, y], ['L', x + r, y]];
  },
  smooth: function smooth(x, y, r) {
    return [['M', x - r, y], ['A', r / 2, r / 2, 0, 1, 1, x, y], ['A', r / 2, r / 2, 0, 1, 0, x + r, y]];
  },
  hv: function hv(x, y, r) {
    return [['M', x - r - 1, y - 2.5], ['L', x, y - 2.5], ['L', x, y + 2.5], ['L', x + r + 1, y + 2.5]];
  },
  vh: function vh(x, y, r) {
    return [['M', x - r - 1, y + 2.5], ['L', x, y + 2.5], ['L', x, y - 2.5], ['L', x + r + 1, y - 2.5]];
  },
  hvh: function hvh(x, y, r) {
    return [['M', x - (r + 1), y + 2.5], ['L', x - r / 2, y + 2.5], ['L', x - r / 2, y - 2.5], ['L', x + r / 2, y - 2.5], ['L', x + r / 2, y + 2.5], ['L', x + r + 1, y + 2.5]];
  },
  vhv: function vhv(x, y) {
    //  13px 8px
    return [['M', x - 5, y + 2.5], ['L', x - 5, y], ['L', x, y], ['L', x, y - 3], ['L', x, y + 3], ['L', x + 6.5, y + 3]];
  }
};
/**
 * Gets line marker
 * @ignore
 * @param markerCfg
 * @param shapeType
 * @returns  Line  marker 
 */

function getLineMarker(markerCfg, shapeType) {
  var color = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color
    }
  };
}

exports.getLineMarker = getLineMarker;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var path_1 = __webpack_require__(146);

var split_points_1 = __webpack_require__(278);

var EdgeShapeFactory = base_1.registerShapeFactory('edge', {
  defaultShapeType: 'line',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return split_points_1.splitPoints(pointInfo);
  }
});
base_1.registerShape('edge', 'line', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false, 'lineWidth');
    var path = path_1.getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      })
    });
  },
  getMarker: function getMarker(markerCfg) {
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
exports.default = EdgeShapeFactory;

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultSize = void 0;

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51); // 


function findMinDistance(arr, scale) {
  var count = arr.length;
  var sourceArr = arr;

  if (util_1.isString(sourceArr[0])) {
    //  values 
    sourceArr = arr.map(function (v) {
      return scale.translate(v);
    });
  }

  var distance = sourceArr[1] - sourceArr[0];

  for (var i = 2; i < count; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];

    if (distance > tmp) {
      distance = tmp;
    }
  }

  return distance;
}

function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = util_1.flatten(dataArray);
    var values = util_1.valuesOfKey(mergeData, dodgeBy);
    return values.length;
  }

  return dataArray.length;
}
/** @ignore */


function getDefaultSize(geometry) {
  var theme = geometry.theme;
  var coordinate = geometry.coordinate;
  var xScale = geometry.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry.beforeMappingData;
  var count = xValues.length;
  var xDimensionLength = coordinate_1.getXDimensionLength(geometry.coordinate); // 

  var intervalPadding = geometry.intervalPadding,
      dodgePadding = geometry.dodgePadding; // theme

  var maxColumnWidth = geometry.maxColumnWidth || theme.maxColumnWidth;
  var minColumnWidth = geometry.minColumnWidth || theme.minColumnWidth;
  var columnWidthRatio = geometry.columnWidthRatio || theme.columnWidthRatio;
  var multiplePieWidthRatio = geometry.multiplePieWidthRatio || theme.multiplePieWidthRatio;
  var roseWidthRatio = geometry.roseWidthRatio || theme.roseWidthRatio; // count

  if (xScale.isLinear && xValues.length > 1) {
    // Linear  min, max  count
    xValues.sort();
    var interval = findMinDistance(xValues, xScale);
    count = (xScale.max - xScale.min) / interval;

    if (xValues.length > count) {
      count = xValues.length;
    }
  }

  var range = xScale.range;
  var normalizedSize = 1 / count;
  var wr = 1;

  if (coordinate.isPolar) {
    // 
    if (coordinate.isTransposed && count > 1) {
      // 
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    // 
    if (xScale.isLinear) {
      normalizedSize *= range[1] - range[0];
    }

    wr = columnWidthRatio;
  } // 


  if (!util_1.isNil(intervalPadding) && intervalPadding >= 0) {
    // 
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count - 1) * normalizedIntervalPadding) / count;
  } else {
    // 
    normalizedSize *= wr;
  } // 


  if (geometry.getAdjust('dodge')) {
    var dodgeAdjust = geometry.getAdjust('dodge');
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);

    if (!util_1.isNil(dodgePadding) && dodgePadding >= 0) {
      // 
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!util_1.isNil(intervalPadding) && intervalPadding >= 0) {
      // wr
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      // 
      normalizedSize = normalizedSize / dodgeCount;
    }

    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  } // 


  if (!util_1.isNil(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;

    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  } // minColumnWidth0


  if (!util_1.isNil(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;

    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }

  return normalizedSize;
}

exports.getDefaultSize = getDefaultSize;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

function getPath(points) {
  var flag = points[0];
  var i = 1;
  var path = [['M', flag.x, flag.y]];

  while (i < points.length) {
    var c = points[i];

    if (c.x !== points[i - 1].x || c.y !== points[i - 1].y) {
      path.push(['L', c.x, c.y]);

      if (c.x === flag.x && c.y === flag.y && i < points.length - 1) {
        flag = points[i + 1];
        path.push(['Z']);
        path.push(['M', flag.x, flag.y]);
        i++;
      }
    }

    i++;
  }

  if (!util_1.isEqual(util_1.last(path), flag)) {
    path.push(['L', flag.x, flag.y]);
  }

  path.push(['Z']);
  return path;
}

var PolygonShapeFactory = base_1.registerShapeFactory('polygon', {
  defaultShapeType: 'polygon',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    var points = [];
    util_1.each(pointInfo.x, function (subX, index) {
      var subY = pointInfo.y[index];
      points.push({
        x: subX,
        y: subY
      });
    });
    return points;
  }
});
base_1.registerShape('polygon', 'polygon', {
  draw: function draw(cfg, container) {
    if (!util_1.isEmpty(cfg.points)) {
      var shapeAttrs = get_style_1.getStyle(cfg, true, true);
      var path = this.parsePath(getPath(cfg.points));
      return container.addShape('path', {
        attrs: tslib_1.__assign(tslib_1.__assign({}, shapeAttrs), {
          path: path
        }),
        name: 'polygon'
      });
    }
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});
exports.default = PolygonShapeFactory;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(29);

var SchemaShapeFactory = base_1.registerShapeFactory('schema', {
  defaultShapeType: ''
});
exports.default = SchemaShapeFactory;

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQPath = exports.getCPath = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 * Gets cpath
 * @param from
 * @param to
 * @returns
 */


function getCPath(from, to) {
  return ['C', from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}

exports.getCPath = getCPath;
/**
 * @ignore
 * Gets qpath
 * @param to
 * @param center
 * @returns
 */

function getQPath(to, center) {
  var points = [];
  points.push({
    x: center.x,
    y: center.y
  });
  points.push(to);
  var sub = ['Q'];
  util_1.each(points, function (point) {
    sub.push(point.x, point.y);
  });
  return sub;
}

exports.getQPath = getQPath;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(151);
/**  */


base_1.registerShape('interval', 'funnel', {
  getPoints: function getPoints(shapePoint) {
    shapePoint.size = shapePoint.size * 2; //  size 

    return util_1.getRectPoints(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, false, true);
    var path = this.parsePath(util_1.getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var constant_1 = __webpack_require__(270);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(151);
/**  */


base_1.registerShape('interval', 'hollow-rect', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false);
    var group = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;

    if (backgroundCfg) {
      group = container.addGroup();
      var backgroundStyle = get_style_1.getBackgroundRectStyle(cfg);
      var backgroundPath = util_1.getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group.addShape('path', {
        attrs: tslib_1.__assign(tslib_1.__assign({}, backgroundStyle), {
          path: backgroundPath
        }),
        zIndex: -1,
        name: constant_1.BACKGROUND_SHAPE
      });
    }

    var path = this.parsePath(util_1.getRectPath(cfg.points));
    var shape = group.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return backgroundCfg ? group : shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color,
        isInPolar = markerCfg.isInPolar;

    if (isInPolar) {
      return {
        symbol: 'circle',
        style: {
          r: 4.5,
          stroke: color,
          fill: null
        }
      };
    }

    return {
      symbol: 'square',
      style: {
        r: 4,
        stroke: color,
        fill: null
      }
    };
  }
});

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var util_2 = __webpack_require__(151);

var helper_1 = __webpack_require__(76); //  Line 


function getLinePoints(pointInfo) {
  var x = pointInfo.x,
      y = pointInfo.y,
      y0 = pointInfo.y0;

  if (util_1.isArray(y)) {
    return y.map(function (yItem, idx) {
      return {
        x: util_1.isArray(x) ? x[idx] : x,
        y: yItem
      };
    });
  } //  y0 


  return [{
    x: x,
    y: y0
  }, {
    x: x,
    y: y
  }];
}

base_1.registerShape('interval', 'line', {
  getPoints: function getPoints(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false, 'lineWidth');
    var newStyle = helper_1.omit(tslib_1.__assign({}, style), ['fill']);
    var path = this.parsePath(util_2.getRectPath(cfg.points, false));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, newStyle), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        return [['M', x, y - r], ['L', x, y + r]];
      },
      style: {
        r: 5,
        stroke: color
      }
    };
  }
});

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(151);
/**  */


base_1.registerShape('interval', 'pyramid', {
  getPoints: function getPoints(shapePoint) {
    shapePoint.size = shapePoint.size * 2; //  size 

    return util_1.getRectPoints(shapePoint, true);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, false, true);
    var path = this.parsePath(util_1.getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40); //  tick shape  6 


function getTickPoints(pointInfo) {
  var x = pointInfo.x,
      y = pointInfo.y,
      y0 = pointInfo.y0,
      size = pointInfo.size;
  var yMin;
  var yMax;

  if (util_1.isArray(y)) {
    yMin = y[0], yMax = y[1];
  } else {
    yMin = y0;
    yMax = y;
  }

  var xMax = x + size / 2;
  var xMin = x - size / 2; // tick 
  // 4 - 1 - 5
  //     |
  // 2 - 0 - 3

  return [{
    x: x,
    y: yMin
  }, {
    x: x,
    y: yMax
  }, {
    x: xMin,
    y: yMin
  }, {
    x: xMax,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }, {
    x: xMax,
    y: yMax
  }];
} //  tick  path


function getTickPath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y]];
}
/** I  error bar chart */


base_1.registerShape('interval', 'tick', {
  getPoints: function getPoints(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false);
    var path = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        return [['M', x - r / 2, y - r], ['L', x + r / 2, y - r], ['M', x, y - r], ['L', x, y + r], ['M', x - r / 2, y + r], ['L', x + r / 2, y + r]];
      },
      style: {
        r: 5,
        stroke: color
      }
    };
  }
});

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var marker_1 = __webpack_require__(147);

var base_1 = __webpack_require__(29);

var util_2 = __webpack_require__(280); //  hollowShape


util_1.each(util_2.HOLLOW_SHAPES, function (shapeName) {
  base_1.registerShape('point', shapeName, {
    draw: function draw(cfg, container) {
      return util_2.drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function getMarker(markerCfg) {
      var color = markerCfg.color;
      return {
        symbol: marker_1.MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color,
          fill: null
        }
      };
    }
  });
});

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

base_1.registerShape('point', 'image', {
  draw: function draw(cfg, container) {
    var size = get_style_1.getStyle(cfg, false, false, 'r').r;
    var points = this.parsePoints(cfg.points);
    var pointPosition = points[0];

    if (cfg.isStack) {
      pointPosition = points[1];
    } else if (points.length > 1) {
      var group = container.addGroup();

      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
        var point = points_1[_i];
        group.addShape('image', {
          attrs: {
            x: point.x - size / 2,
            y: point.y - size,
            width: size,
            height: size,
            img: cfg.shape[1]
          }
        });
      }

      return group;
    }

    return container.addShape('image', {
      attrs: {
        x: pointPosition.x - size / 2,
        y: pointPosition.y - size,
        width: size,
        height: size,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: color
      }
    };
  }
});

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var marker_1 = __webpack_require__(147);

var base_1 = __webpack_require__(29);

var util_2 = __webpack_require__(280); //  SHAPES 


util_1.each(util_2.SHAPES, function (shapeName) {
  base_1.registerShape('point', shapeName, {
    draw: function draw(cfg, container) {
      return util_2.drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function getMarker(markerCfg) {
      var color = markerCfg.color;
      return {
        symbol: marker_1.MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color
        }
      };
    }
  });
});

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

function parseValue(value) {
  var array = !util_1.isArray(value) ? [value] : value;
  var min = array[0]; // 

  var max = array[array.length - 1]; // 

  var min1 = array.length > 1 ? array[1] : min;
  var max1 = array.length > 3 ? array[3] : max;
  var median = array.length > 2 ? array[2] : min1;
  return {
    min: min,
    max: max,
    min1: min1,
    max1: max1,
    median: median
  };
}

function getBoxPoints(x, y, size) {
  var halfSize = size / 2;
  var pointsArray;

  if (util_1.isArray(y)) {
    // 2
    var _a = parseValue(y),
        min = _a.min,
        max = _a.max,
        median = _a.median,
        min1 = _a.min1,
        max1 = _a.max1;

    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [[minX, max], [maxX, max], [x, max], [x, max1], [minX, min1], [minX, max1], [maxX, max1], [maxX, min1], [x, min1], [x, min], [minX, min], [maxX, min], [minX, median], [maxX, median]];
  } else {
    // 
    y = util_1.isNil(y) ? 0.5 : y;

    var _b = parseValue(x),
        min = _b.min,
        max = _b.max,
        median = _b.median,
        min1 = _b.min1,
        max1 = _b.max1;

    var minY = y - halfSize;
    var maxY = y + halfSize;
    pointsArray = [[min, minY], [min, maxY], [min, y], [min1, y], [min1, minY], [min1, maxY], [max1, maxY], [max1, minY], [max1, y], [max, y], [max, minY], [max, maxY], [median, minY], [median, maxY]];
  }

  return pointsArray.map(function (arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}

function getBoxPath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x, points[10].y], ['L', points[11].x, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
} // box shape


base_1.registerShape('schema', 'box', {
  getPoints: function getPoints(shapePoint) {
    var x = shapePoint.x,
        y = shapePoint.y,
        size = shapePoint.size;
    return getBoxPoints(x, y, size);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false);
    var path = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path,
        name: 'schema'
      })
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points = getBoxPoints(x, yValues, r);
        return [['M', points[0].x + 1, points[0].y], ['L', points[1].x - 1, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['M', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['L', points[6].x, points[6].y], ['L', points[7].x, points[7].y], ['L', points[4].x, points[4].y], ['Z'], ['M', points[8].x, points[8].y], ['L', points[9].x, points[9].y], ['M', points[10].x + 1, points[10].y], ['L', points[11].x - 1, points[11].y], ['M', points[12].x, points[12].y], ['L', points[13].x, points[13].y]];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color
      }
    };
  }
});

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var helper_1 = __webpack_require__(76);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

function getCandleYValues(value) {
  var array = !util_1.isArray(value) ? [value] : value; // 

  var sorted = array.sort(function (a, b) {
    return b - a;
  });
  return helper_1.padEnd(sorted, 4, sorted[sorted.length - 1]);
} // get candle shape's key points


function getCandlePoints(x, y, size) {
  var yValues = getCandleYValues(y);
  return [{
    x: x,
    y: yValues[0]
  }, {
    x: x,
    y: yValues[1]
  }, {
    x: x - size / 2,
    y: yValues[2]
  }, {
    x: x - size / 2,
    y: yValues[1]
  }, {
    x: x + size / 2,
    y: yValues[1]
  }, {
    x: x + size / 2,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[2]
  }, {
    x: x,
    y: yValues[3]
  }];
}

function getCandlePath(points) {
  return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
} // k line shape


base_1.registerShape('schema', 'candle', {
  getPoints: function getPoints(shapePoint) {
    var x = shapePoint.x,
        y = shapePoint.y,
        size = shapePoint.size;
    return getCandlePoints(x, y, size);
  },
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, true);
    var path = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path,
        name: 'schema'
      })
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points = getCandlePoints(x, yValues, r);
        return [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['L', points[4].x, points[4].y], ['L', points[5].x, points[5].y], ['Z'], ['M', points[6].x, points[6].y], ['L', points[7].x, points[7].y]];
      },
      style: {
        lineWidth: 1,
        stroke: color,
        fill: color,
        r: 6
      }
    };
  }
});

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

function getRectAttrs(points, size) {
  var width = Math.abs(points[0].x - points[2].x);
  var height = Math.abs(points[0].y - points[2].y);
  var len = Math.min(width, height);

  if (size) {
    len = util_1.clamp(size, 0, Math.min(width, height));
  }

  len = len / 2;
  var centerX = (points[0].x + points[2].x) / 2;
  var centerY = (points[0].y + points[2].y) / 2;
  return {
    x: centerX - len,
    y: centerY - len,
    width: len * 2,
    height: len * 2
  };
}

base_1.registerShape('polygon', 'square', {
  draw: function draw(cfg, container) {
    if (!util_1.isEmpty(cfg.points)) {
      var shapeAttrs = get_style_1.getStyle(cfg, true, true);
      var points = this.parsePoints(cfg.points); // 

      return container.addShape('rect', {
        attrs: tslib_1.__assign(tslib_1.__assign({}, shapeAttrs), getRectAttrs(points, cfg.size)),
        name: 'polygon'
      });
    }
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});

/***/ }),
/* 463 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.antiCollision = void 0;
/**
 * 
 */

function antiCollision(items, labelHeight, plotRange) {
  var labels = items.filter(function (item) {
    return !item.invisible;
  }); // sorted by y, mutable

  labels.sort(function (a, b) {
    return a.y - b.y;
  }); // adjust y position of labels to avoid overlapping

  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function (label) {
    if (label.y > maxY) {
      maxY = label.y;
    }

    if (label.y < minY) {
      minY = label.y;
    }

    return {
      content: label.content,
      size: labelHeight,
      targets: [label.y - startY],
      pos: null
    };
  });
  minY -= startY;

  if (maxY - startY > totalHeight) {
    totalHeight = maxY - startY;
  }

  while (overlapping) {
    /* eslint no-loop-func: 0 */
    boxes.forEach(function (box) {
      var target = (Math.min.apply(minY, box.targets) + Math.max.apply(minY, box.targets)) / 2;
      box.pos = Math.min(Math.max(minY, target - box.size / 2), totalHeight - box.size);
      box.pos = Math.max(0, box.pos);
    }); // detect overlapping and join boxes

    overlapping = false;
    i = boxes.length;

    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box = boxes[i];

        if (previousBox.pos + previousBox.size > box.pos) {
          // overlapping
          previousBox.size += box.size;
          previousBox.targets = previousBox.targets.concat(box.targets); // overflow, shift up

          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }

          boxes.splice(i, 1); // removing box

          overlapping = true;
        }
      }
    }
  }

  i = 0; // step 4: normalize y and adjust x

  boxes.forEach(function (b) {
    var posInCompositeBox = startY + labelHeight / 2; // middle of the label

    b.targets.forEach(function () {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}

exports.antiCollision = antiCollision;

/***/ }),
/* 464 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(288));
/**
 * @ignore
 *  Action
 */


var RectMask =
/** @class */
function (_super) {
  tslib_1.__extends(RectMask, _super);

  function RectMask() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.shapeType = 'rect';
    return _this;
  }

  RectMask.prototype.getRegion = function () {
    var points = this.points;
    return {
      start: util_1.head(points),
      end: util_1.last(points)
    };
  }; // 


  RectMask.prototype.getMaskAttrs = function () {
    var _a = this.getRegion(),
        start = _a.start,
        end = _a.end;

    var x = Math.min(start.x, end.x);
    var y = Math.min(start.y, end.y);
    var width = Math.abs(end.x - start.x);
    var height = Math.abs(end.y - start.y);
    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  };

  return RectMask;
}(base_1.default);

exports.default = RectMask;

/***/ }),
/* 465 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(288));
/**
 * @ignore
 *  Path  Action
 */


var PathMask =
/** @class */
function (_super) {
  tslib_1.__extends(PathMask, _super);

  function PathMask() {
    return _super !== null && _super.apply(this, arguments) || this;
  } //  mask 


  PathMask.prototype.getMaskPath = function () {
    var points = this.points;
    var path = [];

    if (points.length) {
      util_1.each(points, function (point, index) {
        if (index === 0) {
          path.push(['M', point.x, point.y]);
        } else {
          path.push(['L', point.x, point.y]);
        }
      });
      path.push(['L', points[0].x, points[0].y]);
    }

    return path;
  };

  PathMask.prototype.getMaskAttrs = function () {
    return {
      path: this.getMaskPath()
    };
  };
  /**
   * 
   */


  PathMask.prototype.addPoint = function () {
    this.resize();
  };

  return PathMask;
}(base_1.default);

exports.default = PathMask;

/***/ }),
/* 466 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_1 = __webpack_require__(30); //  scale


function getFilter(scale, dim, point1, point2) {
  var min = Math.min(point1[dim], point2[dim]);
  var max = Math.max(point1[dim], point2[dim]);
  var _a = scale.range,
      rangeMin = _a[0],
      rangeMax = _a[1]; //  scale  range 

  if (min < rangeMin) {
    min = rangeMin;
  }

  if (max > rangeMax) {
    max = rangeMax;
  } //  view  null


  if (min === rangeMax && max === rangeMax) {
    return null;
  }

  var minValue = scale.invert(min);
  var maxValue = scale.invert(max);

  if (scale.isCategory) {
    var minIndex = scale.values.indexOf(minValue);
    var maxIndex = scale.values.indexOf(maxValue);
    var arr_1 = scale.values.slice(minIndex, maxIndex + 1);
    return function (value) {
      return arr_1.includes(value);
    };
  } else {
    return function (value) {
      return value >= minValue && value <= maxValue;
    };
  }
}
/**
 *  Action
 * @ignore
 */


var RangeFilter =
/** @class */
function (_super) {
  tslib_1.__extends(RangeFilter, _super);

  function RangeFilter() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**
     * / x, y
     */


    _this.dims = ['x', 'y'];
    /**  */

    _this.startPoint = null;
    _this.isStarted = false;
    return _this;
  } // x,y 


  RangeFilter.prototype.hasDim = function (dim) {
    return this.dims.includes(dim);
  };
  /**
   * 
   */


  RangeFilter.prototype.start = function () {
    var context = this.context;
    this.isStarted = true;
    this.startPoint = context.getCurrentPoint();
  };
  /**
   * 
   */


  RangeFilter.prototype.filter = function () {
    var startPoint;
    var currentPoint;

    if (util_1.isMask(this.context)) {
      var maskShape = this.context.event.target;
      var bbox = maskShape.getCanvasBBox();
      startPoint = {
        x: bbox.x,
        y: bbox.y
      };
      currentPoint = {
        x: bbox.maxX,
        y: bbox.maxY
      };
    } else {
      if (!this.isStarted) {
        // 
        return;
      }

      startPoint = this.startPoint;
      currentPoint = this.context.getCurrentPoint();
    }

    if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
      // 
      return;
    }

    var view = this.context.view;
    var coord = view.getCoordinate();
    var normalCurrent = coord.invert(currentPoint);
    var normalStart = coord.invert(startPoint); //  x  filter

    if (this.hasDim('x')) {
      var xScale = view.getXScale();
      var filter = getFilter(xScale, 'x', normalCurrent, normalStart);
      this.filterView(view, xScale.field, filter);
    } //  y  filter


    if (this.hasDim('y')) {
      var yScale = view.getYScales()[0];
      var filter = getFilter(yScale, 'y', normalCurrent, normalStart);
      this.filterView(view, yScale.field, filter);
    }

    this.reRender(view);
  };
  /**
   * 
   */


  RangeFilter.prototype.end = function () {
    this.isStarted = false;
  };
  /**
   *  Action  x,y
   */


  RangeFilter.prototype.reset = function () {
    var view = this.context.view;
    this.isStarted = false;

    if (this.hasDim('x')) {
      var xScale = view.getXScale();
      this.filterView(view, xScale.field, null); // 
    }

    if (this.hasDim('y')) {
      // y  yScale
      var yScale = view.getYScales()[0];
      this.filterView(view, yScale.field, null); // 
    }

    this.reRender(view);
  };
  /**
   *  view 
   */


  RangeFilter.prototype.filterView = function (view, field, filter) {
    view.filter(field, filter);
  };
  /**
   * 
   * @param view
   */


  RangeFilter.prototype.reRender = function (view) {
    view.render(true);
  };

  return RangeFilter;
}(base_1.default);

exports.default = RangeFilter;

/***/ }),
/* 467 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var __1 = __webpack_require__(265);

var DIM_X = 'x';
var DIM_Y = 'y';
/**
 * Scale translate
 * @ignore
 */

var ScaleTranslate =
/** @class */
function (_super) {
  tslib_1.__extends(ScaleTranslate, _super);

  function ScaleTranslate() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.dims = [DIM_X, DIM_Y];
    _this.cfgFields = ['dims'];
    _this.cacheScaleDefs = {};
    return _this;
  } // 


  ScaleTranslate.prototype.hasDim = function (dim) {
    return this.dims.includes(dim);
  };

  ScaleTranslate.prototype.getScale = function (dim) {
    var view = this.context.view;

    if (dim === 'x') {
      return view.getXScale();
    } else {
      return view.getYScales()[0];
    }
  };

  ScaleTranslate.prototype.resetDim = function (dim) {
    var view = this.context.view;

    if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
      var scale = this.getScale(dim);
      view.scale(scale.field, this.cacheScaleDefs[dim]);
      this.cacheScaleDefs[dim] = null;
    }
  };
  /**
   * 
   */


  ScaleTranslate.prototype.reset = function () {
    this.resetDim(DIM_X);
    this.resetDim(DIM_Y);
    var view = this.context.view;
    view.render(true);
  };

  return ScaleTranslate;
}(__1.Action);

exports.default = ScaleTranslate;

/***/ }),
/* 468 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeToArray = __webpack_require__(470);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),
/* 470 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});

var isObjectLike = function isObjectLike(value) {
  /**
   * isObjectLike({}) => true
   * isObjectLike([1, 2, 3]) => true
   * isObjectLike(Function) => false
   * isObjectLike(null) => false
   */
  return (0, _typeof2.default)(value) === 'object' && value !== null;
};

exports.default = isObjectLike;

/***/ }),
/* 472 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(327);
/* harmony import */ var _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(328);
/* harmony import */ var _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(329);
/* harmony import */ var _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(330);
/* harmony import */ var _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(331);
/* harmony import */ var _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(332);
/* harmony import */ var _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(42);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('rect', _antv_g2_lib_facet_rect__WEBPACK_IMPORTED_MODULE_6___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('mirror', _antv_g2_lib_facet_mirror__WEBPACK_IMPORTED_MODULE_5___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('list', _antv_g2_lib_facet_list__WEBPACK_IMPORTED_MODULE_3___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('matrix', _antv_g2_lib_facet_matrix__WEBPACK_IMPORTED_MODULE_4___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('circle', _antv_g2_lib_facet_circle__WEBPACK_IMPORTED_MODULE_2___default.a);
Object(_core__WEBPACK_IMPORTED_MODULE_9__["registerFacet"])('tree', _antv_g2_lib_facet_tree__WEBPACK_IMPORTED_MODULE_7___default.a);
;

function Facet(props) {
  var chart = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"])();

  var type = props.type,
      children = props.children,
      cfg = __rest(props, ["type", "children"]);

  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default()(children)) {
    chart.facet(type, object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg), {
      // @ts-ignore
      eachView: children
    }));
  } else {
    chart.facet(type, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg));
  }

  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (Facet);

/***/ }),
/* 473 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(335);
/* harmony import */ var _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);



 //  slider 

Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_2__["registerComponentController"])('slider', _antv_g2_lib_chart_controller_slider__WEBPACK_IMPORTED_MODULE_1___default.a);

function Slider(props) {
  var view = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])();
  view.option('slider', props);
  return null;
}

/* harmony default export */ __webpack_exports__["a"] = (Slider);

/***/ }),
/* 474 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(113);
/* harmony import */ var _antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_chart__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(272);
/* harmony import */ var _antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_interface__WEBPACK_IMPORTED_MODULE_1__);
/* unused harmony reexport * */



;

/***/ }),
/* 475 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SchemaGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(323);
/* harmony import */ var _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(450);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_schema__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(461);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_schema_candle__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(460);
/* harmony import */ var _antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_shape_schema_box__WEBPACK_IMPORTED_MODULE_9__);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }







Object(_core__WEBPACK_IMPORTED_MODULE_6__["registerGeometry"])('Schema', _antv_g2_lib_geometry_schema__WEBPACK_IMPORTED_MODULE_4___default.a);

var SchemaGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(SchemaGeom, _BaseGemo);

  var _super = _createSuper(SchemaGeom);

  function SchemaGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, SchemaGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'schema';
    return _this;
  }

  return SchemaGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);



/***/ }),
/* 476 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PathGeom; });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(164);
/* harmony import */ var _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(166);
/* harmony import */ var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerAnimation"])('path-in', _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_5__["pathIn"]);
Object(_core__WEBPACK_IMPORTED_MODULE_7__["registerGeometry"])('Path', _antv_g2_lib_geometry_path__WEBPACK_IMPORTED_MODULE_4___default.a);

var PathGeom = /*#__PURE__*/function (_BaseGemo) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_1___default()(PathGeom, _BaseGemo);

  var _super = _createSuper(PathGeom);

  function PathGeom() {
    var _this;

    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, PathGeom);

    _this = _super.apply(this, arguments);
    _this.GemoBaseClassName = 'path';
    return _this;
  }

  return PathGeom;
}(_Base__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]);



/***/ }),
/* 477 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Area__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(128);
/* harmony import */ var _Edge__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(214);
/* harmony import */ var _Heatmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(215);
/* harmony import */ var _Interval__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(216);
/* harmony import */ var _Line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(129);
/* harmony import */ var _Point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(130);
/* harmony import */ var _Polygon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(217);
/* harmony import */ var _LineAdvance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(218);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_10__);


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};











var GEOM_MAP = {
  area: _Area__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"],
  edge: _Edge__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"],
  heatmap: _Heatmap__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"],
  interval: _Interval__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"],
  line: _Line__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"],
  point: _Point__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"],
  polygon: _Polygon__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"],
  // bx 
  'line-advance': _LineAdvance__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"]
};
/* harmony default export */ __webpack_exports__["a"] = (function (props) {
  var type = props.type,
      cfg = __rest(props, ["type"]);

  var Geom = GEOM_MAP[type];
  if (Geom) return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Geom, object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, cfg));
  warning__WEBPACK_IMPORTED_MODULE_10___default()(false, 'Only support the below type: area|edge|heatmap|interval|line|point|polygon|line-advance');
  return null;
});

/***/ }),
/* 478 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Coord; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(213);




function Coord(props) {
  warning__WEBPACK_IMPORTED_MODULE_2___default()(false, 'Coord ()  Coordinate,Coordinate5.0Coord');
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_index__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"], object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, props));
}

/***/ }),
/* 479 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Annotation_arc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/* harmony import */ var _components_Annotation_dataMarker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(206);
/* harmony import */ var _components_Annotation_dataRegion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(207);
/* harmony import */ var _components_Annotation_image__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(208);
/* harmony import */ var _components_Annotation_line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(209);
/* harmony import */ var _components_Annotation_region__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(210);
/* harmony import */ var _components_Annotation_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(211);
// , 4.2 
 // annotation G2



 // import Html from '../components/Annotation/html';






var Guide = function Guide(props) {
  warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Guide5.0AnnotationAnnotation');
  return props.children;
};

Guide.Arc = _components_Annotation_arc__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];
Guide.DataMarker = _components_Annotation_dataMarker__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"];
Guide.DataRegion = _components_Annotation_dataRegion__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]; // Guide.Html = Html;

Guide.Image = _components_Annotation_image__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"];
Guide.Line = _components_Annotation_line__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"];
Guide.Region = _components_Annotation_region__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"];
Guide.Text = _components_Annotation_text__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"];
/* harmony default export */ __webpack_exports__["a"] = (Guide);

/***/ }),
/* 480 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Effects; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var _antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(126);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(13);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_3__);




function Effects(props) {
  var chart = Object(_hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])();

  if (_antv_util_lib_is_function__WEBPACK_IMPORTED_MODULE_1___default()(props.children)) {
    var res = props.children(chart);
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.isValidElement(res) ? res : null;
  }

  warning__WEBPACK_IMPORTED_MODULE_3___default()(false, 'Effects  (chart) => {}');
  return null;
}

/***/ }),
/* 481 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Interaction; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);


function Interaction(props) {
  var chart = Object(_hooks_useChartView__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])();
  var type = props.type,
      config = props.config; // @ts-ignore

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"])(function () {
    chart.interaction(type, config);
    return function () {
      chart.removeInteraction(type);
    };
  });
  return null;
}

/***/ }),
/* 482 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return useTheme; });
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91);
/* harmony import */ var _antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__);



function useTheme() {
  var defaultThemeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
  var defaultTheme = Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__["getTheme"])(defaultThemeName);
  defaultTheme.name = defaultThemeName;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__["useState"])(defaultTheme),
      _useState2 = _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_0___default()(_useState, 2),
      theme = _useState2[0],
      setG2Theme = _useState2[1];

  var setTheme = function setTheme(themeName) {
    var nextTheme = Object(_antv_g2_lib_theme__WEBPACK_IMPORTED_MODULE_2__["getTheme"])(themeName);
    nextTheme.name = themeName;
    setG2Theme(nextTheme);
  };

  return [theme, setTheme];
}

/***/ }),
/* 483 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ver = exports.clear = exports.bind = void 0;

var _sensorPool = __webpack_require__(991);
/**
 * Created by hustcc on 18/6/9.[]
 * Contract: i@hust.cc
 */

/**
 * bind an element with resize callback function
 * @param {*} element
 * @param {*} cb
 */


var bind = function bind(element, cb) {
  var sensor = (0, _sensorPool.getSensor)(element); // listen with callback

  sensor.bind(cb); // return unbind function

  return function () {
    sensor.unbind(cb);
  };
};
/**
 * clear all the listener and sensor of an element
 * @param element
 */


exports.bind = bind;

var clear = function clear(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};

exports.clear = clear;
var ver = "1.0.1";
exports.ver = ver;

/***/ }),
/* 484 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

var _default = function _default(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;
  var timer = null;
  return function () {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(_this, args);
    }, delay);
  };
};

exports["default"] = _default;

/***/ }),
/* 485 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SensorTabIndex = exports.SensorClassName = exports.SizeSensorId = void 0;
/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

var SizeSensorId = 'size-sensor-id';
exports.SizeSensorId = SizeSensorId;
var SensorClassName = 'size-sensor-object';
exports.SensorClassName = SensorClassName;
var SensorTabIndex = '-1';
exports.SensorTabIndex = SensorTabIndex;

/***/ }),
/* 486 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderGaugeStatistic = exports.renderStatistic = exports.setStatisticContainerStyle = exports.adapteStyle = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var _1 = __webpack_require__(16);
/**
 * @desc  html-statistic  style  ( canvas  shapeStyle  css)
 *
 * @param width
 * @param style
 */


function adapteStyle(style) {
  var styleObject = {
    overflow: 'hidden',
    'white-space': 'nowrap',
    'text-overflow': 'ellipsis',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  };
  var shapeStyleKeys = ['stroke', 'lineWidth', 'shadowColor', 'strokeOpacity', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'fill']; //  shapeStyle   start

  if (util_1.get(style, 'fill')) {
    styleObject['color'] = style['fill'];
  }

  var _a = _1.pick(style, shapeStyleKeys),
      shadowColor = _a.shadowColor,
      _b = _a.shadowBlur,
      shadowBlur = _b === void 0 ? 0 : _b,
      _c = _a.shadowOffsetX,
      shadowOffsetX = _c === void 0 ? 0 : _c,
      _d = _a.shadowOffsetY,
      shadowOffsetY = _d === void 0 ? 0 : _d;

  styleObject['text-shadow'] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(' ');

  var _e = _1.pick(style, shapeStyleKeys),
      stroke = _e.stroke,
      _f = _e.lineWidth,
      lineWidth = _f === void 0 ? 0 : _f;

  styleObject['-webkit-text-stroke'] = "" + [lineWidth + "px", stroke].join(' '); //  shapeStyle   end

  util_1.each(style, function (v, k) {
    //   shapeStyle  fontSize 
    if (['fontSize'].includes(k) && util_1.isNumber(v)) {
      styleObject[_1.kebabCase(k)] = v + "px";
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[_1.kebabCase(k)] = "" + v;
    }
  });
  return styleObject;
}

exports.adapteStyle = adapteStyle;
/**
 * @desc  html-statistic 
 *
 * - 
 */

function setStatisticContainerStyle(container, style) {
  container.style['pointer-events'] = 'none';
  util_1.each(style, function (v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}

exports.setStatisticContainerStyle = setStatisticContainerStyle;
/**
 *  html-annotation position  [50%, 50%]
 * @param chart
 * @param options
 * @param meta 
 * @param {optional} datum 
 */

exports.renderStatistic = function (chart, options, datum) {
  var statistic = options.statistic,
      plotType = options.plotType;
  var titleOpt = statistic.title,
      contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option, idx) {
    if (!option) {
      return;
    }

    var text = '';
    var transform = '';

    if (idx === 0) {
      transform = contentOpt ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
    } else {
      transform = titleOpt ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
    }

    var style = util_1.isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(tslib_1.__assign({
      position: ['50%', '50%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        var containerW = 0;

        if (plotType === 'pie' || plotType === 'ring-progress') {
          containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
        } else if (plotType === 'liquid') {
          var liquidShape = util_1.get(view.geometries, [0, 'elements', 0, 'shape']);

          if (liquidShape) {
            var circle = liquidShape.find(function (t) {
              return t.get('type') === 'circle';
            });
            var width = circle.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          // 
          containerW = coordinate.getWidth();
        }

        setStatisticContainerStyle(container, tslib_1.__assign({
          width: containerW + "px",
          transform: transform
        }, adapteStyle(style)));
        var filteredData = view.getData();

        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }

        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        } // todo G2  & G2  number


        return text ? util_1.isString(text) ? text : "" + text : '<div></div>';
      },
      // @ts-ignore
      key: (idx === 0 ? 'top' : 'bottom') + "-statistic"
    }, _1.pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter'])
    /**  */
    ));
  });
};
/**
 *  html-annotation for gauge ( plot),  position  [50%, 100%]
 * @param chart
 * @param options
 * @param meta 
 * @param {optional} datum 
 */


exports.renderGaugeStatistic = function (chart, options, datum) {
  var statistic = options.statistic;
  var titleOpt = statistic.title,
      contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option) {
    if (!option) {
      return;
    }

    var text = '';
    var style = util_1.isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(tslib_1.__assign({
      position: ['50%', '100%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate(); // 

        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat(util_1.get(style, 'fontSize', 0));
        var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
        setStatisticContainerStyle(container, tslib_1.__assign({
          width: containerWidth + "px",
          transform: "translate(-50%, " + offsetY + "px)"
        }, adapteStyle(style)));
        var filteredData = view.getData();

        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }

        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        } // todo G2  & G2  number


        return text ? util_1.isString(text) ? text : "" + text : '<div></div>';
      }
    }, _1.pick(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter'])
    /**  */
    ));
  });
};

/***/ }),
/* 487 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.geometry = void 0;

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);

var constant_1 = __webpack_require__(489);

var utils_2 = __webpack_require__(291);
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      progressStyle = options.progressStyle,
      color = options.color,
      barWidthRatio = options.barWidthRatio;
  chart.data(utils_2.getProgressData(percent));
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: '1',
      yField: 'percent',
      seriesField: 'type',
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: util_1.isString(color) ? [color, constant_1.DEFAULT_COLOR[1]] : color
      }
    }
  });
  geometries_1.interval(p); // 

  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}

exports.geometry = geometry;
/**
 * other 
 * @param params
 */

function coordinate(params) {
  var chart = params.chart;
  chart.coordinate('rect').transpose();
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // @ts-ignore
  return utils_1.flow(geometry, common_1.scale({}), coordinate, common_1.animation, common_1.theme, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 488 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polygon = void 0;

var tslib_1 = __webpack_require__(1);

var tooltip_1 = __webpack_require__(88);

var utils_1 = __webpack_require__(16);

var base_1 = __webpack_require__(89);
/**
 * polygon 
 * @param params
 */


function polygon(params) {
  var options = params.options;
  var polygon = options.polygon,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return polygon ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'polygon',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        tooltip: formatter
      }, polygon)
    }
  })) : params;
}

exports.polygon = polygon;

/***/ }),
/* 489 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_COLOR = void 0;
exports.DEFAULT_COLOR = ['#FAAD14', '#E8EDF3'];

/***/ }),
/* 490 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRealNumber = void 0;
/**
 * 
 * @param v
 */

function isRealNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}

exports.isRealNumber = isRealNumber;

/***/ }),
/* 491 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.adjust = exports.legend = exports.axis = exports.meta = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(16);

var data_1 = __webpack_require__(153);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      color = options.color,
      lineStyle = options.lineStyle,
      lineShape = options.lineShape,
      pointMapping = options.point,
      seriesField = options.seriesField;
  chart.data(data); // line geometry 

  var primary = utils_1.deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color,
        style: lineStyle,
        shape: lineShape
      },
      //  tooltip 
      // 
      point: pointMapping && tslib_1.__assign({
        color: color,
        shape: 'circle'
      }, pointMapping),
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  });
  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  geometries_1.line(primary);
  geometries_1.point(second);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      data = options.data;
  return utils_2.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = data_1.adjustYMetaByZero(data, yField), _b)))(params);
}

exports.meta = meta;
/**
 * axis 
 * @param params
 */

function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}

exports.axis = axis;
/**
 * legend 
 * @param params
 */

function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }

  return params;
}

exports.legend = legend;
/**
 * 
 * @param params
 */

function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var lineGeometry = utils_1.findGeometry(chart, 'line'); // label  false,   label

  if (!label) {
    lineGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    lineGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: tslib_1.__assign({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, utils_1.transformLabel(cfg))
    });
  }

  return params;
}
/**
 *  adjust
 * @param params
 */


function adjust(params) {
  var chart = params.chart,
      options = params.options;
  var isStack = options.isStack;

  if (isStack) {
    util_1.each(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }

  return params;
}

exports.adjust = adjust;
/**
 * 
 * @param chart
 * @param options
 */

function adaptor(params) {
  // flow  G2 API
  return utils_2.flow(geometry, meta, adjust, common_1.theme, axis, legend, common_1.tooltip, label, common_1.slider, common_1.interaction, common_1.animation, common_1.annotation(), common_1.limitInPlot)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 492 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = exports.getFommatInteractions = exports.isDrillDown = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var treemap_1 = __webpack_require__(1022);

var utils_1 = __webpack_require__(16);

function isDrillDown(interactions) {
  if (!util_1.isArray(interactions)) return false;
  return interactions.findIndex(function (i) {
    return i.type === 'treemap-drill-down';
  }) > -1;
}

exports.isDrillDown = isDrillDown;

function getFommatInteractions(interactions, hierarchyConfig) {
  var openDrillDown = isDrillDown(interactions);

  if (openDrillDown) {
    return interactions.map(function (i) {
      if (i.type === 'treemap-drill-down') {
        return utils_1.deepAssign({}, i, {
          cfg: {
            hierarchyConfig: hierarchyConfig
          }
        });
      }

      return i;
    });
  }

  return interactions;
}

exports.getFommatInteractions = getFommatInteractions;

function transformData(options) {
  var data = options.data,
      colorField = options.colorField,
      openDrillDown = options.openDrillDown,
      _a = options.hierarchyConfig,
      hierarchyConfig = _a === void 0 ? {} : _a;
  var nodes = treemap_1.treemap(data, tslib_1.__assign(tslib_1.__assign({}, hierarchyConfig), {
    // @ts-ignore
    type: 'hierarchy.treemap',
    field: 'value',
    as: ['x', 'y']
  }));
  var result = [];
  nodes.forEach(function (node) {
    if (node.depth === 0) {
      return null;
    } //  depth === 1 


    if (openDrillDown && node.depth !== 1) {
      return null;
    } // 


    if (!openDrillDown && node.children) {
      return null;
    }

    var eachNode = Object.assign({}, node.data, {
      x: node.x,
      y: node.y,
      depth: node.depth,
      value: node.value
    });

    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function (n) {
        return n.data[colorField];
      });
      eachNode[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      eachNode[colorField] = node.data[colorField];
    }

    result.push(eachNode);
  });
  return result;
}

exports.transformData = transformData;

/***/ }),
/* 493 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.packEnclose = packEnclose;
exports.default = _default;

var _array = _interopRequireDefault(__webpack_require__(494));

var _enclose = _interopRequireDefault(__webpack_require__(495));

function place(b, a, c) {
  var dx = b.x - a.x,
      x,
      a2,
      dy = b.y - a.y,
      y,
      b2,
      d2 = dx * dx + dy * dy;

  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;

    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = (circles = (0, _array.default)(circles)).length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk; // Place the first circle.

  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r; // Place the second circle.

  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r; // Place the third circle.

  place(b, a, c = circles[2]); // Initialize the front-chain using the first three circles a, b and c.

  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a; // Attempt to place each remaining circle

  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c); // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.

    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;

    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next); // Success! Insert the new circle c between a and b.


    c.previous = a, c.next = b, a.next = b.previous = b = c; // Compute the new closest circle pair to the centroid.

    aa = score(a);

    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }

    b = a.next;
  } // Compute the enclosing circle of the front chain.


  a = [b._], c = b;

  while ((c = c.next) !== b) {
    a.push(c._);
  }

  c = (0, _enclose.default)(a); // Translate the circles to put the enclosing circle around the origin.

  for (i = 0; i < n; ++i) {
    a = circles[i], a.x -= c.x, a.y -= c.y;
  }

  return c.r;
}

function _default(circles) {
  packEnclose(circles);
  return circles;
}

/***/ }),
/* 494 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.shuffle = shuffle;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

function _default(x) {
  return (0, _typeof2.default)(x) === "object" && "length" in x ? x // Array, TypedArray, NodeList, array-like
  : Array.from(x); // Map, Set, iterable, string, or anything else
}

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

/***/ }),
/* 495 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = __webpack_require__(494);

function _default(circles) {
  var i = 0,
      n = (circles = (0, _array.shuffle)(Array.from(circles))).length,
      B = [],
      p,
      e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p]; // If we get here then B must have at least one element.

  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  } // If we get here then B must have at least two elements.


  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  } // If we get here then something is very wrong.


  throw new Error();
}

function enclosesNot(a, b) {
  var dr = a.r - b.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }

  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);

    case 2:
      return encloseBasis2(B[0], B[1]);

    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x21 = x2 - x1,
      y21 = y2 - y1,
      r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x3 = c.x,
      y3 = c.y,
      r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

/***/ }),
/* 496 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constantZero = constantZero;
exports.default = _default;

function constantZero() {
  return 0;
}

function _default(x) {
  return function () {
    return x;
  };
}

/***/ }),
/* 497 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

/***/ }),
/* 498 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

g2_1.registerInteraction('drag-move', {
  start: [{
    trigger: 'plot:mousedown',
    action: 'scale-translate:start'
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: 'scale-translate:translate',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: 'scale-translate:end'
  }]
});

/***/ }),
/* 499 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.legend = void 0;

var tslib_1 = __webpack_require__(1);

var utils_1 = __webpack_require__(16);

var common_1 = __webpack_require__(34);

var conversion_tag_1 = __webpack_require__(1051);

var connected_area_1 = __webpack_require__(1052);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(16);

var percent_1 = __webpack_require__(156);

var data_1 = __webpack_require__(153);
/**
 * defaultOptions
 * @param params
 */


function defaultOptions(params) {
  var options = params.options; //  legend 

  var legend = options.legend;
  var seriesField = options.seriesField,
      isStack = options.isStack;

  if (seriesField) {
    if (legend !== false) {
      legend = tslib_1.__assign({
        position: isStack ? 'right-top' : 'top-left'
      }, legend);
    }
  } else {
    legend = false;
  } // @ts-ignore 


  params.options.legend = legend;
  return params;
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      columnStyle = options.columnStyle,
      color = options.color,
      columnWidthRatio = options.columnWidthRatio,
      isPercent = options.isPercent,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;
  chart.data(percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent)); //  % , 

  var tooltipOptions = isPercent ? tslib_1.__assign({
    formatter: function formatter(datum) {
      return {
        name: datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var p = utils_2.deepAssign({}, params, {
    options: {
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        style: columnStyle,
        color: color
      }
    }
  });
  geometries_1.interval(p);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      data = options.data,
      isPercent = options.isPercent;
  var percentYMeta = isPercent ? {
    max: 1,
    min: 0,
    minLimit: 0,
    maxLimit: 1
  } : {};
  return utils_2.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = tslib_1.__assign(tslib_1.__assign({}, data_1.adjustYMetaByZero(data, yField)), percentYMeta), _b)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }

  return params;
}

exports.legend = legend;
/**
 * 
 * @param params
 */

function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField,
      isRange = options.isRange;
  var geometry = utils_1.findGeometry(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: tslib_1.__assign({
        //  label layout  layout  position  layout
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? undefined : [{
          type: 'interval-adjust-position'
        }, {
          type: 'interval-hide-overlap'
        }, {
          type: 'adjust-color'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, utils_2.transformLabel(isRange ? tslib_1.__assign({
        content: function content(item) {
          var _a;

          return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
        }
      }, cfg) : cfg))
    });
  }

  return params;
}
/**
 * 
 * @param params
 */


function adaptor(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }

  var options = params.options;
  var seriesField = options.seriesField;
  return utils_2.flow(defaultOptions, // 
  common_1.theme, // theme  geometry 
  geometry, meta, axis, legend, common_1.tooltip, common_1.slider, common_1.scrollbar, label, common_1.interaction, common_1.animation, common_1.annotation(), conversion_tag_1.conversionTag(options.yField, !isBar, !!seriesField), // 
  connected_area_1.connectedArea(!options.isStack), common_1.limitInPlot)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 500 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagFormatter = void 0;

var util_1 = __webpack_require__(0);
/**
 * 
 * @param prev
 * @param next
 */


function conversionTagFormatter(prev, next) {
  if (!util_1.isNumber(prev) || !util_1.isNumber(next)) {
    return '-';
  }

  if (prev === next) {
    return '100%';
  }

  if (prev === 0) {
    return '';
  }

  if (next === 0) {
    return '-';
  }

  return (100 * next / prev).toFixed(2) + "%";
}

exports.conversionTagFormatter = conversionTagFormatter;

/***/ }),
/* 501 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = void 0;

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);
/**
 * 
 */


exports.DEFAULT_OPTIONS = utils_1.deepAssign({}, plot_1.Plot.getDefaultOptions(), {
  legend: {
    position: 'right'
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: {
      type: 'limit-in-plot',
      cfg: {
        action: 'ellipsis'
      }
    }
  },

  /** ,  */
  pieStyle: {
    stroke: 'white',
    lineWidth: 1
  },

  /**  */
  statistic: {
    title: {
      style: {
        fontWeight: 300,
        color: '#4B535E',
        textAlign: 'center',
        fontSize: '20px',
        lineHeight: 1
      }
    },
    content: {
      style: {
        fontWeight: 'bold',
        color: 'rgba(44,53,66,0.85)',
        textAlign: 'center',
        fontSize: '32px',
        lineHeight: 1
      }
    }
  },

  /**  text-annotation  */
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});

/***/ }),
/* 502 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAllZero = exports.processIllegalData = exports.adaptOffset = exports.getTotalValue = void 0;

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);
/**
 * 
 * @param data
 * @param field
 */


function getTotalValue(data, field) {
  var total = null;
  util_1.each(data, function (item) {
    if (typeof item[field] === 'number') {
      total += item[field];
    }
  });
  return total;
}

exports.getTotalValue = getTotalValue;
/**
 * pie label offset adaptor
 */

function adaptOffset(type, offset) {
  var defaultOffset;

  switch (type) {
    case 'inner':
      defaultOffset = '-30%';

      if (util_1.isString(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }

      return offset < 0 ? offset : defaultOffset;

    case 'outer':
      defaultOffset = 12;

      if (util_1.isString(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }

      return offset > 0 ? offset : defaultOffset;

    default:
      return offset;
  }
}

exports.adaptOffset = adaptOffset;
/**
 * (   NaN null)
 * @param data
 * @param angleField
 */

function processIllegalData(data, angleField) {
  var processData = util_1.filter(data, function (d) {
    var v = d[angleField];
    return typeof v === 'number' && !isNaN(v) || v === null;
  }); // 

  utils_1.log(utils_1.LEVEL.WARN, processData.length === data.length, 'illegal data existed in chart data.');
  return processData;
}

exports.processIllegalData = processIllegalData;
/**
 *  0
 * @param data
 * @param angleField
 */

function isAllZero(data, angleField) {
  return util_1.every(data, function (d) {
    return d[angleField] === 0;
  });
}

exports.isAllZero = isAllZero;

/***/ }),
/* 503 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
/**
 * 
 * @param actions
 * @param matrix
 */

function transform(actions, matrix) {
  var ulMatrix = matrix ? tslib_1.__spreadArrays(matrix) : tslib_1.__spreadArrays(ORIGIN_MATRIX);
  return g2_1.Util.transform(ulMatrix, actions);
}

exports.transform = transform;

/***/ }),
/* 504 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSingleKeyValues = exports.getFontSizeMapping = exports.processImageMask = exports.getSize = exports.transform = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var word_cloud_1 = __webpack_require__(1062);
/**
 *  DataSet 
 * @param params
 */


function transform(params) {
  var rawOptions = params.options,
      chart = params.chart;
  var _a = chart,
      width = _a.width,
      height = _a.height,
      chartPadding = _a.padding,
      appendPadding = _a.appendPadding,
      ele = _a.ele;
  var data = rawOptions.data,
      imageMask = rawOptions.imageMask,
      wordField = rawOptions.wordField,
      weightField = rawOptions.weightField,
      colorField = rawOptions.colorField,
      wordStyle = rawOptions.wordStyle,
      timeInterval = rawOptions.timeInterval,
      random = rawOptions.random,
      spiral = rawOptions.spiral,
      _b = rawOptions.autoFit,
      autoFit = _b === void 0 ? true : _b,
      placementStrategy = rawOptions.placementStrategy;

  if (!data || !data.length) {
    return [];
  }

  var fontFamily = wordStyle.fontFamily,
      fontWeight = wordStyle.fontWeight,
      padding = wordStyle.padding,
      fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data, weightField);
  var range = [min(arr), max(arr)]; //  text  value 

  var words = data.map(function (datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum: datum
    };
  });
  var options = {
    imageMask: imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight: fontWeight,
    //  padding 
    size: getSize({
      width: width,
      height: height,
      padding: chartPadding,
      appendPadding: appendPadding,
      autoFit: autoFit,
      container: ele
    }),
    padding: padding,
    timeInterval: timeInterval,
    random: random,
    spiral: spiral,
    rotate: getRotate(rawOptions)
  }; // 

  if (util_1.isFunction(placementStrategy)) {
    var result = words.map(function (word, index, words) {
      return tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, word), {
        hasText: !!word.text,
        font: word_cloud_1.functor(options.font)(word, index, words),
        weight: word_cloud_1.functor(options.fontWeight)(word, index, words),
        rotate: word_cloud_1.functor(options.rotate)(word, index, words),
        size: word_cloud_1.functor(options.fontSize)(word, index, words),
        style: 'normal'
      }), placementStrategy.call(chart, word, index, words));
    }); // 

    result.push({
      text: '',
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: '',
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  } // wordCloud 


  return word_cloud_1.wordCloud(words, options);
}

exports.transform = transform;
/**
 * [width, height]
 * @param chart
 */

function getSize(options) {
  var width = options.width,
      height = options.height;
  var container = options.container,
      autoFit = options.autoFit,
      padding = options.padding,
      appendPadding = options.appendPadding; //  DataSet 
  //  DataSet 
  //  DataSet 
  // 

  if (autoFit) {
    var containerSize = utils_1.getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  } //  0


  width = width || 400;
  height = height || 400;

  var _a = resolvePadding({
    padding: padding,
    appendPadding: appendPadding
  }),
      top = _a[0],
      right = _a[1],
      bottom = _a[2],
      left = _a[3];

  var result = [width - (left + right), height - (top + bottom)];
  return result;
}

exports.getSize = getSize;
/**
 *  padding  appendPadding  padding
 * @param chart
 */

function resolvePadding(options) {
  var padding = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding[0] + appendPadding[0];
  var right = padding[1] + appendPadding[1];
  var bottom = padding[2] + appendPadding[2];
  var left = padding[3] + appendPadding[3];
  return [top, right, bottom, left];
}
/**
 *  padding 
 * @param padding
 */


function normalPadding(padding) {
  if (util_1.isNumber(padding)) {
    return [padding, padding, padding, padding];
  }

  if (util_1.isArray(padding)) {
    var length_1 = padding.length;

    if (length_1 === 1) {
      return [padding[0], padding[0], padding[0], padding[0]];
    }

    if (length_1 === 2) {
      return [padding[0], padding[1], padding[0], padding[1]];
    }

    if (length_1 === 3) {
      return [padding[0], padding[1], padding[2], padding[1]];
    }

    if (length_1 === 4) {
      return padding;
    }
  }

  return [0, 0, 0, 0];
}
/**
 *  imageMask  url 
 * @param  {HTMLImageElement | string} img
 * @return {Promise}
 */


function processImageMask(img) {
  return new Promise(function (res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }

    if (util_1.isString(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = 'anonymous';
      image_1.src = img;

      image_1.onload = function () {
        res(image_1);
      };

      image_1.onerror = function () {
        utils_1.log(utils_1.LEVEL.ERROR, false, 'image %s load failed !!!', img);
        rej();
      };

      return;
    }

    utils_1.log(utils_1.LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');
    rej();
  });
}

exports.processImageMask = processImageMask;
/**
 *  fontSize  DataSet 
 * @param options
 * @param range
 */

function getFontSizeMapping(fontSize, range) {
  if (util_1.isFunction(fontSize)) {
    return fontSize;
  }

  if (util_1.isArray(fontSize)) {
    var fMin_1 = fontSize[0],
        fMax_1 = fontSize[1];

    if (!range) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }

    var min_1 = range[0],
        max_1 = range[1];

    if (max_1 === min_1) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }

    return function fontSize(_a) {
      var value = _a.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;
    };
  }

  return function () {
    return fontSize;
  };
}

exports.getFontSizeMapping = getFontSizeMapping;

function getSingleKeyValues(data, key) {
  return data.map(function (v) {
    return v[key];
  }).filter(function (v) {
    //  number
    if (typeof v === 'number' && !isNaN(v)) return true;
    return false;
  });
}

exports.getSingleKeyValues = getSingleKeyValues;
/**
 *  DataSet 
 * @param options
 */

function getRotate(options) {
  var _a = resolveRotate(options),
      rotation = _a.rotation,
      rotationSteps = _a.rotationSteps;

  if (!util_1.isArray(rotation)) return rotation;
  var min = rotation[0];
  var max = rotation[1]; //  1  0

  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
  return function rotate() {
    if (max === min) return max;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
/**
 * 
 * @param options
 */


function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;

  if (rotationSteps < 1) {
    utils_1.log(utils_1.LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');
    rotationSteps = 1;
  }

  return {
    rotation: options.wordStyle.rotation,
    rotationSteps: rotationSteps
  };
}
/**
 * 
 * 
 * @param numbers
 */


function min(numbers) {
  return Math.min.apply(Math, numbers);
}
/**
 * 
 * 
 * @param numbers
 */


function max(numbers) {
  return Math.max.apply(Math, numbers);
}

/***/ }),
/* 505 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basicFunnel = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var tooltip_1 = __webpack_require__(88);

var base_1 = __webpack_require__(89);

var constant_1 = __webpack_require__(119);

var common_1 = __webpack_require__(296);
/**
 * 
 * @param params
 */


function field(params) {
  var chart = params.chart,
      options = params.options;
  var _a = options.data,
      data = _a === void 0 ? [] : _a,
      yField = options.yField,
      maxSize = options.maxSize,
      minSize = options.minSize;
  var formatData = common_1.transformData(data, data, {
    yField: yField,
    maxSize: maxSize,
    minSize: minSize
  }); // 

  chart.data(formatData);
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      color = options.color,
      tooltip = options.tooltip,
      label = options.label;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField]),
      fields = _a.fields,
      formatter = _a.formatter;

  base_1.geometry({
    chart: chart,
    options: {
      type: 'interval',
      xField: xField,
      yField: constant_1.FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: util_1.isArray(fields) && fields.concat([constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION]),
      mapping: {
        shape: 'funnel',
        tooltip: formatter,
        color: color
      },
      label: label
    }
  });
  var geo = utils_1.findGeometry(params.chart, 'interval');
  geo.adjust('symmetric');
  return params;
}
/**
 * 
 * @param params
 */


function transpose(params) {
  var chart = params.chart,
      options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: 'rect',
    actions: !isTransposed ? [['transpose'], ['scale', 1, -1]] : []
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var options = params.options;
  var maxSize = options.maxSize;

  var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
    var percent = maxSize - (maxSize - datum[constant_1.FUNNEL_MAPPING_VALUE]) / 2;
    return tslib_1.__assign(tslib_1.__assign({}, initLineOption), {
      start: [datumIndex - 0.5, percent],
      end: [datumIndex - 0.5, percent + 0.05]
    });
  };

  common_1.conversionTagComponent(getLineCoordinate)(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function basicFunnel(params) {
  return utils_1.flow(field, geometry, transpose, conversionTag)(params);
}

exports.basicFunnel = basicFunnel;

/***/ }),
/* 506 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLiquidData = void 0;
var CAT_VALUE = 'liquid';
/**
 * 
 */

function getLiquidData(percent) {
  return [{
    percent: percent,
    type: CAT_VALUE
  }];
}

exports.getLiquidData = getLiquidData;

/***/ }),
/* 507 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binHistogram = void 0;

var util_1 = __webpack_require__(0); //  range


function getBinKey(value, binWidth) {
  var index = Math.floor(value / binWidth);
  return [binWidth * index, binWidth * (index + 1)];
} //  sturges 


function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
/**
 * 
 * @param data
 * @param binField
 * @param binWidth
 * @param binNumber
 * @param stackField
 */


function binHistogram(data, binField, binWidth, binNumber, stackField) {
  var originData_copy = util_1.clone(data); //  binField 

  util_1.sortBy(originData_copy, binField); //  binField  range

  var values = util_1.valuesOfKey(originData_copy, binField);
  var range = util_1.getRange(values);
  var rangeWidth = range.max - range.min; //  binWidth binNumber  binWidth 

  var _binWidth = binWidth;

  if (!binWidth && binNumber) {
    _binWidth = rangeWidth / binNumber;
  } //  binWidth  binNumber  Sturges formula  binWidth


  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values);

    _binWidth = rangeWidth / _defaultBinNumber;
  } //  key - StatisticData 


  var bins = {};
  var groups = util_1.groupBy(originData_copy, stackField); //  stackField 

  if (util_1.isEmpty(groups)) {
    util_1.each(originData_copy, function (data) {
      var value = data[binField];
      var bin = getBinKey(value, _binWidth);
      var binKey = bin[0] + "-" + bin[1];

      if (!util_1.hasKey(bins, binKey)) {
        bins[binKey] = {
          range: bin,
          count: 0
        };
      }

      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function (groupKey) {
      util_1.each(groups[groupKey], function (data) {
        var value = data[binField];
        var bin = getBinKey(value, _binWidth);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;

        if (!util_1.hasKey(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = {
            range: bin,
            count: 0
          };
          bins[groupKeyBinKey][stackField] = groupKey;
        }

        bins[groupKeyBinKey].count += 1;
      });
    });
  } //  plotData 


  var plotData = [];
  util_1.each(bins, function (bin) {
    plotData.push(bin);
  });
  return plotData;
}

exports.binHistogram = binHistogram;

/***/ }),
/* 508 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_TOTAL = exports.ABSOLUTE_FIELD = exports.DIFF_FIELD = exports.Y_FIELD = void 0;
exports.Y_FIELD = '$$yField$$';
exports.DIFF_FIELD = '$$diffField$$';
exports.ABSOLUTE_FIELD = '$$absoluteField$$';
exports.IS_TOTAL = '$$isTotal$$';

/***/ }),
/* 509 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = exports.processData = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var constants_1 = __webpack_require__(508);
/**
 * @desc [start, end]
 * @param data
 * @param xField
 * @param yField
 * @param totalLabel
 */


function processData(data, xField, yField, newYField, total) {
  var _a;

  var newData = [];
  util_1.reduce(data, function (r, d) {
    var _a; // 


    utils_1.log(utils_1.LEVEL.WARN, util_1.isNumber(d[yField]), d[yField] + " is not a valid number");
    var value = util_1.isUndefined(d[yField]) ? null : d[yField];
    newData.push(tslib_1.__assign(tslib_1.__assign({}, d), (_a = {}, _a[newYField] = [r, r + value], _a)));
    return r + value;
  }, 0); // 

  if (newData.length && total) {
    var sum = util_1.get(newData, [[data.length - 1], newYField, [1]]);
    newData.push((_a = {}, _a[xField] = total.label, _a[yField] = sum, _a[newYField] = [0, sum], _a));
  }

  return newData;
}

exports.processData = processData;
/**
 *   
 */

function transformData(data, xField, yField, total) {
  var processed = processData(data, xField, yField, constants_1.Y_FIELD, total);
  return processed.map(function (d, dIdx) {
    var _a;

    if (!util_1.isObject(d)) {
      return d;
    }

    return tslib_1.__assign(tslib_1.__assign({}, d), (_a = {}, _a[constants_1.ABSOLUTE_FIELD] = d[constants_1.Y_FIELD][1], _a[constants_1.DIFF_FIELD] = d[constants_1.Y_FIELD][1] - d[constants_1.Y_FIELD][0], _a[constants_1.IS_TOTAL] = dIdx === data.length, _a));
  });
}

exports.transformData = transformData;

/***/ }),
/* 510 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "regressionExp", {
  enumerable: true,
  get: function get() {
    return _exponential.default;
  }
});
Object.defineProperty(exports, "regressionLinear", {
  enumerable: true,
  get: function get() {
    return _linear.default;
  }
});
Object.defineProperty(exports, "regressionLoess", {
  enumerable: true,
  get: function get() {
    return _loess.default;
  }
});
Object.defineProperty(exports, "regressionLog", {
  enumerable: true,
  get: function get() {
    return _logarithmic.default;
  }
});
Object.defineProperty(exports, "regressionPoly", {
  enumerable: true,
  get: function get() {
    return _polynomial.default;
  }
});
Object.defineProperty(exports, "regressionPow", {
  enumerable: true,
  get: function get() {
    return _power.default;
  }
});
Object.defineProperty(exports, "regressionQuad", {
  enumerable: true,
  get: function get() {
    return _quadratic.default;
  }
});

var _exponential = _interopRequireDefault(__webpack_require__(1079));

var _linear = _interopRequireDefault(__webpack_require__(511));

var _loess = _interopRequireDefault(__webpack_require__(1081));

var _logarithmic = _interopRequireDefault(__webpack_require__(1083));

var _polynomial = _interopRequireDefault(__webpack_require__(1084));

var _power = _interopRequireDefault(__webpack_require__(1085));

var _quadratic = _interopRequireDefault(__webpack_require__(512));

/***/ }),
/* 511 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _ols3 = __webpack_require__(158);

var _points = __webpack_require__(98);

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      domain;

  function linear(data) {
    var n = 0,
        X = 0,
        // sum of x
    Y = 0,
        // sum of y
    XY = 0,
        // sum of x * y
    X2 = 0,
        // sum of x * x
    xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points.visitPoints)(data, x, y, function (dx, dy) {
      ++n;
      X += (dx - X) / n;
      Y += (dy - Y) / n;
      XY += (dx * dy - XY) / n;
      X2 += (dx * dx - X2) / n;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });

    var _ols = (0, _ols3.ols)(X, Y, XY, X2),
        _ols2 = (0, _slicedToArray2.default)(_ols, 2),
        intercept = _ols2[0],
        slope = _ols2[1],
        fn = function fn(x) {
      return slope * x + intercept;
    },
        out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];

    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, Y, fn);
    return out;
  }

  linear.domain = function (arr) {
    return arguments.length ? (domain = arr, linear) : domain;
  };

  linear.x = function (fn) {
    return arguments.length ? (x = fn, linear) : x;
  };

  linear.y = function (fn) {
    return arguments.length ? (y = fn, linear) : y;
  };

  return linear;
}

/***/ }),
/* 512 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _interpose = __webpack_require__(157);

var _points3 = __webpack_require__(98);

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      domain;

  function quadratic(data) {
    var _points = (0, _points3.points)(data, x, y),
        _points2 = (0, _slicedToArray2.default)(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length;

    var X2 = 0,
        X3 = 0,
        X4 = 0,
        XY = 0,
        X2Y = 0,
        i,
        dx,
        dy,
        x2;

    for (i = 0; i < n;) {
      dx = xv[i];
      dy = yv[i++];
      x2 = dx * dx;
      X2 += (x2 - X2) / i;
      X3 += (x2 * dx - X3) / i;
      X4 += (x2 * x2 - X4) / i;
      XY += (dx * dy - XY) / i;
      X2Y += (x2 * dy - X2Y) / i;
    }

    var Y = 0,
        n0 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points3.visitPoints)(data, x, y, function (dx, dy) {
      n0++;
      Y += (dy - Y) / n0;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });

    var X2X2 = X4 - X2 * X2,
        d = X2 * X2X2 - X3 * X3,
        a = (X2Y * X2 - XY * X3) / d,
        b = (XY * X2X2 - X2Y * X3) / d,
        c = -a * X2,
        fn = function fn(x) {
      x = x - ux;
      return a * x * x + b * x + c + uy;
    };

    var out = (0, _interpose.interpose)(xmin, xmax, fn);
    out.a = a;
    out.b = b - 2 * a * ux;
    out.c = c - b * ux + a * ux * ux + uy;
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, Y, fn);
    return out;
  }

  quadratic.domain = function (arr) {
    return arguments.length ? (domain = arr, quadratic) : domain;
  };

  quadratic.x = function (fn) {
    return arguments.length ? (x = fn, quadratic) : x;
  };

  quadratic.y = function (fn) {
    return arguments.length ? (y = fn, quadratic) : y;
  };

  return quadratic;
}

/***/ }),
/* 513 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = void 0;
/**
 * bullet 
 * @param options
 */

function transformData(options) {
  var data = options.data,
      xField = options.xField,
      measureField = options.measureField,
      rangeField = options.rangeField,
      targetField = options.targetField,
      layout = options.layout;
  var ds = [];
  var scales = [];
  data.forEach(function (item, index) {
    var _a; //  title * range


    item[rangeField].sort(function (a, b) {
      return a - b;
    });
    item[rangeField].forEach(function (d, i) {
      var _a;

      var range = i === 0 ? d : item[rangeField][i] - item[rangeField][i - 1];
      ds.push((_a = {
        rKey: rangeField + "_" + i
      }, _a[xField] = xField ? item[xField] : String(index), _a[rangeField] = range, _a));
    }); //  title * measure

    item[measureField].forEach(function (d, i) {
      var _a;

      ds.push((_a = {
        mKey: item[measureField].length > 1 ? measureField + "_" + i : "" + measureField
      }, _a[xField] = xField ? item[xField] : String(index), _a[measureField] = d, _a));
    }); //  title * target

    ds.push((_a = {
      tKey: "" + targetField
    }, _a[xField] = xField ? item[xField] : String(index), _a[targetField] = item[targetField], _a)); // 

    scales.push(item[rangeField], item[measureField], item[targetField]);
  }); // scales 

  var min = Math.min.apply(Math, scales.flat(Infinity));
  var max = Math.max.apply(Math, scales.flat(Infinity)); // min  0  0 

  min = min > 0 ? 0 : min; // 

  if (layout === 'vertical') {
    ds.reverse();
  }

  return {
    min: min,
    max: max,
    ds: ds
  };
}

exports.transformData = transformData;

/***/ }),
/* 514 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findViewById = findViewById;

/**
 *  Chart  id  View
 * @param chart
 * @param id
 */
function findViewById(chart, id) {
  return chart.views.find(function (view) {
    return view.id === id;
  });
}

/***/ }),
/* 515 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adapteStyle = adapteStyle;
exports.setStatisticContainerStyle = setStatisticContainerStyle;
exports.renderGaugeStatistic = exports.renderStatistic = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _ = __webpack_require__(12);

/**
 * @desc  html-statistic  style  ( canvas  shapeStyle  css)
 *
 * @param width
 * @param style
 */
function adapteStyle(style) {
  var styleObject = {
    overflow: 'hidden',
    'white-space': 'nowrap',
    'text-overflow': 'ellipsis',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center'
  };
  var shapeStyleKeys = ['stroke', 'lineWidth', 'shadowColor', 'strokeOpacity', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'fill']; //  shapeStyle   start

  if ((0, _util.get)(style, 'fill')) {
    styleObject['color'] = style['fill'];
  }

  var _a = (0, _.pick)(style, shapeStyleKeys),
      shadowColor = _a.shadowColor,
      _b = _a.shadowBlur,
      shadowBlur = _b === void 0 ? 0 : _b,
      _c = _a.shadowOffsetX,
      shadowOffsetX = _c === void 0 ? 0 : _c,
      _d = _a.shadowOffsetY,
      shadowOffsetY = _d === void 0 ? 0 : _d;

  styleObject['text-shadow'] = "" + [shadowColor, shadowOffsetX + "px", shadowOffsetY + "px", shadowBlur + "px"].join(' ');

  var _e = (0, _.pick)(style, shapeStyleKeys),
      stroke = _e.stroke,
      _f = _e.lineWidth,
      lineWidth = _f === void 0 ? 0 : _f;

  styleObject['-webkit-text-stroke'] = "" + [lineWidth + "px", stroke].join(' '); //  shapeStyle   end

  (0, _util.each)(style, function (v, k) {
    //   shapeStyle  fontSize 
    if (['fontSize'].includes(k) && (0, _util.isNumber)(v)) {
      styleObject[(0, _.kebabCase)(k)] = v + "px";
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[(0, _.kebabCase)(k)] = "" + v;
    }
  });
  return styleObject;
}
/**
 * @desc  html-statistic 
 *
 * - 
 */


function setStatisticContainerStyle(container, style) {
  container.style['pointer-events'] = 'none';
  (0, _util.each)(style, function (v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
/**
 *  html-annotation position  [50%, 50%]
 * @param chart
 * @param options
 * @param meta 
 * @param {optional} datum 
 */


var renderStatistic = function renderStatistic(chart, options, datum) {
  var statistic = options.statistic,
      plotType = options.plotType;
  var titleOpt = statistic.title,
      contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option, idx) {
    if (!option) {
      return;
    }

    var text = '';
    var transform = '';

    if (idx === 0) {
      transform = contentOpt ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
    } else {
      transform = titleOpt ? 'translate(-50%, 0)' : 'translate(-50%, -50%)';
    }

    var style = (0, _util.isFunction)(option.style) ? option.style(datum) : option.style;
    chart.annotation().html((0, _tslib.__assign)({
      position: ['50%', '50%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate();
        var containerW = 0;

        if (plotType === 'pie' || plotType === 'ring-progress') {
          containerW = coordinate.getRadius() * coordinate.innerRadius * 2;
        } else if (plotType === 'liquid') {
          var liquidShape = (0, _util.get)(view.geometries, [0, 'elements', 0, 'shape']);

          if (liquidShape) {
            var circle = liquidShape.find(function (t) {
              return t.get('type') === 'circle';
            });
            var width = circle.getCanvasBBox().width;
            containerW = width;
          }
        } else if (!containerW) {
          // 
          containerW = coordinate.getWidth();
        }

        setStatisticContainerStyle(container, (0, _tslib.__assign)({
          width: containerW + "px",
          transform: transform
        }, adapteStyle(style)));
        var filteredData = view.getData();

        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }

        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        } // todo G2  & G2  number


        return text ? (0, _util.isString)(text) ? text : "" + text : '<div></div>';
      },
      // @ts-ignore
      key: (idx === 0 ? 'top' : 'bottom') + "-statistic"
    }, (0, _.pick)(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter'])
    /**  */
    ));
  });
};
/**
 *  html-annotation for gauge ( plot),  position  [50%, 100%]
 * @param chart
 * @param options
 * @param meta 
 * @param {optional} datum 
 */


exports.renderStatistic = renderStatistic;

var renderGaugeStatistic = function renderGaugeStatistic(chart, options, datum) {
  var statistic = options.statistic;
  var titleOpt = statistic.title,
      contentOpt = statistic.content;
  [titleOpt, contentOpt].forEach(function (option) {
    if (!option) {
      return;
    }

    var text = '';
    var style = (0, _util.isFunction)(option.style) ? option.style(datum) : option.style;
    chart.annotation().html((0, _tslib.__assign)({
      position: ['50%', '100%'],
      html: function html(container, view) {
        var coordinate = view.getCoordinate(); // 

        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate.y.start - parseFloat((0, _util.get)(style, 'fontSize', 0));
        var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
        setStatisticContainerStyle(container, (0, _tslib.__assign)({
          width: containerWidth + "px",
          transform: "translate(-50%, " + offsetY + "px)"
        }, adapteStyle(style)));
        var filteredData = view.getData();

        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }

        if (option.formatter) {
          text = option.formatter(datum, filteredData);
        } // todo G2  & G2  number


        return text ? (0, _util.isString)(text) ? text : "" + text : '<div></div>';
      }
    }, (0, _.pick)(option, ['offsetX', 'offsetY', 'rotate', 'style', 'formatter'])
    /**  */
    ));
  });
};

exports.renderGaugeStatistic = renderGaugeStatistic;

/***/ }),
/* 516 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = meta;
exports.axis = axis;
exports.legend = legend;
exports.adjust = adjust;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _data = __webpack_require__(106);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      color = options.color,
      lineStyle = options.lineStyle,
      lineShape = options.lineShape,
      pointMapping = options.point,
      seriesField = options.seriesField;
  chart.data(data); // line geometry 

  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color,
        style: lineStyle,
        shape: lineShape
      },
      //  tooltip 
      // 
      point: pointMapping && (0, _tslib.__assign)({
        color: color,
        shape: 'circle'
      }, pointMapping),
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  });
  (0, _geometries.line)(primary);
  (0, _geometries.point)(second);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      data = options.data;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = (0, _data.adjustYMetaByZero)(data, yField), _b)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var lineGeometry = (0, _utils.findGeometry)(chart, 'line'); // label  false,   label

  if (!label) {
    lineGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(cfg))
    });
  }

  return params;
}
/**
 *  adjust
 * @param params
 */


function adjust(params) {
  var chart = params.chart,
      options = params.options;
  var isStack = options.isStack;

  if (isStack) {
    (0, _util.each)(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, adjust, _common.theme, axis, legend, _common.tooltip, label, _common.slider, _common.interaction, _common.animation, (0, _common.annotation)(), _common.limitInPlot)(params);
}

/***/ }),
/* 517 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polygon = polygon;

var _tslib = __webpack_require__(1);

var _tooltip = __webpack_require__(90);

var _utils = __webpack_require__(12);

var _base = __webpack_require__(78);

/**
 * polygon 
 * @param params
 */
function polygon(params) {
  var options = params.options;
  var polygon = options.polygon,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return polygon ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'polygon',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, polygon)
    }
  })) : params;
}

/***/ }),
/* 518 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRealNumber = isRealNumber;

/**
 * 
 * @param v
 */
function isRealNumber(v) {
  return typeof v === 'number' && !isNaN(v);
}

/***/ }),
/* 519 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.legend = legend;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _utils = __webpack_require__(12);

var _common = __webpack_require__(25);

var _conversionTag = __webpack_require__(1117);

var _connectedArea = __webpack_require__(1118);

var _geometries = __webpack_require__(32);

var _percent = __webpack_require__(122);

var _data = __webpack_require__(106);

/**
 * defaultOptions
 * @param params
 */
function defaultOptions(params) {
  var options = params.options; //  legend 

  var legend = options.legend;
  var seriesField = options.seriesField,
      isStack = options.isStack;

  if (seriesField) {
    if (legend !== false) {
      legend = (0, _tslib.__assign)({
        position: isStack ? 'right-top' : 'top-left'
      }, legend);
    }
  } else {
    legend = false;
  } // @ts-ignore 


  params.options.legend = legend;
  return params;
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      columnStyle = options.columnStyle,
      color = options.color,
      columnWidthRatio = options.columnWidthRatio,
      isPercent = options.isPercent,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;
  chart.data((0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent)); //  % , 

  var tooltipOptions = isPercent ? (0, _tslib.__assign)({
    formatter: function formatter(datum) {
      return {
        name: datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        style: columnStyle,
        color: color
      }
    }
  });
  (0, _geometries.interval)(p);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      data = options.data,
      isPercent = options.isPercent;
  var percentYMeta = isPercent ? {
    max: 1,
    min: 0,
    minLimit: 0,
    maxLimit: 1
  } : {};
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a), (_b = {}, _b[xField] = {
    type: 'cat'
  }, _b[yField] = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _data.adjustYMetaByZero)(data, yField)), percentYMeta), _b)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend && seriesField) {
    chart.legend(seriesField, legend);
  } else if (legend === false) {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField,
      isRange = options.isRange;
  var geometry = (0, _utils.findGeometry)(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        //  label layout  layout  position  layout
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? undefined : [{
          type: 'interval-adjust-position'
        }, {
          type: 'interval-hide-overlap'
        }, {
          type: 'adjust-color'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(isRange ? (0, _tslib.__assign)({
        content: function content(item) {
          var _a;

          return (_a = item[yField]) === null || _a === void 0 ? void 0 : _a.join('-');
        }
      }, cfg) : cfg))
    });
  }

  return params;
}
/**
 * 
 * @param params
 */


function adaptor(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }

  var options = params.options;
  var seriesField = options.seriesField;
  return (0, _utils.flow)(defaultOptions, // 
  _common.theme, // theme  geometry 
  geometry, meta, axis, legend, _common.tooltip, _common.slider, _common.scrollbar, label, _common.interaction, _common.animation, (0, _common.annotation)(), (0, _conversionTag.conversionTag)(options.yField, !isBar, !!seriesField), // 
  (0, _connectedArea.connectedArea)(!options.isStack), _common.limitInPlot)(params);
}

/***/ }),
/* 520 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTagFormatter = conversionTagFormatter;

var _util = __webpack_require__(0);

/**
 * 
 * @param prev
 * @param next
 */
function conversionTagFormatter(prev, next) {
  if (!(0, _util.isNumber)(prev) || !(0, _util.isNumber)(next)) {
    return '-';
  }

  if (prev === next) {
    return '100%';
  }

  if (prev === 0) {
    return '';
  }

  if (next === 0) {
    return '-';
  }

  return (100 * next / prev).toFixed(2) + "%";
}

/***/ }),
/* 521 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_OPTIONS = void 0;

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

/**
 * 
 */
var DEFAULT_OPTIONS = (0, _utils.deepAssign)({}, _plot.Plot.getDefaultOptions(), {
  legend: {
    position: 'right'
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: {
      type: 'limit-in-plot',
      cfg: {
        action: 'ellipsis'
      }
    }
  },

  /** ,  */
  pieStyle: {
    stroke: 'white',
    lineWidth: 1
  },

  /**  */
  statistic: {
    title: {
      style: {
        fontWeight: 300,
        color: '#4B535E',
        textAlign: 'center',
        fontSize: '20px',
        lineHeight: 1
      }
    },
    content: {
      style: {
        fontWeight: 'bold',
        color: 'rgba(44,53,66,0.85)',
        textAlign: 'center',
        fontSize: '32px',
        lineHeight: 1
      }
    }
  },

  /**  text-annotation  */
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;

/***/ }),
/* 522 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTotalValue = getTotalValue;
exports.adaptOffset = adaptOffset;
exports.processIllegalData = processIllegalData;
exports.isAllZero = isAllZero;

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

/**
 * 
 * @param data
 * @param field
 */
function getTotalValue(data, field) {
  var total = null;
  (0, _util.each)(data, function (item) {
    if (typeof item[field] === 'number') {
      total += item[field];
    }
  });
  return total;
}
/**
 * pie label offset adaptor
 */


function adaptOffset(type, offset) {
  var defaultOffset;

  switch (type) {
    case 'inner':
      defaultOffset = '-30%';

      if ((0, _util.isString)(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }

      return offset < 0 ? offset : defaultOffset;

    case 'outer':
      defaultOffset = 12;

      if ((0, _util.isString)(offset) && offset.endsWith('%')) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }

      return offset > 0 ? offset : defaultOffset;

    default:
      return offset;
  }
}
/**
 * (   NaN null)
 * @param data
 * @param angleField
 */


function processIllegalData(data, angleField) {
  var processData = (0, _util.filter)(data, function (d) {
    var v = d[angleField];
    return typeof v === 'number' && !isNaN(v) || v === null;
  }); // 

  (0, _utils.log)(_utils.LEVEL.WARN, processData.length === data.length, 'illegal data existed in chart data.');
  return processData;
}
/**
 *  0
 * @param data
 * @param angleField
 */


function isAllZero(data, angleField) {
  return (0, _util.every)(data, function (d) {
    return d[angleField] === 0;
  });
}

/***/ }),
/* 523 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = transform;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
/**
 * 
 * @param actions
 * @param matrix
 */

function transform(actions, matrix) {
  var ulMatrix = matrix ? (0, _tslib.__spreadArrays)(matrix) : (0, _tslib.__spreadArrays)(ORIGIN_MATRIX);
  return _g.Util.transform(ulMatrix, actions);
}

/***/ }),
/* 524 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transform = transform;
exports.getSize = getSize;
exports.processImageMask = processImageMask;
exports.getFontSizeMapping = getFontSizeMapping;
exports.getSingleKeyValues = getSingleKeyValues;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _wordCloud = __webpack_require__(1130);

/**
 *  DataSet 
 * @param params
 */
function transform(params) {
  var rawOptions = params.options,
      chart = params.chart;
  var _a = chart,
      width = _a.width,
      height = _a.height,
      chartPadding = _a.padding,
      appendPadding = _a.appendPadding,
      ele = _a.ele;
  var data = rawOptions.data,
      imageMask = rawOptions.imageMask,
      wordField = rawOptions.wordField,
      weightField = rawOptions.weightField,
      colorField = rawOptions.colorField,
      wordStyle = rawOptions.wordStyle,
      timeInterval = rawOptions.timeInterval,
      random = rawOptions.random,
      spiral = rawOptions.spiral,
      _b = rawOptions.autoFit,
      autoFit = _b === void 0 ? true : _b,
      placementStrategy = rawOptions.placementStrategy;

  if (!data || !data.length) {
    return [];
  }

  var fontFamily = wordStyle.fontFamily,
      fontWeight = wordStyle.fontWeight,
      padding = wordStyle.padding,
      fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data, weightField);
  var range = [min(arr), max(arr)]; //  text  value 

  var words = data.map(function (datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum: datum
    };
  });
  var options = {
    imageMask: imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight: fontWeight,
    //  padding 
    size: getSize({
      width: width,
      height: height,
      padding: chartPadding,
      appendPadding: appendPadding,
      autoFit: autoFit,
      container: ele
    }),
    padding: padding,
    timeInterval: timeInterval,
    random: random,
    spiral: spiral,
    rotate: getRotate(rawOptions)
  }; // 

  if ((0, _util.isFunction)(placementStrategy)) {
    var result = words.map(function (word, index, words) {
      return (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, word), {
        hasText: !!word.text,
        font: (0, _wordCloud.functor)(options.font)(word, index, words),
        weight: (0, _wordCloud.functor)(options.fontWeight)(word, index, words),
        rotate: (0, _wordCloud.functor)(options.rotate)(word, index, words),
        size: (0, _wordCloud.functor)(options.fontSize)(word, index, words),
        style: 'normal'
      }), placementStrategy.call(chart, word, index, words));
    }); // 

    result.push({
      text: '',
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: '',
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  } // wordCloud 


  return (0, _wordCloud.wordCloud)(words, options);
}
/**
 * [width, height]
 * @param chart
 */


function getSize(options) {
  var width = options.width,
      height = options.height;
  var container = options.container,
      autoFit = options.autoFit,
      padding = options.padding,
      appendPadding = options.appendPadding; //  DataSet 
  //  DataSet 
  //  DataSet 
  // 

  if (autoFit) {
    var containerSize = (0, _utils.getContainerSize)(container);
    width = containerSize.width;
    height = containerSize.height;
  } //  0


  width = width || 400;
  height = height || 400;

  var _a = resolvePadding({
    padding: padding,
    appendPadding: appendPadding
  }),
      top = _a[0],
      right = _a[1],
      bottom = _a[2],
      left = _a[3];

  var result = [width - (left + right), height - (top + bottom)];
  return result;
}
/**
 *  padding  appendPadding  padding
 * @param chart
 */


function resolvePadding(options) {
  var padding = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding[0] + appendPadding[0];
  var right = padding[1] + appendPadding[1];
  var bottom = padding[2] + appendPadding[2];
  var left = padding[3] + appendPadding[3];
  return [top, right, bottom, left];
}
/**
 *  padding 
 * @param padding
 */


function normalPadding(padding) {
  if ((0, _util.isNumber)(padding)) {
    return [padding, padding, padding, padding];
  }

  if ((0, _util.isArray)(padding)) {
    var length_1 = padding.length;

    if (length_1 === 1) {
      return [padding[0], padding[0], padding[0], padding[0]];
    }

    if (length_1 === 2) {
      return [padding[0], padding[1], padding[0], padding[1]];
    }

    if (length_1 === 3) {
      return [padding[0], padding[1], padding[2], padding[1]];
    }

    if (length_1 === 4) {
      return padding;
    }
  }

  return [0, 0, 0, 0];
}
/**
 *  imageMask  url 
 * @param  {HTMLImageElement | string} img
 * @return {Promise}
 */


function processImageMask(img) {
  return new Promise(function (res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }

    if ((0, _util.isString)(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = 'anonymous';
      image_1.src = img;

      image_1.onload = function () {
        res(image_1);
      };

      image_1.onerror = function () {
        (0, _utils.log)(_utils.LEVEL.ERROR, false, 'image %s load failed !!!', img);
        rej();
      };

      return;
    }

    (0, _utils.log)(_utils.LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');
    rej();
  });
}
/**
 *  fontSize  DataSet 
 * @param options
 * @param range
 */


function getFontSizeMapping(fontSize, range) {
  if ((0, _util.isFunction)(fontSize)) {
    return fontSize;
  }

  if ((0, _util.isArray)(fontSize)) {
    var fMin_1 = fontSize[0],
        fMax_1 = fontSize[1];

    if (!range) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }

    var min_1 = range[0],
        max_1 = range[1];

    if (max_1 === min_1) {
      return function () {
        return (fMax_1 + fMin_1) / 2;
      };
    }

    return function fontSize(_a) {
      var value = _a.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;
    };
  }

  return function () {
    return fontSize;
  };
}

function getSingleKeyValues(data, key) {
  return data.map(function (v) {
    return v[key];
  }).filter(function (v) {
    //  number
    if (typeof v === 'number' && !isNaN(v)) return true;
    return false;
  });
}
/**
 *  DataSet 
 * @param options
 */


function getRotate(options) {
  var _a = resolveRotate(options),
      rotation = _a.rotation,
      rotationSteps = _a.rotationSteps;

  if (!(0, _util.isArray)(rotation)) return rotation;
  var min = rotation[0];
  var max = rotation[1]; //  1  0

  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);
  return function rotate() {
    if (max === min) return max;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
/**
 * 
 * @param options
 */


function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;

  if (rotationSteps < 1) {
    (0, _utils.log)(_utils.LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');
    rotationSteps = 1;
  }

  return {
    rotation: options.wordStyle.rotation,
    rotationSteps: rotationSteps
  };
}
/**
 * 
 * 
 * @param numbers
 */


function min(numbers) {
  return Math.min.apply(Math, numbers);
}
/**
 * 
 * 
 * @param numbers
 */


function max(numbers) {
  return Math.max.apply(Math, numbers);
}

/***/ }),
/* 525 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

(0, _g.registerInteraction)('drag-move', {
  start: [{
    trigger: 'plot:mousedown',
    action: 'scale-translate:start'
  }],
  processing: [{
    trigger: 'plot:mousemove',
    action: 'scale-translate:translate',
    throttle: {
      wait: 100,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseup',
    action: 'scale-translate:end'
  }]
});

/***/ }),
/* 526 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DualAxesGeometry = exports.AxisType = void 0;
var AxisType;
exports.AxisType = AxisType;

(function (AxisType) {
  AxisType["Left"] = "Left";
  AxisType["Right"] = "Right";
})(AxisType || (exports.AxisType = AxisType = {}));

var DualAxesGeometry;
exports.DualAxesGeometry = DualAxesGeometry;

(function (DualAxesGeometry) {
  DualAxesGeometry["Line"] = "line";
  DualAxesGeometry["Column"] = "column";
})(DualAxesGeometry || (exports.DualAxesGeometry = DualAxesGeometry = {}));

/***/ }),
/* 527 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_RIGHT_YAXIS_CONFIG = exports.DEFAULT_LEFT_YAXIS_CONFIG = exports.DEFAULT_YAXIS_CONFIG = exports.RIGHT_AXES_VIEW = exports.LEFT_AXES_VIEW = void 0;

var _tslib = __webpack_require__(1);

var LEFT_AXES_VIEW = 'left-axes-view';
exports.LEFT_AXES_VIEW = LEFT_AXES_VIEW;
var RIGHT_AXES_VIEW = 'right-axes-view';
exports.RIGHT_AXES_VIEW = RIGHT_AXES_VIEW;
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
exports.DEFAULT_YAXIS_CONFIG = DEFAULT_YAXIS_CONFIG;
var DEFAULT_LEFT_YAXIS_CONFIG = (0, _tslib.__assign)((0, _tslib.__assign)({}, DEFAULT_YAXIS_CONFIG), {
  position: 'left'
});
exports.DEFAULT_LEFT_YAXIS_CONFIG = DEFAULT_LEFT_YAXIS_CONFIG;
var DEFAULT_RIGHT_YAXIS_CONFIG = (0, _tslib.__assign)((0, _tslib.__assign)({}, DEFAULT_YAXIS_CONFIG), {
  position: 'right',
  grid: null
});
exports.DEFAULT_RIGHT_YAXIS_CONFIG = DEFAULT_RIGHT_YAXIS_CONFIG;

/***/ }),
/* 528 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.binHistogram = binHistogram;

var _util = __webpack_require__(0);

//  range
function getBinKey(value, binWidth) {
  var index = Math.floor(value / binWidth);
  return [binWidth * index, binWidth * (index + 1)];
} //  sturges 


function sturges(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
/**
 * 
 * @param data
 * @param binField
 * @param binWidth
 * @param binNumber
 * @param stackField
 */


function binHistogram(data, binField, binWidth, binNumber, stackField) {
  var originData_copy = (0, _util.clone)(data); //  binField 

  (0, _util.sortBy)(originData_copy, binField); //  binField  range

  var values = (0, _util.valuesOfKey)(originData_copy, binField);
  var range = (0, _util.getRange)(values);
  var rangeWidth = range.max - range.min; //  binWidth binNumber  binWidth 

  var _binWidth = binWidth;

  if (!binWidth && binNumber) {
    _binWidth = rangeWidth / binNumber;
  } //  binWidth  binNumber  Sturges formula  binWidth


  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values);

    _binWidth = rangeWidth / _defaultBinNumber;
  } //  key - StatisticData 


  var bins = {};
  var groups = (0, _util.groupBy)(originData_copy, stackField); //  stackField 

  if ((0, _util.isEmpty)(groups)) {
    (0, _util.each)(originData_copy, function (data) {
      var value = data[binField];
      var bin = getBinKey(value, _binWidth);
      var binKey = bin[0] + "-" + bin[1];

      if (!(0, _util.hasKey)(bins, binKey)) {
        bins[binKey] = {
          range: bin,
          count: 0
        };
      }

      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function (groupKey) {
      (0, _util.each)(groups[groupKey], function (data) {
        var value = data[binField];
        var bin = getBinKey(value, _binWidth);
        var binKey = bin[0] + "-" + bin[1];
        var groupKeyBinKey = binKey + "-" + groupKey;

        if (!(0, _util.hasKey)(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = {
            range: bin,
            count: 0
          };
          bins[groupKeyBinKey][stackField] = groupKey;
        }

        bins[groupKeyBinKey].count += 1;
      });
    });
  } //  plotData 


  var plotData = [];
  (0, _util.each)(bins, function (bin) {
    plotData.push(bin);
  });
  return plotData;
}

/***/ }),
/* 529 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geometry = geometry;
exports.adaptor = adaptor;

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _constant = __webpack_require__(530);

var _utils2 = __webpack_require__(298);

/**
 * 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      progressStyle = options.progressStyle,
      color = options.color,
      barWidthRatio = options.barWidthRatio;
  chart.data((0, _utils2.getProgressData)(percent));
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: '1',
      yField: 'percent',
      seriesField: 'type',
      isStack: true,
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: (0, _util.isString)(color) ? [color, _constant.DEFAULT_COLOR[1]] : color
      }
    }
  });
  (0, _geometries.interval)(p); // 

  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
/**
 * other 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart;
  chart.coordinate('rect').transpose();
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // @ts-ignore
  return (0, _utils.flow)(geometry, (0, _common.scale)({}), coordinate, _common.animation, _common.theme, (0, _common.annotation)())(params);
}

/***/ }),
/* 530 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_COLOR = void 0;
var DEFAULT_COLOR = ['#FAAD14', '#E8EDF3'];
exports.DEFAULT_COLOR = DEFAULT_COLOR;

/***/ }),
/* 531 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BOX_SYNC_NAME = exports.BOX_RANGE_ALIAS = exports.BOX_RANGE = void 0;
var BOX_RANGE = '$$range$$';
exports.BOX_RANGE = BOX_RANGE;
var BOX_RANGE_ALIAS = 'low-q1-median-q3-high';
exports.BOX_RANGE_ALIAS = BOX_RANGE_ALIAS;
var BOX_SYNC_NAME = '$$y_outliers$$';
exports.BOX_SYNC_NAME = BOX_SYNC_NAME;

/***/ }),
/* 532 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStockData = getStockData;

var _util = __webpack_require__(0);

var _constant = __webpack_require__(299);

/**
 * @desc 
 * @param data
 * @param yField
 */
function getStockData(data, yField) {
  return (0, _util.map)(data, function (obj) {
    if ((0, _util.isArray)(yField)) {
      var open_1 = yField[0],
          close_1 = yField[1],
          high = yField[2],
          low = yField[3];
      obj[_constant.TREND_FIELD] = obj[open_1] <= obj[close_1] ? _constant.TREND_UP : _constant.TREND_DOWN;
      obj[_constant.Y_FIELD] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }

    return obj;
  });
}

/***/ }),
/* 533 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basicFunnel = basicFunnel;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _tooltip = __webpack_require__(90);

var _base = __webpack_require__(78);

var _constant = __webpack_require__(124);

var _common = __webpack_require__(300);

/**
 * 
 * @param params
 */
function field(params) {
  var chart = params.chart,
      options = params.options;
  var _a = options.data,
      data = _a === void 0 ? [] : _a,
      yField = options.yField,
      maxSize = options.maxSize,
      minSize = options.minSize;
  var formatData = (0, _common.transformData)(data, data, {
    yField: yField,
    maxSize: maxSize,
    minSize: minSize
  }); // 

  chart.data(formatData);
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      color = options.color,
      tooltip = options.tooltip,
      label = options.label;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField]),
      fields = _a.fields,
      formatter = _a.formatter;

  (0, _base.geometry)({
    chart: chart,
    options: {
      type: 'interval',
      xField: xField,
      yField: _constant.FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: (0, _util.isArray)(fields) && fields.concat([_constant.FUNNEL_PERCENT, _constant.FUNNEL_CONVERSATION]),
      mapping: {
        shape: 'funnel',
        tooltip: formatter,
        color: color
      },
      label: label
    }
  });
  var geo = (0, _utils.findGeometry)(params.chart, 'interval');
  geo.adjust('symmetric');
  return params;
}
/**
 * 
 * @param params
 */


function transpose(params) {
  var chart = params.chart,
      options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: 'rect',
    actions: !isTransposed ? [['transpose'], ['scale', 1, -1]] : []
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var options = params.options;
  var maxSize = options.maxSize;

  var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
    var percent = maxSize - (maxSize - datum[_constant.FUNNEL_MAPPING_VALUE]) / 2;
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, initLineOption), {
      start: [datumIndex - 0.5, percent],
      end: [datumIndex - 0.5, percent + 0.05]
    });
  };

  (0, _common.conversionTagComponent)(getLineCoordinate)(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function basicFunnel(params) {
  return (0, _utils.flow)(field, geometry, transpose, conversionTag)(params);
}

/***/ }),
/* 534 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLiquidData = getLiquidData;
var CAT_VALUE = 'liquid';
/**
 * 
 */

function getLiquidData(percent) {
  return [{
    percent: percent,
    type: CAT_VALUE
  }];
}

/***/ }),
/* 535 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = transformData;

/**
 * bullet 
 * @param options
 */
function transformData(options) {
  var data = options.data,
      xField = options.xField,
      measureField = options.measureField,
      rangeField = options.rangeField,
      targetField = options.targetField,
      layout = options.layout;
  var ds = [];
  var scales = [];
  data.forEach(function (item, index) {
    var _a; //  title * range


    item[rangeField].sort(function (a, b) {
      return a - b;
    });
    item[rangeField].forEach(function (d, i) {
      var _a;

      var range = i === 0 ? d : item[rangeField][i] - item[rangeField][i - 1];
      ds.push((_a = {
        rKey: rangeField + "_" + i
      }, _a[xField] = xField ? item[xField] : String(index), _a[rangeField] = range, _a));
    }); //  title * measure

    item[measureField].forEach(function (d, i) {
      var _a;

      ds.push((_a = {
        mKey: item[measureField].length > 1 ? measureField + "_" + i : "" + measureField
      }, _a[xField] = xField ? item[xField] : String(index), _a[measureField] = d, _a));
    }); //  title * target

    ds.push((_a = {
      tKey: "" + targetField
    }, _a[xField] = xField ? item[xField] : String(index), _a[targetField] = item[targetField], _a)); // 

    scales.push(item[rangeField], item[measureField], item[targetField]);
  }); // scales 

  var min = Math.min.apply(Math, scales.flat(Infinity));
  var max = Math.max.apply(Math, scales.flat(Infinity)); // min  0  0 

  min = min > 0 ? 0 : min; // 

  if (layout === 'vertical') {
    ds.reverse();
  }

  return {
    min: min,
    max: max,
    ds: ds
  };
}

/***/ }),
/* 536 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getField = getField;
exports.getAllNodes = getAllNodes;

var _util = __webpack_require__(0);

var INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';

function getField(options, defaultField) {
  var field = options.field,
      fields = options.fields;

  if ((0, _util.isString)(field)) {
    return field;
  }

  if ((0, _util.isArray)(field)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field[0];
  }

  console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");

  if ((0, _util.isString)(fields)) {
    return fields;
  }

  if ((0, _util.isArray)(fields) && fields.length) {
    return fields[0];
  }

  if (defaultField) {
    return defaultField;
  }

  throw new TypeError(INVALID_FIELD_ERR_MSG);
}

function getAllNodes(root) {
  var nodes = [];

  if (root && root.each) {
    // d3-hierarchy
    root.each(function (node) {
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    // @antv/hierarchy
    root.eachNode(function (node) {
      nodes.push(node);
    });
  }

  return nodes;
}

/***/ }),
/* 537 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.treemap = treemap;

var d3Hierarchy = _interopRequireWildcard(__webpack_require__(292));

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(536);

var DEFAULT_OPTIONS = {
  field: 'value',
  tile: 'treemapSquarify',
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ['x', 'y']
};

function treemap(data, options) {
  options = (0, _util.assign)({}, DEFAULT_OPTIONS, options);
  var as = options.as;

  if (!(0, _util.isArray)(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }

  var field;

  try {
    field = (0, _util2.getField)(options);
  } catch (e) {
    console.warn(e);
  }

  var partition = function partition(data) {
    return d3Hierarchy.treemap().tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
    /**
     * d3Hierarchy  sum  node  node  post-order traversal  value  node
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
     * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
     * ignoreParentValue  true()  0 + 5 + 5 = 10
     * ignoreParentValue  false   10 + 5 + 5 = 20
     * sum d  data, children 
     */
    d3Hierarchy.hierarchy(data).sum(function (d) {
      return options.ignoreParentValue && d.children ? 0 : d[field];
    }));
  };

  var root = partition(data);
  /*
   * points:
   *   3  2
   *   0  1
   */

  var x = as[0];
  var y = as[1];
  root.each(function (node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return (0, _util2.getAllNodes)(root);
}

/***/ }),
/* 538 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processRangeData = processRangeData;
exports.getIndicatorData = getIndicatorData;
exports.getRangeData = getRangeData;

var _util = __webpack_require__(0);

var _constant = __webpack_require__(196);

/**
 *  range  data 
 * @param range
 * @param key
 */
function processRangeData(range) {
  return range //  stack 
  .map(function (r, idx) {
    var _a;

    return _a = {}, _a[_constant.RANGE_VALUE] = r - (range[idx - 1] || 0), _a[_constant.RANGE_TYPE] = "" + idx, _a;
  }) //  0 
  .filter(function (d) {
    return !!d[_constant.RANGE_VALUE];
  });
}
/**
 *   
 * @param percent
 */


function getIndicatorData(percent) {
  var _a;

  return [(_a = {}, _a[_constant.PERCENT] = (0, _util.clamp)(percent, 0, 1), _a)];
}
/**
 *  
 * @param percent
 * @param range
 */


function getRangeData(percent, range) {
  var ticks = (0, _util.get)(range, ['ticks'], []);
  var clampTicks = (0, _util.size)(ticks) ? ticks : [0, (0, _util.clamp)(percent, 0, 1), 1];
  return processRangeData(clampTicks);
}

/***/ }),
/* 539 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IS_TOTAL = exports.ABSOLUTE_FIELD = exports.DIFF_FIELD = exports.Y_FIELD = void 0;
var Y_FIELD = '$$yField$$';
exports.Y_FIELD = Y_FIELD;
var DIFF_FIELD = '$$diffField$$';
exports.DIFF_FIELD = DIFF_FIELD;
var ABSOLUTE_FIELD = '$$absoluteField$$';
exports.ABSOLUTE_FIELD = ABSOLUTE_FIELD;
var IS_TOTAL = '$$isTotal$$';
exports.IS_TOTAL = IS_TOTAL;

/***/ }),
/* 540 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processData = processData;
exports.transformData = transformData;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _constants = __webpack_require__(539);

/**
 * @desc [start, end]
 * @param data
 * @param xField
 * @param yField
 * @param totalLabel
 */
function processData(data, xField, yField, newYField, total) {
  var _a;

  var newData = [];
  (0, _util.reduce)(data, function (r, d) {
    var _a; // 


    (0, _utils.log)(_utils.LEVEL.WARN, (0, _util.isNumber)(d[yField]), d[yField] + " is not a valid number");
    var value = (0, _util.isUndefined)(d[yField]) ? null : d[yField];
    newData.push((0, _tslib.__assign)((0, _tslib.__assign)({}, d), (_a = {}, _a[newYField] = [r, r + value], _a)));
    return r + value;
  }, 0); // 

  if (newData.length && total) {
    var sum = (0, _util.get)(newData, [[data.length - 1], newYField, [1]]);
    newData.push((_a = {}, _a[xField] = total.label, _a[yField] = sum, _a[newYField] = [0, sum], _a));
  }

  return newData;
}
/**
 *   
 */


function transformData(data, xField, yField, total) {
  var processed = processData(data, xField, yField, _constants.Y_FIELD, total);
  return processed.map(function (d, dIdx) {
    var _a;

    if (!(0, _util.isObject)(d)) {
      return d;
    }

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, d), (_a = {}, _a[_constants.ABSOLUTE_FIELD] = d[_constants.Y_FIELD][1], _a[_constants.DIFF_FIELD] = d[_constants.Y_FIELD][1] - d[_constants.Y_FIELD][0], _a[_constants.IS_TOTAL] = dIdx === data.length, _a));
  });
}

/***/ }),
/* 541 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = transformData;
exports.isHorizontal = isHorizontal;
exports.syncViewPadding = syncViewPadding;

var _util = __webpack_require__(0);

/**
 * bidirectional-bar ,  SERIES_FIELD_KEY 
 * @param xField
 * @param yField
 * @param data
 */
function transformData(xField, yField, seriesField, data, reverse) {
  var hopeData = [];
  yField.forEach(function (d) {
    data.forEach(function (k) {
      var _a;

      var obj = (_a = {}, _a[xField] = k[xField], _a[seriesField] = d, _a[d] = k[d], _a);
      hopeData.push(obj);
    });
  });
  var groupData = Object.values((0, _util.groupBy)(hopeData, seriesField));
  var _a = groupData[0],
      data1 = _a === void 0 ? [] : _a,
      _b = groupData[1],
      data2 = _b === void 0 ? [] : _b;
  return reverse ? [data1.reverse(), data2.reverse()] : [data1, data2];
}
/**
 * 
 * @param layout
 */


function isHorizontal(layout) {
  return layout !== 'vertical';
}
/**
 *  view  padding 
 * @param chart
 * @param views
 * @param p
 */


function syncViewPadding(chart, views, p) {
  var v1 = views[0],
      v2 = views[1];
  var p1 = v1.autoPadding;
  var p2 = v2.autoPadding;
  var _a = chart.__axisPosition,
      layout = _a.layout,
      position = _a.position; //  layout

  if (isHorizontal(layout) && position === 'top') {
    /**
     *  v1  left  v2 right  v1 
     * position top  v1  0
     */
    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
  }

  if (isHorizontal(layout) && position === 'bottom') {
    /**
     *  v1  left  v2 right  v1 
     * position bottom  v1 v1 right = right / 2  v2 left = right / 2
     * + 5  
     */
    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
  }

  if (!isHorizontal(layout) && position === 'bottom') {
    /**
     *  v1  left  v2 left  left 
     * position bottom  v1 v1 bottom = bottom / 2  v2 top = bottom / 2
     * + 5  
     */
    var left = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left);
    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left);
  } // position  top 


  if (!isHorizontal(layout) && position === 'top') {
    var left = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, 0, left);
    v2.autoPadding = p.instance(0, p2.right, p1.top, left);
  }
}

/***/ }),
/* 542 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDrillDown = isDrillDown;
exports.getFommatInteractions = getFommatInteractions;
exports.transformData = transformData;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _treemap = __webpack_require__(537);

var _utils = __webpack_require__(12);

function isDrillDown(interactions) {
  if (!(0, _util.isArray)(interactions)) return false;
  return interactions.findIndex(function (i) {
    return i.type === 'treemap-drill-down';
  }) > -1;
}

function getFommatInteractions(interactions, hierarchyConfig) {
  var openDrillDown = isDrillDown(interactions);

  if (openDrillDown) {
    return interactions.map(function (i) {
      if (i.type === 'treemap-drill-down') {
        return (0, _utils.deepAssign)({}, i, {
          cfg: {
            hierarchyConfig: hierarchyConfig
          }
        });
      }

      return i;
    });
  }

  return interactions;
}

function transformData(options) {
  var data = options.data,
      colorField = options.colorField,
      openDrillDown = options.openDrillDown,
      _a = options.hierarchyConfig,
      hierarchyConfig = _a === void 0 ? {} : _a;
  var nodes = (0, _treemap.treemap)(data, (0, _tslib.__assign)((0, _tslib.__assign)({}, hierarchyConfig), {
    // @ts-ignore
    type: 'hierarchy.treemap',
    field: 'value',
    as: ['x', 'y']
  }));
  var result = [];
  nodes.forEach(function (node) {
    if (node.depth === 0) {
      return null;
    } //  depth === 1 


    if (openDrillDown && node.depth !== 1) {
      return null;
    } // 


    if (!openDrillDown && node.children) {
      return null;
    }

    var eachNode = Object.assign({}, node.data, {
      x: node.x,
      y: node.y,
      depth: node.depth,
      value: node.value
    });

    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function (n) {
        return n.data[colorField];
      });
      eachNode[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      eachNode[colorField] = node.data[colorField];
    }

    result.push(eachNode);
  });
  return result;
}

/***/ }),
/* 543 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "bisect", {
  enumerable: true,
  get: function get() {
    return _bisect.default;
  }
});
Object.defineProperty(exports, "bisectRight", {
  enumerable: true,
  get: function get() {
    return _bisect.bisectRight;
  }
});
Object.defineProperty(exports, "bisectLeft", {
  enumerable: true,
  get: function get() {
    return _bisect.bisectLeft;
  }
});
Object.defineProperty(exports, "bisectCenter", {
  enumerable: true,
  get: function get() {
    return _bisect.bisectCenter;
  }
});
Object.defineProperty(exports, "ascending", {
  enumerable: true,
  get: function get() {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "bisector", {
  enumerable: true,
  get: function get() {
    return _bisector.default;
  }
});
Object.defineProperty(exports, "count", {
  enumerable: true,
  get: function get() {
    return _count.default;
  }
});
Object.defineProperty(exports, "cross", {
  enumerable: true,
  get: function get() {
    return _cross.default;
  }
});
Object.defineProperty(exports, "cumsum", {
  enumerable: true,
  get: function get() {
    return _cumsum.default;
  }
});
Object.defineProperty(exports, "descending", {
  enumerable: true,
  get: function get() {
    return _descending.default;
  }
});
Object.defineProperty(exports, "deviation", {
  enumerable: true,
  get: function get() {
    return _deviation.default;
  }
});
Object.defineProperty(exports, "extent", {
  enumerable: true,
  get: function get() {
    return _extent.default;
  }
});
Object.defineProperty(exports, "fsum", {
  enumerable: true,
  get: function get() {
    return _fsum.default;
  }
});
Object.defineProperty(exports, "Adder", {
  enumerable: true,
  get: function get() {
    return _fsum.Adder;
  }
});
Object.defineProperty(exports, "group", {
  enumerable: true,
  get: function get() {
    return _group.default;
  }
});
Object.defineProperty(exports, "groups", {
  enumerable: true,
  get: function get() {
    return _group.groups;
  }
});
Object.defineProperty(exports, "index", {
  enumerable: true,
  get: function get() {
    return _group.index;
  }
});
Object.defineProperty(exports, "indexes", {
  enumerable: true,
  get: function get() {
    return _group.indexes;
  }
});
Object.defineProperty(exports, "rollup", {
  enumerable: true,
  get: function get() {
    return _group.rollup;
  }
});
Object.defineProperty(exports, "rollups", {
  enumerable: true,
  get: function get() {
    return _group.rollups;
  }
});
Object.defineProperty(exports, "groupSort", {
  enumerable: true,
  get: function get() {
    return _groupSort.default;
  }
});
Object.defineProperty(exports, "bin", {
  enumerable: true,
  get: function get() {
    return _bin.default;
  }
});
Object.defineProperty(exports, "histogram", {
  enumerable: true,
  get: function get() {
    return _bin.default;
  }
});
Object.defineProperty(exports, "thresholdFreedmanDiaconis", {
  enumerable: true,
  get: function get() {
    return _freedmanDiaconis.default;
  }
});
Object.defineProperty(exports, "thresholdScott", {
  enumerable: true,
  get: function get() {
    return _scott.default;
  }
});
Object.defineProperty(exports, "thresholdSturges", {
  enumerable: true,
  get: function get() {
    return _sturges.default;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function get() {
    return _max.default;
  }
});
Object.defineProperty(exports, "maxIndex", {
  enumerable: true,
  get: function get() {
    return _maxIndex.default;
  }
});
Object.defineProperty(exports, "mean", {
  enumerable: true,
  get: function get() {
    return _mean.default;
  }
});
Object.defineProperty(exports, "median", {
  enumerable: true,
  get: function get() {
    return _median.default;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function get() {
    return _merge.default;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function get() {
    return _min.default;
  }
});
Object.defineProperty(exports, "minIndex", {
  enumerable: true,
  get: function get() {
    return _minIndex.default;
  }
});
Object.defineProperty(exports, "nice", {
  enumerable: true,
  get: function get() {
    return _nice.default;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function get() {
    return _pairs.default;
  }
});
Object.defineProperty(exports, "permute", {
  enumerable: true,
  get: function get() {
    return _permute.default;
  }
});
Object.defineProperty(exports, "quantile", {
  enumerable: true,
  get: function get() {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "quantileSorted", {
  enumerable: true,
  get: function get() {
    return _quantile.quantileSorted;
  }
});
Object.defineProperty(exports, "quickselect", {
  enumerable: true,
  get: function get() {
    return _quickselect.default;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function get() {
    return _range.default;
  }
});
Object.defineProperty(exports, "least", {
  enumerable: true,
  get: function get() {
    return _least.default;
  }
});
Object.defineProperty(exports, "leastIndex", {
  enumerable: true,
  get: function get() {
    return _leastIndex.default;
  }
});
Object.defineProperty(exports, "greatest", {
  enumerable: true,
  get: function get() {
    return _greatest.default;
  }
});
Object.defineProperty(exports, "greatestIndex", {
  enumerable: true,
  get: function get() {
    return _greatestIndex.default;
  }
});
Object.defineProperty(exports, "scan", {
  enumerable: true,
  get: function get() {
    return _scan.default;
  }
});
Object.defineProperty(exports, "shuffle", {
  enumerable: true,
  get: function get() {
    return _shuffle.default;
  }
});
Object.defineProperty(exports, "shuffler", {
  enumerable: true,
  get: function get() {
    return _shuffle.shuffler;
  }
});
Object.defineProperty(exports, "sum", {
  enumerable: true,
  get: function get() {
    return _sum.default;
  }
});
Object.defineProperty(exports, "ticks", {
  enumerable: true,
  get: function get() {
    return _ticks.default;
  }
});
Object.defineProperty(exports, "tickIncrement", {
  enumerable: true,
  get: function get() {
    return _ticks.tickIncrement;
  }
});
Object.defineProperty(exports, "tickStep", {
  enumerable: true,
  get: function get() {
    return _ticks.tickStep;
  }
});
Object.defineProperty(exports, "transpose", {
  enumerable: true,
  get: function get() {
    return _transpose.default;
  }
});
Object.defineProperty(exports, "variance", {
  enumerable: true,
  get: function get() {
    return _variance.default;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function get() {
    return _zip.default;
  }
});
Object.defineProperty(exports, "every", {
  enumerable: true,
  get: function get() {
    return _every.default;
  }
});
Object.defineProperty(exports, "some", {
  enumerable: true,
  get: function get() {
    return _some.default;
  }
});
Object.defineProperty(exports, "filter", {
  enumerable: true,
  get: function get() {
    return _filter.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function get() {
    return _map.default;
  }
});
Object.defineProperty(exports, "reduce", {
  enumerable: true,
  get: function get() {
    return _reduce.default;
  }
});
Object.defineProperty(exports, "reverse", {
  enumerable: true,
  get: function get() {
    return _reverse.default;
  }
});
Object.defineProperty(exports, "sort", {
  enumerable: true,
  get: function get() {
    return _sort.default;
  }
});
Object.defineProperty(exports, "difference", {
  enumerable: true,
  get: function get() {
    return _difference.default;
  }
});
Object.defineProperty(exports, "disjoint", {
  enumerable: true,
  get: function get() {
    return _disjoint.default;
  }
});
Object.defineProperty(exports, "intersection", {
  enumerable: true,
  get: function get() {
    return _intersection.default;
  }
});
Object.defineProperty(exports, "subset", {
  enumerable: true,
  get: function get() {
    return _subset.default;
  }
});
Object.defineProperty(exports, "superset", {
  enumerable: true,
  get: function get() {
    return _superset.default;
  }
});
Object.defineProperty(exports, "union", {
  enumerable: true,
  get: function get() {
    return _union.default;
  }
});
Object.defineProperty(exports, "InternMap", {
  enumerable: true,
  get: function get() {
    return _internmap.InternMap;
  }
});
Object.defineProperty(exports, "InternSet", {
  enumerable: true,
  get: function get() {
    return _internmap.InternSet;
  }
});

var _bisect = _interopRequireWildcard(__webpack_require__(544));

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _bisector = _interopRequireDefault(__webpack_require__(545));

var _count = _interopRequireDefault(__webpack_require__(197));

var _cross = _interopRequireDefault(__webpack_require__(1200));

var _cumsum = _interopRequireDefault(__webpack_require__(1201));

var _descending = _interopRequireDefault(__webpack_require__(1202));

var _deviation = _interopRequireDefault(__webpack_require__(547));

var _extent = _interopRequireDefault(__webpack_require__(549));

var _fsum = _interopRequireWildcard(__webpack_require__(1203));

var _group = _interopRequireWildcard(__webpack_require__(550));

var _groupSort = _interopRequireDefault(__webpack_require__(1208));

var _bin = _interopRequireDefault(__webpack_require__(1209));

var _freedmanDiaconis = _interopRequireDefault(__webpack_require__(1212));

var _scott = _interopRequireDefault(__webpack_require__(1213));

var _sturges = _interopRequireDefault(__webpack_require__(556));

var _max = _interopRequireDefault(__webpack_require__(557));

var _maxIndex = _interopRequireDefault(__webpack_require__(559));

var _mean = _interopRequireDefault(__webpack_require__(1214));

var _median = _interopRequireDefault(__webpack_require__(1215));

var _merge = _interopRequireDefault(__webpack_require__(1216));

var _min = _interopRequireDefault(__webpack_require__(303));

var _minIndex = _interopRequireDefault(__webpack_require__(560));

var _nice = _interopRequireDefault(__webpack_require__(555));

var _pairs = _interopRequireDefault(__webpack_require__(1217));

var _permute = _interopRequireDefault(__webpack_require__(554));

var _quantile = _interopRequireWildcard(__webpack_require__(302));

var _quickselect = _interopRequireDefault(__webpack_require__(558));

var _range = _interopRequireDefault(__webpack_require__(1218));

var _least = _interopRequireDefault(__webpack_require__(1219));

var _leastIndex = _interopRequireDefault(__webpack_require__(561));

var _greatest = _interopRequireDefault(__webpack_require__(1220));

var _greatestIndex = _interopRequireDefault(__webpack_require__(1221));

var _scan = _interopRequireDefault(__webpack_require__(1222));

var _shuffle = _interopRequireWildcard(__webpack_require__(1223));

var _sum = _interopRequireDefault(__webpack_require__(1224));

var _ticks = _interopRequireWildcard(__webpack_require__(301));

var _transpose = _interopRequireDefault(__webpack_require__(562));

var _variance = _interopRequireDefault(__webpack_require__(548));

var _zip = _interopRequireDefault(__webpack_require__(1225));

var _every = _interopRequireDefault(__webpack_require__(1226));

var _some = _interopRequireDefault(__webpack_require__(1227));

var _filter = _interopRequireDefault(__webpack_require__(1228));

var _map = _interopRequireDefault(__webpack_require__(1229));

var _reduce = _interopRequireDefault(__webpack_require__(1230));

var _reverse = _interopRequireDefault(__webpack_require__(1231));

var _sort = _interopRequireDefault(__webpack_require__(553));

var _difference = _interopRequireDefault(__webpack_require__(1232));

var _disjoint = _interopRequireDefault(__webpack_require__(1233));

var _intersection = _interopRequireDefault(__webpack_require__(1234));

var _subset = _interopRequireDefault(__webpack_require__(1236));

var _superset = _interopRequireDefault(__webpack_require__(563));

var _union = _interopRequireDefault(__webpack_require__(1237));

var _internmap = __webpack_require__(551);

/***/ }),
/* 544 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.bisectCenter = exports.bisectLeft = exports.bisectRight = void 0;

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _bisector = _interopRequireDefault(__webpack_require__(545));

var _number = _interopRequireDefault(__webpack_require__(546));

var ascendingBisect = (0, _bisector.default)(_ascending.default);
var bisectRight = ascendingBisect.right;
exports.bisectRight = bisectRight;
var bisectLeft = ascendingBisect.left;
exports.bisectLeft = bisectLeft;
var bisectCenter = (0, _bisector.default)(_number.default).center;
exports.bisectCenter = bisectCenter;
var _default = bisectRight;
exports.default = _default;

/***/ }),
/* 545 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(__webpack_require__(79));

function _default(f) {
  var delta = f;
  var compare = f;

  if (f.length === 1) {
    delta = function delta(d, x) {
      return f(d) - x;
    };

    compare = ascendingComparator(f);
  }

  function left(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
    }

    return lo;
  }

  function right(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;

    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
    }

    return lo;
  }

  function center(a, x, lo, hi) {
    if (lo == null) lo = 0;
    if (hi == null) hi = a.length;
    var i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }

  return {
    left: left,
    center: center,
    right: right
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return (0, _ascending.default)(f(d), x);
  };
}

/***/ }),
/* 546 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _regeneratorRuntime2 = __webpack_require__(154);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.numbers = numbers;

var _regenerator = _interopRequireDefault(__webpack_require__(154));

var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(numbers);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _default(x) {
  return x === null ? NaN : +x;
}

function numbers(values, valueof) {
  var _iterator, _step, value, index, _iterator2, _step2, _value;

  return _regenerator.default.wrap(function numbers$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!(valueof === undefined)) {
            _context.next = 21;
            break;
          }

          _iterator = _createForOfIteratorHelper(values);
          _context.prev = 2;

          _iterator.s();

        case 4:
          if ((_step = _iterator.n()).done) {
            _context.next = 11;
            break;
          }

          value = _step.value;

          if (!(value != null && (value = +value) >= value)) {
            _context.next = 9;
            break;
          }

          _context.next = 9;
          return value;

        case 9:
          _context.next = 4;
          break;

        case 11:
          _context.next = 16;
          break;

        case 13:
          _context.prev = 13;
          _context.t0 = _context["catch"](2);

          _iterator.e(_context.t0);

        case 16:
          _context.prev = 16;

          _iterator.f();

          return _context.finish(16);

        case 19:
          _context.next = 40;
          break;

        case 21:
          index = -1;
          _iterator2 = _createForOfIteratorHelper(values);
          _context.prev = 23;

          _iterator2.s();

        case 25:
          if ((_step2 = _iterator2.n()).done) {
            _context.next = 32;
            break;
          }

          _value = _step2.value;

          if (!((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value)) {
            _context.next = 30;
            break;
          }

          _context.next = 30;
          return _value;

        case 30:
          _context.next = 25;
          break;

        case 32:
          _context.next = 37;
          break;

        case 34:
          _context.prev = 34;
          _context.t1 = _context["catch"](23);

          _iterator2.e(_context.t1);

        case 37:
          _context.prev = 37;

          _iterator2.f();

          return _context.finish(37);

        case 40:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[2, 13, 16, 19], [23, 34, 37, 40]]);
}

/***/ }),
/* 547 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = deviation;

var _variance = _interopRequireDefault(__webpack_require__(548));

function deviation(values, valueof) {
  var v = (0, _variance.default)(values, valueof);
  return v ? Math.sqrt(v) : v;
}

/***/ }),
/* 548 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = variance;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function variance(values, valueof) {
  var count = 0;
  var delta;
  var mean = 0;
  var sum = 0;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null && (value = +value) >= value) {
          delta = value - mean;
          mean += delta / ++count;
          sum += delta * (value - mean);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          delta = _value - mean;
          mean += delta / ++count;
          sum += delta * (_value - mean);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  if (count > 1) return sum / (count - 1);
}

/***/ }),
/* 549 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _default(values, valueof) {
  var min;
  var max;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null) {
          if (min === undefined) {
            if (value >= value) min = max = value;
          } else {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null) {
          if (min === undefined) {
            if (_value >= _value) min = max = _value;
          } else {
            if (min > _value) min = _value;
            if (max < _value) max = _value;
          }
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return [min, max];
}

/***/ }),
/* 550 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = group;
exports.groups = groups;
exports.rollup = rollup;
exports.rollups = rollups;
exports.index = index;
exports.indexes = indexes;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _internmap = __webpack_require__(551);

var _identity = _interopRequireDefault(__webpack_require__(552));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function group(values) {
  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    keys[_key - 1] = arguments[_key];
  }

  return nest(values, _identity.default, _identity.default, keys);
}

function groups(values) {
  for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    keys[_key2 - 1] = arguments[_key2];
  }

  return nest(values, Array.from, _identity.default, keys);
}

function rollup(values, reduce) {
  for (var _len3 = arguments.length, keys = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    keys[_key3 - 2] = arguments[_key3];
  }

  return nest(values, _identity.default, reduce, keys);
}

function rollups(values, reduce) {
  for (var _len4 = arguments.length, keys = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    keys[_key4 - 2] = arguments[_key4];
  }

  return nest(values, Array.from, reduce, keys);
}

function index(values) {
  for (var _len5 = arguments.length, keys = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    keys[_key5 - 1] = arguments[_key5];
  }

  return nest(values, _identity.default, unique, keys);
}

function indexes(values) {
  for (var _len6 = arguments.length, keys = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
    keys[_key6 - 1] = arguments[_key6];
  }

  return nest(values, Array.from, unique, keys);
}

function unique(values) {
  if (values.length !== 1) throw new Error("duplicate key");
  return values[0];
}

function nest(values, map, reduce, keys) {
  return function regroup(values, i) {
    if (i >= keys.length) return reduce(values);
    var groups = new _internmap.InternMap();
    var keyof = keys[i++];
    var index = -1;

    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        var key = keyof(value, ++index, values);

        var _group = groups.get(key);

        if (_group) _group.push(value);else groups.set(key, [value]);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(groups),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
            _key7 = _step2$value[0],
            _values = _step2$value[1];

        groups.set(_key7, regroup(_values, i));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return map(groups);
  }(values, 0);
}

/***/ }),
/* 551 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InternSet = exports.InternMap = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7));

var _createClass2 = _interopRequireDefault(__webpack_require__(23));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(375));

var _get2 = _interopRequireDefault(__webpack_require__(219));

var _inherits2 = _interopRequireDefault(__webpack_require__(8));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(9));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(4));

var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(1204));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var InternMap = /*#__PURE__*/function (_Map) {
  (0, _inherits2.default)(InternMap, _Map);

  var _super = _createSuper(InternMap);

  function InternMap() {
    var _this;

    var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keyof;
    (0, _classCallCheck2.default)(this, InternMap);
    _this = _super.call(this);
    Object.defineProperties((0, _assertThisInitialized2.default)(_this), {
      _intern: {
        value: new Map()
      },
      _key: {
        value: key
      }
    });

    var _iterator = _createForOfIteratorHelper(entries),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
            _key2 = _step$value[0],
            value = _step$value[1];

        _this.set(_key2, value);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return _this;
  }

  (0, _createClass2.default)(InternMap, [{
    key: "get",
    value: function get(key) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternMap.prototype), "get", this).call(this, intern_get(this, key));
    }
  }, {
    key: "has",
    value: function has(key) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternMap.prototype), "has", this).call(this, intern_get(this, key));
    }
  }, {
    key: "set",
    value: function set(key, value) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternMap.prototype), "set", this).call(this, intern_set(this, key), value);
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternMap.prototype), "delete", this).call(this, intern_delete(this, key));
    }
  }]);
  return InternMap;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Map));

exports.InternMap = InternMap;

var InternSet = /*#__PURE__*/function (_Set) {
  (0, _inherits2.default)(InternSet, _Set);

  var _super2 = _createSuper(InternSet);

  function InternSet() {
    var _this2;

    var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keyof;
    (0, _classCallCheck2.default)(this, InternSet);
    _this2 = _super2.call(this);
    Object.defineProperties((0, _assertThisInitialized2.default)(_this2), {
      _intern: {
        value: new Map()
      },
      _key: {
        value: key
      }
    });

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var value = _step2.value;

        _this2.add(value);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return _this2;
  }

  (0, _createClass2.default)(InternSet, [{
    key: "has",
    value: function has(value) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternSet.prototype), "has", this).call(this, intern_get(this, value));
    }
  }, {
    key: "add",
    value: function add(value) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternSet.prototype), "add", this).call(this, intern_set(this, value));
    }
  }, {
    key: "delete",
    value: function _delete(value) {
      return (0, _get2.default)((0, _getPrototypeOf2.default)(InternSet.prototype), "delete", this).call(this, intern_delete(this, value));
    }
  }]);
  return InternSet;
}( /*#__PURE__*/(0, _wrapNativeSuper2.default)(Set));

exports.InternSet = InternSet;

function intern_get(_ref, value) {
  var _intern = _ref._intern,
      _key = _ref._key;

  var key = _key(value);

  return _intern.has(key) ? _intern.get(key) : value;
}

function intern_set(_ref2, value) {
  var _intern = _ref2._intern,
      _key = _ref2._key;

  var key = _key(value);

  if (_intern.has(key)) return _intern.get(key);

  _intern.set(key, value);

  return value;
}

function intern_delete(_ref3, value) {
  var _intern = _ref3._intern,
      _key = _ref3._key;

  var key = _key(value);

  if (_intern.has(key)) {
    value = _intern.get(value);

    _intern.delete(key);
  }

  return value;
}

function keyof(value) {
  return value !== null && (0, _typeof2.default)(value) === "object" ? value.valueOf() : value;
}

/***/ }),
/* 552 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return x;
}

/***/ }),
/* 553 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sort;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _permute = _interopRequireDefault(__webpack_require__(554));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function sort(values) {
  for (var _len = arguments.length, F = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    F[_key - 1] = arguments[_key];
  }

  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  values = Array.from(values);

  var _F = F,
      _F2 = (0, _slicedToArray2.default)(_F, 1),
      _F2$ = _F2[0],
      f = _F2$ === void 0 ? _ascending.default : _F2$;

  if (f.length === 1 || F.length > 1) {
    var index = Uint32Array.from(values, function (d, i) {
      return i;
    });

    if (F.length > 1) {
      F = F.map(function (f) {
        return values.map(f);
      });
      index.sort(function (i, j) {
        var _iterator = _createForOfIteratorHelper(F),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _f = _step.value;
            var c = (0, _ascending.default)(_f[i], _f[j]);
            if (c) return c;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    } else {
      f = values.map(f);
      index.sort(function (i, j) {
        return (0, _ascending.default)(f[i], f[j]);
      });
    }

    return (0, _permute.default)(values, index);
  }

  return values.sort(f);
}

/***/ }),
/* 554 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(source, keys) {
  return Array.from(keys, function (key) {
    return source[key];
  });
}

/***/ }),
/* 555 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = nice;

var _ticks = __webpack_require__(301);

function nice(start, stop, count) {
  var prestep;

  while (true) {
    var step = (0, _ticks.tickIncrement)(start, stop, count);

    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start, stop];
    } else if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
    }

    prestep = step;
  }
}

/***/ }),
/* 556 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _count = _interopRequireDefault(__webpack_require__(197));

function _default(values) {
  return Math.ceil(Math.log((0, _count.default)(values)) / Math.LN2) + 1;
}

/***/ }),
/* 557 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = max;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function max(values, valueof) {
  var max;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null && (max < value || max === undefined && value >= value)) {
          max = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (max < _value || max === undefined && _value >= _value)) {
          max = _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return max;
}

/***/ }),
/* 558 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quickselect;

var _ascending = _interopRequireDefault(__webpack_require__(79));

// Based on https://github.com/mourner/quickselect
// ISC license, Copyright 2018 Vladimir Agafonkin.
function quickselect(array, k) {
  var left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : array.length - 1;
  var compare = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ascending.default;

  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(array, k, newLeft, newRight, compare);
    }

    var t = array[k];
    var i = left;
    var j = right;
    swap(array, left, k);
    if (compare(array[right], t) > 0) swap(array, left, right);

    while (i < j) {
      swap(array, i, j), ++i, --j;

      while (compare(array[i], t) < 0) {
        ++i;
      }

      while (compare(array[j], t) > 0) {
        --j;
      }
    }

    if (compare(array[left], t) === 0) swap(array, left, j);else ++j, swap(array, j, right);
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }

  return array;
}

function swap(array, i, j) {
  var t = array[i];
  array[i] = array[j];
  array[j] = t;
}

/***/ }),
/* 559 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = maxIndex;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function maxIndex(values, valueof) {
  var max;
  var maxIndex = -1;
  var index = -1;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        ++index;

        if (value != null && (max < value || max === undefined && value >= value)) {
          max = value, maxIndex = index;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (max < _value || max === undefined && _value >= _value)) {
          max = _value, maxIndex = index;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return maxIndex;
}

/***/ }),
/* 560 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = minIndex;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function minIndex(values, valueof) {
  var min;
  var minIndex = -1;
  var index = -1;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        ++index;

        if (value != null && (min > value || min === undefined && value >= value)) {
          min = value, minIndex = index;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (min > _value || min === undefined && _value >= _value)) {
          min = _value, minIndex = index;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return minIndex;
}

/***/ }),
/* 561 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = leastIndex;

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _minIndex = _interopRequireDefault(__webpack_require__(560));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function leastIndex(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  if (compare.length === 1) return (0, _minIndex.default)(values, compare);
  var minValue;
  var min = -1;
  var index = -1;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      ++index;

      if (min < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
        minValue = value;
        min = index;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return min;
}

/***/ }),
/* 562 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _min = _interopRequireDefault(__webpack_require__(303));

function _default(matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = (0, _min.default)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
}

function length(d) {
  return d.length;
}

/***/ }),
/* 563 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = superset;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function superset(values, other) {
  var iterator = values[Symbol.iterator](),
      set = new Set();

  var _iterator = _createForOfIteratorHelper(other),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var o = _step.value;
      if (set.has(o)) continue;
      var value = void 0,
          done = void 0;

      while (_iterator$next = iterator.next(), value = _iterator$next.value, done = _iterator$next.done, _iterator$next) {
        var _iterator$next;

        if (done) return false;
        set.add(value);
        if (Object.is(o, value)) break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}

/***/ }),
/* 564 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.left = left;
exports.right = right;
exports.justify = justify;
exports.center = center;

var _d3Array = __webpack_require__(543);

function targetDepth(d) {
  return d.target.depth;
}

function left(node) {
  return node.depth;
}

function right(node, n) {
  return n - 1 - node.height;
}

function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}

function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? (0, _d3Array.min)(node.sourceLinks, targetDepth) - 1 : 0;
}

/***/ }),
/* 565 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = __webpack_require__(160);

var _constant = _interopRequireDefault(__webpack_require__(107));

var _linear = _interopRequireDefault(__webpack_require__(198));

var _line = _interopRequireDefault(__webpack_require__(304));

var _point = __webpack_require__(305);

function _default() {
  var x0 = _point.x,
      x1 = null,
      y0 = (0, _constant.default)(0),
      y1 = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();

          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }

          output.lineEnd();
          output.areaEnd();
        }
      }

      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0, _line.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

/***/ }),
/* 566 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curveRadial;
exports.curveRadialLinear = void 0;

var _linear = _interopRequireDefault(__webpack_require__(198));

var curveRadialLinear = curveRadial(_linear.default);
exports.curveRadialLinear = curveRadialLinear;

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function areaStart() {
    this._curve.areaStart();
  },
  areaEnd: function areaEnd() {
    this._curve.areaEnd();
  },
  lineStart: function lineStart() {
    this._curve.lineStart();
  },
  lineEnd: function lineEnd() {
    this._curve.lineEnd();
  },
  point: function point(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;
  return radial;
}

/***/ }),
/* 567 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineRadial = lineRadial;
exports.default = _default;

var _radial = _interopRequireWildcard(__webpack_require__(566));

var _line = _interopRequireDefault(__webpack_require__(304));

function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return l;
}

function _default() {
  return lineRadial((0, _line.default)().curve(_radial.curveRadialLinear));
}

/***/ }),
/* 568 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}

/***/ }),
/* 569 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = void 0;
var slice = Array.prototype.slice;
exports.slice = slice;

/***/ }),
/* 570 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = __webpack_require__(161);

var _default = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / _math.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math.tau);
  }
};
exports.default = _default;

/***/ }),
/* 571 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
exports.default = _default;

/***/ }),
/* 572 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;
var _default = {
  draw: function draw(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};
exports.default = _default;

/***/ }),
/* 573 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = __webpack_require__(161);

var ka = 0.89081309152928522810,
    kr = Math.sin(_math.pi / 10) / Math.sin(7 * _math.pi / 10),
    kx = Math.sin(_math.tau / 10) * kr,
    ky = -Math.cos(_math.tau / 10) * kr;
var _default = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);

    for (var i = 1; i < 5; ++i) {
      var a = _math.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }

    context.closePath();
  }
};
exports.default = _default;

/***/ }),
/* 574 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function draw(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};
exports.default = _default;

/***/ }),
/* 575 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var sqrt3 = Math.sqrt(3);
var _default = {
  draw: function draw(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};
exports.default = _default;

/***/ }),
/* 576 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;
var _default = {
  draw: function draw(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};
exports.default = _default;

/***/ }),
/* 577 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalClosed = CardinalClosed;
exports.default = void 0;

var _noop = _interopRequireDefault(__webpack_require__(199));

var _cardinal = __webpack_require__(201);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

/***/ }),
/* 578 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalOpen = CardinalOpen;
exports.default = void 0;

var _cardinal = __webpack_require__(201);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;

/***/ }),
/* 579 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(__webpack_require__(163));

function _default(series) {
  var peaks = series.map(peak);
  return (0, _none.default)(series).sort(function (a, b) {
    return peaks[a] - peaks[b];
  });
}

function peak(series) {
  var i = -1,
      j = 0,
      n = series.length,
      vi,
      vj = -Infinity;

  while (++i < n) {
    if ((vi = +series[i][1]) > vj) vj = vi, j = i;
  }

  return j;
}

/***/ }),
/* 580 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiView = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1273);

/**
 *  G2 80% 
 * 1. 
 *   -  + 
 *   - 
 *   - ...
 * 2. 
 *   - 
 *   - 
 *   - ...
 */
var MultiView =
/** @class */
function (_super) {
  (0, _tslib.__extends)(MultiView, _super);

  function MultiView() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'multi-view';
    return _this;
  }
  /**
   * 
   */


  MultiView.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return MultiView;
}(_plot.Plot);

exports.MultiView = MultiView;

/***/ }),
/* 581 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getRangeData = exports.getIndicatorData = exports.processRangeData = void 0;

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(194);
/**
 *  range  data 
 * @param range
 * @param key
 */


function processRangeData(range) {
  return range //  stack 
  .map(function (r, idx) {
    var _a;

    return _a = {}, _a[constant_1.RANGE_VALUE] = r - (range[idx - 1] || 0), _a[constant_1.RANGE_TYPE] = "" + idx, _a;
  }) //  0 
  .filter(function (d) {
    return !!d[constant_1.RANGE_VALUE];
  });
}

exports.processRangeData = processRangeData;
/**
 *   
 * @param percent
 */

function getIndicatorData(percent) {
  var _a;

  return [(_a = {}, _a[constant_1.PERCENT] = util_1.clamp(percent, 0, 1), _a)];
}

exports.getIndicatorData = getIndicatorData;
/**
 *  
 * @param percent
 * @param range
 */

function getRangeData(percent, range) {
  var ticks = util_1.get(range, ['ticks'], []);
  var clampTicks = util_1.size(ticks) ? ticks : [0, util_1.clamp(percent, 0, 1), 1];
  return processRangeData(clampTicks);
}

exports.getRangeData = getRangeData;

/***/ }),
/* 582 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "w", function() { return /* reexport */ ProgressChart; });
__webpack_require__.d(__webpack_exports__, "A", function() { return /* reexport */ RingProgressChart; });
__webpack_require__.d(__webpack_exports__, "J", function() { return /* reexport */ TinyColumnChart; });
__webpack_require__.d(__webpack_exports__, "I", function() { return /* reexport */ TinyAreaChart; });
__webpack_require__.d(__webpack_exports__, "K", function() { return /* reexport */ TinyLineChart; });
__webpack_require__.d(__webpack_exports__, "p", function() { return /* reexport */ LineChart; });
__webpack_require__.d(__webpack_exports__, "L", function() { return /* reexport */ TreemapChart; });
__webpack_require__.d(__webpack_exports__, "H", function() { return /* reexport */ StepLineChart; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ BarChart; });
__webpack_require__.d(__webpack_exports__, "E", function() { return /* reexport */ StackedBarChart; });
__webpack_require__.d(__webpack_exports__, "k", function() { return /* reexport */ GroupedBarChart; });
__webpack_require__.d(__webpack_exports__, "s", function() { return /* reexport */ PercentStackedBarChart; });
__webpack_require__.d(__webpack_exports__, "y", function() { return /* reexport */ RangeBarChart; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ AreaChart; });
__webpack_require__.d(__webpack_exports__, "D", function() { return /* reexport */ StackedAreaChart; });
__webpack_require__.d(__webpack_exports__, "r", function() { return /* reexport */ PercentStackedAreaChart; });
__webpack_require__.d(__webpack_exports__, "f", function() { return /* reexport */ ColumnChart; });
__webpack_require__.d(__webpack_exports__, "l", function() { return /* reexport */ GroupedColumnChart; });
__webpack_require__.d(__webpack_exports__, "F", function() { return /* reexport */ StackedColumnChart; });
__webpack_require__.d(__webpack_exports__, "z", function() { return /* reexport */ RangeColumnChart; });
__webpack_require__.d(__webpack_exports__, "t", function() { return /* reexport */ PercentStackedColumnChart; });
__webpack_require__.d(__webpack_exports__, "u", function() { return /* reexport */ PieChart; });
__webpack_require__.d(__webpack_exports__, "g", function() { return /* reexport */ DensityHeatmapChart; });
__webpack_require__.d(__webpack_exports__, "n", function() { return /* reexport */ HeatmapChart; });
__webpack_require__.d(__webpack_exports__, "N", function() { return /* reexport */ WordCloudChart; });
__webpack_require__.d(__webpack_exports__, "B", function() { return /* reexport */ RoseChart; });
__webpack_require__.d(__webpack_exports__, "i", function() { return /* reexport */ FunnelChart; });
__webpack_require__.d(__webpack_exports__, "G", function() { return /* reexport */ StackedRoseChart; });
__webpack_require__.d(__webpack_exports__, "m", function() { return /* reexport */ GroupedRoseChart; });
__webpack_require__.d(__webpack_exports__, "x", function() { return /* reexport */ RadarChart; });
__webpack_require__.d(__webpack_exports__, "q", function() { return /* reexport */ LiquidChart; });
__webpack_require__.d(__webpack_exports__, "o", function() { return /* reexport */ HistogramChart; });
__webpack_require__.d(__webpack_exports__, "h", function() { return /* reexport */ DonutChart; });
__webpack_require__.d(__webpack_exports__, "M", function() { return /* reexport */ WaterfallChart; });
__webpack_require__.d(__webpack_exports__, "C", function() { return /* reexport */ ScatterChart; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ BubbleChart; });
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ BulletChart; });
__webpack_require__.d(__webpack_exports__, "e", function() { return /* reexport */ CalendarChart; });
__webpack_require__.d(__webpack_exports__, "j", function() { return /* reexport */ GaugeChart; });
__webpack_require__.d(__webpack_exports__, "v", function() { return /* reexport */ plots_PlotAdapter; });

// NAMESPACE OBJECT: ./src/plots/sparkline.tsx
var sparkline_namespaceObject = {};
__webpack_require__.r(sparkline_namespaceObject);
__webpack_require__.d(sparkline_namespaceObject, "ProgressChart", function() { return ProgressChart; });
__webpack_require__.d(sparkline_namespaceObject, "RingProgressChart", function() { return RingProgressChart; });
__webpack_require__.d(sparkline_namespaceObject, "TinyColumnChart", function() { return TinyColumnChart; });
__webpack_require__.d(sparkline_namespaceObject, "TinyAreaChart", function() { return TinyAreaChart; });
__webpack_require__.d(sparkline_namespaceObject, "TinyLineChart", function() { return TinyLineChart; });

// NAMESPACE OBJECT: ./src/plots/plots.tsx
var plots_namespaceObject = {};
__webpack_require__.r(plots_namespaceObject);
__webpack_require__.d(plots_namespaceObject, "LineChart", function() { return LineChart; });
__webpack_require__.d(plots_namespaceObject, "TreemapChart", function() { return TreemapChart; });
__webpack_require__.d(plots_namespaceObject, "StepLineChart", function() { return StepLineChart; });
__webpack_require__.d(plots_namespaceObject, "BarChart", function() { return BarChart; });
__webpack_require__.d(plots_namespaceObject, "StackedBarChart", function() { return StackedBarChart; });
__webpack_require__.d(plots_namespaceObject, "GroupedBarChart", function() { return GroupedBarChart; });
__webpack_require__.d(plots_namespaceObject, "PercentStackedBarChart", function() { return PercentStackedBarChart; });
__webpack_require__.d(plots_namespaceObject, "RangeBarChart", function() { return RangeBarChart; });
__webpack_require__.d(plots_namespaceObject, "AreaChart", function() { return AreaChart; });
__webpack_require__.d(plots_namespaceObject, "StackedAreaChart", function() { return StackedAreaChart; });
__webpack_require__.d(plots_namespaceObject, "PercentStackedAreaChart", function() { return PercentStackedAreaChart; });
__webpack_require__.d(plots_namespaceObject, "ColumnChart", function() { return ColumnChart; });
__webpack_require__.d(plots_namespaceObject, "GroupedColumnChart", function() { return GroupedColumnChart; });
__webpack_require__.d(plots_namespaceObject, "StackedColumnChart", function() { return StackedColumnChart; });
__webpack_require__.d(plots_namespaceObject, "RangeColumnChart", function() { return RangeColumnChart; });
__webpack_require__.d(plots_namespaceObject, "PercentStackedColumnChart", function() { return PercentStackedColumnChart; });
__webpack_require__.d(plots_namespaceObject, "PieChart", function() { return PieChart; });
__webpack_require__.d(plots_namespaceObject, "DensityHeatmapChart", function() { return DensityHeatmapChart; });
__webpack_require__.d(plots_namespaceObject, "HeatmapChart", function() { return HeatmapChart; });
__webpack_require__.d(plots_namespaceObject, "WordCloudChart", function() { return WordCloudChart; });
__webpack_require__.d(plots_namespaceObject, "RoseChart", function() { return RoseChart; });
__webpack_require__.d(plots_namespaceObject, "FunnelChart", function() { return FunnelChart; });
__webpack_require__.d(plots_namespaceObject, "StackedRoseChart", function() { return StackedRoseChart; });
__webpack_require__.d(plots_namespaceObject, "GroupedRoseChart", function() { return GroupedRoseChart; });
__webpack_require__.d(plots_namespaceObject, "RadarChart", function() { return RadarChart; });
__webpack_require__.d(plots_namespaceObject, "LiquidChart", function() { return LiquidChart; });
__webpack_require__.d(plots_namespaceObject, "HistogramChart", function() { return HistogramChart; });
__webpack_require__.d(plots_namespaceObject, "DonutChart", function() { return DonutChart; });
__webpack_require__.d(plots_namespaceObject, "WaterfallChart", function() { return WaterfallChart; });
__webpack_require__.d(plots_namespaceObject, "ScatterChart", function() { return ScatterChart; });
__webpack_require__.d(plots_namespaceObject, "BubbleChart", function() { return BubbleChart; });
__webpack_require__.d(plots_namespaceObject, "BulletChart", function() { return BulletChart; });
__webpack_require__.d(plots_namespaceObject, "CalendarChart", function() { return CalendarChart; });
__webpack_require__.d(plots_namespaceObject, "GaugeChart", function() { return GaugeChart; });

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/progress/index.js
var progress = __webpack_require__(597);

// EXTERNAL MODULE: ./src/createPlot.tsx + 1 modules
var createPlot = __webpack_require__(10);

// CONCATENATED MODULE: ./src/plots/ProgressChart.tsx




/* harmony default export */ var ProgressChart = (Object(createPlot["a" /* default */])(progress["Progress"], 'ProgressChart', function (opt) {
  // value dataplaceholder
  return _object_assign_4_1_2_object_assign_default()({
    data: opt.percent,
    color: '#5B8FF9'
  }, opt);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/ring-progress/index.js
var ring_progress = __webpack_require__(598);

// CONCATENATED MODULE: ./src/plots/RingProgressChart.tsx




/* harmony default export */ var RingProgressChart = (Object(createPlot["a" /* default */])(ring_progress["RingProgress"], 'RingProgressChart', function (opt) {
  // value dataplaceholder
  return _object_assign_4_1_2_object_assign_default()({
    data: opt.percent,
    color: '#5B8FF9'
  }, opt);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/tiny-column/index.js
var tiny_column = __webpack_require__(599);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/set.js
var set = __webpack_require__(18);
var set_default = /*#__PURE__*/__webpack_require__.n(set);

// EXTERNAL MODULE: ./src/plots/core/polyfill.ts
var core_polyfill = __webpack_require__(11);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/esm/index.js
var esm = __webpack_require__(0);

// CONCATENATED MODULE: ./src/plots/TinyColumnChart.tsx







var TinyColumnChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);

  if (!Object(esm["isNil"])(options.yField)) {
    // yFieldnull/undefined
    var list = options.data.map(function (item) {
      return item[options.yField];
    }).filter(function (val) {
      return !Object(esm["isNil"])(val);
    });
    list && list.length && set_default()(options, 'data', list);
  }

  set_default()(options, 'tooltip', false);
  return options;
};

/* harmony default export */ var TinyColumnChart = (Object(createPlot["a" /* default */])(tiny_column["TinyColumn"], 'TinyColumnChart', TinyColumnChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/tiny-area/index.js
var tiny_area = __webpack_require__(600);

// CONCATENATED MODULE: ./src/plots/TinyAreaChart.tsx


var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





/* harmony default export */ var TinyAreaChart = (Object(createPlot["a" /* default */])(tiny_area["TinyArea"], 'TinyAreaChart', function (props) {
  var _a = Object(core_polyfill["c" /* polyfillOptions */])(props),
      xField = _a.xField,
      yField = _a.yField,
      data = _a.data,
      options = __rest(_a, ["xField", "yField", "data"]);

  if (xField && yField && data) {
    options.data = data.map(function (it) {
      return it[yField];
    });
  }

  return _object_assign_4_1_2_object_assign_default()({}, options);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/tiny-line/index.js
var tiny_line = __webpack_require__(601);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/get.js
var get = __webpack_require__(15);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// CONCATENATED MODULE: ./src/plots/TinyLineChart.tsx









var TinyLineChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);

  if (!Object(esm["isNil"])(options.yField)) {
    // yFieldnull/undefined
    var list = options.data.map(function (item) {
      return item[options.yField];
    }).filter(function (val) {
      return !Object(esm["isNil"])(val);
    });
    list && list.length && set_default()(options, 'data', list);
  }

  var size = get_default()(options, 'size');

  if (!Object(esm["isNil"])(size)) {
    var lineStyle = get_default()(options, 'lineStyle', {});
    set_default()(options, 'lineStyle', _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, lineStyle), {
      lineWidth: size
    }));
  }

  set_default()(options, 'tooltip', false);
  return options;
};

/* harmony default export */ var TinyLineChart = (Object(createPlot["a" /* default */])(tiny_line["TinyLine"], 'TinyLineChart', TinyLineChart_polyfill));
// CONCATENATED MODULE: ./src/plots/sparkline.tsx





// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/line/index.js
var line = __webpack_require__(231);

// CONCATENATED MODULE: ./src/plots/LineChart.tsx




;
var LineChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt); // point

  Object(core_polyfill["e" /* polyfillVisible */])(options, 'point'); // bizcharts  <LineChart point /> 

  if (options.point === true) {
    options.point = {};
  }

  return options;
};
/* harmony default export */ var LineChart = (Object(createPlot["a" /* default */])(line["Line"], 'LineChart', LineChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/treemap/index.js
var treemap = __webpack_require__(602);

// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// CONCATENATED MODULE: ./src/plots/TreemapChart.tsx







var formatDataByMaxlevel = function formatDataByMaxlevel(data, maxLevel) {
  var curLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  if (curLevel > maxLevel) {
    delete data.children;
  } else {
    var children = data.children;

    if (children && children.length) {
      children.forEach(function (it) {
        formatDataByMaxlevel(it, maxLevel, curLevel + 1);
      });
    }
  }
};

var TreemapChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  var maxLevel = Object(esm["get"])(options, 'maxLevel', 2);

  if (!Object(esm["isNil"])(maxLevel)) {
    if (maxLevel < 1) {
      warning_default()(false, 'maxLevel 1');
    } else {
      var data = Object(esm["get"])(options, 'data', {});
      formatDataByMaxlevel(data, maxLevel);
      Object(esm["set"])(options, 'data', data);
      Object(esm["set"])(options, 'maxLevel', maxLevel);
    }
  }

  return options;
};

/* harmony default export */ var TreemapChart = (Object(createPlot["a" /* default */])(treemap["Treemap"], 'TreemapChart', TreemapChart_polyfill));
// CONCATENATED MODULE: ./src/plots/StepLineChart.tsx





;
/* harmony default export */ var StepLineChart = (Object(createPlot["a" /* default */])(line["Line"], 'StepLineChart', function (props) {
  warning_default()(false, '<StepLineChart />5.0<LineChart />');
  props.stepType = props.stepType || props.step || 'hv';
  return LineChart_polyfill(props);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/bar/index.js
var bar = __webpack_require__(82);

// CONCATENATED MODULE: ./src/plots/BarChart.tsx
var BarChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






var BarChart_polyfill = function polyfill(opt) {
  var _a = Object(core_polyfill["c" /* polyfillOptions */])(opt),
      barSize = _a.barSize,
      options = BarChart_rest(_a, ["barSize"]);

  Object(core_polyfill["f" /* replaceApi */])([{
    sourceKey: 'stackField',
    targetKey: 'seriesField',
    notice: 'stackFieldAPI seriesField'
  }, {
    sourceKey: 'colorField',
    targetKey: 'seriesField',
    notice: 'colorFieldAPI seriesField'
  }], options);

  if (!Object(esm["isNil"])(barSize)) {
    options.minBarWidth = barSize;
    options.maxBarWidth = barSize;
  }

  return options;
};
/* harmony default export */ var BarChart = (Object(createPlot["a" /* default */])(bar["Bar"], 'BarChart', BarChart_polyfill));
// CONCATENATED MODULE: ./src/plots/StackedBarChart.tsx






/* harmony default export */ var StackedBarChart = (Object(createPlot["a" /* default */])(bar["Bar"], 'StackedBarChart', function (props) {
  warning_default()(false, '<StackedBarChart /> 5.0<BarChart />');
  Object(esm["deepMix"])(props, {
    isStack: true
  });
  return BarChart_polyfill(props);
}));
// CONCATENATED MODULE: ./src/plots/GroupedBarChart.tsx
var GroupedBarChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var REPLACEAPILIST = [{
  sourceKey: 'colorField',
  targetKey: 'seriesField',
  notice: 'colorField  g2@1.0seriesField'
}];
/* harmony default export */ var GroupedBarChart = (Object(createPlot["a" /* default */])(bar["Bar"], 'GroupedBarChart', function (props) {
  warning_default()(false, '<GroupedBarChart /> 5.0<BarChart /> ');

  var _a = Object(core_polyfill["c" /* polyfillOptions */])(props),
      barSize = _a.barSize,
      options = GroupedBarChart_rest(_a, ["barSize"]);

  Object(core_polyfill["f" /* replaceApi */])(REPLACEAPILIST, options);

  if (!Object(esm["isNil"])(barSize)) {
    options.minBarWidth = barSize;
    options.maxBarWidth = barSize;
  }

  return options;
}));
// CONCATENATED MODULE: ./src/plots/PercentStackedBarChart.tsx






;
/* harmony default export */ var PercentStackedBarChart = (Object(createPlot["a" /* default */])(bar["Bar"], 'PercentStackedBarChart', function (props) {
  warning_default()(false, '<PercentStackedBarChart /> 5.0<BarChart />');
  Object(esm["deepMix"])(props, {
    isPercent: true,
    isStack: true
  });
  return BarChart_polyfill(props);
}));
// CONCATENATED MODULE: ./src/plots/RangeBarChart.tsx






/* harmony default export */ var RangeBarChart = (Object(createPlot["a" /* default */])(bar["Bar"], 'RangeBarChart', function (props) {
  warning_default()(false, '<RangeBarChart /> 5.0<BarChart />');
  Object(esm["deepMix"])(props, {
    isRange: true
  });
  return BarChart_polyfill(props);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/area/index.js
var plots_area = __webpack_require__(133);

// CONCATENATED MODULE: ./src/plots/AreaChart.tsx





;
var AreaChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt); // line

  Object(core_polyfill["e" /* polyfillVisible */])(options, 'line'); // point

  Object(core_polyfill["e" /* polyfillVisible */])(options, 'point'); // stack

  options.isStack = Object(esm["isNil"])(options.isStack) ? false : options.isStack;
  Object(core_polyfill["f" /* replaceApi */])([{
    sourceKey: 'stackField',
    targetKey: 'seriesField',
    notice: 'stackFieldapi seriesField'
  }], options);
  return options;
};
/* harmony default export */ var AreaChart = (Object(createPlot["a" /* default */])(plots_area["Area"], 'AreaChart', AreaChart_polyfill));
// CONCATENATED MODULE: ./src/plots/StackedAreaChart.tsx





/* harmony default export */ var StackedAreaChart = (Object(createPlot["a" /* default */])(plots_area["Area"], 'StackedAreaChart', function (props) {
  warning_default()(false, '<StackedAreaChart /> 5.0<AreaChart /> ');
  return AreaChart_polyfill(props);
}));
// CONCATENATED MODULE: ./src/plots/PercentStackedAreaChart.tsx






/* harmony default export */ var PercentStackedAreaChart = (Object(createPlot["a" /* default */])(plots_area["Area"], 'PercentStackedAreaChart', function (props) {
  warning_default()(false, '<PercentStackedAreaChart /> 5.0<AreaChart /> ');
  Object(esm["deepMix"])(props, {
    isPercent: true
  });
  return AreaChart_polyfill(props);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/column/index.js
var column = __webpack_require__(83);

// CONCATENATED MODULE: ./src/plots/ColumnChart.tsx




var ColumnChart_REPLACEAPILIST = [{
  sourceKey: 'colorField',
  targetKey: 'seriesField',
  notice: 'colorField  g2@1.0seriesField'
}, {
  sourceKey: 'stackField',
  targetKey: 'seriesField',
  notice: 'colorFieldAPI seriesField'
}];
var ColumnChart_polyfill = function polyfill(props) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(props);
  Object(core_polyfill["f" /* replaceApi */])(ColumnChart_REPLACEAPILIST, options);
  return options;
};
/* harmony default export */ var ColumnChart = (Object(createPlot["a" /* default */])(column["Column"], 'ColumnChart', ColumnChart_polyfill));
// CONCATENATED MODULE: ./src/plots/GroupedColumnChart.tsx
var GroupedColumnChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







/* harmony default export */ var GroupedColumnChart = (Object(createPlot["a" /* default */])(column["Column"], 'GroupedColumnChart', function (props) {
  warning_default()(false, '<GroupedColumnChart /> 5.0<ColumnChart /> ');

  var _a = Object(core_polyfill["c" /* polyfillOptions */])(props),
      columnSize = _a.columnSize,
      options = GroupedColumnChart_rest(_a, ["columnSize"]);

  if (!Object(esm["isNil"])(columnSize)) {
    options.minColumnWidth = columnSize;
    options.maxColumnWidth = columnSize;
  }

  return options;
}));
// CONCATENATED MODULE: ./src/plots/StackedColumnChart.tsx






;
/* harmony default export */ var StackedColumnChart = (Object(createPlot["a" /* default */])(column["Column"], 'StackedColumnChart', function (props) {
  warning_default()(false, '<StackedColumnChart />5.0<ColumnChart />');
  Object(esm["deepMix"])(props, {
    isStack: true
  });
  return ColumnChart_polyfill(props);
}));
// CONCATENATED MODULE: ./src/plots/RangeColumnChart.tsx






;
/* harmony default export */ var RangeColumnChart = (Object(createPlot["a" /* default */])(column["Column"], 'RangeColumnChart', function (props) {
  warning_default()(false, '<RangeColumnChart /> 5.0<ColumnChart />');
  Object(esm["deepMix"])(props, {
    isRange: true
  });
  return ColumnChart_polyfill(props);
}));
// CONCATENATED MODULE: ./src/plots/PercentStackedColumnChart.tsx






/* harmony default export */ var PercentStackedColumnChart = (Object(createPlot["a" /* default */])(column["Column"], 'PercentStackedColumnChart', function (props) {
  warning_default()(false, '<PercentStackedColumnChart /> 5.0<ColumnChart />');
  Object(esm["deepMix"])(props, {
    isPercent: true,
    isStack: true
  });
  return ColumnChart_polyfill(props);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/pie/index.js
var pie = __webpack_require__(232);

// CONCATENATED MODULE: ./src/plots/PieChart.tsx




;
/* harmony default export */ var PieChart = (Object(createPlot["a" /* default */])(pie["Pie"], 'PieChart', core_polyfill["c" /* polyfillOptions */]));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/heatmap/index.js
var heatmap = __webpack_require__(134);

// CONCATENATED MODULE: ./src/plots/DensityHeatmapChart.tsx





/* harmony default export */ var DensityHeatmapChart = (Object(createPlot["a" /* default */])(heatmap["Heatmap"], 'DensityHeatmapChartChart', function (props) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(props);
  Object(core_polyfill["f" /* replaceApi */])([{
    sourceKey: 'radius',
    targetKey: 'sizeRatio',
    notice: 'radius sizeRatio'
  }], options);
  Object(esm["set"])(options, 'type', 'density');
  return options;
}));
// CONCATENATED MODULE: ./src/plots/HeatmapChart.tsx
var HeatmapChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






/* harmony default export */ var HeatmapChart = (Object(createPlot["a" /* default */])(heatmap["Heatmap"], 'HeatmapChart', function (props) {
  var _a = Object(core_polyfill["c" /* polyfillOptions */])(props),
      shapeType = _a.shapeType,
      options = HeatmapChart_rest(_a, ["shapeType"]);

  if (shapeType) {
    options.heatmapStyle = shapeType;
    Object(warning["warn"])(false, 'shapeTypeg2plot@1.0 `heatmapStyle` ');
  } // shape sizeField


  if (!options.shape && options.sizeField) {
    options.shape = "square";
  }

  return options;
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/word-cloud/index.js
var word_cloud = __webpack_require__(603);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/index.js
var lib = __webpack_require__(17);

// CONCATENATED MODULE: ./src/plots/WordCloudChart.tsx


var WordCloudChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





/* harmony default export */ var WordCloudChart = (Object(createPlot["a" /* default */])(word_cloud["WordCloud"], 'WordCloudChart', function (cfg) {
  var maskImage = cfg.maskImage,
      _cfg$wordField = cfg.wordField,
      wordField = _cfg$wordField === void 0 ? 'word' : _cfg$wordField,
      _cfg$weightField = cfg.weightField,
      weightField = _cfg$weightField === void 0 ? 'weight' : _cfg$weightField,
      _cfg$colorField = cfg.colorField,
      colorField = _cfg$colorField === void 0 ? 'word' : _cfg$colorField,
      selected = cfg.selected,
      shuffle = cfg.shuffle,
      _cfg$interactions = cfg.interactions,
      interactions = _cfg$interactions === void 0 ? [{
    type: 'element-active'
  }] : _cfg$interactions,
      _onGetG2Instance = cfg.onGetG2Instance,
      tooltip = cfg.tooltip,
      wordStyle = cfg.wordStyle,
      onWordCloudHover = cfg.onWordCloudHover,
      onWordCloudClick = cfg.onWordCloudClick,
      others = WordCloudChart_rest(cfg, ["maskImage", "wordField", "weightField", "colorField", "selected", "shuffle", "interactions", "onGetG2Instance", "tooltip", "wordStyle", "onWordCloudHover", "onWordCloudClick"]);

  var active = wordStyle.active,
      otherStyles = WordCloudChart_rest(wordStyle, ["active"]);

  return _object_assign_4_1_2_object_assign_default()({
    colorField: colorField,
    wordField: wordField,
    weightField: weightField,
    imageMask: maskImage,
    random: shuffle,
    interactions: interactions,
    wordStyle: otherStyles,
    tooltip: tooltip && !tooltip.visible ? false : tooltip,
    onGetG2Instance: function onGetG2Instance(c) {
      _onGetG2Instance && _onGetG2Instance(c);

      if (selected >= 0) {
        var chart = c.chart;
        var theme = Object(lib["getTheme"])();

        if (active) {
          // debugger;
          _object_assign_4_1_2_object_assign_default()(theme.geometries.point['hollow-circle'].active.style, active);
        }

        chart.on('afterrender', function () {
          if (chart.geometries.length) {
            chart.geometries[0].elements.forEach(function (e, idx) {
              if (idx === selected) e.setState('active', true);
            });
          }
        });
        chart.on('plot:mousemove', function (e) {
          if (!e.data) {
            onWordCloudHover && onWordCloudHover(undefined, undefined, e.event);
            return;
          }

          var _e$data$data = e.data.data,
              datum = _e$data$data.datum,
              x = _e$data$data.x,
              y = _e$data$data.y,
              width = _e$data$data.width,
              height = _e$data$data.height;
          onWordCloudHover && onWordCloudHover(datum, {
            x: x,
            y: y,
            w: width,
            h: height
          }, e.event);
        });
        chart.on('plot:click', function (e) {
          if (!e.data) {
            onWordCloudClick && onWordCloudClick(undefined, undefined, e.event);
            return;
          }

          var _e$data$data2 = e.data.data,
              datum = _e$data$data2.datum,
              x = _e$data$data2.x,
              y = _e$data$data2.y,
              width = _e$data$data2.width,
              height = _e$data$data2.height;
          onWordCloudClick && onWordCloudClick(datum, {
            x: x,
            y: y,
            w: width,
            h: height
          }, e.event);
        });
      }
    }
  }, others);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/rose/index.js
var rose = __webpack_require__(135);

// CONCATENATED MODULE: ./src/plots/RoseChart.tsx






var RoseChart_REPLACEAPILIST = [{
  sourceKey: 'colorField',
  targetKey: 'seriesField',
  notice: 'colorField  g2@1.0seriesField'
}, {
  sourceKey: 'categoryField',
  targetKey: 'xField',
  notice: 'categoryField  g2@1.0xField'
}, {
  sourceKey: 'radiusField',
  targetKey: 'yField',
  notice: 'radiusField  g2@1.0yFeild'
}];

var RoseChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  Object(core_polyfill["f" /* replaceApi */])(RoseChart_REPLACEAPILIST, options);

  if (get_default()(options, 'tooltip.visible') === false) {
    set_default()(options, 'tooltip', false);
  }

  if (get_default()(options, 'label.visible') === false) {
    set_default()(options, 'label', false);
  }

  if (get_default()(options, 'label.type') === 'inner') {
    options.label.offset = -15;
    delete options.label.type;
  }

  if (get_default()(options, 'label.type') === 'outer') {
    delete options.label.type;
  }

  return options;
};

/* harmony default export */ var RoseChart = (Object(createPlot["a" /* default */])(rose["Rose"], 'RoseChart', RoseChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/funnel/index.js
var funnel = __webpack_require__(604);

// CONCATENATED MODULE: ./src/plots/FunnelChart.tsx




/* harmony default export */ var FunnelChart = (Object(createPlot["a" /* default */])(funnel["Funnel"], 'FunnelChart', function (props) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(props);
  Object(core_polyfill["f" /* replaceApi */])([{
    sourceKey: 'transpose',
    targetKey: 'isTransposed',
    notice: 'transpose  isTransposed'
  }], options);
  return options;
}));
// CONCATENATED MODULE: ./src/plots/StackedRoseChart.tsx








var StackedRoseChart_REPLACEAPILIST = [{
  sourceKey: 'stackField',
  targetKey: 'seriesField',
  notice: 'stackField  g2@1.0seriesField'
}, {
  sourceKey: 'categoryField',
  targetKey: 'xField',
  notice: 'categoryField  g2@1.0xField'
}, {
  sourceKey: 'radiusField',
  targetKey: 'yField',
  notice: 'radiusField  g2@1.0yFeild'
}];

var StackedRoseChart_polyfill = function polyfill(opt) {
  warning_default()(false, '<StackedRoseChart /> 5.0<RoseChart />');
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  Object(core_polyfill["f" /* replaceApi */])(StackedRoseChart_REPLACEAPILIST, options);

  if (get_default()(options, 'tooltip.visible') === false) {
    set_default()(options, 'tooltip', false);
  }

  if (get_default()(options, 'label.visible') === false) {
    set_default()(options, 'label', false);
  }

  if (get_default()(options, 'label.type') === 'inner') {
    options.label.offset = -15;
    delete options.label.type;
  }

  if (get_default()(options, 'label.type') === 'outer') {
    delete options.label.type;
  }

  return _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, options), {
    isStack: true
  });
};

/* harmony default export */ var StackedRoseChart = (Object(createPlot["a" /* default */])(rose["Rose"], 'StackedRoseChart', StackedRoseChart_polyfill));
// CONCATENATED MODULE: ./src/plots/GroupedRoseChart.tsx







var GroupedRoseChart_REPLACEAPILIST = [{
  sourceKey: 'groupField',
  targetKey: 'seriesField',
  notice: 'groupField  g2@1.0seriesField'
}, {
  sourceKey: 'categoryField',
  targetKey: 'xField',
  notice: 'categoryField  g2@1.0xField'
}, {
  sourceKey: 'radiusField',
  targetKey: 'yField',
  notice: 'radiusField  g2@1.0yFeild'
}];

var GroupedRoseChart_polyfill = function polyfill(opt) {
  warning_default()(false, '<GroupedRose /> 5.0<Rose />');
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  Object(core_polyfill["f" /* replaceApi */])(GroupedRoseChart_REPLACEAPILIST, options);

  if (Object(esm["get"])(options, 'label.type') === 'inner') {
    options.label.offset = -15;
    delete options.label.type;
  }

  if (Object(esm["get"])(options, 'label.type') === 'outer') {
    delete options.label.type;
  }

  return _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, options), {
    isGroup: true
  });
};

/* harmony default export */ var GroupedRoseChart = (Object(createPlot["a" /* default */])(rose["Rose"], 'GroupedRoseChart', GroupedRoseChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-nil.js
var is_nil = __webpack_require__(38);
var is_nil_default = /*#__PURE__*/__webpack_require__.n(is_nil);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-object.js
var is_object = __webpack_require__(62);
var is_object_default = /*#__PURE__*/__webpack_require__.n(is_object);

// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/radar/index.js
var radar = __webpack_require__(605);

// CONCATENATED MODULE: ./src/plots/RadarChart.tsx









var RadarChart_REPLACEAPILIST = [{
  sourceKey: 'angleField',
  targetKey: 'xField',
  notice: 'angleField  g2@1.0xField'
}, {
  sourceKey: 'radiusField',
  targetKey: 'yField',
  notice: 'radiusField  g2@1.0yFeild'
}];

var RadarChart_getVisibleStyle = function getVisibleStyle(visible) {
  if (is_nil_default()(visible) || visible) {
    // // null,undefined :     visibletrue: 
    return {
      fillOpacity: 1,
      strokeOpacity: 1
    };
  } // 


  return {
    fillOpacity: 0,
    strokeOpacity: 0
  };
}; // bizcharts.plotsradaChartLineAPI G2.plotsAPILineStyle


var RadarChart_replaceLineWithLinestyle = function replaceLineWithLinestyle(options) {
  var _get = get_default()(options, 'line', {}),
      visible = _get.visible,
      size = _get.size,
      style = _get.style;

  var newStyle = _object_assign_4_1_2_object_assign_default()({}, style || {}, _object_assign_4_1_2_object_assign_default()({
    opacity: 1,
    lineWidth: typeof size === 'number' ? size : 2
  }, RadarChart_getVisibleStyle(visible)));

  set_default()(options, 'lineStyle', newStyle);
};

var RadarChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  Object(core_polyfill["f" /* replaceApi */])(RadarChart_REPLACEAPILIST, options); // angleField,statusField  api

  if (get_default()(options, 'area.visible') === false) {
    set_default()(options, 'area', false);
  }

  if (get_default()(options, 'point.visible') === false) {
    set_default()(options, 'point', false);
  }

  RadarChart_replaceLineWithLinestyle(options);

  if (is_object_default()(options.angleAxis) || is_object_default()(options.radiusAxis)) {
    // line
    if (!options.angleAxis) {
      options.angleAxis = {};
    }

    options.angleAxis.line = get_default()(options, 'angleAxis.line', null);
    options.angleAxis.tickLine = get_default()(options, 'angleAxis.tickLine', null);
  }

  Object(core_polyfill["g" /* replaceAxis */])(options, 'angleAxis', 'xAxis');
  Object(core_polyfill["g" /* replaceAxis */])(options, 'radiusAxis', 'yAxis');

  if (get_default()(options, 'tooltip.visible') === false) {
    set_default()(options, 'tooltip', false);
  }

  if (get_default()(options, 'label.visible') === false) {
    set_default()(options, 'label', false);
  }

  return options;
};

/* harmony default export */ var RadarChart = (Object(createPlot["a" /* default */])(radar["Radar"], 'RadarChart', RadarChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/liquid/index.js
var liquid = __webpack_require__(606);

// CONCATENATED MODULE: ./src/plots/LiquidChart.tsx


var LiquidChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






/* harmony default export */ var LiquidChart = (Object(createPlot["a" /* default */])(liquid["Liquid"], 'LiquidChart', function (opt) {
  var _a = Object(core_polyfill["c" /* polyfillOptions */])(opt),
      range = _a.range,
      _a$min = _a.min,
      min = _a$min === void 0 ? 0 : _a$min,
      _a$max = _a.max,
      max = _a$max === void 0 ? 1 : _a$max,
      value = _a.value,
      options = LiquidChart_rest(_a, ["range", "min", "max", "value"]);

  if (!Object(esm["isNil"])(value)) {
    // 
    options.percent = value / (max - min);

    var _formatter = Object(esm["get"])(options, 'statistic.content.formatter');

    Object(esm["deepMix"])(options, {
      statistic: {
        content: {
          formatter: function formatter() {
            if (Object(esm["isFunction"])(_formatter)) {
              _formatter(value);
            }

            return value;
          }
        }
      }
    });
  } // value dataplaceholder


  var data = options.percent;
  return _object_assign_4_1_2_object_assign_default()({
    data: data
  }, options);
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/histogram/index.js
var histogram = __webpack_require__(607);

// CONCATENATED MODULE: ./src/plots/HistogramChart.tsx



/* harmony default export */ var HistogramChart = (Object(createPlot["a" /* default */])(histogram["Histogram"], 'HistogramChart'));
// CONCATENATED MODULE: ./src/plots/DonutChart.tsx





;

var DonutChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);
  var statistic = options.statistic;
  Object(core_polyfill["e" /* polyfillVisible */])(options, 'statistic');
  Object(core_polyfill["e" /* polyfillVisible */])(options, 'statistic.title');
  Object(core_polyfill["e" /* polyfillVisible */])(options, 'statistic.content'); // g2Plot@1  0.8 innerRadius

  return _object_assign_4_1_2_object_assign_default()({
    innerRadius: 0.8
  }, options);
};

/* harmony default export */ var DonutChart = (Object(createPlot["a" /* default */])(pie["Pie"], 'DonutChart', DonutChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/waterfall/index.js
var waterfall = __webpack_require__(608);

// CONCATENATED MODULE: ./src/plots/WaterfallChart.tsx



/* harmony default export */ var WaterfallChart = (Object(createPlot["a" /* default */])(waterfall["Waterfall"], 'WaterfallChart'));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/scatter/index.js
var scatter = __webpack_require__(233);

// CONCATENATED MODULE: ./src/plots/ScatterChart.tsx








var ScatterChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt);

  if (get_default()(options, 'pointSize')) {
    set_default()(options, 'size', get_default()(options, 'pointSize'));
  }

  Object(core_polyfill["g" /* replaceAxis */])(options, 'xAxis', 'xAxis');
  Object(core_polyfill["g" /* replaceAxis */])(options, 'yAxis', 'yAxis');
  Object(core_polyfill["e" /* polyfillVisible */])(options, 'quadrant');
  var quadrantLabel = get_default()(options, 'quadrant.label');
  var qLabels = get_default()(options, 'quadrant.labels');

  if (!qLabels && quadrantLabel) {
    var text = quadrantLabel.text,
        style = quadrantLabel.style;

    if (text && text.length && style) {
      var labels = text.map(function (txt) {
        return {
          style: style,
          content: txt
        };
      });
      set_default()(options, 'quadrant.labels', labels);
    }
  }

  var regressionLine = get_default()(options, 'regressionLine');

  if (!regressionLine) {
    var trendline = get_default()(options, 'trendline');

    if (Object(esm["isObject"])(trendline) && get_default()(trendline, 'visible') === false) {
      set_default()(options, 'regressionLine', null);
    } else {
      set_default()(options, 'regressionLine', trendline);
    }
  }

  return options;
};

/* harmony default export */ var ScatterChart = (Object(createPlot["a" /* default */])(scatter["Scatter"], 'ScatterChart', ScatterChart_polyfill));
// CONCATENATED MODULE: ./src/plots/BubbleChart.tsx








; // , 

/* harmony default export */ var BubbleChart = (Object(createPlot["a" /* default */])(scatter["Scatter"], 'BubbleChart', function (props) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(props);

  if (!is_nil_default()(get_default()(options, 'pointSize'))) {
    set_default()(options, 'size', get_default()(options, 'pointSize'));
  }

  warning_default()(false, 'BubbleChart Scatter<ScatterChart />');
  return options;
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/bullet/index.js
var bullet = __webpack_require__(609);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// CONCATENATED MODULE: ./src/plots/BulletChart.tsx










var BulletChart_polyfill = function polyfill(opt) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(opt); // size

  if (!is_nil_default()(get_default()(opt, 'measureSize'))) {
    warning_default()(false, 'measureSizesize.measure');
    set_default()(options, 'size.measure', get_default()(opt, 'measureSize'));
  }

  if (!is_nil_default()(get_default()(opt, 'rangeSize'))) {
    warning_default()(false, 'rangeSizesize.range');
    set_default()(options, 'size.range', get_default()(opt, 'rangeSize'));
  }

  if (!is_nil_default()(get_default()(opt, 'markerSize'))) {
    warning_default()(false, 'markerSizeesize.target');
    set_default()(options, 'size.target', get_default()(opt, 'markerSize'));
  } // color


  if (!is_nil_default()(get_default()(opt, 'measureColors'))) {
    warning_default()(false, 'measureColorscolor.measure');
    set_default()(options, 'color.measure', get_default()(opt, 'measureColors'));
  }

  if (!is_nil_default()(get_default()(opt, 'rangeColors'))) {
    warning_default()(false, 'rangeColorscolor.range');
    set_default()(options, 'color.range', get_default()(opt, 'rangeColors'));
  }

  if (!is_nil_default()(get_default()(opt, 'markerColors'))) {
    warning_default()(false, 'markerColorscolor.target');
    set_default()(options, 'color.target', get_default()(opt, 'markerColors'));
  } // bulletStyle


  if (!is_nil_default()(get_default()(opt, 'markerStyle'))) {
    warning_default()(false, 'markerStylebulletStyle.target');
    set_default()(options, 'bulletStyle.target', get_default()(opt, 'markerStyle'));
  }

  if (is_nil_default()(get_default()(opt, 'xAxis.line'))) {
    // 
    set_default()(options, 'xAxis.line', false);
  }

  if (is_nil_default()(get_default()(opt, 'yAxis'))) {
    // y
    set_default()(options, 'yAxis', false);
  }

  if (is_nil_default()(get_default()(opt, 'measureField'))) {
    // measureField
    set_default()(options, 'measureField', 'measures');
  }

  if (is_nil_default()(get_default()(opt, 'rangeField'))) {
    // rangeField
    set_default()(options, 'rangeField', 'ranges');
  }

  if (is_nil_default()(get_default()(opt, 'targetField'))) {
    // targetField
    set_default()(options, 'targetField', 'target');
  } // polyfill


  if (is_array_default()(get_default()(opt, 'data.0.targets'))) {
    // 
    set_default()(options, 'data.0.target', get_default()(opt, 'data.0.targets')[0]);
  }

  if (!is_nil_default()(get_default()(opt, 'rangeMax'))) {
    warning_default()(false, 'rangerangeField');
    set_default()(options, 'data.0.ranges', [get_default()(opt, 'rangeMax')]);
  }

  return options;
}; // 


/* harmony default export */ var BulletChart = (Object(createPlot["a" /* default */])(bullet["Bullet"], 'BulletChart', BulletChart_polyfill));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/esm/index.js
var g2plot_esm = __webpack_require__(610);

// CONCATENATED MODULE: ./src/plots/CalendarChart.tsx







g2plot_esm["G2"].registerShape('polygon', 'boundary-polygon', {
  draw: function draw(cfg, container) {
    var group = container.addGroup();
    var attrs = {
      stroke: '#fff',
      lineWidth: 1,
      fill: cfg.color,
      paht: []
    };
    var points = cfg.points;
    var path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], ['L', points[2].x, points[2].y], ['L', points[3].x, points[3].y], ['Z']]; // @ts-ignore

    attrs.path = this.parsePath(path);
    group.addShape('path', {
      attrs: attrs
    });

    if (Object(esm["get"])(cfg, 'data.lastWeek')) {
      var linePath = [['M', points[2].x, points[2].y], ['L', points[3].x, points[3].y]]; // 

      group.addShape('path', {
        attrs: {
          path: this.parsePath(linePath),
          lineWidth: 4,
          stroke: '#404040'
        }
      });

      if (Object(esm["get"])(cfg, 'data.lastDay')) {
        group.addShape('path', {
          attrs: {
            path: this.parsePath([['M', points[1].x, points[1].y], ['L', points[2].x, points[2].y]]),
            lineWidth: 4,
            stroke: '#404040'
          }
        });
      }
    }

    return group;
  }
});
var CalendarChart_REPLACEAPILIST = [{
  sourceKey: 'colors',
  targetKey: 'color',
  notice: 'colors  g2Plot@1.0  color '
}, {
  sourceKey: 'valueField',
  targetKey: 'colorField',
  notice: 'valueField  g2@1.0colorField'
}, {
  sourceKey: 'radiusField',
  targetKey: 'yField',
  notice: 'radiusField  g2@1.0yFeild'
}];
/* harmony default export */ var CalendarChart = (Object(createPlot["a" /* default */])(heatmap["Heatmap"], 'CalendarChart', function (props) {
  var options = Object(core_polyfill["c" /* polyfillOptions */])(props);
  Object(core_polyfill["f" /* replaceApi */])(CalendarChart_REPLACEAPILIST, options);

  if (Object(esm["isNil"])(Object(esm["get"])(props, 'shape'))) {
    Object(esm["set"])(options, 'shape', 'boundary-polygon');
  } // 1.0 


  if (Object(esm["isNil"])(Object(esm["get"])(options, 'xField')) && Object(esm["isNil"])(Object(esm["get"])(options, 'yField'))) {
    Object(esm["set"])(options, 'xField', 'week');
    Object(esm["set"])(options, 'meta.week', _object_assign_4_1_2_object_assign_default()({
      type: 'cat'
    }, Object(esm["get"])(options, 'meta.week', {})));
    Object(esm["set"])(options, 'yField', 'day');
    Object(esm["set"])(options, 'meta.day', {
      type: 'cat',
      values: ['Sun.', 'Mon.', 'Tues.', 'Wed.', 'Thur.', 'Fri.', 'Sat.']
    });
    Object(esm["set"])(options, 'reflect', 'y');
    Object(esm["set"])(options, 'xAxis', _object_assign_4_1_2_object_assign_default()({
      tickLine: null,
      line: null,
      title: null,
      label: {
        offset: 20,
        style: {
          fontSize: 12,
          fill: '#bbb',
          textBaseline: 'top'
        },
        formatter: function formatter(val) {
          if (val == '2') {
            return 'MAY';
          } else if (val === '6') {
            return 'JUN';
          } else if (val == '10') {
            return 'JUL';
          } else if (val === '14') {
            return 'AUG';
          } else if (val == '18') {
            return 'SEP';
          } else if (val === '24') {
            return 'OCT';
          }

          return '';
        }
      }
    }, Object(esm["get"])(options, 'xAxis', {})));
  }

  return options;
}));
// EXTERNAL MODULE: ./node_modules/_@antv_g2plot@2.3.10@@antv/g2plot/lib/plots/gauge/index.js
var gauge = __webpack_require__(611);

// CONCATENATED MODULE: ./src/plots/GaugeChart.tsx


var GaugeChart_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







 // plot 

/* harmony default export */ var GaugeChart = (Object(createPlot["a" /* default */])(gauge["Gauge"], 'GaugeChart', function (opt) {
  var _a = Object(core_polyfill["c" /* polyfillOptions */])(opt),
      range = _a.range,
      _a$min = _a.min,
      min = _a$min === void 0 ? 0 : _a$min,
      _a$max = _a.max,
      max = _a$max === void 0 ? 1 : _a$max,
      value = _a.value,
      options = GaugeChart_rest(_a, ["range", "min", "max", "value"]);

  if (Object(esm["isArray"])(range)) {
    warning_default()(false, 'range ');
    options.range = {
      ticks: range.map(function (t) {
        return t / (max - min);
      }),
      color: Object(lib["getTheme"])().colors10
    };
  } else {
    options.range = range || {};
  }

  var color = Object(esm["get"])(options, 'color');

  if (!Object(esm["isNil"])(color)) {
    warning_default()(false, 'range.color');
    options.range.color = color;
  }

  if (Object(esm["isNil"])(Object(esm["get"])(options, 'indicator'))) {
    //  indicator
    Object(esm["set"])(options, 'indicator', {
      pointer: {
        style: {
          stroke: '#D0D0D0'
        }
      },
      pin: {
        style: {
          stroke: '#D0D0D0'
        }
      }
    });
  }

  if (Object(esm["get"])(options, 'statistic.visible')) {
    // visible
    Object(esm["set"])(options, 'statistic.title', Object(esm["get"])(options, 'statistic'));
  }

  if (!Object(esm["isNil"])(min) && !Object(esm["isNil"])(max) && !Object(esm["isNil"])(value)) {
    // 
    options.percent = value / (max - min);

    var _formatter = Object(esm["get"])(options, 'axis.label.formatter');

    Object(esm["set"])(options, 'axis', {
      label: {
        formatter: function formatter(v) {
          var val = v * (max - min);

          if (Object(esm["isFunction"])(_formatter)) {
            return _formatter(val);
          }

          return val;
        }
      }
    });
  }

  warning_default()(!(Object(esm["get"])(options, 'min') || Object(esm["get"])(options, 'max')), ' `max`  `min`  range.ticks');
  warning_default()(!(Object(esm["get"])(options, 'rangeSize') || Object(esm["get"])(options, 'rangeStyle') || 'rangeBackgroundStyle'), 'rangeSizerangeStylerangeBackgroundStyle, '); // value dataplaceholder

  var data = !Object(esm["isNil"])(options.percent) ? options.percent : value;
  return _object_assign_4_1_2_object_assign_default()({
    data: data
  }, options);
}));
// CONCATENATED MODULE: ./src/plots/plots.tsx
// g2-plot 


































// CONCATENATED MODULE: ./src/plots/PlotAdapter.tsx


var PlotAdapter_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






var PLOT_MAP = _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, plots_namespaceObject), sparkline_namespaceObject);

var DEFAULT_PLOT = 'Line';

var PlotAdapter_PlotAdapter = function PlotAdapter(props) {
  var chartName = props.chartName,
      adapter = props.adapter,
      others = PlotAdapter_rest(props, ["chartName", "adapter"]);

  var adapterFnc = adapter || function (opt) {
    // plot
    return {
      plotType: props.plotType || DEFAULT_PLOT,
      options: opt
    };
  };

  var _ref = adapterFnc(others) || {},
      plotType = _ref.plotType,
      options = _ref.options;

  var Plot = PLOT_MAP[plotType];
  Plot.displayName = chartName;

  if (!Plot) {
    return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
      style: {
        color: '#aaa'
      }
    }, "\u4E0D\u5B58\u5728plotName=\uFF1A", "".concat(plotType), "\u7684Plot\u7EC4\u4EF6");
  }

  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(Plot, _object_assign_4_1_2_object_assign_default()({}, options));
}; // @ts-ignore


PlotAdapter_PlotAdapter.registerPlot = function (name, Component) {
  warning_default()(!PLOT_MAP[name], '%splot', name);
  PLOT_MAP[name] = Component;
};

/* harmony default export */ var plots_PlotAdapter = (PlotAdapter_PlotAdapter);
// CONCATENATED MODULE: ./src/plots/index.tsx




/***/ }),
/* 583 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Canvas", function() { return /* reexport */ g_components_Canvas; });
__webpack_require__.d(__webpack_exports__, "Group", function() { return /* reexport */ g_components_Group; });
__webpack_require__.d(__webpack_exports__, "Circle", function() { return /* reexport */ g_components_Circle; });
__webpack_require__.d(__webpack_exports__, "Ellipse", function() { return /* reexport */ g_components_Ellipse; });
__webpack_require__.d(__webpack_exports__, "Image", function() { return /* reexport */ g_components_Image; });
__webpack_require__.d(__webpack_exports__, "Line", function() { return /* reexport */ g_components_Line; });
__webpack_require__.d(__webpack_exports__, "Marker", function() { return /* reexport */ g_components_Marker; });
__webpack_require__.d(__webpack_exports__, "Path", function() { return /* reexport */ Path; });
__webpack_require__.d(__webpack_exports__, "Polygon", function() { return /* reexport */ g_components_Polygon; });
__webpack_require__.d(__webpack_exports__, "Polyline", function() { return /* reexport */ g_components_Polyline; });
__webpack_require__.d(__webpack_exports__, "Rect", function() { return /* reexport */ g_components_Rect; });
__webpack_require__.d(__webpack_exports__, "Text", function() { return /* reexport */ g_components_Text; });
__webpack_require__.d(__webpack_exports__, "render", function() { return /* binding */ g_components_render; });

// EXTERNAL MODULE: ./node_modules/_react-reconciler@0.25.1@react-reconciler/index.js
var _react_reconciler_0_25_1_react_reconciler = __webpack_require__(591);
var _react_reconciler_0_25_1_react_reconciler_default = /*#__PURE__*/__webpack_require__.n(_react_reconciler_0_25_1_react_reconciler);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./src/context/group.tsx
var context_group = __webpack_require__(28);

// CONCATENATED MODULE: ./src/g-components/reconciler/index.tsx



var emptyObject = {}; // 

var HostConfig = {
  getRootHostContext: function getRootHostContext() {},
  getChildHostContext: function getChildHostContext() {},
  createInstance: function createInstance() {},
  finalizeInitialChildren: function finalizeInitialChildren() {
    return false;
  },
  hideTextInstance: function hideTextInstance() {},
  getPublicInstance: function getPublicInstance(instance) {
    return instance;
  },
  hideInstance: function hideInstance() {},
  unhideInstance: function unhideInstance() {},
  createTextInstance: function createTextInstance() {},
  prepareUpdate: function prepareUpdate() {
    return emptyObject;
  },
  shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree() {
    return false;
  },
  appendInitialChild: function appendInitialChild() {},
  appendChildToContainer: function appendChildToContainer() {},
  removeChildFromContainer: function removeChildFromContainer() {},
  prepareForCommit: function prepareForCommit() {},
  resetAfterCommit: function resetAfterCommit() {},
  // 
  shouldSetTextContent: function shouldSetTextContent() {
    return false;
  },
  supportsMutation: true,
  appendChild: function appendChild() {}
};
var Renderer = _react_reconciler_0_25_1_react_reconciler_default()(HostConfig);
var LegacyRoot = 0;

var reconciler_withContext = function withContext(element, container) {
  return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(context_group["a" /* default */].Provider, {
    value: container
  }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null, element));
};

var ReactG = {
  render: function render(element, container) {
    if (container.clear) {
      container.clear();
    }

    var root = Renderer.createContainer(container, LegacyRoot, false);
    Renderer.updateContainer(reconciler_withContext(element, container), root, null, function () {
      return undefined;
    });
    return Renderer.getPublicRootInstance(root);
  }
};
/* harmony default export */ var reconciler = (ReactG);
// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@antv_g-canvas@0.5.6@@antv/g-canvas/esm/index.js
var esm = __webpack_require__(204);

// EXTERNAL MODULE: ./node_modules/_@antv_g-svg@0.5.6@@antv/g-svg/esm/index.js
var g_svg_esm = __webpack_require__(315);

// EXTERNAL MODULE: ./src/boundary/withContainer.tsx
var withContainer = __webpack_require__(132);

// EXTERNAL MODULE: ./src/boundary/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(65);

// CONCATENATED MODULE: ./src/context/canvas.tsx

 // canvas 

var CanvasContext = /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createContext(null);
CanvasContext.displayName = 'CanvasContext';
function withCanvasContext(Component) {
  var Com = /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.forwardRef(function (props, ref) {
    return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(CanvasContext.Consumer, null, function (ctx) {
      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(Component, _object_assign_4_1_2_object_assign_default()({
        ref: ref,
        ctx: ctx
      }, props));
    });
  });
  Com.displayName = Component.name;
  return Com;
}
;
/* harmony default export */ var canvas = (CanvasContext);
// CONCATENATED MODULE: ./src/g-components/Canvas.tsx







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};









var Canvas_CanvasHelper = /*#__PURE__*/function () {
  function CanvasHelper() {
    classCallCheck_default()(this, CanvasHelper);
  }

  createClass_default()(CanvasHelper, [{
    key: "createInstance",
    value: function createInstance(props) {
      var children = props.children,
          renderer = props.renderer,
          config = __rest(props, ["children", "renderer"]);

      if (renderer === 'svg') {
        this.instance = new g_svg_esm["Canvas"](_object_assign_4_1_2_object_assign_default()({}, config));
      } else {
        this.instance = new esm["Canvas"](_object_assign_4_1_2_object_assign_default()({}, config));
      }
    }
  }, {
    key: "update",
    value: function update(newConfig) {
      if (!this.instance) {
        this.createInstance(newConfig);
      }
    }
  }, {
    key: "draw",
    value: function draw() {
      if (!this.instance) {
        return;
      }

      this.instance.draw();
    }
  }, {
    key: "destory",
    value: function destory() {
      if (this.instance) {
        this.instance.remove();
        this.instance = null;
      }
    }
  }]);

  return CanvasHelper;
}();

var Canvas_Canvas = /*#__PURE__*/function (_React$Component) {
  inherits_default()(Canvas, _React$Component);

  var _super = _createSuper(Canvas);

  function Canvas(props) {
    var _this;

    classCallCheck_default()(this, Canvas);

    _this = _super.call(this, props);
    _this.helper = new Canvas_CanvasHelper();
    return _this;
  }

  createClass_default()(Canvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.helper.draw();
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.helper.destory();
    }
  }, {
    key: "getInstance",
    value: function getInstance() {
      return this.helper.instance;
    }
  }, {
    key: "render",
    value: function render() {
      this.helper.update(this.props);
      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" /* default */], _object_assign_4_1_2_object_assign_default()({}, this.props.ErrorBoundaryProps), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(canvas.Provider, {
        value: this.helper
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(context_group["a" /* default */].Provider, {
        value: this.helper.instance
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null, this.props.children))));
    }
  }]);

  return Canvas;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

/* harmony default export */ var g_components_Canvas = (Object(withContainer["a" /* default */])(Canvas_Canvas));
// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(46);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/for-in.js
var for_in = __webpack_require__(74);
var for_in_default = /*#__PURE__*/__webpack_require__.n(for_in);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/debounce.js
var debounce = __webpack_require__(226);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js
var unique_id = __webpack_require__(92);
var unique_id_default = /*#__PURE__*/__webpack_require__.n(unique_id);

// CONCATENATED MODULE: ./src/g-components/Base/events.ts
var EVENTS = {
  onClick: 'click',
  onMousedown: 'mousedown',
  onMouseup: 'mouseup',
  onDblclick: 'dblclick',
  onMouseout: 'mouseout',
  onMouseover: 'mouseover',
  onMousemove: 'mousemove',
  onMouseleave: 'mouseleave',
  onMouseenter: 'mouseenter',
  onTouchstart: 'touchstart',
  onTouchmove: 'touchmove',
  onTouchend: 'touchend',
  onDragenter: 'dragenter',
  onDragover: 'dragover',
  onDragleave: 'dragleave',
  onDrop: 'drop',
  onContextmenu: 'contextmenu'
};
// CONCATENATED MODULE: ./src/g-components/Group.tsx







function Group_createSuper(Derived) { var hasNativeReflectConstruct = Group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var Group_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};










var Group_Group = /*#__PURE__*/function (_React$Component) {
  inherits_default()(Group, _React$Component);

  var _super = Group_createSuper(Group);

  function Group(props) {
    var _this;

    classCallCheck_default()(this, Group);

    _this = _super.call(this, props);
    _this.state = {
      isReady: false
    };
    _this.handleRender = debounce_default()(function () {
      if (!_this.instance) {
        var _this$props = _this.props,
            _group = _this$props.group,
            _zIndex = _this$props.zIndex,
            _name = _this$props.name; // children.push push 

        _this.instance = _group.chart.canvas.addGroup({
          zIndex: _zIndex,
          name: _name
        });

        _group.chart.canvas.sort();

        _this.setState({
          isReady: true
        });
      } else {
        _this.forceUpdate();
      }
    }, 300);

    _this.configGroup = function (props) {
      var rotate = props.rotate,
          animate = props.animate,
          rotateAtPoint = props.rotateAtPoint,
          scale = props.scale,
          translate = props.translate,
          move = props.move;

      if (rotate) {
        _this.instance.rotate(rotate);
      }

      if (is_array_default()(rotateAtPoint)) {
        var _this$instance;

        // @ts-ignore
        (_this$instance = _this.instance).rotateAtPoint.apply(_this$instance, toConsumableArray_default()(rotateAtPoint));
      }

      if (scale) {
        _this.instance.rotate(scale);
      }

      if (translate) {
        _this.instance.translate(translate[0], translate[1]);
      }

      if (move) {
        _this.instance.move(move.x, move.y);
      }

      if (animate) {
        var toAttrs = animate.toAttrs,
            animateCfg = Group_rest(animate, ["toAttrs"]);

        _this.instance.animate(toAttrs, animateCfg);
      }
    };

    _this.bindEvents = function () {
      _this.instance.off();

      for_in_default()(EVENTS, function (v, k) {
        if (is_function_default()(_this.props[k])) {
          _this.instance.on(v, _this.props[k]);
        }
      });
    };

    var group = props.group,
        zIndex = props.zIndex,
        name = props.name;
    _this.id = unique_id_default()('group');

    if (group.isChartCanvas) {
      group.chart.on('afterrender', _this.handleRender);
    } else {
      _this.instance = group.addGroup({
        zIndex: zIndex,
        name: name
      });

      _this.configGroup(props);
    }

    return _this;
  }

  createClass_default()(Group, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var group = this.props.group;

      if (group.isChartCanvas) {
        group.chart.off('afterrender', this.handleRender);
      }

      if (this.instance) {
        this.instance.remove(true);
      }
    }
  }, {
    key: "getInstance",
    value: function getInstance() {
      return this.instance;
    }
  }, {
    key: "render",
    value: function render() {
      var group = this.props.group;

      if (this.instance) {
        this.instance.clear();
        this.bindEvents();
      }

      return group.isChartCanvas && this.state.isReady || !group.isChartCanvas ? /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(context_group["a" /* default */].Provider, {
        value: this.instance
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, {
        key: unique_id_default()(this.id)
      }, this.props.children)) : /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null);
    }
  }]);

  return Group;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

Group_Group.defaultProps = {
  zIndex: 3
};
/* harmony default export */ var g_components_Group = (Object(context_group["b" /* withGroupContext */])(Group_Group));
// EXTERNAL MODULE: ./src/utils/pickWithout.ts
var pickWithout = __webpack_require__(66);

// EXTERNAL MODULE: ./src/utils/constant.ts
var constant = __webpack_require__(93);

// EXTERNAL MODULE: ./src/utils/cloneDeep.ts
var cloneDeep = __webpack_require__(80);

// CONCATENATED MODULE: ./src/g-components/Base/Helper.ts




var Helper_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};








var Helper_Helper = /*#__PURE__*/function () {
  function Helper(shape) {
    classCallCheck_default()(this, Helper);

    this.shape = shape;
    this.shape = shape;
  }

  createClass_default()(Helper, [{
    key: "createInstance",
    value: function createInstance(props) {
      this.instance = props.group.addShape(this.shape, Object(pickWithout["a" /* default */])(props, ['group', 'ctx']));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.instance) {
        this.instance.remove(true);
        this.instance = null;
      }
    }
  }, {
    key: "update",
    value: function update(props) {
      var _this = this;

      var newConfig = Object(pickWithout["a" /* default */])(props, toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]));
      this.destroy();
      this.createInstance(newConfig);

      var attrs = newConfig.attrs,
          animate = newConfig.animate,
          isClipShape = newConfig.isClipShape,
          visible = newConfig.visible,
          matrix = newConfig.matrix,
          others = Helper_rest(newConfig, ["attrs", "animate", "isClipShape", "visible", "matrix"]);

      this.instance.attr(attrs);

      if (animate) {
        var toAttrs = animate.toAttrs,
            animateCfg = Helper_rest(animate, ["toAttrs"]);

        this.instance.animate(toAttrs, animateCfg);
      }

      if (isClipShape) {
        this.instance.isClipShape();
      }

      if (visible === false) {
        this.instance.hide();
      }

      if (matrix) {
        this.instance.setMatrix(matrix);
      }

      for_in_default()(EVENTS, function (v, k) {
        if (is_function_default()(others[k])) {
          _this.instance.on(v, others[k]);
        }
      });
      this.config = Object(cloneDeep["a" /* default */])(newConfig);
    }
  }]);

  return Helper;
}();


// CONCATENATED MODULE: ./src/g-components/Base/index.tsx






function Base_createSuper(Derived) { var hasNativeReflectConstruct = Base_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Base_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }




var Base_Base = /*#__PURE__*/function (_React$Component) {
  inherits_default()(Base, _React$Component);

  var _super = Base_createSuper(Base);

  function Base() {
    classCallCheck_default()(this, Base);

    return _super.apply(this, arguments);
  }

  createClass_default()(Base, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.helper.destroy();
    }
  }, {
    key: "getInstance",
    value: function getInstance() {
      return this.helper.instance;
    }
  }, {
    key: "render",
    value: function render() {
      this.helper.update(this.props);
      return null;
    }
  }]);

  return Base;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

/* harmony default export */ var g_components_Base = (Base_Base);
// CONCATENATED MODULE: ./src/g-components/Circle.tsx





function Circle_createSuper(Derived) { var hasNativeReflectConstruct = Circle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Circle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Circle_Circle = /*#__PURE__*/function (_Base) {
  inherits_default()(Circle, _Base);

  var _super = Circle_createSuper(Circle);

  function Circle(props) {
    var _this;

    classCallCheck_default()(this, Circle);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('circle');
    return _this;
  }

  return Circle;
}(g_components_Base);

/* harmony default export */ var g_components_Circle = (Object(context_group["b" /* withGroupContext */])(Circle_Circle));
// CONCATENATED MODULE: ./src/g-components/Ellipse.tsx





function Ellipse_createSuper(Derived) { var hasNativeReflectConstruct = Ellipse_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Ellipse_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Ellipse_Ellipse = /*#__PURE__*/function (_Base) {
  inherits_default()(Ellipse, _Base);

  var _super = Ellipse_createSuper(Ellipse);

  function Ellipse(props) {
    var _this;

    classCallCheck_default()(this, Ellipse);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('ellipse');
    return _this;
  }

  return Ellipse;
}(g_components_Base);

/* harmony default export */ var g_components_Ellipse = (Object(context_group["b" /* withGroupContext */])(Ellipse_Ellipse));
// CONCATENATED MODULE: ./src/g-components/Image.tsx





function Image_createSuper(Derived) { var hasNativeReflectConstruct = Image_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Image_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Image_Image = /*#__PURE__*/function (_Base) {
  inherits_default()(Image, _Base);

  var _super = Image_createSuper(Image);

  function Image(props) {
    var _this;

    classCallCheck_default()(this, Image);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('image');
    return _this;
  }

  return Image;
}(g_components_Base);

/* harmony default export */ var g_components_Image = (Object(context_group["b" /* withGroupContext */])(Image_Image));
// CONCATENATED MODULE: ./src/g-components/Line.tsx





function Line_createSuper(Derived) { var hasNativeReflectConstruct = Line_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Line_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Line_Line = /*#__PURE__*/function (_Base) {
  inherits_default()(Line, _Base);

  var _super = Line_createSuper(Line);

  function Line(props) {
    var _this;

    classCallCheck_default()(this, Line);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('line');
    return _this;
  }

  return Line;
}(g_components_Base);

/* harmony default export */ var g_components_Line = (Object(context_group["b" /* withGroupContext */])(Line_Line));
// CONCATENATED MODULE: ./src/g-components/Marker.tsx





function Marker_createSuper(Derived) { var hasNativeReflectConstruct = Marker_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Marker_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Marker_Marker = /*#__PURE__*/function (_Base) {
  inherits_default()(Marker, _Base);

  var _super = Marker_createSuper(Marker);

  function Marker(props) {
    var _this;

    classCallCheck_default()(this, Marker);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('marker');
    return _this;
  }

  return Marker;
}(g_components_Base);

/* harmony default export */ var g_components_Marker = (Object(context_group["b" /* withGroupContext */])(Marker_Marker));
// CONCATENATED MODULE: ./src/g-components/Path.tsx





function Path_createSuper(Derived) { var hasNativeReflectConstruct = Path_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Path_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Path_Image = /*#__PURE__*/function (_Base) {
  inherits_default()(Image, _Base);

  var _super = Path_createSuper(Image);

  function Image(props) {
    var _this;

    classCallCheck_default()(this, Image);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('path');
    return _this;
  }

  return Image;
}(g_components_Base);

/* harmony default export */ var Path = (Object(context_group["b" /* withGroupContext */])(Path_Image));
// CONCATENATED MODULE: ./src/g-components/Polygon.tsx





function Polygon_createSuper(Derived) { var hasNativeReflectConstruct = Polygon_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Polygon_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Polygon_Polygon = /*#__PURE__*/function (_Base) {
  inherits_default()(Polygon, _Base);

  var _super = Polygon_createSuper(Polygon);

  function Polygon(props) {
    var _this;

    classCallCheck_default()(this, Polygon);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('polygon');
    return _this;
  }

  return Polygon;
}(g_components_Base);

/* harmony default export */ var g_components_Polygon = (Object(context_group["b" /* withGroupContext */])(Polygon_Polygon));
// CONCATENATED MODULE: ./src/g-components/Polyline.tsx





function Polyline_createSuper(Derived) { var hasNativeReflectConstruct = Polyline_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Polyline_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Polyline_Polyline = /*#__PURE__*/function (_Base) {
  inherits_default()(Polyline, _Base);

  var _super = Polyline_createSuper(Polyline);

  function Polyline(props) {
    var _this;

    classCallCheck_default()(this, Polyline);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('polyline');
    return _this;
  }

  return Polyline;
}(g_components_Base);

/* harmony default export */ var g_components_Polyline = (Object(context_group["b" /* withGroupContext */])(Polyline_Polyline));
// CONCATENATED MODULE: ./src/g-components/Rect.tsx





function Rect_createSuper(Derived) { var hasNativeReflectConstruct = Rect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Rect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Rect_Rect = /*#__PURE__*/function (_Base) {
  inherits_default()(Rect, _Base);

  var _super = Rect_createSuper(Rect);

  function Rect(props) {
    var _this;

    classCallCheck_default()(this, Rect);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('rect');
    return _this;
  }

  return Rect;
}(g_components_Base);

/* harmony default export */ var g_components_Rect = (Object(context_group["b" /* withGroupContext */])(Rect_Rect));
// CONCATENATED MODULE: ./src/g-components/Text.tsx





function Text_createSuper(Derived) { var hasNativeReflectConstruct = Text_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Text_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var Text_Text = /*#__PURE__*/function (_Base) {
  inherits_default()(Text, _Base);

  var _super = Text_createSuper(Text);

  function Text(props) {
    var _this;

    classCallCheck_default()(this, Text);

    _this = _super.call(this, props);
    _this.helper = new Helper_Helper('text');
    return _this;
  }

  return Text;
}(g_components_Base);

/* harmony default export */ var g_components_Text = (Object(context_group["b" /* withGroupContext */])(Text_Text));
// CONCATENATED MODULE: ./src/g-components/index.ts













var g_components_render = reconciler.render;


/***/ }),
/* 584 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Base", function() { return /* reexport */ base["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "Arc", function() { return /* reexport */ arc["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "DataMarker", function() { return /* reexport */ dataMarker["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "DataRegion", function() { return /* reexport */ dataRegion["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "RegionFilter", function() { return /* reexport */ regionFilter_RegionFilter; });
__webpack_require__.d(__webpack_exports__, "Html", function() { return /* reexport */ html_Html; });
__webpack_require__.d(__webpack_exports__, "Image", function() { return /* reexport */ Annotation_image["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "Line", function() { return /* reexport */ line["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "Region", function() { return /* reexport */ region["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "Text", function() { return /* reexport */ Annotation_text["a" /* default */]; });

// EXTERNAL MODULE: ./src/components/Annotation/base.tsx
var base = __webpack_require__(36);

// EXTERNAL MODULE: ./src/components/Annotation/arc.tsx
var arc = __webpack_require__(205);

// EXTERNAL MODULE: ./src/components/Annotation/dataMarker.tsx
var dataMarker = __webpack_require__(206);

// EXTERNAL MODULE: ./src/components/Annotation/dataRegion.tsx
var dataRegion = __webpack_require__(207);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// CONCATENATED MODULE: ./src/components/Annotation/regionFilter.tsx





function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var regionFilter_RegionFilter = /*#__PURE__*/function (_Base) {
  inherits_default()(RegionFilter, _Base);

  var _super = _createSuper(RegionFilter);

  function RegionFilter() {
    var _this;

    classCallCheck_default()(this, RegionFilter);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'regionFilter';
    return _this;
  }

  return RegionFilter;
}(base["a" /* default */]);


;
// CONCATENATED MODULE: ./src/components/Annotation/html.tsx





function html_createSuper(Derived) { var hasNativeReflectConstruct = html_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function html_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



var html_Html = /*#__PURE__*/function (_Base) {
  inherits_default()(Html, _Base);

  var _super = html_createSuper(Html);

  function Html() {
    var _this;

    classCallCheck_default()(this, Html);

    _this = _super.apply(this, arguments);
    _this.annotationType = 'html';
    return _this;
  }

  return Html;
}(base["a" /* default */]);


;
// EXTERNAL MODULE: ./src/components/Annotation/image.tsx
var Annotation_image = __webpack_require__(208);

// EXTERNAL MODULE: ./src/components/Annotation/line.tsx
var line = __webpack_require__(209);

// EXTERNAL MODULE: ./src/components/Annotation/region.tsx
var region = __webpack_require__(210);

// EXTERNAL MODULE: ./src/components/Annotation/text.tsx
var Annotation_text = __webpack_require__(211);

// CONCATENATED MODULE: ./src/components/Annotation/index.tsx
// annotation G2











/***/ }),
/* 585 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Tooltip_Tooltip; });

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/chart/controller/tooltip.js
var tooltip = __webpack_require__(203);
var tooltip_default = /*#__PURE__*/__webpack_require__.n(tooltip);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js
var unique_id = __webpack_require__(92);
var unique_id_default = /*#__PURE__*/__webpack_require__.n(unique_id);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js
var is_string = __webpack_require__(50);
var is_string_default = /*#__PURE__*/__webpack_require__.n(is_string);

// EXTERNAL MODULE: ./src/core.ts
var core = __webpack_require__(6);

// EXTERNAL MODULE: ./src/hooks/useChartView.tsx
var useChartView = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom","umd":"react-dom"}
var external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_ = __webpack_require__(594);
var external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_default = /*#__PURE__*/__webpack_require__.n(external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/get.js
var get = __webpack_require__(15);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/_@antv_dom-util@2.0.3@@antv/dom-util/lib/modify-css.js
var modify_css = __webpack_require__(595);
var modify_css_default = /*#__PURE__*/__webpack_require__.n(modify_css);

// EXTERNAL MODULE: ./src/context/view.tsx
var view = __webpack_require__(49);

// CONCATENATED MODULE: ./src/components/Tooltip/ReactTooltip.tsx







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var CONTAINER_CLASS = 'g2-tooltip';

var ReactTooltip_Tooltip = /*#__PURE__*/function (_React$Component) {
  inherits_default()(Tooltip, _React$Component);

  var _super = _createSuper(Tooltip);

  function Tooltip() {
    var _this;

    classCallCheck_default()(this, Tooltip);

    _this = _super.apply(this, arguments);

    _this.renderInnder = function (e) {
      var _e$data = e.data,
          title = _e$data.title,
          items = _e$data.items,
          x = _e$data.x,
          y = _e$data.y; // , todo: fiberreactdom

      external_root_ReactDOM_commonjs2_react_dom_commonjs_react_dom_amd_react_dom_umd_react_dom_default.a.render(_this.props.children(title, items, x, y, e), _this.getElement());
    };

    return _this;
  }

  createClass_default()(Tooltip, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var chartView = this.props.chartView;

      if (this.element) {
        this.element.remove();
      }

      chartView.getController('tooltip').clear();
      chartView.off('tooltip:change', this.renderInnder);
    }
  }, {
    key: "getElement",
    value: function getElement() {
      if (!this.element) {
        this.element = document.createElement('div');
        this.element.classList.add('bizcharts-tooltip');
        this.element.classList.add('g2-tooltip');
        this.element.style.width = 'auto';
        this.element.style.height = 'auto';
      }

      return this.element;
    }
  }, {
    key: "overwriteCfg",
    value: function overwriteCfg() {
      var _this2 = this;

      var _a = this.props,
          chartView = _a.chartView,
          children = _a.children,
          _a$domStyles = _a.domStyles,
          domStyles = _a$domStyles === void 0 ? {} : _a$domStyles,
          config = __rest(_a, ["chartView", "children", "domStyles"]);

      chartView.tooltip(_object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({
        inPlot: false,
        domStyles: domStyles
      }, config), {
        // 
        customContent: function customContent() {
          return _this2.getElement();
        }
      }));
      chartView.on('tooltip:change', this.renderInnder); // fixme: meger domStyle

      var domStylesTheme = get_default()(Object(core["getTheme"])(), ['components', 'tooltip', 'domStyles', CONTAINER_CLASS], {});

      modify_css_default()(this.element, _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, domStylesTheme), domStyles[CONTAINER_CLASS]));
    }
  }, {
    key: "render",
    value: function render() {
      this.overwriteCfg();
      return null; // 
    }
  }]);

  return Tooltip;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);

/* harmony default export */ var ReactTooltip = (Object(view["b" /* withView */])(ReactTooltip_Tooltip));
// EXTERNAL MODULE: ./src/connector/createTooltipConnector.ts
var createTooltipConnector = __webpack_require__(171);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/active-region.js
var active_region = __webpack_require__(336);
var active_region_default = /*#__PURE__*/__webpack_require__.n(active_region);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/tooltip/sibling.js
var sibling = __webpack_require__(337);
var sibling_default = /*#__PURE__*/__webpack_require__.n(sibling);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/tooltip/geometry.js
var geometry = __webpack_require__(127);
var geometry_default = /*#__PURE__*/__webpack_require__.n(geometry);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/tooltip/ellipsis-text.js
var ellipsis_text = __webpack_require__(338);
var ellipsis_text_default = /*#__PURE__*/__webpack_require__.n(ellipsis_text);

// CONCATENATED MODULE: ./src/components/Tooltip/actions.ts





Object(core["registerAction"])('tooltip', geometry_default.a);
Object(core["registerAction"])('sibling-tooltip', sibling_default.a);
Object(core["registerAction"])('active-region', active_region_default.a);
Object(core["registerAction"])('ellipsis-text', ellipsis_text_default.a); //  tooltip  interaction

Object(core["registerInteraction"])('tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:touchmove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:leave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:touchend',
    action: 'tooltip:hide'
  }]
});
Object(core["registerInteraction"])('ellipsis-text', {
  start: [{
    trigger: 'legend-item-name:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'legend-item-name:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:mousemove',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'axis-label:touchstart',
    action: 'ellipsis-text:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'legend-item-name:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'legend-item-name:touchend',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:mouseleave',
    action: 'ellipsis-text:hide'
  }, {
    trigger: 'axis-label:touchend',
    action: 'ellipsis-text:hide'
  }]
}); // click 

Object(core["registerInteraction"])('tooltip-click', {
  start: [{
    trigger: 'plot:click',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:touchstart',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }],
  end: [{
    trigger: 'plot:leave',
    action: 'tooltip:hide'
  }]
}); // tooltip 

var toggleLock = function toggleLock(context) {
  var locked = context.view.isTooltipLocked();

  if (locked) {
    context.view.unlockTooltip();
  } else {
    context.view.lockTooltip();
  }
};

Object(core["registerInteraction"])('tooltip-lock', {
  start: [{
    trigger: 'plot:click',
    action: toggleLock
  }, {
    trigger: 'plot:touchstart',
    action: toggleLock
  }, {
    trigger: 'plot:touchmove',
    action: 'tooltip:show',
    throttle: {
      wait: 50,
      leading: true,
      trailing: false
    }
  }, {
    trigger: 'plot:mousemove',
    action: 'tooltip:show'
  }],
  end: [{
    trigger: 'plot:click',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:leave',
    action: 'tooltip:hide'
  }, {
    trigger: 'plot:touchend',
    action: 'tooltip:hide'
  }]
}); //  sibling-tooltip  interaction

Object(core["registerInteraction"])('sibling-tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'sibling-tooltip:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'sibling-tooltip:hide'
  }]
});
// CONCATENATED MODULE: ./src/components/Tooltip/index.tsx


var Tooltip_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};












Object(core["registerComponentController"])('tooltip', tooltip_default.a);

var Tooltip_isReactTooltip = function isReactTooltip(props) {
  var _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      children = props.children;
  return visible && is_function_default()(children);
};

var Tooltip_TooltipNormal = function TooltipNormal(props) {
  var _props$visible2 = props.visible,
      visible = _props$visible2 === void 0 ? true : _props$visible2,
      children = props.children,
      options = Tooltip_rest(props, ["visible", "children"]);

  var chartView = Object(useChartView["a" /* default */])();
  chartView.getController('tooltip').clear();

  if (visible === true) {
    chartView.tooltip(_object_assign_4_1_2_object_assign_default()({
      customContent: null,
      showMarkers: false
    }, options));
  } else {
    chartView.tooltip(false);
  }

  return null;
};

function Tooltip_Tooltip(props) {
  var children = props.children,
      triggerOn = props.triggerOn,
      onShow = props.onShow,
      onChange = props.onChange,
      onHide = props.onHide,
      lock = props.lock,
      linkage = props.linkage,
      options = Tooltip_rest(props, ["children", "triggerOn", "onShow", "onChange", "onHide", "lock", "linkage"]);

  var chartView = Object(useChartView["a" /* default */])();
  chartView.removeInteraction('tooltip');
  chartView.removeInteraction('tooltip-click');
  chartView.removeInteraction('tooltip-lock');

  if (triggerOn === 'click') {
    // clicktooltiphover 
    chartView.interaction("tooltip-click");
  } else if (lock) {
    // hover
    chartView.interaction("tooltip-lock");
  } else {
    // clickhover
    chartView.interaction("tooltip");
  }

  var connectorId = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useRef"])(unique_id_default()('tooltip')); // tooltip 

  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useEffect"])(function () {
    if (is_array_default()(linkage)) {
      Object(createTooltipConnector["b" /* registerConnector */])(linkage[0], connectorId.current, chartView, options.shared, linkage[1]);
    } else if (is_string_default()(linkage)) {
      Object(createTooltipConnector["b" /* registerConnector */])(linkage, connectorId.current, chartView, options.shared);
    }
  }, [linkage, chartView]);
  var showFnc = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(function (ITooltipEvent) {
    if (is_function_default()(onShow)) {
      onShow(ITooltipEvent, chartView);
    }
  }, []);
  var changeFnc = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(function (ITooltipEvent) {
    if (is_function_default()(onChange)) {
      onChange(ITooltipEvent, chartView);
    }
  }, []);
  var hideFnc = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useCallback"])(function (ITooltipEvent) {
    if (is_function_default()(onHide)) {
      onHide(ITooltipEvent, chartView);
    }
  }, []);
  chartView.off('tooltip:show', showFnc);
  chartView.on('tooltip:show', showFnc);
  chartView.off('tooltip:change', changeFnc);
  chartView.on('tooltip:change', changeFnc);
  chartView.off('tooltip:hide', hideFnc);
  chartView.on('tooltip:hide', hideFnc);
  return Tooltip_isReactTooltip(props) ? /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ReactTooltip, _object_assign_4_1_2_object_assign_default()({}, options), children) : /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(Tooltip_TooltipNormal, _object_assign_4_1_2_object_assign_default()({}, props));
}
Tooltip_Tooltip.defaultProps = {
  showMarkers: false,
  triggerOn: 'hover'
};

/***/ }),
/* 586 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: Chart

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/debounce.js
var debounce = __webpack_require__(226);
var debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/util/dom.js
var dom = __webpack_require__(309);

// EXTERNAL MODULE: ./node_modules/_resize-observer-polyfill@1.5.1@resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es = __webpack_require__(229);
var ResizeObserver_es_default = /*#__PURE__*/__webpack_require__.n(ResizeObserver_es);

// EXTERNAL MODULE: ./src/boundary/ErrorBoundary.tsx
var ErrorBoundary = __webpack_require__(65);

// EXTERNAL MODULE: ./src/boundary/withContainer.tsx
var withContainer = __webpack_require__(132);

// EXTERNAL MODULE: ./src/context/root.tsx
var root = __webpack_require__(73);

// EXTERNAL MODULE: ./src/context/view.tsx
var context_view = __webpack_require__(49);

// EXTERNAL MODULE: ./src/context/group.tsx
var group = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/toConsumableArray.js
var toConsumableArray = __webpack_require__(46);
var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/unique-id.js
var unique_id = __webpack_require__(92);
var unique_id_default = /*#__PURE__*/__webpack_require__.n(unique_id);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js
var each = __webpack_require__(56);
var each_default = /*#__PURE__*/__webpack_require__.n(each);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-equal.js
var is_equal = __webpack_require__(230);
var is_equal_default = /*#__PURE__*/__webpack_require__.n(is_equal);

// EXTERNAL MODULE: ./src/core.ts
var core = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// EXTERNAL MODULE: ./src/utils/shallowEqual.ts
var shallowEqual = __webpack_require__(81);

// EXTERNAL MODULE: ./src/utils/pickWithout.ts
var pickWithout = __webpack_require__(66);

// EXTERNAL MODULE: ./src/utils/cloneDeep.ts
var cloneDeep = __webpack_require__(80);

// EXTERNAL MODULE: ./src/utils/constant.ts
var constant = __webpack_require__(93);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/constant.js
var lib_constant = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/_@antv_event-emitter@0.1.2@@antv/event-emitter/esm/index.js
var esm = __webpack_require__(125);
var esm_default = /*#__PURE__*/__webpack_require__.n(esm);

// EXTERNAL MODULE: ./src/components/Chart/events.ts
var Chart_events = __webpack_require__(136);

// CONCATENATED MODULE: ./src/components/Chart/chartHelper.ts








function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};
















var processData = function processData(data) {
  if (data && data.rows) {
    return data.rows;
  }

  return data;
};

var chartHelper_ChartHelper = /*#__PURE__*/function (_EventEmitter) {
  inherits_default()(ChartHelper, _EventEmitter);

  var _super = _createSuper(ChartHelper);

  function ChartHelper() {
    var _this;

    classCallCheck_default()(this, ChartHelper);

    _this = _super.apply(this, arguments);
    _this.config = {};
    return _this;
  }

  createClass_default()(ChartHelper, [{
    key: "createInstance",
    value: function createInstance(config) {
      this.chart = new core["Chart"](_object_assign_4_1_2_object_assign_default()({}, config));
      this.key = unique_id_default()('bx-chart');
      this.chart.emit('initialed');
      this.isNewInstance = true; // 

      this.extendGroup = {
        isChartCanvas: true,
        chart: this.chart
      };
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.chart) {
        return;
      } // this.chart.render();
      // if (this.isNewInstance) {
      //   this.onGetG2Instance();
      //   // @ts-ignore
      //   this.chart.unbindAutoFit(); // g2
      //   this.isNewInstance = false;
      // }
      // // elements
      // this.chart.emit('processElemens');


      try {
        // error react rendererror chart rendererror 
        this.chart.render();

        if (this.isNewInstance) {
          this.onGetG2Instance(); // @ts-ignore

          this.chart.unbindAutoFit(); // g2

          this.isNewInstance = false;
        } // elements


        this.chart.emit('processElemens');
      } catch (e) {
        this.emit('renderError', e);
        this.destory();

        if (console) {
          console.error(e === null || e === void 0 ? void 0 : e.stack);
        }
      }
    }
  }, {
    key: "onGetG2Instance",
    value: function onGetG2Instance() {
      //  isNewInstance 
      if (is_function_default()(this.config.onGetG2Instance)) {
        this.config.onGetG2Instance(this.chart);
      }
    }
  }, {
    key: "shouldReCreateInstance",
    value: function shouldReCreateInstance(newConfig) {
      // 
      if (!this.chart || newConfig.forceUpdate) {
        return true;
      }

      var _a = this.config,
          preData = _a.data,
          preOptions = __rest(_a, ["data"]);

      var data = newConfig.data,
          options = __rest(newConfig, ["data"]);

      if (is_array_default()(this.config.data) && preData.length === 0 && is_array_default()(data) && data.length !== 0) {
        return true;
      } // scale 


      var unCompareProps = [].concat(toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]), ['scale', 'width', 'height', 'container', '_container', '_interactions', 'placeholder', /^on/, /^\_on/]);

      if (!is_equal_default()(Object(pickWithout["a" /* default */])(preOptions, toConsumableArray_default()(unCompareProps)), Object(pickWithout["a" /* default */])(options, toConsumableArray_default()(unCompareProps)))) {
        return true;
      }

      return false;
    }
  }, {
    key: "update",
    value: function update(props) {
      var _this2 = this;

      var newConfig = Object(cloneDeep["a" /* default */])(this.adapterOptions(props));

      if (this.shouldReCreateInstance(newConfig)) {
        this.destory();
        this.createInstance(newConfig);
      } // 


      if (newConfig.pure) {
        //  
        this.chart.axis(false);
        this.chart.tooltip(false);
        this.chart.legend(false);
      } // 


      var events = Object(Chart_events["a" /* pickEventName */])(this.config);
      var newEvents = Object(Chart_events["a" /* pickEventName */])(newConfig); // 

      var data = newConfig.data,
          interactions = newConfig.interactions,
          options = __rest(newConfig, ["data", "interactions"]);

      var _this$config = this.config,
          preData = _this$config.data,
          _this$config$interact = _this$config.interactions,
          preInteractions = _this$config$interact === void 0 ? [] : _this$config$interact;

      if (!this.isNewInstance) {
        // 
        events.forEach(function (ev) {
          _this2.chart.off(ev[1], _this2.config["_".concat(ev[0])]);
        });
      }
      /**  */
      // 


      newEvents.forEach(function (evName) {
        newConfig["_".concat(evName[0])] = function (ev) {
          // chart
          newConfig[evName[0]](ev, _this2.chart);
        };

        _this2.chart.on(evName[1], newConfig["_".concat(evName[0])]);
      }); //  

      if (is_array_default()(preData) && preData.length) {
        // 2
        // fixme: 4
        var isEqual = true;

        if (newConfig.notCompareData) {
          // 
          isEqual = false;
        }

        if (preData.length !== data.length) {
          // 
          isEqual = false;
        } else {
          preData.forEach(function (element, index) {
            if (!Object(shallowEqual["a" /* default */])(element, data[index])) {
              isEqual = false;
            }
          });
        }

        if (!isEqual) {
          // @ts-ignore
          this.chart.isDataChanged = true;
          this.chart.emit(lib_constant["VIEW_LIFE_CIRCLE"].BEFORE_CHANGE_DATA); // 1. 

          this.chart.data(data); // 2. 
          // 3.  view  change data

          var views = this.chart.views;

          for (var i = 0, len = views.length; i < len; i++) {
            var view = views[i]; //  view , view

            view.changeData(data);
          }

          this.chart.emit(lib_constant["VIEW_LIFE_CIRCLE"].AFTER_CHANGE_DATA);
        }
      } else {
        this.chart.data(data);
      } // 


      this.chart.scale(options.scale); // 

      if (options.animate === false) {
        this.chart.animate(false);
      } else {
        this.chart.animate(true);
      } //  interactions


      preInteractions.forEach(function (interact) {
        // 
        _this2.chart.removeInteraction(interact);
      });
      interactions.forEach(function (interact) {
        _this2.chart.interaction(interact);
      }); // filter

      each_default()(this.config.filter, function (it, index) {
        // 
        if (is_array_default()(it)) {
          _this2.chart.filter(it[0], null);
        } else {
          _this2.chart.filter(index, null);
        }
      });

      each_default()(newConfig.filter, function (it, index) {
        if (is_array_default()(it)) {
          _this2.chart.filter(it[0], it[1]);
        } else {
          _this2.chart.filter(index, it);
        }
      }); // 


      this.chart.theme(newConfig.theme); // 

      this.config = newConfig;
    }
  }, {
    key: "adapterOptions",
    value: function adapterOptions(_a) {
      var data = _a.data,
          others = __rest(_a, ["data"]); //  React 


      var options = Object(pickWithout["a" /* default */])(others, toConsumableArray_default()(constant["a" /* REACT_PIVATE_PROPS */]));

      if (options.forceFit) {
        warning_default()(false, 'forceFit `autoFit`');
      }

      options.data = processData(data) || [];
      return options;
    }
  }, {
    key: "destory",
    value: function destory() {
      if (!this.chart) {
        return;
      }

      this.extendGroup = null;
      var chart = this.chart;
      chart.destroy();
      chart = null;
      this.chart = null;
      this.config = {};
    }
  }]);

  return ChartHelper;
}(esm_default.a);

/* harmony default export */ var chartHelper = (chartHelper_ChartHelper);
// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/esm/index.js
var util_esm = __webpack_require__(0);

// CONCATENATED MODULE: ./src/components/Chart/index.tsx







function Chart_createSuper(Derived) { var hasNativeReflectConstruct = Chart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function Chart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }












var Chart_Chart = /*#__PURE__*/function (_React$Component) {
  inherits_default()(Chart, _React$Component);

  var _super = Chart_createSuper(Chart);

  function Chart(props) {
    var _this;

    classCallCheck_default()(this, Chart);

    _this = _super.call(this, props);
    _this.isRootView = true;
    _this.resize = debounce_default()(function () {
      var chart = _this.chartHelper.chart;

      if (_this.props.autoFit && _this.chartHelper.chart) {
        var _getChartSize = Object(dom["getChartSize"])(_this.props.container, _this.props.autoFit, chart.width, chart.height),
            width = _getChartSize.width,
            height = _getChartSize.height;

        if (chart.width !== width || chart.height !== height) {
          chart.changeSize(width, height);
          chart.emit('resize');
        }
      }
    }, 300); // resize

    _this.resizeObserver = new ResizeObserver_es_default.a(_this.resize);

    _this.resizeObserver.observe(props.container);

    _this.chartHelper = new chartHelper();
    return _this;
  }

  createClass_default()(Chart, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.isError) {
        this.chartHelper.destory();
      } else {
        this.chartHelper.render();
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      if (this.isError) {
        this.chartHelper.destory();
        return;
      } // 


      var _this$props = this.props,
          width = _this$props.width,
          height = _this$props.height,
          autoFit = _this$props.autoFit; // 

      if (!autoFit && this.chartHelper.chart) {
        if (width >= 0 && width !== this.chartHelper.chart.width || height >= 0 && height !== this.chartHelper.chart.height) {
          var nextWidth = width || this.chartHelper.chart.width;
          var nextHeight = height || this.chartHelper.chart.height; // changeSizerender, 

          this.chartHelper.chart.changeSize(nextWidth, nextHeight);
          this.chartHelper.chart.emit('resize');
        } else {
          this.chartHelper.render();
        }
      } else {
        this.chartHelper.render();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.chartHelper.destory();
      this.resizeObserver.unobserve(this.props.container);
    } // ref

  }, {
    key: "getG2Instance",
    value: function getG2Instance() {
      return this.chartHelper.chart;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          placeholder = _this$props2.placeholder,
          data = _this$props2.data,
          errorContent = _this$props2.errorContent;
      var ErrorBoundaryProps = this.props.ErrorBoundaryProps;

      if ((data === undefined || data.length === 0) && placeholder) {
        this.chartHelper.destory();
        var pl = placeholder === true ? /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement("div", {
          style: {
            position: 'relative',
            top: '48%',
            color: '#aaa',
            textAlign: 'center'
          }
        }, "\u6682\u65E0\u6570\u636E") : placeholder;
        return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" /* default */], _object_assign_4_1_2_object_assign_default()({}, ErrorBoundaryProps), pl);
      }

      this.chartHelper.update(this.props);

      if (errorContent) {
        //  4.0 
        ErrorBoundaryProps = _object_assign_4_1_2_object_assign_default()({
          fallback: errorContent
        }, ErrorBoundaryProps);
      } else {
        // react-ErrorBoundary
        ErrorBoundaryProps = {
          FallbackComponent: ErrorBoundary["a" /* ErrorFallback */]
        };
      }

      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(ErrorBoundary["b" /* default */], _object_assign_4_1_2_object_assign_default()({}, ErrorBoundaryProps, {
        key: this.chartHelper.key,
        onError: function onError() {
          var _ErrorBoundaryProps;

          _this2.isError = true;
          Object(util_esm["isFunction"])(ErrorBoundaryProps.onError) && (_ErrorBoundaryProps = ErrorBoundaryProps).onError.apply(_ErrorBoundaryProps, arguments);
        },
        onReset: function onReset() {
          var _ErrorBoundaryProps2;

          _this2.isError = false;
          Object(util_esm["isFunction"])(ErrorBoundaryProps.onReset) && (_ErrorBoundaryProps2 = ErrorBoundaryProps).onReset.apply(_ErrorBoundaryProps2, arguments);
        },
        resetKeys: [this.chartHelper.key],
        fallback: errorContent
      }), /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(root["a" /* default */].Provider, {
        value: this.chartHelper
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(context_view["a" /* default */].Provider, {
        value: this.chartHelper.chart
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(group["a" /* default */].Provider, {
        value: this.chartHelper.extendGroup
      }, this.props.children))));
    }
  }]);

  return Chart;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);
Chart_Chart.defaultProps = {
  placeholder: false,
  visible: true,
  interactions: [],
  filter: []
};
/* harmony default export */ var components_Chart = __webpack_exports__["a"] = (Object(withContainer["a" /* default */])(Chart_Chart));

/***/ }),
/* 587 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: View

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_);

// EXTERNAL MODULE: ./src/context/root.tsx
var root = __webpack_require__(73);

// EXTERNAL MODULE: ./src/context/view.tsx
var view = __webpack_require__(49);

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/deep-mix.js
var deep_mix = __webpack_require__(173);
var deep_mix_default = /*#__PURE__*/__webpack_require__.n(deep_mix);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/each.js
var each = __webpack_require__(56);
var each_default = /*#__PURE__*/__webpack_require__.n(each);

// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// EXTERNAL MODULE: ./src/utils/shallowEqual.ts
var shallowEqual = __webpack_require__(81);

// CONCATENATED MODULE: ./src/components/View/viewHelper.ts




var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







var viewHelper_ViewHelper = /*#__PURE__*/function () {
  function ViewHelper(chart) {
    classCallCheck_default()(this, ViewHelper);

    this.chart = chart;
    this.config = {};
    this.isRootView = false;
    this.chart = chart;
  }

  createClass_default()(ViewHelper, [{
    key: "creatViewInstance",
    value: function creatViewInstance(options) {
      this.view = this.chart.createView(this.processOptions(options)); // @ts-ignore

      this.view.rootChart = this.chart;
    }
  }, {
    key: "getView",
    value: function getView() {
      return this.view;
    }
  }, {
    key: "update",
    value: function update(newConfig) {
      var _this = this;

      // 
      var preData = this.config.data;
      var scale = newConfig.scale,
          animate = newConfig.animate,
          filter = newConfig.filter,
          visible = newConfig.visible;
      var _newConfig$data = newConfig.data,
          data = _newConfig$data === void 0 ? [] : _newConfig$data;

      if (data.rows) {
        warning_default()(!data.rows, 'bizcharts@4 datasetdata={dv.rows}');
        data = data.rows;
      }

      if (!this.view || is_array_default()(preData) && preData.length === 0) {
        // hack g2 
        this.destroy();
        this.creatViewInstance(newConfig);
      } // 


      if (is_array_default()(preData)) {
        this.view.changeData(data); // 2

        var isEqual = true;

        if (preData.length !== data.length) {
          isEqual = false;
        } else {
          preData.forEach(function (element, index) {
            if (!Object(shallowEqual["a" /* default */])(element, data[index])) {
              isEqual = false;
            }
          });
        }

        if (!isEqual) {
          this.view.changeData(data);
        }
      } else {
        this.view.data(data);
      } // 


      this.view.scale(scale); // animate

      this.view.animate(animate); // filter

      each_default()(this.config.filter, function (it, index) {
        // 
        if (is_array_default()(it)) {
          _this.view.filter(it[0], null);
        } else {
          _this.view.filter(index, null);
        }
      });

      each_default()(filter, function (it, index) {
        if (is_array_default()(it)) {
          _this.view.filter(it[0], it[1]);
        } else {
          _this.view.filter(index, it);
        }
      }); // visible 


      if (visible) {
        this.view.show();
      } else {
        this.view.hide();
      }

      this.config = _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, newConfig), {
        data: data
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.view) {
        this.view.destroy();
        this.view = null;
      }

      this.config = {};
    }
  }, {
    key: "processOptions",
    value: function processOptions(options) {
      var region = options.region,
          start = options.start,
          end = options.end,
          other = __rest(options, ["region", "start", "end"]);

      warning_default()(!start, 'start 5.0 region={{ start: {x:0,y:0}}} ');
      warning_default()(!end, 'end 5.0 region={{ end: {x:0,y:0}}} ');

      var regionCfg = deep_mix_default()({
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 1,
          y: 1
        }
      }, {
        start: start,
        end: end
      }, region);

      return _object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, other), {
        region: regionCfg
      });
    }
  }]);

  return ViewHelper;
}();


// CONCATENATED MODULE: ./src/components/View/index.tsx






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }





var View_View = /*#__PURE__*/function (_React$Component) {
  inherits_default()(View, _React$Component);

  var _super = _createSuper(View);

  function View() {
    var _this;

    classCallCheck_default()(this, View);

    _this = _super.apply(this, arguments);
    _this.name = 'view';
    return _this;
  }

  createClass_default()(View, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.viewHelper.destroy();
      this.viewHelper = null;
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.viewHelper) {
        this.viewHelper = new viewHelper_ViewHelper(this.context.chart);
      }

      this.viewHelper.update(this.props);
      return /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(view["a" /* default */].Provider, {
        value: this.viewHelper.view
      }, /*#__PURE__*/external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.createElement(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Fragment, null, this.props.children));
    }
  }]);

  return View;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_default.a.Component);
View_View.defaultProps = {
  visible: true,
  preInteractions: [],
  filter: []
};
View_View.contextType = root["a" /* default */];
/* harmony default export */ var components_View = __webpack_exports__["a"] = (View_View);

/***/ }),
/* 588 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Legend; });

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_ = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/chart/controller/legend.js
var legend = __webpack_require__(334);
var legend_default = /*#__PURE__*/__webpack_require__.n(legend);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./src/core.ts
var core = __webpack_require__(6);

// EXTERNAL MODULE: ./src/hooks/useChartView.tsx
var useChartView = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/list-highlight.js
var list_highlight = __webpack_require__(225);
var list_highlight_default = /*#__PURE__*/__webpack_require__.n(list_highlight);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/list-active.js
var list_active = __webpack_require__(349);
var list_active_default = /*#__PURE__*/__webpack_require__.n(list_active);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/list-unchecked.js
var list_unchecked = __webpack_require__(351);
var list_unchecked_default = /*#__PURE__*/__webpack_require__.n(list_unchecked);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/data/filter.js
var data_filter = __webpack_require__(353);
var filter_default = /*#__PURE__*/__webpack_require__.n(data_filter);

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/interaction/action/component/list-selected.js
var list_selected = __webpack_require__(350);
var list_selected_default = /*#__PURE__*/__webpack_require__.n(list_selected);

// CONCATENATED MODULE: ./src/components/Legend/actions.ts






Object(core["registerAction"])('list-active', list_active_default.a);
Object(core["registerAction"])('list-selected', list_selected_default.a);
Object(core["registerAction"])('list-highlight', list_highlight_default.a);
Object(core["registerAction"])('list-unchecked', list_unchecked_default.a); // 

Object(core["registerAction"])('data-filter', filter_default.a);
Object(core["registerAction"])('legend-item-highlight', list_highlight_default.a, {
  componentNames: ['legend']
});
Object(core["registerInteraction"])('legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['list-active:active', 'element-active:active']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['list-active:reset', 'element-active:reset']
  }]
}); // legend hoverelement active

Object(core["registerInteraction"])('legend-highlight', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: ['legend-item-highlight:highlight', 'element-highlight:highlight']
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: ['legend-item-highlight:reset', 'element-highlight:reset']
  }]
});
Object(core["registerInteraction"])('legend-filter', {
  showEnable: [{
    trigger: 'legend-item:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'legend-item:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'legend-item:click',
    action: 'list-unchecked:toggle'
  }, {
    trigger: 'legend-item:click',
    action: 'data-filter:filter'
  }]
});
// CONCATENATED MODULE: ./src/components/Legend/index.tsx
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};







Object(core["registerComponentController"])('legend', legend_default.a);

var undefinedField = function undefinedField(name) {
  return name === undefined;
}; // 


function Legend(props) {
  var name = props.name,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      onChange = props.onChange,
      filter = props.filter,
      options = __rest(props, ["name", "visible", "onChange", "filter"]);

  var view = Object(useChartView["a" /* default */])();

  if (undefinedField(name)) {
    // 
    if (visible) {
      view.legend(options);
    } else {
      view.legend(false);
    }
  } else {
    if (visible) {
      view.legend(name, options);
    } else {
      view.legend(name, false);
    }
  } // 


  if (is_function_default()(filter) && name) {
    view.filter(name, filter);
  } // didmount


  Object(external_root_React_commonjs2_react_commonjs_react_amd_react_umd_react_["useEffect"])(function () {
    // 
    view.on('legend:valuechanged', function (ev) {
      if (is_function_default()(props.onChange)) {
        props.onChange(ev, view);
      }
    }); // 

    view.on('legend-item:click', function (ev) {
      if (is_function_default()(props.onChange)) {
        var target = ev.target;
        var delegateObject = target.get('delegateObject');
        var item = delegateObject.item; // 

        ev.item = item; // 

        props.onChange(ev, view);
      }
    });
  }, []);
  return null;
}

/***/ }),
/* 589 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Axis; });

// EXTERNAL MODULE: ./node_modules/_@antv_g2@4.1.8@@antv/g2/lib/chart/controller/axis.js
var axis = __webpack_require__(333);
var axis_default = /*#__PURE__*/__webpack_require__.n(axis);

// EXTERNAL MODULE: ./src/hooks/useChartView.tsx
var useChartView = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/clone.js
var clone = __webpack_require__(596);
var clone_default = /*#__PURE__*/__webpack_require__.n(clone);

// CONCATENATED MODULE: ./src/utils/transBooleanCfg.ts
 // g2  xxCfg | null

/* harmony default export */ var transBooleanCfg = (function (cfg, keys) {
  var opt = clone_default()(cfg);

  keys.forEach(function (key) {
    if (opt[key] === true) {
      opt[key] = {};
    } else if (opt[key] === false) {
      opt[key] = null;
    }
  });
  return opt;
});
// EXTERNAL MODULE: ./src/core.ts
var core = __webpack_require__(6);

// CONCATENATED MODULE: ./src/components/Axis/index.tsx
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};





Object(core["registerComponentController"])('axis', axis_default.a);

var undefinedField = function undefinedField(name) {
  return name === undefined;
};

var Axis_mixinAxisCfg = function mixinAxisCfg(options) {
  // boolean  <Axis title /> 
  return transBooleanCfg(options, ['title', 'line', 'tickLine', 'subTickLine', 'label', 'grid']);
};

function Axis(props) {
  var name = props.name,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? true : _props$visible,
      options = __rest(props, ["name", "visible"]);

  var view = Object(useChartView["a" /* default */])();
  var newConfig = Axis_mixinAxisCfg(options); // warning(newConfig.grid !== null, 'fix g2 bug: Axis null ChartforceUpdate g2 ');

  if (visible) {
    if (undefinedField(name)) {
      // visible
      view.axis(true);
    } else {
      view.axis(name, newConfig);
    }
  } else {
    if (undefinedField(name)) {
      view.axis(false);
    } else {
      view.axis(name, false);
    }
  }

  return null;
}

/***/ }),
/* 590 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = exports.Shape = void 0;

var tslib_1 = __webpack_require__(1);

var Shape = __webpack_require__(189);

exports.Shape = Shape;

tslib_1.__exportStar(__webpack_require__(27), exports);

var canvas_1 = __webpack_require__(883);

Object.defineProperty(exports, "Canvas", {
  enumerable: true,
  get: function get() {
    return canvas_1.default;
  }
});

var group_1 = __webpack_require__(260);

Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return group_1.default;
  }
});
exports.version = '0.5.6';

/***/ }),
/* 591 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(978);
} else {}

/***/ }),
/* 592 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_array_1 = __webpack_require__(22);

var is_function_1 = __webpack_require__(26);

var hasOwnProperty = Object.prototype.hasOwnProperty;

function groupBy(data, condition) {
  if (!condition || !is_array_1.default(data)) {
    return {};
  }

  var result = {}; //  

  var predicate = is_function_1.default(condition) ? condition : function (item) {
    return item[condition];
  };
  var key;

  for (var i = 0; i < data.length; i++) {
    var item = data[i];
    key = predicate(item);

    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }

  return result;
}

exports.default = groupBy;

/***/ }),
/* 593 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 
 *
 * @param {Object} value 
 * @return {Boolean}
 */

var is_type_1 = __webpack_require__(117);

var isBoolean = function isBoolean(value) {
  return is_type_1.default(value, 'Boolean');
};

exports.default = isBoolean;

/***/ }),
/* 594 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__594__;

/***/ }),
/* 595 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }

  return dom;
}

exports.default = modifyCSS;

/***/ }),
/* 596 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_array_1 = __webpack_require__(22);

var clone = function clone(obj) {
  if ((0, _typeof2.default)(obj) !== 'object' || obj === null) {
    return obj;
  }

  var rst;

  if (is_array_1.default(obj)) {
    rst = [];

    for (var i = 0, l = obj.length; i < l; i++) {
      if ((0, _typeof2.default)(obj[i]) === 'object' && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};

    for (var k in obj) {
      if ((0, _typeof2.default)(obj[k]) === 'object' && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }

  return rst;
};

exports.default = clone;

/***/ }),
/* 597 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Progress = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(487);

var constant_1 = __webpack_require__(489);

var utils_1 = __webpack_require__(291);

var Progress =
/** @class */
function (_super) {
  tslib_1.__extends(Progress, _super);

  function Progress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'process';
    return _this;
  }

  Progress.prototype.getDefaultOptions = function () {
    return {
      percent: 0.2,
      color: constant_1.DEFAULT_COLOR,
      animation: true
    };
  };
  /**
   * 
   * @param percent
   */


  Progress.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.changeData(utils_1.getProgressData(percent));
  };
  /**
   *   
   */


  Progress.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Progress;
}(plot_1.Plot);

exports.Progress = Progress;

/***/ }),
/* 598 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingProgress = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(291);

var adaptor_1 = __webpack_require__(1014);

var RingProgress =
/** @class */
function (_super) {
  tslib_1.__extends(RingProgress, _super);

  function RingProgress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'ring-process';
    return _this;
  }

  RingProgress.prototype.getDefaultOptions = function () {
    return {
      percent: 0.2,
      innerRadius: 0.8,
      radius: 0.98,
      color: ['#FAAD14', '#E8EDF3'],
      statistic: {
        title: false,
        content: {
          style: {
            fontSize: '14px',
            fontWeight: 300,
            fill: '#4D4D4D',
            textAlign: 'center',
            textBaseline: 'middle'
          },
          formatter: function formatter(_a) {
            var percent = _a.percent;
            return (percent * 100).toFixed(2) + "%";
          }
        }
      },
      animation: true
    };
  };
  /**
   * 
   * @param percent
   */


  RingProgress.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.data(utils_1.getProgressData(percent)); // todo  G2  afterrender  annotations

    adaptor_1.statistic({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   *   
   */


  RingProgress.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return RingProgress;
}(plot_1.Plot);

exports.RingProgress = RingProgress;

/***/ }),
/* 599 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyColumn = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(118);

var adaptor_1 = __webpack_require__(1015);

var constants_1 = __webpack_require__(1016);

var TinyColumn =
/** @class */
function (_super) {
  tslib_1.__extends(TinyColumn, _super);

  function TinyColumn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-column';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyColumn.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(utils_1.getTinyData(data));
  };

  TinyColumn.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: tslib_1.__assign({}, constants_1.DEFAULT_TOOLTIP_OPTIONS),
      animation: true
    };
  };
  /**
   *   
   */


  TinyColumn.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return TinyColumn;
}(plot_1.Plot);

exports.TinyColumn = TinyColumn;

/***/ }),
/* 600 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyArea = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var constants_1 = __webpack_require__(152);

var utils_1 = __webpack_require__(118);

var adaptor_1 = __webpack_require__(1017);

var TinyArea =
/** @class */
function (_super) {
  tslib_1.__extends(TinyArea, _super);

  function TinyArea() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-area';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyArea.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(utils_1.getTinyData(data));
  };

  TinyArea.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: tslib_1.__assign({}, constants_1.DEFAULT_TOOLTIP_OPTIONS),
      // 
      color: 'l(90) 0:#E5EDFE 1:#ffffff',
      areaStyle: {
        fillOpacity: 0.6
      },
      line: {
        size: 1,
        color: '#5B8FF9'
      },
      animation: true
    };
  };
  /**
   *   
   */


  TinyArea.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return TinyArea;
}(plot_1.Plot);

exports.TinyArea = TinyArea;

/***/ }),
/* 601 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyLine = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1018);

var constants_1 = __webpack_require__(152);

var utils_1 = __webpack_require__(118);

var TinyLine =
/** @class */
function (_super) {
  tslib_1.__extends(TinyLine, _super);

  function TinyLine() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-line';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyLine.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(utils_1.getTinyData(data));
  };

  TinyLine.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: tslib_1.__assign({}, constants_1.DEFAULT_TOOLTIP_OPTIONS),
      animation: true
    };
  };
  /**
   *   
   */


  TinyLine.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return TinyLine;
}(plot_1.Plot);

exports.TinyLine = TinyLine;

/***/ }),
/* 602 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Treemap = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1021);

__webpack_require__(1047);

__webpack_require__(498);

var Treemap =
/** @class */
function (_super) {
  tslib_1.__extends(Treemap, _super);

  function Treemap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'treemap';
    return _this;
  }

  Treemap.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Treemap;
}(plot_1.Plot);

exports.Treemap = Treemap;

/***/ }),
/* 603 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WordCloud = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1061);

var utils_2 = __webpack_require__(504); // shape


__webpack_require__(1063);

var WordCloud =
/** @class */
function (_super) {
  tslib_1.__extends(WordCloud, _super);

  function WordCloud() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'word-cloud';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  WordCloud.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });

    if (this.options.imageMask) {
      this.render();
    } else {
      this.chart.changeData(utils_2.transform({
        chart: this.chart,
        options: this.options
      }));
    }
  };
  /**
   *  options 
   */


  WordCloud.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      timeInterval: 2000,
      legend: false,
      tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: false,
        fields: ['text', 'value', 'color'],
        formatter: function formatter(datum) {
          return {
            name: datum.text,
            value: datum.value
          };
        }
      },
      wordStyle: {
        fontFamily: 'Verdana',
        fontWeight: 'normal',
        padding: 1,
        fontSize: [12, 60],
        rotation: [0, 90],
        rotationSteps: 2,
        rotateRatio: 0.5
      }
    });
  };
  /**
   * 
   */


  WordCloud.prototype.render = function () {
    var _this = this;

    return new Promise(function (res) {
      var imageMask = _this.options.imageMask;

      if (!imageMask) {
        // 
        _super.prototype.render.call(_this);

        res();
        return;
      }

      var handler = function handler(img) {
        _this.options = tslib_1.__assign(tslib_1.__assign({}, _this.options), {
          imageMask: img || null
        }); // 

        _super.prototype.render.call(_this);

        res();
      };

      utils_2.processImageMask(imageMask).then(handler).catch(handler);
    });
  };
  /**
   *   
   */


  WordCloud.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  /**
   *   
   */


  WordCloud.prototype.triggerResize = function () {
    var _this = this;

    if (!this.chart.destroyed) {
      // 
      //  adaptor
      // 
      this.execAdaptor(); // 
      // TODO: 

      window.setTimeout(function () {
        // 
        _super.prototype.triggerResize.call(_this);
      });
    }
  };

  return WordCloud;
}(plot_1.Plot);

exports.WordCloud = WordCloud;

/***/ }),
/* 604 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Funnel = exports.FUNNEL_CONVERSATION_FIELD = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1065);

var constant_1 = __webpack_require__(119);

Object.defineProperty(exports, "FUNNEL_CONVERSATION_FIELD", {
  enumerable: true,
  get: function get() {
    return constant_1.FUNNEL_CONVERSATION;
  }
});

var Funnel =
/** @class */
function (_super) {
  tslib_1.__extends(Funnel, _super);

  function Funnel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'funnel';
    return _this;
  }
  /**
   *   
   */


  Funnel.prototype.getDefaultOptions = function () {
    //  defaultOption  core.getDefaultOptions funnel  defaulOption  adaptor  defaultOption 
    return {
      appendPadding: [0, 80]
    };
  };
  /**
   *   
   */


  Funnel.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Funnel;
}(plot_1.Plot);

exports.Funnel = Funnel;

/***/ }),
/* 605 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Radar = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1069);

__webpack_require__(1070);

var Radar =
/** @class */
function (_super) {
  tslib_1.__extends(Radar, _super);

  function Radar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'radar';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Radar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *   
   */


  Radar.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: {
        label: {
          offset: 15
        },
        grid: {
          line: {
            type: 'line'
          }
        }
      },
      yAxis: {
        grid: {
          line: {
            type: 'circle'
          }
        }
      },
      legend: {
        position: 'top'
      },
      tooltip: {
        shared: true,
        showCrosshairs: true,
        showMarkers: true,
        crosshairs: {
          type: 'xy',
          line: {
            style: {
              stroke: '#565656',
              lineDash: [4]
            }
          },
          follow: true
        }
      }
    });
  };
  /**
   *   
   */


  Radar.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Radar;
}(plot_1.Plot);

exports.Radar = Radar;

/***/ }),
/* 606 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Liquid = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1072);

var utils_1 = __webpack_require__(506); // register liquid shape


__webpack_require__(1073);
/**
 * 
 */


var Liquid =
/** @class */
function (_super) {
  tslib_1.__extends(Liquid, _super);

  function Liquid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'liquid';
    return _this;
  }

  Liquid.prototype.getDefaultOptions = function () {
    return {
      color: '#6a99f9',
      radius: 0.9,
      statistic: {
        title: false,
        content: {
          formatter: function formatter(_a) {
            var percent = _a.percent;
            return (percent * 100).toFixed(2) + "%";
          },
          style: {
            opacity: 0.75,
            fontSize: '30px',
            lineHeight: '30px',
            textAlign: 'center'
          }
        }
      },
      outline: {
        border: 2,
        distance: 0
      },
      wave: {
        count: 3,
        length: 192
      }
    };
  };
  /**
   * 
   * @param percent
   */


  Liquid.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.data(utils_1.getLiquidData(percent));
    adaptor_1.statistic({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   * 
   */


  Liquid.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Liquid;
}(plot_1.Plot);

exports.Liquid = Liquid;

/***/ }),
/* 607 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var histogram_1 = __webpack_require__(507);

var adaptor_1 = __webpack_require__(1074);

var Histogram =
/** @class */
function (_super) {
  tslib_1.__extends(Histogram, _super);

  function Histogram() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'histogram';
    return _this;
  }

  Histogram.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        binField = _a.binField,
        binNumber = _a.binNumber,
        binWidth = _a.binWidth,
        stackField = _a.stackField;
    this.chart.changeData(histogram_1.binHistogram(data, binField, binWidth, binNumber, stackField));
  };

  Histogram.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      // @ts-ignore
      columnStyle: {
        stroke: '#FFFFFF'
      },
      tooltip: {
        shared: true,
        showMarkers: false
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   * 
   */


  Histogram.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Histogram;
}(plot_1.Plot);

exports.Histogram = Histogram;

/***/ }),
/* 608 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Waterfall = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1075);

var utils_1 = __webpack_require__(509);
/**
 * 
 */


var Waterfall =
/** @class */
function (_super) {
  tslib_1.__extends(Waterfall, _super);

  function Waterfall() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'waterfall';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Waterfall.prototype.changeData = function (data) {
    var _a = this.options,
        xField = _a.xField,
        yField = _a.yField,
        total = _a.total;
    this.updateOption({
      data: data
    });
    this.chart.changeData(utils_1.transformData(data, xField, yField, total));
  };
  /**
   *   
   */


  Waterfall.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };
  /**
   *   
   */


  Waterfall.prototype.getDefaultOptions = function () {
    return {
      /** default: show label */
      label: {},

      /** default: show leaderLine */
      leaderLine: {
        style: {
          lineWidth: 1,
          stroke: '#8c8c8c',
          lineDash: [4, 2]
        }
      },

      /** default: show total */
      total: {
        label: '',
        style: {
          fill: 'rgba(0, 0, 0, 0.25)'
        }
      },
      interactions: [{
        type: 'element-active'
      }],
      risingFill: '#f4664a',
      fallingFill: '#30bf78',
      waterfallStyle: {
        fill: 'rgba(0, 0, 0, 0.25)'
      },
      yAxis: {
        grid: {
          line: {
            style: {
              lineDash: [4, 2]
            }
          }
        }
      }
    };
  };

  return Waterfall;
}(plot_1.Plot);

exports.Waterfall = Waterfall;

/***/ }),
/* 609 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bullet = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var utils_1 = __webpack_require__(16);

var adaptor_1 = __webpack_require__(1086);

var utils_2 = __webpack_require__(513);

var Bullet =
/** @class */
function (_super) {
  tslib_1.__extends(Bullet, _super);

  function Bullet() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'bullet';
    return _this;
  }

  Bullet.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });

    var _a = utils_2.transformData(this.options),
        min = _a.min,
        max = _a.max,
        ds = _a.ds; // scale


    adaptor_1.meta({
      options: this.options,
      ext: {
        data: {
          min: min,
          max: max
        }
      },
      chart: this.chart
    });
    this.chart.changeData(ds);
  };
  /**
   * 
   */


  Bullet.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  Bullet.prototype.getDefaultOptions = function () {
    return utils_1.deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      layout: 'horizontal',
      size: {
        range: 30,
        measure: 20,
        target: 20
      },
      xAxis: {
        tickLine: false,
        line: null
      },
      bulletStyle: {
        range: {
          fillOpacity: 0.5
        }
      },
      label: {
        measure: {
          position: 'right'
        }
      },
      tooltip: {
        // 
        showMarkers: false
      }
    });
  };

  return Bullet;
}(plot_1.Plot);

exports.Bullet = Bullet;

/***/ }),
/* 610 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true,
  adaptors: true,
  G2: true,
  Plot: true,
  Line: true,
  Area: true,
  Column: true,
  Bar: true,
  Pie: true,
  Rose: true,
  WordCloud: true,
  Scatter: true,
  Radar: true,
  DualAxes: true,
  TinyLine: true,
  TinyColumn: true,
  TinyArea: true,
  Histogram: true,
  Progress: true,
  RingProgress: true,
  Heatmap: true,
  Box: true,
  Stock: true,
  Funnel: true,
  FUNNEL_CONVERSATION_FIELD: true,
  Liquid: true,
  Bullet: true,
  Sunburst: true,
  Gauge: true,
  Waterfall: true,
  RadialBar: true,
  BidirectionalBar: true,
  Treemap: true,
  Sankey: true,
  Chord: true,
  P: true,
  MultiView: true,
  flow: true,
  measureTextWidth: true,
  line: true,
  interval: true,
  area: true,
  point: true,
  polygon: true,
  Lab: true
};
Object.defineProperty(exports, "Plot", {
  enumerable: true,
  get: function get() {
    return _plot.Plot;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.Line;
  }
});
Object.defineProperty(exports, "Area", {
  enumerable: true,
  get: function get() {
    return _area.Area;
  }
});
Object.defineProperty(exports, "Column", {
  enumerable: true,
  get: function get() {
    return _column.Column;
  }
});
Object.defineProperty(exports, "Bar", {
  enumerable: true,
  get: function get() {
    return _bar.Bar;
  }
});
Object.defineProperty(exports, "Pie", {
  enumerable: true,
  get: function get() {
    return _pie.Pie;
  }
});
Object.defineProperty(exports, "Rose", {
  enumerable: true,
  get: function get() {
    return _rose.Rose;
  }
});
Object.defineProperty(exports, "WordCloud", {
  enumerable: true,
  get: function get() {
    return _wordCloud.WordCloud;
  }
});
Object.defineProperty(exports, "Scatter", {
  enumerable: true,
  get: function get() {
    return _scatter.Scatter;
  }
});
Object.defineProperty(exports, "Radar", {
  enumerable: true,
  get: function get() {
    return _radar.Radar;
  }
});
Object.defineProperty(exports, "DualAxes", {
  enumerable: true,
  get: function get() {
    return _dualAxes.DualAxes;
  }
});
Object.defineProperty(exports, "TinyLine", {
  enumerable: true,
  get: function get() {
    return _tinyLine.TinyLine;
  }
});
Object.defineProperty(exports, "TinyColumn", {
  enumerable: true,
  get: function get() {
    return _tinyColumn.TinyColumn;
  }
});
Object.defineProperty(exports, "TinyArea", {
  enumerable: true,
  get: function get() {
    return _tinyArea.TinyArea;
  }
});
Object.defineProperty(exports, "Histogram", {
  enumerable: true,
  get: function get() {
    return _histogram.Histogram;
  }
});
Object.defineProperty(exports, "Progress", {
  enumerable: true,
  get: function get() {
    return _progress.Progress;
  }
});
Object.defineProperty(exports, "RingProgress", {
  enumerable: true,
  get: function get() {
    return _ringProgress.RingProgress;
  }
});
Object.defineProperty(exports, "Heatmap", {
  enumerable: true,
  get: function get() {
    return _heatmap.Heatmap;
  }
});
Object.defineProperty(exports, "Box", {
  enumerable: true,
  get: function get() {
    return _box.Box;
  }
});
Object.defineProperty(exports, "Stock", {
  enumerable: true,
  get: function get() {
    return _stock.Stock;
  }
});
Object.defineProperty(exports, "Funnel", {
  enumerable: true,
  get: function get() {
    return _funnel.Funnel;
  }
});
Object.defineProperty(exports, "FUNNEL_CONVERSATION_FIELD", {
  enumerable: true,
  get: function get() {
    return _funnel.FUNNEL_CONVERSATION_FIELD;
  }
});
Object.defineProperty(exports, "Liquid", {
  enumerable: true,
  get: function get() {
    return _liquid.Liquid;
  }
});
Object.defineProperty(exports, "Bullet", {
  enumerable: true,
  get: function get() {
    return _bullet.Bullet;
  }
});
Object.defineProperty(exports, "Sunburst", {
  enumerable: true,
  get: function get() {
    return _sunburst.Sunburst;
  }
});
Object.defineProperty(exports, "Gauge", {
  enumerable: true,
  get: function get() {
    return _gauge.Gauge;
  }
});
Object.defineProperty(exports, "Waterfall", {
  enumerable: true,
  get: function get() {
    return _waterfall.Waterfall;
  }
});
Object.defineProperty(exports, "RadialBar", {
  enumerable: true,
  get: function get() {
    return _radialBar.RadialBar;
  }
});
Object.defineProperty(exports, "BidirectionalBar", {
  enumerable: true,
  get: function get() {
    return _bidirectionalBar.BidirectionalBar;
  }
});
Object.defineProperty(exports, "Treemap", {
  enumerable: true,
  get: function get() {
    return _treemap.Treemap;
  }
});
Object.defineProperty(exports, "Sankey", {
  enumerable: true,
  get: function get() {
    return _sankey.Sankey;
  }
});
Object.defineProperty(exports, "Chord", {
  enumerable: true,
  get: function get() {
    return _chord.Chord;
  }
});
Object.defineProperty(exports, "P", {
  enumerable: true,
  get: function get() {
    return _plugin.P;
  }
});
Object.defineProperty(exports, "MultiView", {
  enumerable: true,
  get: function get() {
    return _multiView.MultiView;
  }
});
Object.defineProperty(exports, "flow", {
  enumerable: true,
  get: function get() {
    return _utils.flow;
  }
});
Object.defineProperty(exports, "measureTextWidth", {
  enumerable: true,
  get: function get() {
    return _utils.measureTextWidth;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return _geometries.line;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return _geometries.interval;
  }
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return _geometries.area;
  }
});
Object.defineProperty(exports, "point", {
  enumerable: true,
  get: function get() {
    return _geometries.point;
  }
});
Object.defineProperty(exports, "polygon", {
  enumerable: true,
  get: function get() {
    return _geometries.polygon;
  }
});
Object.defineProperty(exports, "Lab", {
  enumerable: true,
  get: function get() {
    return _lab.Lab;
  }
});
exports.G2 = exports.adaptors = exports.version = void 0;

var G2 = _interopRequireWildcard(__webpack_require__(17));

exports.G2 = G2;

var _plot = __webpack_require__(21);

var _types = __webpack_require__(1099);

Object.keys(_types).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _types[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _types[key];
    }
  });
});

var _line = __webpack_require__(1106);

var _area = __webpack_require__(1114);

var _column = __webpack_require__(1116);

var _bar = __webpack_require__(1119);

var _pie = __webpack_require__(1121);

var _rose = __webpack_require__(1126);

var _wordCloud = __webpack_require__(1128);

var _scatter = __webpack_require__(1132);

var _radar = __webpack_require__(1135);

var _dualAxes = __webpack_require__(1139);

var _tinyLine = __webpack_require__(1143);

var _tinyColumn = __webpack_require__(1145);

var _tinyArea = __webpack_require__(1148);

var _histogram = __webpack_require__(1150);

var _progress = __webpack_require__(1152);

var _ringProgress = __webpack_require__(1153);

var _heatmap = __webpack_require__(1155);

var _box = __webpack_require__(1159);

var _stock = __webpack_require__(1161);

var _funnel = __webpack_require__(1163);

var _liquid = __webpack_require__(1168);

var _bullet = __webpack_require__(1171);

var _sunburst = __webpack_require__(1173);

var _gauge = __webpack_require__(1177);

var _waterfall = __webpack_require__(1181);

var _radialBar = __webpack_require__(1184);

var _bidirectionalBar = __webpack_require__(1187);

var _treemap = __webpack_require__(1190);

var _sankey = __webpack_require__(1195);

var _chord = __webpack_require__(1268);

var _plugin = __webpack_require__(1272);

var _multiView = __webpack_require__(580);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _common = __webpack_require__(25);

var _lab = __webpack_require__(1274);

var version = '2.3.10'; // G2 

exports.version = version;
var adaptors = {
  scale: _common.scale,
  legend: _common.legend,
  tooltip: _common.tooltip,
  annotation: _common.annotation,
  interaction: _common.interaction,
  theme: _common.theme,
  animation: _common.animation
};
/**  Lab  export */

exports.adaptors = adaptors;

/***/ }),
/* 611 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gauge = void 0;

var tslib_1 = __webpack_require__(1);

var plot_1 = __webpack_require__(31);

var adaptor_1 = __webpack_require__(1275);

var constant_1 = __webpack_require__(194);

var utils_1 = __webpack_require__(581); //  shape


__webpack_require__(1276);

__webpack_require__(1277);
/**
 * 
 */


var Gauge =
/** @class */
function (_super) {
  tslib_1.__extends(Gauge, _super);

  function Gauge() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'gauge';
    return _this;
  }

  Gauge.prototype.getDefaultOptions = function () {
    var _a;

    return {
      percent: 0,
      range: {
        ticks: []
      },
      innerRadius: 0.9,
      radius: 0.95,
      startAngle: -7 / 6 * Math.PI,
      endAngle: 1 / 6 * Math.PI,
      syncViewPadding: true,
      axis: {
        line: null,
        label: {
          offset: -24,
          style: {
            textAlign: 'center',
            textBaseline: 'middle'
          }
        },
        subTickLine: {
          length: -8
        },
        tickLine: {
          length: -12
        },
        grid: null
      },
      indicator: {
        pointer: {
          style: {
            lineWidth: 5,
            lineCap: 'round'
          }
        },
        pin: {
          style: {
            r: 9.75,
            lineWidth: 4.5,
            fill: '#fff'
          }
        }
      },
      statistic: {
        title: false
      },
      meta: (_a = {}, //  view  scale  v 
      _a[constant_1.RANGE_VALUE] = {
        sync: 'v'
      }, _a[constant_1.PERCENT] = {
        sync: 'v',
        tickCount: 5,
        tickInterval: 0.2
      }, _a),
      animation: false
    };
  };
  /**
   * 
   * @param percent
   */


  Gauge.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    var indicatorView = this.chart.views.find(function (v) {
      return v.id === constant_1.INDICATEOR_VIEW_ID;
    });

    if (indicatorView) {
      indicatorView.data(utils_1.getIndicatorData(percent));
    }

    var rangeView = this.chart.views.find(function (v) {
      return v.id === constant_1.RANGE_VIEW_ID;
    });

    if (rangeView) {
      rangeView.data(utils_1.getRangeData(percent, this.options.range));
    } // todo  G2  afterrender  annotations


    adaptor_1.statistic({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   * 
   */


  Gauge.prototype.getSchemaAdaptor = function () {
    return adaptor_1.adaptor;
  };

  return Gauge;
}(plot_1.Plot);

exports.Gauge = Gauge;

/***/ }),
/* 612 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "fold", function() { return /* reexport */ fold; });
__webpack_require__.d(__webpack_exports__, "percentage", function() { return /* reexport */ percentage; });
__webpack_require__.d(__webpack_exports__, "minifyNum", function() { return /* reexport */ minifyNum; });
__webpack_require__.d(__webpack_exports__, "splitBySeparator", function() { return /* reexport */ splitBySeparator; });
__webpack_require__.d(__webpack_exports__, "visibleHelper", function() { return /* reexport */ plotTools["a" /* visibleHelper */]; });
__webpack_require__.d(__webpack_exports__, "cloneDeep", function() { return /* reexport */ cloneDeep["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "shallowEqual", function() { return /* reexport */ shallowEqual["a" /* default */]; });

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/defineProperty.js
var defineProperty = __webpack_require__(227);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);

// EXTERNAL MODULE: ./node_modules/_object.assign@4.1.2@object.assign/index.js
var _object_assign_4_1_2_object_assign = __webpack_require__(5);
var _object_assign_4_1_2_object_assign_default = /*#__PURE__*/__webpack_require__.n(_object_assign_4_1_2_object_assign);

// CONCATENATED MODULE: ./src/utils/data-transform/fold.ts


// 

/**
 * 
 * @param data 
 * @param fields 
 * @param foldCate 
 * @param foldValue 
 */
/* harmony default export */ var fold = (function (data, fields, foldCate, foldValue) {
  var resultRows = [];
  data.forEach(function (row) {
    fields.forEach(function (field) {
      var _default2;

      resultRows.push(_object_assign_4_1_2_object_assign_default()(_object_assign_4_1_2_object_assign_default()({}, row), (_default2 = {}, defineProperty_default()(_default2, foldCate, field), defineProperty_default()(_default2, foldValue, row[field]), _default2)));
    });
  });
  return resultRows;
});
// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/for-in.js
var for_in = __webpack_require__(74);
var for_in_default = /*#__PURE__*/__webpack_require__.n(for_in);

// EXTERNAL MODULE: ./src/utils/data-transform/sum.ts
var sum = __webpack_require__(228);

// EXTERNAL MODULE: ./node_modules/_warning@4.0.3@warning/warning.js
var warning = __webpack_require__(13);
var warning_default = /*#__PURE__*/__webpack_require__.n(warning);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-array.js
var is_array = __webpack_require__(22);
var is_array_default = /*#__PURE__*/__webpack_require__.n(is_array);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-function.js
var is_function = __webpack_require__(26);
var is_function_default = /*#__PURE__*/__webpack_require__.n(is_function);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/is-string.js
var is_string = __webpack_require__(50);
var is_string_default = /*#__PURE__*/__webpack_require__.n(is_string);

// EXTERNAL MODULE: ./node_modules/_@antv_util@2.0.10@@antv/util/lib/group-by.js
var lib_group_by = __webpack_require__(592);
var group_by_default = /*#__PURE__*/__webpack_require__.n(lib_group_by);

// CONCATENATED MODULE: ./src/utils/data-transform/simple-sort-by.ts
// from g2-dataSte



function sortBy(arr) {
  var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var comparer;

  if (is_function_default()(keys)) {
    comparer = keys;
  } else if (is_array_default()(keys)) {
    comparer = function comparer(a, b) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (a[key] < b[key]) {
          return -1;
        }

        if (a[key] > b[key]) {
          return 1;
        }
      }

      return 0;
    };
  } else if (is_string_default()(keys)) {
    comparer = function comparer(a, b) {
      if (a[keys] < b[keys]) {
        return -1;
      }

      if (a[keys] > b[keys]) {
        return 1;
      }

      return 0;
    };
  }

  return arr.sort(comparer);
}
// CONCATENATED MODULE: ./src/utils/data-transform/partition.ts
// from g2-dataSte





/** 
 * @param {any[]} rows
 * @param {(string | string[] | ((item: any) => string))} group_by
 * @param {(string | string[] | ((item: any) => number))} [order_by=[]]
 * @returns {Record<string, any[]>}
 */

function partition(rows, group_by) {
  var order_by = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var newRows = rows;

  if (order_by && order_by.length) {
    newRows = sortBy(rows, order_by);
  }

  var groupingFn;

  if (is_function_default()(group_by)) {
    groupingFn = group_by;
  } else if (is_array_default()(group_by)) {
    groupingFn = function groupingFn(row) {
      return "_".concat(group_by.map(function (col) {
        return row[col];
      }).join('-'));
    }; // NOTE: Object.keys({'b': 'b', '2': '2', '1': '1', 'a': 'a'}) => [ '1', '2', 'b', 'a' ]
    // that is why we have to add a prefix

  } else if (is_string_default()(group_by)) {
    groupingFn = function groupingFn(row) {
      return "_".concat(row[group_by]);
    };
  }

  var groups = group_by_default()(newRows, groupingFn);
  return groups;
}

;
/* harmony default export */ var data_transform_partition = (partition);
// CONCATENATED MODULE: ./src/utils/data-transform/percentage.ts

// 




/**
 * , 
 * @param data object[] 
 * @param field string 
 * @param as string 
 * @param groupBy : string | string[] 
 */

/* harmony default export */ var percentage = (function (data, field, as, groupBy) {
  var result = [];
  var groups = groupBy ? data_transform_partition(data, groupBy) : {
    _data: data
  };

  for_in_default()(groups, function (group) {
    var totalSum = Object(sum["a" /* default */])(group.map(function (row) {
      return row[field];
    }));
    warning_default()(totalSum !== 0, "Invalid data: total sum of field ".concat(field, " is 0!"));

    for_in_default()(group, function (item) {
      var resultRow = _object_assign_4_1_2_object_assign_default()({}, item);

      if (totalSum === 0) {
        resultRow[as] = 0;
      } else {
        resultRow[as] = item[field] / totalSum;
      }

      result.push(resultRow);
    });
  });

  return result;
});
// CONCATENATED MODULE: ./src/utils/data-transform/minifyNum.ts
/* harmony default export */ var minifyNum = (function (num) {
  var decimal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  var wan = 10000;
  var yi = 100000000;

  if (num >= yi) {
    return "".concat((num / yi).toFixed(decimal).replace(/\.?0*$/, ''), "\u4EBF");
  }

  if (num >= wan) {
    return "".concat((num / wan).toFixed(decimal).replace(/\.?0*$/, ''), "\u4E07");
  }

  return num.toFixed(decimal).replace(/\.?0*$/, '');
});
// CONCATENATED MODULE: ./src/utils/data-transform/splitBySeparator.ts
/* harmony default export */ var splitBySeparator = (function (num) {
  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ',';

  if (typeof num === 'number') {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, separator);
  }

  return num;
});
// EXTERNAL MODULE: ./src/utils/plotTools.ts
var plotTools = __webpack_require__(170);

// EXTERNAL MODULE: ./src/utils/cloneDeep.ts
var cloneDeep = __webpack_require__(80);

// EXTERNAL MODULE: ./src/utils/shallowEqual.ts
var shallowEqual = __webpack_require__(81);

// CONCATENATED MODULE: ./src/utils/index.ts
// 



 // 

 // 




/***/ }),
/* 613 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(614);


/***/ }),
/* 614 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return Util; });
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(object_assign__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_util__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Annotation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(584);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Annotation", function() { return _components_Annotation__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _g2_all__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(314);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "G2", function() { return _g2_all__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _g_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(583);
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "GComponents", function() { return _g_components__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(612);
/* harmony import */ var _components_Chart__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(586);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Chart", function() { return _components_Chart__WEBPACK_IMPORTED_MODULE_6__["a"]; });

/* harmony import */ var _components_View__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(587);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "View", function() { return _components_View__WEBPACK_IMPORTED_MODULE_7__["a"]; });

/* harmony import */ var _components_Tooltip__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(585);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return _components_Tooltip__WEBPACK_IMPORTED_MODULE_8__["a"]; });

/* harmony import */ var _components_Legend__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(588);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Legend", function() { return _components_Legend__WEBPACK_IMPORTED_MODULE_9__["a"]; });

/* harmony import */ var _components_Coordinate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(213);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Coordinate", function() { return _components_Coordinate__WEBPACK_IMPORTED_MODULE_10__["a"]; });

/* harmony import */ var _components_Axis__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(589);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Axis", function() { return _components_Axis__WEBPACK_IMPORTED_MODULE_11__["a"]; });

/* harmony import */ var _components_Facet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(472);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Facet", function() { return _components_Facet__WEBPACK_IMPORTED_MODULE_12__["a"]; });

/* harmony import */ var _components_Slider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(473);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Slider", function() { return _components_Slider__WEBPACK_IMPORTED_MODULE_13__["a"]; });

/* harmony import */ var _geometry_Area__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(128);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Area", function() { return _geometry_Area__WEBPACK_IMPORTED_MODULE_14__["a"]; });

/* harmony import */ var _geometry_Edge__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(214);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Edge", function() { return _geometry_Edge__WEBPACK_IMPORTED_MODULE_15__["a"]; });

/* harmony import */ var _geometry_Heatmap__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(215);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Heatmap", function() { return _geometry_Heatmap__WEBPACK_IMPORTED_MODULE_16__["a"]; });

/* harmony import */ var _geometry_Interval__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(216);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interval", function() { return _geometry_Interval__WEBPACK_IMPORTED_MODULE_17__["a"]; });

/* harmony import */ var _geometry_Line__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(129);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return _geometry_Line__WEBPACK_IMPORTED_MODULE_18__["a"]; });

/* harmony import */ var _geometry_Point__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(130);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Point", function() { return _geometry_Point__WEBPACK_IMPORTED_MODULE_19__["a"]; });

/* harmony import */ var _geometry_Polygon__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(217);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Polygon", function() { return _geometry_Polygon__WEBPACK_IMPORTED_MODULE_20__["a"]; });

/* harmony import */ var _geometry_Schema__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(475);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Schema", function() { return _geometry_Schema__WEBPACK_IMPORTED_MODULE_21__["a"]; });

/* harmony import */ var _geometry_Base__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(37);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseGeom", function() { return _geometry_Base__WEBPACK_IMPORTED_MODULE_22__["a"]; });

/* harmony import */ var _geometry_Label__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(289);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return _geometry_Label__WEBPACK_IMPORTED_MODULE_23__["a"]; });

/* harmony import */ var _geometry_Path__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(476);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return _geometry_Path__WEBPACK_IMPORTED_MODULE_24__["a"]; });

/* harmony import */ var _geometry_LineAdvance__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(218);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineAdvance", function() { return _geometry_LineAdvance__WEBPACK_IMPORTED_MODULE_25__["a"]; });

/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(477);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Geom", function() { return _geometry__WEBPACK_IMPORTED_MODULE_26__["a"]; });

/* harmony import */ var _components_Coordinate_coord__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(478);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Coord", function() { return _components_Coordinate_coord__WEBPACK_IMPORTED_MODULE_27__["a"]; });

/* harmony import */ var _adapter_Guide__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(479);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Guide", function() { return _adapter_Guide__WEBPACK_IMPORTED_MODULE_28__["a"]; });

/* harmony import */ var _components_Effects__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(480);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Effects", function() { return _components_Effects__WEBPACK_IMPORTED_MODULE_29__["a"]; });

/* harmony import */ var _components_Interaction__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(481);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interaction", function() { return _components_Interaction__WEBPACK_IMPORTED_MODULE_30__["a"]; });

/* harmony import */ var _createPlot__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(10);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPlot", function() { return _createPlot__WEBPACK_IMPORTED_MODULE_31__["a"]; });

/* harmony import */ var _connector_createTooltipConnector__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(171);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createTooltipConnector", function() { return _connector_createTooltipConnector__WEBPACK_IMPORTED_MODULE_32__["a"]; });

/* harmony import */ var _hooks_useChartView__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(42);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useView", function() { return _hooks_useChartView__WEBPACK_IMPORTED_MODULE_33__["a"]; });

/* harmony import */ var _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(126);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRootChart", function() { return _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_34__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useChartInstance", function() { return _hooks_useChartInstance__WEBPACK_IMPORTED_MODULE_34__["a"]; });

/* harmony import */ var _hooks_useTheme__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(482);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useTheme", function() { return _hooks_useTheme__WEBPACK_IMPORTED_MODULE_35__["a"]; });

/* harmony import */ var _context_view__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(49);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withView", function() { return _context_view__WEBPACK_IMPORTED_MODULE_36__["b"]; });

/* harmony import */ var _context_root__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(73);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withChartInstance", function() { return _context_root__WEBPACK_IMPORTED_MODULE_37__["b"]; });

/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(6);
/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _core__WEBPACK_IMPORTED_MODULE_38__) if(["default","Util","Annotation","G2","GComponents","Chart","View","Tooltip","Legend","Coordinate","Axis","Facet","Slider","Area","Edge","Heatmap","Interval","Line","Point","Polygon","Schema","BaseGeom","Label","Path","LineAdvance","Geom","Coord","Guide","Effects","Interaction","createPlot","createTooltipConnector","useView","useRootChart","useChartInstance","useTheme","withView","withChartInstance"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _core__WEBPACK_IMPORTED_MODULE_38__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var _plots__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(582);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgressChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["w"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RingProgressChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["A"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["J"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyAreaChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["I"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TinyLineChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["K"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["p"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TreemapChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["L"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StepLineChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["H"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["b"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StackedBarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["E"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupedBarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["k"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PercentStackedBarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["s"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RangeBarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["y"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AreaChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["a"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StackedAreaChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PercentStackedAreaChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["r"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["f"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupedColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["l"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StackedColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["F"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RangeColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["z"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PercentStackedColumnChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["t"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PieChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["u"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DensityHeatmapChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["g"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HeatmapChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["n"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WordCloudChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["N"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RoseChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["B"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunnelChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["i"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StackedRoseChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["G"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupedRoseChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["m"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["x"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LiquidChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["q"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HistogramChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["o"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DonutChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["h"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WaterfallChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["M"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScatterChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["C"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BubbleChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["c"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BulletChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["d"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CalendarChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["e"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GaugeChart", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["j"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlotAdapter", function() { return _plots__WEBPACK_IMPORTED_MODULE_39__["v"]; });







var Util = object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()(object_assign__WEBPACK_IMPORTED_MODULE_0___default()({}, _antv_util__WEBPACK_IMPORTED_MODULE_1__), _utils__WEBPACK_IMPORTED_MODULE_5__), _g2_all__WEBPACK_IMPORTED_MODULE_3__["Util"]); // 









 // geometry












 //  geometry

 // 


 // 




 // hooks

 // fixme: 5.0 useChartInstance

 // 




 // 

 //  g2-plots 

 // g-components

/***/ }),
/* 615 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var keysShim;

if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArgs = __webpack_require__(356); // eslint-disable-line global-require


  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };

  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };

  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }

    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && (0, _typeof2.default)(window[k]) === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }

    return false;
  }();

  var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }

    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };

  keysShim = function keys(object) {
    var isObject = object !== null && (0, _typeof2.default)(object) === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];

    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }

    var skipProto = hasProtoEnumBug && isFunction;

    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }

    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }

    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }

    return theKeys;
  };
}

module.exports = keysShim;

/***/ }),
/* 616 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

/***/ }),
/* 617 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var origSymbol = global.Symbol;

var hasSymbolSham = __webpack_require__(360);

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if ((0, _typeof2.default)(origSymbol('foo')) !== 'symbol') {
    return false;
  }

  if ((0, _typeof2.default)(Symbol('bar')) !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(359)))

/***/ }),
/* 618 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(235);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

/***/ }),
/* 619 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(358);

var callBind = __webpack_require__(357);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

/***/ }),
/* 620 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(354);

var getPolyfill = __webpack_require__(362);

module.exports = function shimAssign() {
  var polyfill = getPolyfill();
  define(Object, {
    assign: polyfill
  }, {
    assign: function assign() {
      return Object.assign !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 621 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _filter = _interopRequireDefault(__webpack_require__(363));

var _contains = _interopRequireDefault(__webpack_require__(174));

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to inspect.
 * @param {Array} values The values to exclude.
 * @return {Array} Returns the new array of filtered values.
 * @example
 * difference([2, 1], [2, 3]);  // => [1]
 */
var difference = function difference(arr, values) {
  if (values === void 0) {
    values = [];
  }

  return (0, _filter.default)(arr, function (value) {
    return !(0, _contains.default)(values, value);
  });
};

var _default = difference;
exports.default = _default;

/***/ }),
/* 622 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var _isMatch = _interopRequireDefault(__webpack_require__(364));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isPlainObject = _interopRequireDefault(__webpack_require__(137));

function find(arr, predicate) {
  if (!(0, _isArray.default)(arr)) return null;

  var _predicate;

  if ((0, _isFunction.default)(predicate)) {
    _predicate = predicate;
  }

  if ((0, _isPlainObject.default)(predicate)) {
    _predicate = function _predicate(a) {
      return (0, _isMatch.default)(a, predicate);
    };
  }

  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }

  return null;
}

var _default = find;
exports.default = _default;

/***/ }),
/* 623 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }

  for (var i = fromIndex; i < arr.length; i++) {
    if (predicate(arr[i], i)) {
      // 
      return i;
    }
  }

  return -1;
}

var _default = findIndex;
exports.default = _default;

/***/ }),
/* 624 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var firstValue = function firstValue(data, name) {
  var rst = null;

  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];

    if (!(0, _isNil.default)(value)) {
      if ((0, _isArray.default)(value)) {
        rst = value[0]; // todo  firstValue @
      } else {
        rst = value;
      }

      break;
    }
  }

  return rst;
};

var _default = firstValue;
exports.default = _default;

/***/ }),
/* 625 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]
 */
var flatten = function flatten(arr) {
  if (!(0, _isArray.default)(arr)) {
    return [];
  }

  var rst = [];

  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }

  return rst;
};

var _default = flatten;
exports.default = _default;

/***/ }),
/* 626 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

/**
 * Flattens `array` a single level deep.
 *
 * @param {Array} arr The array to flatten.
 * @param {Array} result The array to return.
 * @return {Array} Returns the new flattened array.
 * @example
 *
 * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]
 */
var flattenDeep = function flattenDeep(arr, result) {
  if (result === void 0) {
    result = [];
  }

  if (!(0, _isArray.default)(arr)) {
    result.push(arr);
  } else {
    for (var i = 0; i < arr.length; i += 1) {
      flattenDeep(arr[i], result);
    }
  }

  return result;
};

var _default = flattenDeep;
exports.default = _default;

/***/ }),
/* 627 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var getRange = function getRange(values) {
  //  NaN min,max 
  var filterValues = values.filter(function (v) {
    return !isNaN(v);
  });

  if (!filterValues.length) {
    // 0
    return {
      min: 0,
      max: 0
    };
  }

  if ((0, _isArray.default)(values[0])) {
    var tmp = [];

    for (var i = 0; i < values.length; i++) {
      tmp = tmp.concat(values[i]);
    }

    filterValues = tmp;
  }

  var max = Math.max.apply(null, filterValues);
  var min = Math.min.apply(null, filterValues);
  return {
    min: min,
    max: max
  };
};

var _default = getRange;
exports.default = _default;

/***/ }),
/* 628 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var arrPrototype = Array.prototype;
var splice = arrPrototype.splice;
var indexOf = arrPrototype.indexOf;

var pull = function pull(arr) {
  var values = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    values[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var fromIndex = -1;

    while ((fromIndex = indexOf.call(arr, value)) > -1) {
      splice.call(arr, fromIndex, 1);
    }
  }

  return arr;
};

var _default = pull;
exports.default = _default;

/***/ }),
/* 629 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isPlainObject = _interopRequireDefault(__webpack_require__(137));

var reduce = function reduce(arr, fn, init) {
  if (!(0, _isArray.default)(arr) && !(0, _isPlainObject.default)(arr)) {
    return arr;
  }

  var result = init;
  (0, _each.default)(arr, function (data, i) {
    result = fn(result, data, i);
  });
  return result;
};

var _default = reduce;
exports.default = _default;

/***/ }),
/* 630 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var _pullAt = _interopRequireDefault(__webpack_require__(366));

var remove = function remove(arr, predicate) {
  /**
   * const arr = [1, 2, 3, 4]
   * const evens = remove(arr, n => n % 2 == 0)
   * console.log(arr) // => [1, 3]
   * console.log(evens) // => [2, 4]
   */
  var result = [];

  if (!(0, _isArrayLike.default)(arr)) {
    return result;
  }

  var i = -1;
  var indexes = [];
  var length = arr.length;

  while (++i < length) {
    var value = arr[i];

    if (predicate(value, i, arr)) {
      result.push(value);
      indexes.push(i);
    }
  }

  (0, _pullAt.default)(arr, indexes);
  return result;
};

var _default = remove;
exports.default = _default;

/***/ }),
/* 631 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isString = _interopRequireDefault(__webpack_require__(101));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

function sortBy(arr, key) {
  var comparer;

  if ((0, _isFunction.default)(key)) {
    comparer = function comparer(a, b) {
      return key(a) - key(b);
    };
  } else {
    var keys_1 = [];

    if ((0, _isString.default)(key)) {
      keys_1.push(key);
    } else if ((0, _isArray.default)(key)) {
      keys_1 = key;
    }

    comparer = function comparer(a, b) {
      for (var i = 0; i < keys_1.length; i += 1) {
        var prop = keys_1[i];

        if (a[prop] > b[prop]) {
          return 1;
        }

        if (a[prop] < b[prop]) {
          return -1;
        }
      }

      return 0;
    };
  }

  arr.sort(comparer);
  return arr;
}

var _default = sortBy;
exports.default = _default;

/***/ }),
/* 632 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _uniq = _interopRequireDefault(__webpack_require__(367));

var union = function union() {
  var sources = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }

  return (0, _uniq.default)([].concat.apply([], sources));
};

var _default = union;
exports.default = _default;

/***/ }),
/* 633 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _default = function _default(data, name) {
  var rst = [];
  var tmpMap = {};

  for (var i = 0; i < data.length; i++) {
    var obj = data[i];
    var value = obj[name];

    if (!(0, _isNil.default)(value)) {
      // flatten
      if (!(0, _isArray.default)(value)) {
        value = [value];
      }

      for (var j = 0; j < value.length; j++) {
        var val = value[j]; // unique

        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }

  return rst;
};

exports.default = _default;

/***/ }),
/* 634 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = head;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

function head(o) {
  if ((0, _isArrayLike.default)(o)) {
    return o[0];
  }

  return undefined;
}

/***/ }),
/* 635 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = last;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

function last(o) {
  if ((0, _isArrayLike.default)(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }

  return undefined;
}

/***/ }),
/* 636 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isString = _interopRequireDefault(__webpack_require__(101));

function startsWith(arr, e) {
  return (0, _isArray.default)(arr) || (0, _isString.default)(arr) ? arr[0] === e : false;
}

var _default = startsWith;
exports.default = _default;

/***/ }),
/* 637 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isString = _interopRequireDefault(__webpack_require__(101));

function endsWith(arr, e) {
  return (0, _isArray.default)(arr) || (0, _isString.default)(arr) ? arr[arr.length - 1] === e : false;
}

var _default = endsWith;
exports.default = _default;

/***/ }),
/* 638 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 *  false
 * @param arr
 * @param func
 */
var every = function every(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (!func(arr[i], i)) return false;
  }

  return true;
};

var _default = every;
exports.default = _default;

/***/ }),
/* 639 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 *  true
 * @param arr
 * @param func
 */
var some = function some(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i], i)) return true;
  }

  return false;
};

var _default = some;
exports.default = _default;

/***/ }),
/* 640 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _groupToMap = _interopRequireDefault(__webpack_require__(368));

var _default = function _default(data, condition) {
  if (!condition) {
    // 
    return [data];
  }

  var groups = (0, _groupToMap.default)(data, condition);
  var array = [];

  for (var i in groups) {
    array.push(groups[i]);
  }

  return array;
};

exports.default = _default;

/***/ }),
/* 641 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * 
 * @protected
 * @param  {Object} obj   
 * @param  {String} action 
 * @return {Function}        
 */
function getWrapBehavior(obj, action) {
  return obj['_wrap_' + action];
}

var _default = getWrapBehavior;
exports.default = _default;

/***/ }),
/* 642 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * this,
 * @protected
 * @param  {Object} obj   
 * @param  {String} action 
 * @return {Function}        
 */
function wrapBehavior(obj, action) {
  if (obj['_wrap_' + action]) {
    return obj['_wrap_' + action];
  }

  var method = function method(e) {
    obj[action](e);
  };

  obj['_wrap_' + action] = method;
  return method;
}

var _default = wrapBehavior;
exports.default = _default;

/***/ }),
/* 643 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var numColorCache = {};

function numberToColor(num) {
  // 
  var color = numColorCache[num];

  if (!color) {
    var str = num.toString(16);

    for (var i = str.length; i < 6; i++) {
      str = '0' + str;
    }

    color = '#' + str;
    numColorCache[num] = color;
  }

  return color;
}

var _default = numberToColor;
exports.default = _default;

/***/ }),
/* 644 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

function parseRadius(radius) {
  var r1 = 0,
      r2 = 0,
      r3 = 0,
      r4 = 0;

  if ((0, _isArray.default)(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }

  return {
    r1: r1,
    r2: r2,
    r3: r3,
    r4: r4
  };
}

var _default = parseRadius;
exports.default = _default;

/***/ }),
/* 645 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var clamp = function clamp(a, min, max) {
  if (a < min) {
    return min;
  } else if (a > max) {
    return max;
  }

  return a;
};

var _default = clamp;
exports.default = _default;

/***/ }),
/* 646 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var fixedBase = function fixedBase(v, base) {
  var str = base.toString();
  var index = str.indexOf('.');

  if (index === -1) {
    return Math.round(v);
  }

  var length = str.substr(index + 1).length;

  if (length > 20) {
    length = 20;
  }

  return parseFloat(v.toFixed(length));
};

var _default = fixedBase;
exports.default = _default;

/***/ }),
/* 647 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isDecimal = function isDecimal(num) {
  return (0, _isNumber.default)(num) && num % 1 !== 0;
};

var _default = isDecimal;
exports.default = _default;

/***/ }),
/* 648 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isEven = function isEven(num) {
  return (0, _isNumber.default)(num) && num % 2 === 0;
};

var _default = isEven;
exports.default = _default;

/***/ }),
/* 649 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isInteger = Number.isInteger ? Number.isInteger : function (num) {
  return (0, _isNumber.default)(num) && num % 1 === 0;
};
var _default = isInteger;
exports.default = _default;

/***/ }),
/* 650 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isNegative = function isNegative(num) {
  return (0, _isNumber.default)(num) && num < 0;
};

var _default = isNegative;
exports.default = _default;

/***/ }),
/* 651 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isNumberEqual;
var PRECISION = 0.00001; // numbers less than this is considered as 0

function isNumberEqual(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }

  return Math.abs(a - b) < precision;
}

;

/***/ }),
/* 652 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isOdd = function isOdd(num) {
  return (0, _isNumber.default)(num) && num % 2 !== 0;
};

var _default = isOdd;
exports.default = _default;

/***/ }),
/* 653 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

var isPositive = function isPositive(num) {
  return (0, _isNumber.default)(num) && num > 0;
};

var _default = isPositive;
exports.default = _default;

/***/ }),
/* 654 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the maximum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * maxBy(objects, function(o) { return o.n; });
 * // => { 'n': 2 }
 *
 * maxBy(objects, 'n');
 * // => { 'n': 2 }
 */
var _default = function _default(arr, fn) {
  if (!(0, _isArray.default)(arr)) {
    return undefined;
  }

  var max = arr[0];
  var maxData;

  if ((0, _isFunction.default)(fn)) {
    maxData = fn(arr[0]);
  } else {
    maxData = arr[0][fn];
  }

  var data;
  (0, _each.default)(arr, function (val) {
    if ((0, _isFunction.default)(fn)) {
      data = fn(val);
    } else {
      data = val[fn];
    }

    if (data > maxData) {
      max = val;
      maxData = data;
    }
  });
  return max;
};

exports.default = _default;

/***/ }),
/* 655 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

/**
 * @param {Array} arr The array to iterate over.
 * @param {Function} [fn] The iteratee invoked per element.
 * @return {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * minBy(objects, 'n');
 * // => { 'n': 1 }
 */
var _default = function _default(arr, fn) {
  if (!(0, _isArray.default)(arr)) {
    return undefined;
  }

  var min = arr[0];
  var minData;

  if ((0, _isFunction.default)(fn)) {
    minData = fn(arr[0]);
  } else {
    minData = arr[0][fn];
  }

  var data;
  (0, _each.default)(arr, function (val) {
    if ((0, _isFunction.default)(fn)) {
      data = fn(val);
    } else {
      data = val[fn];
    }

    if (data < minData) {
      min = val;
      minData = data;
    }
  });
  return min;
};

exports.default = _default;

/***/ }),
/* 656 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var mod = function mod(n, m) {
  return (n % m + m) % m;
};

var _default = mod;
exports.default = _default;

/***/ }),
/* 657 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var DEGREE = 180 / Math.PI;

var toDegree = function toDegree(radian) {
  return DEGREE * radian;
};

var _default = toDegree;
exports.default = _default;

/***/ }),
/* 658 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = parseInt;
exports.default = _default;

/***/ }),
/* 659 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var RADIAN = Math.PI / 180;

var toRadian = function toRadian(degree) {
  return RADIAN * degree;
};

var _default = toRadian;
exports.default = _default;

/***/ }),
/* 660 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _default = _each.default;
exports.default = _default;

/***/ }),
/* 661 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _has = _interopRequireDefault(__webpack_require__(370));

var _default = _has.default;
exports.default = _default;

/***/ }),
/* 662 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _contains = _interopRequireDefault(__webpack_require__(174));

var _values = _interopRequireDefault(__webpack_require__(371));

var _default = function _default(obj, value) {
  return (0, _contains.default)((0, _values.default)(obj), value);
};

exports.default = _default;

/***/ }),
/* 663 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toString = _interopRequireDefault(__webpack_require__(138));

var lowerCase = function lowerCase(str) {
  return (0, _toString.default)(str).toLowerCase();
};

var _default = lowerCase;
exports.default = _default;

/***/ }),
/* 664 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toString = _interopRequireDefault(__webpack_require__(138));

var lowerFirst = function lowerFirst(value) {
  var str = (0, _toString.default)(value);
  return str.charAt(0).toLowerCase() + str.substring(1);
};

var _default = lowerFirst;
exports.default = _default;

/***/ }),
/* 665 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function substitute(str, o) {
  if (!str || !o) {
    return str;
  }

  return str.replace(/\\?\{([^{}]+)\}/g, function (match, name) {
    if (match.charAt(0) === '\\') {
      return match.slice(1);
    }

    return o[name] === undefined ? '' : o[name];
  });
}

var _default = substitute;
exports.default = _default;

/***/ }),
/* 666 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toString = _interopRequireDefault(__webpack_require__(138));

var upperCase = function upperCase(str) {
  return (0, _toString.default)(str).toUpperCase();
};

var _default = upperCase;
exports.default = _default;

/***/ }),
/* 667 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toString = _interopRequireDefault(__webpack_require__(138));

var upperFirst = function upperFirst(value) {
  var str = (0, _toString.default)(value);
  return str.charAt(0).toUpperCase() + str.substring(1);
};

var _default = upperFirst;
exports.default = _default;

/***/ }),
/* 668 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

/**
 * 
 *
 * @param {Object} value 
 * @return {Boolean}
 */
var isArguments = function isArguments(value) {
  return (0, _isType.default)(value, 'Arguments');
};

var _default = isArguments;
exports.default = _default;

/***/ }),
/* 669 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

/**
 * 
 *
 * @param {Object} value 
 * @return {Boolean}
 */
var isBoolean = function isBoolean(value) {
  return (0, _isType.default)(value, 'Boolean');
};

var _default = isBoolean;
exports.default = _default;

/***/ }),
/* 670 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

var isDate = function isDate(value) {
  return (0, _isType.default)(value, 'Date');
};

var _default = isDate;
exports.default = _default;

/***/ }),
/* 671 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

/**
 * 
 *
 * @param {Object} value 
 * @return {Boolean}
 */
var isError = function isError(value) {
  return (0, _isType.default)(value, 'Error');
};

var _default = isError;
exports.default = _default;

/***/ }),
/* 672 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _isNumber = _interopRequireDefault(__webpack_require__(85));

/**
 * 
 * @return {Boolean}
 */
function _default(value) {
  return (0, _isNumber.default)(value) && isFinite(value);
}

/***/ }),
/* 673 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isNull = function isNull(value) {
  return value === null;
};

var _default = isNull;
exports.default = _default;

/***/ }),
/* 674 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isType = _interopRequireDefault(__webpack_require__(67));

var isRegExp = function isRegExp(str) {
  return (0, _isType.default)(str, 'RegExp');
};

var _default = isRegExp;
exports.default = _default;

/***/ }),
/* 675 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var isUndefined = function isUndefined(value) {
  return value === undefined;
};

var _default = isUndefined;
exports.default = _default;

/***/ }),
/* 676 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * HTML
 * @return {Boolean} HTML
 */
var isElement = function isElement(o) {
  return o instanceof Element || o instanceof HTMLDocument;
};

var _default = isElement;
exports.default = _default;

/***/ }),
/* 677 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = requestAnimationFrame;

function requestAnimationFrame(fn) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function (f) {
    return setTimeout(f, 16);
  };

  return method(fn);
}

;

/***/ }),
/* 678 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cancelAnimationFrame;

function cancelAnimationFrame(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}

;

/***/ }),
/* 679 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mix = _interopRequireDefault(__webpack_require__(237));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var augment = function augment() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var c = args[0];

  for (var i = 1; i < args.length; i++) {
    var obj = args[i];

    if ((0, _isFunction.default)(obj)) {
      obj = obj.prototype;
    }

    (0, _mix.default)(c.prototype, obj);
  }
};

var _default = augment;
exports.default = _default;

/***/ }),
/* 680 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _isArray = _interopRequireDefault(__webpack_require__(39));

var clone = function clone(obj) {
  if ((0, _typeof2.default)(obj) !== 'object' || obj === null) {
    return obj;
  }

  var rst;

  if ((0, _isArray.default)(obj)) {
    rst = [];

    for (var i = 0, l = obj.length; i < l; i++) {
      if ((0, _typeof2.default)(obj[i]) === 'object' && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};

    for (var k in obj) {
      if ((0, _typeof2.default)(obj[k]) === 'object' && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }

  return rst;
};

var _default = clone;
exports.default = _default;

/***/ }),
/* 681 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
}

var _default = debounce;
exports.default = _default;

/***/ }),
/* 682 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(58));

/**
 * _.memoize(calColor);
 * _.memoize(calColor, (...args) => args[0]);
 * @param f
 * @param resolver
 */
var _default = function _default(f, resolver) {
  if (!(0, _isFunction.default)(f)) {
    throw new TypeError('Expected a function');
  }

  var memoized = function memoized() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    } //  key resolver key


    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = f.apply(this, args); // 

    cache.set(key, result);
    return result;
  };

  memoized.cache = new Map();
  return memoized;
};

exports.default = _default;

/***/ }),
/* 683 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(39));

var _isPlainObject = _interopRequireDefault(__webpack_require__(137));

var MAX_MIX_LEVEL = 5;

function _deepMix(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;

  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];

      if (value !== null && (0, _isPlainObject.default)(value)) {
        if (!(0, _isPlainObject.default)(dist[key])) {
          dist[key] = {};
        }

        if (level < maxLevel) {
          _deepMix(dist[key], value, level + 1, maxLevel);
        } else {
          dist[key] = src[key];
        }
      } else if ((0, _isArray.default)(value)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value);
      } else if (value !== undefined) {
        dist[key] = value;
      }
    }
  }
} // todo 


var deepMix = function deepMix(rst) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }

  return rst;
};

var _default = deepMix;
exports.default = _default;

/***/ }),
/* 684 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _mix = _interopRequireDefault(__webpack_require__(237));

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var extend = function extend(subclass, superclass, overrides, staticOverrides) {
  // 
  if (!(0, _isFunction.default)(superclass)) {
    overrides = superclass;
    superclass = subclass;

    subclass = function subclass() {};
  }

  var create = Object.create ? function (proto, c) {
    return Object.create(proto, {
      constructor: {
        value: c
      }
    });
  } : function (proto, c) {
    function Tmp() {}

    Tmp.prototype = proto;
    var o = new Tmp();
    o.constructor = c;
    return o;
  };
  var superObj = create(superclass.prototype, subclass); // new superclass(),//prototype

  subclass.prototype = (0, _mix.default)(superObj, subclass.prototype); // prototype

  subclass.superclass = create(superclass.prototype, superclass);
  (0, _mix.default)(superObj, overrides);
  (0, _mix.default)(subclass, staticOverrides);
  return subclass;
};

var _default = extend;
exports.default = _default;

/***/ }),
/* 685 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var indexOf = function indexOf(arr, obj) {
  if (!(0, _isArrayLike.default)(arr)) {
    return -1;
  }

  var m = Array.prototype.indexOf;

  if (m) {
    return m.call(arr, obj);
  }

  var index = -1;

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index = i;
      break;
    }
  }

  return index;
};

var _default = indexOf;
exports.default = _default;

/***/ }),
/* 686 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var _getType = _interopRequireDefault(__webpack_require__(372));

var _isPrototype = _interopRequireDefault(__webpack_require__(373));

var hasOwnProperty = Object.prototype.hasOwnProperty;

function isEmpty(value) {
  /**
   * isEmpty(null) => true
   * isEmpty() => true
   * isEmpty(true) => true
   * isEmpty(1) => true
   * isEmpty([1, 2, 3]) => false
   * isEmpty('abc') => false
   * isEmpty({ a: 1 }) => false
   */
  if ((0, _isNil.default)(value)) {
    return true;
  }

  if ((0, _isArrayLike.default)(value)) {
    return !value.length;
  }

  var type = (0, _getType.default)(value);

  if (type === 'Map' || type === 'Set') {
    return !value.size;
  }

  if ((0, _isPrototype.default)(value)) {
    return !Object.keys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

var _default = isEmpty;
exports.default = _default;

/***/ }),
/* 687 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isFunction = _interopRequireDefault(__webpack_require__(58));

var _isEqual = _interopRequireDefault(__webpack_require__(374));

/**
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [fn] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * isEqualWith(array, other, customizer);  // => true
 */
var _default = function _default(value, other, fn) {
  if (!(0, _isFunction.default)(fn)) {
    return (0, _isEqual.default)(value, other);
  }

  return !!fn(value, other);
};

exports.default = _default;

/***/ }),
/* 688 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var map = function map(arr, func) {
  if (!(0, _isArrayLike.default)(arr)) {
    // @ts-ignore
    return arr;
  }

  var result = [];

  for (var index = 0; index < arr.length; index++) {
    var value = arr[index];
    result.push(func(value, index));
  }

  return result;
};

var _default = map;
exports.default = _default;

/***/ }),
/* 689 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _isObject = _interopRequireDefault(__webpack_require__(175));

var identity = function identity(v) {
  return v;
};

var _default = function _default(object, func) {
  if (func === void 0) {
    func = identity;
  }

  var r = {};

  if ((0, _isObject.default)(object) && !(0, _isNil.default)(object)) {
    Object.keys(object).forEach(function (key) {
      // @ts-ignore
      r[key] = func(object[key], key);
    });
  }

  return r;
};

exports.default = _default;

/***/ }),
/* 690 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isString = _interopRequireDefault(__webpack_require__(101));

/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param key
 * @param defaultValue
 */
var _default = function _default(obj, key, defaultValue) {
  var p = 0;
  var keyArr = (0, _isString.default)(key) ? key.split('.') : key;

  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }

  return obj === undefined || p < keyArr.length ? defaultValue : obj;
};

exports.default = _default;

/***/ }),
/* 691 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isObject = _interopRequireDefault(__webpack_require__(175));

var _isString = _interopRequireDefault(__webpack_require__(101));

var _isNumber = _interopRequireDefault(__webpack_require__(85));

/**
 * https://github.com/developit/dlv/blob/master/index.js
 * @param obj
 * @param path
 * @param value
 */
var _default = function _default(obj, path, value) {
  var o = obj;
  var keyArr = (0, _isString.default)(path) ? path.split('.') : path;
  keyArr.forEach(function (key, idx) {
    // 
    if (idx < keyArr.length - 1) {
      if (!(0, _isObject.default)(o[key])) {
        o[key] = (0, _isNumber.default)(keyArr[idx + 1]) ? [] : {};
      }

      o = o[key];
    } else {
      o[key] = value;
    }
  });
  return obj;
};

exports.default = _default;

/***/ }),
/* 692 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _each = _interopRequireDefault(__webpack_require__(84));

var _isPlainObject = _interopRequireDefault(__webpack_require__(137));

var hasOwnProperty = Object.prototype.hasOwnProperty;

var _default = function _default(object, keys) {
  if (object === null || !(0, _isPlainObject.default)(object)) {
    return {};
  }

  var result = {};
  (0, _each.default)(keys, function (key) {
    if (hasOwnProperty.call(object, key)) {
      result[key] = object[key];
    }
  });
  return result;
};

exports.default = _default;

/***/ }),
/* 693 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function throttled() {
    var now = Date.now();
    if (!previous && options.leading === false) previous = now;
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }

      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }

    return result;
  };

  throttled.cancel = function () {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
};

exports.default = _default;

/***/ }),
/* 694 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

var _default = function _default(value) {
  return (0, _isArrayLike.default)(value) ? Array.prototype.slice.call(value) : [];
};

exports.default = _default;

/***/ }),
/* 695 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var map = {};

var _default = function _default(prefix) {
  prefix = prefix || 'g';

  if (!map[prefix]) {
    map[prefix] = 1;
  } else {
    map[prefix] += 1;
  }

  return prefix + map[prefix];
};

exports.default = _default;

/***/ }),
/* 696 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default() {};

exports.default = _default;

/***/ }),
/* 697 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _default = function _default(v) {
  return v;
};

exports.default = _default;

/***/ }),
/* 698 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = size;

var _isNil = _interopRequireDefault(__webpack_require__(94));

var _isArrayLike = _interopRequireDefault(__webpack_require__(57));

function size(o) {
  if ((0, _isNil.default)(o)) {
    return 0;
  }

  if ((0, _isArrayLike.default)(o)) {
    return o.length;
  }

  return Object.keys(o).length;
}

/***/ }),
/* 699 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * k-v 
 */
var default_1 =
/** @class */
function () {
  function default_1() {
    this.map = {};
  }

  default_1.prototype.has = function (key) {
    return this.map[key] !== undefined;
  };

  default_1.prototype.get = function (key, def) {
    var v = this.map[key];
    return v === undefined ? def : v;
  };

  default_1.prototype.set = function (key, value) {
    this.map[key] = value;
  };

  default_1.prototype.clear = function () {
    this.map = {};
  };

  default_1.prototype.delete = function (key) {
    delete this.map[key];
  };

  default_1.prototype.size = function () {
    return Object.keys(this.map).length;
  };

  return default_1;
}();

var _default = default_1;
exports.default = _default;

/***/ }),
/* 700 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 701 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 702 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _detectBrowser = __webpack_require__(239);

var _container = _interopRequireDefault(__webpack_require__(379));

var _util = __webpack_require__(102);

var _timeline = _interopRequireDefault(__webpack_require__(708));

var _eventContoller = _interopRequireDefault(__webpack_require__(740));

var PX_SUFFIX = 'px';
var browser = (0, _detectBrowser.detect)();
var isFirefox = browser && browser.name === 'firefox';

var Canvas =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Canvas, _super);

  function Canvas(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.initContainer();

    _this.initDom();

    _this.initEvents();

    _this.initTimeline();

    return _this;
  }

  Canvas.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this); // set default cursor style for canvas


    cfg['cursor'] = 'default'; // CSS transform 

    cfg['supportCSSTransform'] = false;
    return cfg;
  };
  /**
   * @protected
   * 
   */


  Canvas.prototype.initContainer = function () {
    var container = this.get('container');

    if ((0, _util.isString)(container)) {
      container = document.getElementById(container);
      this.set('container', container);
    }
  };
  /**
   * @protected
   *  DOM
   */


  Canvas.prototype.initDom = function () {
    var el = this.createDom();
    this.set('el', el); // 

    var container = this.get('container');
    container.appendChild(el); // 

    this.setDOMSize(this.get('width'), this.get('height'));
  };
  /**
   * @protected
   * 
   */


  Canvas.prototype.initEvents = function () {
    var eventController = new _eventContoller.default({
      canvas: this
    });
    eventController.init();
    this.set('eventController', eventController);
  };
  /**
   * @protected
   * 
   */


  Canvas.prototype.initTimeline = function () {
    var timeline = new _timeline.default(this);
    this.set('timeline', timeline);
  };
  /**
   * @protected
   *  DOM 
   * @param {number} width  
   * @param {number} height 
   */


  Canvas.prototype.setDOMSize = function (width, height) {
    var el = this.get('el');

    if (_util.isBrowser) {
      el.style.width = width + PX_SUFFIX;
      el.style.height = height + PX_SUFFIX;
    }
  }; // 


  Canvas.prototype.changeSize = function (width, height) {
    this.setDOMSize(width, height);
    this.set('width', width);
    this.set('height', height);
    this.onCanvasChange('changeSize');
  };
  /**
   * 
   * @return {Renderer} 
   */


  Canvas.prototype.getRenderer = function () {
    return this.get('renderer');
  };
  /**
   *  cursor 
   * @return {Cursor}
   */


  Canvas.prototype.getCursor = function () {
    return this.get('cursor');
  };
  /**
   *  cursor 
   * @param {Cursor} cursor  cursor 
   */


  Canvas.prototype.setCursor = function (cursor) {
    this.set('cursor', cursor);
    var el = this.get('el');

    if (_util.isBrowser && el) {
      // 
      el.style.cursor = cursor;
    }
  }; // 


  Canvas.prototype.getPointByEvent = function (ev) {
    var supportCSSTransform = this.get('supportCSSTransform');

    if (supportCSSTransform) {
      // For Firefox <= 38
      if (isFirefox && !(0, _util.isNil)(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }

      if (!(0, _util.isNil)(ev.offsetX)) {
        // For IE6+, Firefox >= 39, Chrome, Safari, Opera
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    } // should calculate by self for other cases, like Safari in ios
    // TODO: support CSS transform


    var _a = this.getClientByEvent(ev),
        clientX = _a.x,
        clientY = _a.y;

    return this.getPointByClient(clientX, clientY);
  }; //  touch  clientX  clientY 


  Canvas.prototype.getClientByEvent = function (ev) {
    var clientInfo = ev;

    if (ev.touches) {
      if (ev.type === 'touchend') {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }

    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  }; // 


  Canvas.prototype.getPointByClient = function (clientX, clientY) {
    var el = this.get('el');
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  }; // 


  Canvas.prototype.getClientByPoint = function (x, y) {
    var el = this.get('el');
    var bbox = el.getBoundingClientRect();
    return {
      x: x + bbox.left,
      y: y + bbox.top
    };
  }; // 


  Canvas.prototype.draw = function () {};
  /**
   * @protected
   *  DOM 
   */


  Canvas.prototype.removeDom = function () {
    var el = this.get('el');
    el.parentNode.removeChild(el);
  };
  /**
   * @protected
   * 
   */


  Canvas.prototype.clearEvents = function () {
    var eventController = this.get('eventController');
    eventController.destroy();
  };

  Canvas.prototype.isCanvas = function () {
    return true;
  };

  Canvas.prototype.getParent = function () {
    return null;
  };

  Canvas.prototype.destroy = function () {
    var timeline = this.get('timeline');

    if (this.get('destroyed')) {
      return;
    }

    this.clear(); // 

    if (timeline) {
      // 
      timeline.stop();
    }

    this.clearEvents();
    this.removeDom();

    _super.prototype.destroy.call(this);
  };

  return Canvas;
}(_container.default);

var _default = Canvas;
exports.default = _default;

/***/ }),
/* 703 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 704 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.transpose = transpose;
exports.invert = invert;
exports.adjoint = adjoint;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.str = str;
exports.frob = frob;
exports.LDU = LDU;
exports.add = add;
exports.subtract = subtract;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(4);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */


function fromValues(m00, m01, m10, m11) {
  var out = new glMatrix.ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */


function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */


function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */


function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;

/***/ }),
/* 705 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.copy = copy;
exports.identity = identity;
exports.fromValues = fromValues;
exports.set = set;
exports.invert = invert;
exports.determinant = determinant;
exports.multiply = multiply;
exports.rotate = rotate;
exports.scale = scale;
exports.translate = translate;
exports.fromRotation = fromRotation;
exports.fromScaling = fromScaling;
exports.fromTranslation = fromTranslation;
exports.str = str;
exports.frob = frob;
exports.add = add;
exports.subtract = subtract;
exports.multiplyScalar = multiplyScalar;
exports.multiplyScalarAndAdd = multiplyScalarAndAdd;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sub = exports.mul = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new glMatrix.ARRAY_TYPE(6);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */


function clone(a) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */


function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */


function fromValues(a, b, c, d, tx, ty) {
  var out = new glMatrix.ARRAY_TYPE(6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */


function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */


function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */


function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/


function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/


function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */


function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */


function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */


function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */


function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */


function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */


function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */


function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */


function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */


var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

exports.mul = mul;
var sub = subtract;
exports.sub = sub;

/***/ }),
/* 706 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = create;
exports.clone = clone;
exports.fromValues = fromValues;
exports.fromRotationTranslationValues = fromRotationTranslationValues;
exports.fromRotationTranslation = fromRotationTranslation;
exports.fromTranslation = fromTranslation;
exports.fromRotation = fromRotation;
exports.fromMat4 = fromMat4;
exports.copy = copy;
exports.identity = identity;
exports.set = set;
exports.getDual = getDual;
exports.setDual = setDual;
exports.getTranslation = getTranslation;
exports.translate = translate;
exports.rotateX = rotateX;
exports.rotateY = rotateY;
exports.rotateZ = rotateZ;
exports.rotateByQuatAppend = rotateByQuatAppend;
exports.rotateByQuatPrepend = rotateByQuatPrepend;
exports.rotateAroundAxis = rotateAroundAxis;
exports.add = add;
exports.multiply = multiply;
exports.scale = scale;
exports.lerp = lerp;
exports.invert = invert;
exports.conjugate = conjugate;
exports.normalize = normalize;
exports.str = str;
exports.exactEquals = exactEquals;
exports.equals = equals;
exports.sqrLen = exports.squaredLength = exports.len = exports.length = exports.dot = exports.mul = exports.setReal = exports.getReal = void 0;

var glMatrix = _interopRequireWildcard(__webpack_require__(75));

var quat = _interopRequireWildcard(__webpack_require__(384));

var mat4 = _interopRequireWildcard(__webpack_require__(383));

/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new glMatrix.ARRAY_TYPE(8);

  if (glMatrix.ARRAY_TYPE != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */


function clone(a) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */


function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new glMatrix.ARRAY_TYPE(8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */


function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */


function fromMat4(out, a) {
  //TODO Optimize this
  var outer = quat.create();
  mat4.getRotation(outer, a);
  var t = new glMatrix.ARRAY_TYPE(3);
  mat4.getTranslation(t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */


function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */


function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */


function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */


var getReal = quat.copy;
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

exports.getReal = getReal;

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */


var setReal = quat.copy;
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

exports.setReal = setReal;

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */


function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */


function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateX(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateY(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */


function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  quat.rotateZ(out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */


function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */


function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */


function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < glMatrix.EPSILON) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */


function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */


function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */


var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

exports.mul = mul;

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */


var dot = quat.dot;
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

exports.dot = dot;

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */


function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */


function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */


var length = quat.length;
/**
 * Alias for {@link quat2.length}
 * @function
 */

exports.length = length;
var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

exports.len = len;
var squaredLength = quat.squaredLength;
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

exports.squaredLength = squaredLength;
var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

exports.sqrLen = sqrLen;

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */


function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */


function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */


function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),
/* 707 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.leftTranslate = leftTranslate;
exports.leftRotate = leftRotate;
exports.leftScale = leftScale;
exports.transform = transform;
exports.direction = direction;
exports.angleTo = angleTo;
exports.vertical = vertical;

var _glMatrix = __webpack_require__(381);

/**
 * @description  gl-matrix 
 * */
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];

  _glMatrix.mat3.fromTranslation(transMat, v);

  return _glMatrix.mat3.multiply(out, transMat, a);
}

function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];

  _glMatrix.mat3.fromRotation(rotateMat, rad);

  return _glMatrix.mat3.multiply(out, rotateMat, a);
}

function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];

  _glMatrix.mat3.fromScaling(scaleMat, v);

  return _glMatrix.mat3.multiply(out, scaleMat, a);
}

function leftMultiply(out, a, a1) {
  return _glMatrix.mat3.multiply(out, a1, a);
}
/**
 *  actions  transform
 * @param m
 * @param actions
 */


function transform(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];

  for (var i = 0, len = actions.length; i < len; i++) {
    var action = actions[i];

    switch (action[0]) {
      case 't':
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;

      case 's':
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;

      case 'r':
        leftRotate(matrix, matrix, action[1]);
        break;

      case 'm':
        leftMultiply(matrix, matrix, action[1]);
        break;

      default:
        break;
    }
  }

  return matrix;
}
/**
 *  v1   v2 
 * @param  {Array} v1 
 * @param  {Array} v2 
 * @return {Boolean} >= 0  < 0 
 */


function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
/**
 *  v1  v2 
 * @param v1
 * @param v2
 * @param direct
 */


function angleTo(v1, v2, direct) {
  var ang = _glMatrix.vec2.angle(v1, v2);

  var angleLargeThanPI = direction(v1, v2) >= 0;

  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }

    return ang;
  }

  if (angleLargeThanPI) {
    return ang;
  }

  return Math.PI * 2 - ang;
}
/**
 * 
 * @param out
 * @param v
 * @param flag
 */


function vertical(out, v, flag) {
  if (flag) {
    out[0] = v[1];
    out[1] = -1 * v[0];
  } else {
    out[0] = -1 * v[1];
    out[1] = v[0];
  }

  return out;
}

/***/ }),
/* 708 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var d3Timer = _interopRequireWildcard(__webpack_require__(709));

var d3Ease = _interopRequireWildcard(__webpack_require__(712));

var _d3Interpolate = __webpack_require__(723);

var PathUtil = _interopRequireWildcard(__webpack_require__(376));

var _color = __webpack_require__(739);

// 
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
/**
 *  ratio 
 * @param {IElement}  shape    
 * @param {Animation} animation 
 * @param {number}    ratio    
 * @return {boolean}  
 */

function _update(shape, animation, ratio) {
  var cProps = {}; // 

  var fromAttrs = animation.fromAttrs,
      toAttrs = animation.toAttrs;

  if (shape.destroyed) {
    return;
  }

  var interf; //  

  for (var k in toAttrs) {
    if (!(0, _util.isEqual)(fromAttrs[k], toAttrs[k])) {
      if (k === 'path') {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];

        if (toPath.length > fromPath.length) {
          toPath = PathUtil.parsePathString(toAttrs[k]); // 

          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 

          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);
          fromPath = PathUtil.formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = PathUtil.parsePathString(toAttrs[k]);
          fromPath = PathUtil.parsePathString(fromAttrs[k]);
          fromPath = PathUtil.formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }

        cProps[k] = [];

        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];

          for (var j = 0; j < toPathPoint.length; j++) {
            if ((0, _util.isNumber)(toPathPoint[j]) && fromPathPoint && (0, _util.isNumber)(fromPathPoint[j])) {
              interf = (0, _d3Interpolate.interpolate)(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }

          cProps[k].push(cPathPoint);
        }
      } else if (k === 'matrix') {
        /*
         
         TODO:  WebGL 
         */
        var matrixFn = (0, _d3Interpolate.interpolateArray)(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if ((0, _color.isColorProp)(k) && (0, _color.isGradientColor)(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!(0, _util.isFunction)(toAttrs[k])) {
        // 
        interf = (0, _d3Interpolate.interpolate)(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }

  shape.attr(cProps);
}
/**
 *  onFrame 
 * @param {IElement}  shape    
 * @param {Animation} animation 
 * @param {number}    elapsed  ()
 * @return {boolean}  
 */


function update(shape, animation, elapsed) {
  var startTime = animation.startTime,
      delay = animation.delay; // 

  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }

  var ratio;
  var duration = animation.duration;
  var easing = animation.easing; // 

  elapsed = elapsed - startTime - animation.delay;

  if (animation.repeat) {
    //  elapsed > duration ratio 
    ratio = elapsed % duration / duration;
    ratio = d3Ease[easing](ratio);
  } else {
    ratio = elapsed / duration;

    if (ratio < 1) {
      // 
      ratio = d3Ease[easing](ratio);
    } else {
      // 
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }

      return true;
    }
  }

  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }

  return false;
}

var Timeline =
/** @class */
function () {
  /**
   * 
   * @param {}
   */
  function Timeline(canvas) {
    /**
     * 
     * @type {IElement[]}
     */
    this.animators = [];
    /**
     * 
     * @type {number}
     */

    this.current = 0;
    /**
     * 
     * @type {d3Timer.Timer}
     */

    this.timer = null;
    this.canvas = canvas;
  }
  /**
   * 
   */


  Timeline.prototype.initTimer = function () {
    var _this = this;

    var isFinished = false;
    var shape;
    var animations;
    var animation;
    this.timer = d3Timer.timer(function (elapsed) {
      _this.current = elapsed;

      if (_this.animators.length > 0) {
        for (var i = _this.animators.length - 1; i >= 0; i--) {
          shape = _this.animators[i];

          if (shape.destroyed) {
            // 
            _this.removeAnimator(i);

            continue;
          }

          if (!shape.isAnimatePaused()) {
            animations = shape.get('animations');

            for (var j = animations.length - 1; j >= 0; j--) {
              animation = animations[j];
              isFinished = update(shape, animation, elapsed);

              if (isFinished) {
                animations.splice(j, 1);
                isFinished = false;

                if (animation.callback) {
                  animation.callback();
                }
              }
            }
          }

          if (animations.length === 0) {
            _this.removeAnimator(i);
          }
        }

        var autoDraw = _this.canvas.get('autoDraw'); //  canvas.draw() 


        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  /**
   * 
   */


  Timeline.prototype.addAnimator = function (shape) {
    this.animators.push(shape);
  };
  /**
   * 
   */


  Timeline.prototype.removeAnimator = function (index) {
    this.animators.splice(index, 1);
  };
  /**
   * 
   */


  Timeline.prototype.isAnimating = function () {
    return !!this.animators.length;
  };
  /**
   * 
   */


  Timeline.prototype.stop = function () {
    if (this.timer) {
      this.timer.stop();
    }
  };
  /**
   * 
   * @param {boolean} toEnd  stopAnimate 
   */


  Timeline.prototype.stopAllAnimations = function (toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }

    this.animators.forEach(function (animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  /**
   * 
   */


  Timeline.prototype.getTime = function () {
    return this.current;
  };

  return Timeline;
}();

var _default = Timeline;
exports.default = _default;

/***/ }),
/* 709 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "now", {
  enumerable: true,
  get: function get() {
    return _timer.now;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function get() {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "timerFlush", {
  enumerable: true,
  get: function get() {
    return _timer.timerFlush;
  }
});
Object.defineProperty(exports, "timeout", {
  enumerable: true,
  get: function get() {
    return _timeout.default;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function get() {
    return _interval.default;
  }
});

var _timer = __webpack_require__(241);

var _timeout = _interopRequireDefault(__webpack_require__(710));

var _interval = _interopRequireDefault(__webpack_require__(711));

/***/ }),
/* 710 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = __webpack_require__(241);

function _default(callback, delay, time) {
  var t = new _timer.Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

/***/ }),
/* 711 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = __webpack_require__(241);

function _default(callback, delay, time) {
  var t = new _timer.Timer(),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? (0, _timer.now)() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}

/***/ }),
/* 712 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "easeLinear", {
  enumerable: true,
  get: function get() {
    return _linear.linear;
  }
});
Object.defineProperty(exports, "easeQuad", {
  enumerable: true,
  get: function get() {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadIn", {
  enumerable: true,
  get: function get() {
    return _quad.quadIn;
  }
});
Object.defineProperty(exports, "easeQuadOut", {
  enumerable: true,
  get: function get() {
    return _quad.quadOut;
  }
});
Object.defineProperty(exports, "easeQuadInOut", {
  enumerable: true,
  get: function get() {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeCubic", {
  enumerable: true,
  get: function get() {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicIn", {
  enumerable: true,
  get: function get() {
    return _cubic.cubicIn;
  }
});
Object.defineProperty(exports, "easeCubicOut", {
  enumerable: true,
  get: function get() {
    return _cubic.cubicOut;
  }
});
Object.defineProperty(exports, "easeCubicInOut", {
  enumerable: true,
  get: function get() {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easePoly", {
  enumerable: true,
  get: function get() {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyIn", {
  enumerable: true,
  get: function get() {
    return _poly.polyIn;
  }
});
Object.defineProperty(exports, "easePolyOut", {
  enumerable: true,
  get: function get() {
    return _poly.polyOut;
  }
});
Object.defineProperty(exports, "easePolyInOut", {
  enumerable: true,
  get: function get() {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easeSin", {
  enumerable: true,
  get: function get() {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinIn", {
  enumerable: true,
  get: function get() {
    return _sin.sinIn;
  }
});
Object.defineProperty(exports, "easeSinOut", {
  enumerable: true,
  get: function get() {
    return _sin.sinOut;
  }
});
Object.defineProperty(exports, "easeSinInOut", {
  enumerable: true,
  get: function get() {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeExp", {
  enumerable: true,
  get: function get() {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpIn", {
  enumerable: true,
  get: function get() {
    return _exp.expIn;
  }
});
Object.defineProperty(exports, "easeExpOut", {
  enumerable: true,
  get: function get() {
    return _exp.expOut;
  }
});
Object.defineProperty(exports, "easeExpInOut", {
  enumerable: true,
  get: function get() {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeCircle", {
  enumerable: true,
  get: function get() {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleIn", {
  enumerable: true,
  get: function get() {
    return _circle.circleIn;
  }
});
Object.defineProperty(exports, "easeCircleOut", {
  enumerable: true,
  get: function get() {
    return _circle.circleOut;
  }
});
Object.defineProperty(exports, "easeCircleInOut", {
  enumerable: true,
  get: function get() {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeBounce", {
  enumerable: true,
  get: function get() {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceIn", {
  enumerable: true,
  get: function get() {
    return _bounce.bounceIn;
  }
});
Object.defineProperty(exports, "easeBounceOut", {
  enumerable: true,
  get: function get() {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceInOut", {
  enumerable: true,
  get: function get() {
    return _bounce.bounceInOut;
  }
});
Object.defineProperty(exports, "easeBack", {
  enumerable: true,
  get: function get() {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackIn", {
  enumerable: true,
  get: function get() {
    return _back.backIn;
  }
});
Object.defineProperty(exports, "easeBackOut", {
  enumerable: true,
  get: function get() {
    return _back.backOut;
  }
});
Object.defineProperty(exports, "easeBackInOut", {
  enumerable: true,
  get: function get() {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeElastic", {
  enumerable: true,
  get: function get() {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticIn", {
  enumerable: true,
  get: function get() {
    return _elastic.elasticIn;
  }
});
Object.defineProperty(exports, "easeElasticOut", {
  enumerable: true,
  get: function get() {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticInOut", {
  enumerable: true,
  get: function get() {
    return _elastic.elasticInOut;
  }
});

var _linear = __webpack_require__(713);

var _quad = __webpack_require__(714);

var _cubic = __webpack_require__(715);

var _poly = __webpack_require__(716);

var _sin = __webpack_require__(717);

var _exp = __webpack_require__(718);

var _circle = __webpack_require__(719);

var _bounce = __webpack_require__(720);

var _back = __webpack_require__(721);

var _elastic = __webpack_require__(722);

/***/ }),
/* 713 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = linear;

function linear(t) {
  return +t;
}

/***/ }),
/* 714 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quadIn = quadIn;
exports.quadOut = quadOut;
exports.quadInOut = quadInOut;

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

/***/ }),
/* 715 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicIn = cubicIn;
exports.cubicOut = cubicOut;
exports.cubicInOut = cubicInOut;

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

/***/ }),
/* 716 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyInOut = exports.polyOut = exports.polyIn = void 0;
var exponent = 3;

var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);

exports.polyIn = polyIn;

var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);

exports.polyOut = polyOut;

var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

exports.polyInOut = polyInOut;

/***/ }),
/* 717 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sinIn = sinIn;
exports.sinOut = sinOut;
exports.sinInOut = sinInOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

/***/ }),
/* 718 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expIn = expIn;
exports.expOut = expOut;
exports.expInOut = expInOut;

var _math = __webpack_require__(387);

function expIn(t) {
  return (0, _math.tpmt)(1 - +t);
}

function expOut(t) {
  return 1 - (0, _math.tpmt)(t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? (0, _math.tpmt)(1 - t) : 2 - (0, _math.tpmt)(t - 1)) / 2;
}

/***/ }),
/* 719 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleIn = circleIn;
exports.circleOut = circleOut;
exports.circleInOut = circleInOut;

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

/***/ }),
/* 720 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceIn = bounceIn;
exports.bounceOut = bounceOut;
exports.bounceInOut = bounceInOut;
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

/***/ }),
/* 721 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backInOut = exports.backOut = exports.backIn = void 0;
var overshoot = 1.70158;

var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);

exports.backIn = backIn;

var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);

exports.backOut = backOut;

var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

exports.backInOut = backInOut;

/***/ }),
/* 722 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elasticInOut = exports.elasticOut = exports.elasticIn = void 0;

var _math = __webpack_require__(387);

var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * (0, _math.tpmt)(- --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);

exports.elasticIn = elasticIn;

var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * (0, _math.tpmt)(t = +t) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);

exports.elasticOut = elasticOut;

var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * (0, _math.tpmt)(-t) * Math.sin((s - t) / p) : 2 - a * (0, _math.tpmt)(t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

exports.elasticInOut = elasticInOut;

/***/ }),
/* 723 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function get() {
    return _value.default;
  }
});
Object.defineProperty(exports, "interpolateArray", {
  enumerable: true,
  get: function get() {
    return _array.default;
  }
});
Object.defineProperty(exports, "interpolateBasis", {
  enumerable: true,
  get: function get() {
    return _basis.default;
  }
});
Object.defineProperty(exports, "interpolateBasisClosed", {
  enumerable: true,
  get: function get() {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "interpolateDate", {
  enumerable: true,
  get: function get() {
    return _date.default;
  }
});
Object.defineProperty(exports, "interpolateDiscrete", {
  enumerable: true,
  get: function get() {
    return _discrete.default;
  }
});
Object.defineProperty(exports, "interpolateHue", {
  enumerable: true,
  get: function get() {
    return _hue.default;
  }
});
Object.defineProperty(exports, "interpolateNumber", {
  enumerable: true,
  get: function get() {
    return _number.default;
  }
});
Object.defineProperty(exports, "interpolateNumberArray", {
  enumerable: true,
  get: function get() {
    return _numberArray.default;
  }
});
Object.defineProperty(exports, "interpolateObject", {
  enumerable: true,
  get: function get() {
    return _object.default;
  }
});
Object.defineProperty(exports, "interpolateRound", {
  enumerable: true,
  get: function get() {
    return _round.default;
  }
});
Object.defineProperty(exports, "interpolateString", {
  enumerable: true,
  get: function get() {
    return _string.default;
  }
});
Object.defineProperty(exports, "interpolateTransformCss", {
  enumerable: true,
  get: function get() {
    return _index.interpolateTransformCss;
  }
});
Object.defineProperty(exports, "interpolateTransformSvg", {
  enumerable: true,
  get: function get() {
    return _index.interpolateTransformSvg;
  }
});
Object.defineProperty(exports, "interpolateZoom", {
  enumerable: true,
  get: function get() {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "interpolateRgb", {
  enumerable: true,
  get: function get() {
    return _rgb.default;
  }
});
Object.defineProperty(exports, "interpolateRgbBasis", {
  enumerable: true,
  get: function get() {
    return _rgb.rgbBasis;
  }
});
Object.defineProperty(exports, "interpolateRgbBasisClosed", {
  enumerable: true,
  get: function get() {
    return _rgb.rgbBasisClosed;
  }
});
Object.defineProperty(exports, "interpolateHsl", {
  enumerable: true,
  get: function get() {
    return _hsl.default;
  }
});
Object.defineProperty(exports, "interpolateHslLong", {
  enumerable: true,
  get: function get() {
    return _hsl.hslLong;
  }
});
Object.defineProperty(exports, "interpolateLab", {
  enumerable: true,
  get: function get() {
    return _lab.default;
  }
});
Object.defineProperty(exports, "interpolateHcl", {
  enumerable: true,
  get: function get() {
    return _hcl.default;
  }
});
Object.defineProperty(exports, "interpolateHclLong", {
  enumerable: true,
  get: function get() {
    return _hcl.hclLong;
  }
});
Object.defineProperty(exports, "interpolateCubehelix", {
  enumerable: true,
  get: function get() {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelixLong", {
  enumerable: true,
  get: function get() {
    return _cubehelix.cubehelixLong;
  }
});
Object.defineProperty(exports, "piecewise", {
  enumerable: true,
  get: function get() {
    return _piecewise.default;
  }
});
Object.defineProperty(exports, "quantize", {
  enumerable: true,
  get: function get() {
    return _quantize.default;
  }
});

var _value = _interopRequireDefault(__webpack_require__(242));

var _array = _interopRequireDefault(__webpack_require__(392));

var _basis = _interopRequireDefault(__webpack_require__(245));

var _basisClosed = _interopRequireDefault(__webpack_require__(390));

var _date = _interopRequireDefault(__webpack_require__(393));

var _discrete = _interopRequireDefault(__webpack_require__(726));

var _hue = _interopRequireDefault(__webpack_require__(727));

var _number = _interopRequireDefault(__webpack_require__(177));

var _numberArray = _interopRequireDefault(__webpack_require__(246));

var _object = _interopRequireDefault(__webpack_require__(394));

var _round = _interopRequireDefault(__webpack_require__(728));

var _string = _interopRequireDefault(__webpack_require__(395));

var _index = __webpack_require__(729);

var _zoom = _interopRequireDefault(__webpack_require__(732));

var _rgb = _interopRequireWildcard(__webpack_require__(389));

var _hsl = _interopRequireWildcard(__webpack_require__(733));

var _lab = _interopRequireDefault(__webpack_require__(734));

var _hcl = _interopRequireWildcard(__webpack_require__(735));

var _cubehelix = _interopRequireWildcard(__webpack_require__(736));

var _piecewise = _interopRequireDefault(__webpack_require__(737));

var _quantize = _interopRequireDefault(__webpack_require__(738));

/***/ }),
/* 724 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gray = gray;
exports.default = lab;
exports.Lab = Lab;
exports.lch = lch;
exports.hcl = hcl;
exports.Hcl = Hcl;

var _define = _interopRequireWildcard(__webpack_require__(244));

var _color = __webpack_require__(243);

var _math = __webpack_require__(388);

// https://observablehq.com/@mbostock/lab-and-rgb
var K = 18,
    Xn = 0.96422,
    Yn = 1,
    Zn = 0.82521,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn),
      x,
      z;
  if (r === g && g === b) x = z = y;else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Lab, lab, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function rgb() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new _color.Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);

  var h = Math.atan2(o.b, o.a) * _math.rad2deg;

  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * _math.deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}

(0, _define.default)(Hcl, hcl, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function rgb() {
    return hcl2lab(this).rgb();
  }
}));

/***/ }),
/* 725 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cubehelix;
exports.Cubehelix = Cubehelix;

var _define = _interopRequireWildcard(__webpack_require__(244));

var _color = __webpack_require__(243);

var _math = __webpack_require__(388);

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * _math.rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Cubehelix, cubehelix, (0, _define.extend)(_color.Color, {
  brighter: function brighter(k) {
    k = k == null ? _color.brighter : Math.pow(_color.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function darker(k) {
    k = k == null ? _color.darker : Math.pow(_color.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math.deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color.Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));

/***/ }),
/* 726 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

/***/ }),
/* 727 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _color = __webpack_require__(110);

function _default(a, b) {
  var i = (0, _color.hue)(+a, +b);
  return function (t) {
    var x = i(t);
    return x - 360 * Math.floor(x / 360);
  };
}

/***/ }),
/* 728 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b = +b, function (t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

/***/ }),
/* 729 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolateTransformSvg = exports.interpolateTransformCss = void 0;

var _number = _interopRequireDefault(__webpack_require__(177));

var _parse = __webpack_require__(730);

function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) {
        s[(o = q[i]).i] = o.x(t);
      }

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse.parseCss, "px, ", "px)", "deg)");
exports.interpolateTransformCss = interpolateTransformCss;
var interpolateTransformSvg = interpolateTransform(_parse.parseSvg, ", ", ")", ")");
exports.interpolateTransformSvg = interpolateTransformSvg;

/***/ }),
/* 730 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCss = parseCss;
exports.parseSvg = parseSvg;

var _decompose = _interopRequireWildcard(__webpack_require__(731));

var cssNode, cssRoot, cssView, svgNode;

function parseCss(value) {
  if (value === "none") return _decompose.identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return (0, _decompose.default)(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return _decompose.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose.identity;
  value = value.matrix;
  return (0, _decompose.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}

/***/ }),
/* 731 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.identity = void 0;
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
exports.identity = identity;

function _default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

/***/ }),
/* 732 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


function _default(p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0  u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function i(t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;

      i = function i(t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }

  i.duration = S * 1000;
  return i;
}

/***/ }),
/* 733 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslLong = exports.default = void 0;

var _d3Color = __webpack_require__(61);

var _color = _interopRequireWildcard(__webpack_require__(110));

function hsl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hsl)(start)).h, (end = (0, _d3Color.hsl)(end)).h),
        s = (0, _color.default)(start.s, end.s),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hsl(_color.hue);

exports.default = _default;
var hslLong = hsl(_color.default);
exports.hslLong = hslLong;

/***/ }),
/* 734 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lab;

var _d3Color = __webpack_require__(61);

var _color = _interopRequireDefault(__webpack_require__(110));

function lab(start, end) {
  var l = (0, _color.default)((start = (0, _d3Color.lab)(start)).l, (end = (0, _d3Color.lab)(end)).l),
      a = (0, _color.default)(start.a, end.a),
      b = (0, _color.default)(start.b, end.b),
      opacity = (0, _color.default)(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

/***/ }),
/* 735 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hclLong = exports.default = void 0;

var _d3Color = __webpack_require__(61);

var _color = _interopRequireWildcard(__webpack_require__(110));

function hcl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hcl)(start)).h, (end = (0, _d3Color.hcl)(end)).h),
        c = (0, _color.default)(start.c, end.c),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hcl(_color.hue);

exports.default = _default;
var hclLong = hcl(_color.default);
exports.hclLong = hclLong;

/***/ }),
/* 736 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubehelixLong = exports.default = void 0;

var _d3Color = __webpack_require__(61);

var _color = _interopRequireWildcard(__webpack_require__(110));

function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0, _d3Color.cubehelix)(start)).h, (end = (0, _d3Color.cubehelix)(end)).h),
          s = (0, _color.default)(start.s, end.s),
          l = (0, _color.default)(start.l, end.l),
          opacity = (0, _color.default)(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}

var _default = cubehelix(_color.hue);

exports.default = _default;
var cubehelixLong = cubehelix(_color.default);
exports.cubehelixLong = cubehelixLong;

/***/ }),
/* 737 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = piecewise;

function piecewise(interpolate, values) {
  var i = 0,
      n = values.length - 1,
      v = values[0],
      I = new Array(n < 0 ? 0 : n);

  while (i < n) {
    I[i] = interpolate(v, v = values[++i]);
  }

  return function (t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

/***/ }),
/* 738 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) {
    samples[i] = interpolator(i / (n - 1));
  }

  return samples;
}

/***/ }),
/* 739 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGradientColor = exports.isColorProp = void 0;

var isColorProp = function isColorProp(prop) {
  return ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(prop);
};

exports.isColorProp = isColorProp;

var isGradientColor = function isGradientColor(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

exports.isGradientColor = isGradientColor;

/***/ }),
/* 740 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _graphEvent = _interopRequireDefault(__webpack_require__(377));

var _util = __webpack_require__(102);

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var DELEGATION_SPLIT = ':';
var EVENTS = ['mousedown', 'mouseup', 'dblclick', 'mouseout', 'mouseover', 'mousemove', 'mouseleave', 'mouseenter', 'touchstart', 'touchmove', 'touchend', 'dragenter', 'dragover', 'dragleave', 'drop', 'contextmenu', 'mousewheel']; // 

function hasDelegation(events, type) {
  for (var key in events) {
    if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {
      return true;
    }
  }

  return false;
} //  shape  canvas


function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
} // , enter  leave  fromShape  toShape 


function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;

    if (type === 'mouseenter') {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === 'mouseleave') {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    } // canvas  mouseenter mouseleave  canvas 


    if (container.isCanvas() && isOverEvent) {
      return;
    } // 


    if (relativeShape && (0, _util.isParent)(container, relativeShape)) {
      // 
      eventObj.bubbles = false;
      return;
    } // 


    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}

var EventController =
/** @class */
function () {
  function EventController(cfg) {
    var _this = this; // 


    this.draggingShape = null;
    this.dragging = false; // /touch

    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null; // 

    this._eventCallback = function (ev) {
      var type = ev.type;

      _this._triggerEvent(type, ev);
    }; //  document 


    this._onDocumentMove = function (ev) {
      var canvas = _this.canvas;
      var el = canvas.get('el');

      if (el !== ev.target) {
        //  canvas 
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev); // 


          if (_this.dragging) {
            _this._emitEvent('drag', ev, pointInfo, _this.draggingShape);
          } // 
          //  mouseleave  bug 
          // if (this.currentShape) {
          //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);
          //   this.currentShape = null;
          // }

        }
      }
    }; //  document  dragend


    this._onDocumentMouseUp = function (ev) {
      var canvas = _this.canvas;
      var el = canvas.get('el');

      if (el !== ev.target) {
        //  canvas 
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);

          if (_this.draggingShape) {
            //  drop 
            _this._emitEvent('drop', ev, pointInfo, null);
          }

          _this._emitEvent('dragend', ev, pointInfo, _this.draggingShape);

          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };

    this.canvas = cfg.canvas;
  }

  EventController.prototype.init = function () {
    this._bindEvents();
  }; // 


  EventController.prototype._bindEvents = function () {
    var _this = this;

    var el = this.canvas.get('el');
    (0, _util.each)(EVENTS, function (eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });

    if (document) {
      //  shape mouse leave 
      // 
      document.addEventListener('mousemove', this._onDocumentMove); // 

      document.addEventListener('mouseup', this._onDocumentMouseUp);
    }
  }; // 


  EventController.prototype._clearEvents = function () {
    var _this = this;

    var el = this.canvas.get('el');
    (0, _util.each)(EVENTS, function (eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });

    if (document) {
      document.removeEventListener('mousemove', this._onDocumentMove);
      document.removeEventListener('mouseup', this._onDocumentMouseUp);
    }
  };

  EventController.prototype._getEventObj = function (type, event, point, target, fromShape, toShape) {
    var eventObj = new _graphEvent.default(type, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point.x;
    eventObj.y = point.y;
    eventObj.clientX = point.clientX;
    eventObj.clientY = point.clientY;
    eventObj.propagationPath.push(target); // x,ycanvasmatrix

    return eventObj;
  }; // 


  EventController.prototype._getShape = function (point, ev) {
    return this.canvas.getShape(point.x, point.y, ev);
  }; // 


  EventController.prototype._getPointInfo = function (ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point = canvas.getPointByEvent(ev);
    return {
      x: point.x,
      y: point.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  }; // 


  EventController.prototype._triggerEvent = function (type, ev) {
    var pointInfo = this._getPointInfo(ev); // 


    var shape = this._getShape(pointInfo, ev);

    var method = this["_on" + type];
    var leaveCanvas = false;

    if (method) {
      method.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape; // 

      if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {
        this._emitEvent(type, ev, pointInfo, null, null, shape); // 


        if (shape) {
          this._emitEvent(type, ev, pointInfo, shape, null, shape); // 

        }

        if (type === 'mouseenter' && this.draggingShape) {
          // ,  dragleave
          this._emitEvent('dragenter', ev, pointInfo, null);
        }
      } else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {
        leaveCanvas = true;

        if (preShape) {
          this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 

        }

        this._emitEvent(type, ev, pointInfo, null, preShape, null); // 


        if (type === 'mouseleave' && this.draggingShape) {
          this._emitEvent('dragleave', ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type, ev, pointInfo, shape, null, null); //  from, to

      }
    }

    if (!leaveCanvas) {
      this.currentShape = shape;
    } //  shape  preShape  shape  shape 


    if (shape && !shape.get('destroyed')) {
      var canvas = this.canvas;
      var el = canvas.get('el');
      el.style.cursor = shape.attr('cursor') || canvas.get('cursor');
    }
  }; // click 


  EventController.prototype._onmousedown = function (pointInfo, shape, event) {
    //  mousedown  mousedownShape  mousedown 
    if (event.button === LEFT_BTN_CODE) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }

    this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown fromShape, toShape

  }; // mouseleave  mouseenter 
  // mouseenter  mouseover 


  EventController.prototype._emitMouseoverEvents = function (event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get('el');

    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);

        this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape); //  fromShape 


        if (!toShape || toShape.get('destroyed')) {
          el.style.cursor = this.canvas.get('cursor');
        }
      }

      if (toShape) {
        this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);

        this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);
      }
    }
  }; // dragover  mouseover mousemove


  EventController.prototype._emitDragoverEvents = function (event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);
        }

        this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);
      }

      if (!isCanvasEmit) {
        this._emitEvent('dragover', event, pointInfo, toShape);
      }
    } else if (fromShape) {
      // TODO:  drag  dragleave  toShape  null
      // 
      this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);
    }

    if (isCanvasEmit) {
      this._emitEvent('dragover', event, pointInfo, toShape);
    }
  }; // drag 


  EventController.prototype._afterDrag = function (draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set('capture', true); // 

      this.draggingShape = null;
    }

    this.dragging = false; // drag  draggingShape 

    var shape = this._getShape(pointInfo, event); //  enterleave 


    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }

    this.currentShape = shape; //  shape mouseleave 
  }; // 


  EventController.prototype._onmouseup = function (pointInfo, shape, event) {
    // eevent.button === 0  mouseup  click 
    // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
    if (event.button === LEFT_BTN_CODE) {
      var draggingShape = this.draggingShape;

      if (this.dragging) {
        //  drag 
        if (draggingShape) {
          this._emitEvent('drop', event, pointInfo, shape);
        }

        this._emitEvent('dragend', event, pointInfo, draggingShape);

        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent('mouseup', event, pointInfo, shape); //  mouseup  click


        if (shape === this.mousedownShape) {
          this._emitEvent('click', event, pointInfo, shape);
        }

        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  }; //  dragover  mousemove  dragenter, dragleave 


  EventController.prototype._ondragover = function (pointInfo, shape, event) {
    event.preventDefault(); //  dragover  preventDefault canvas  drop 

    var preShape = this.currentShape;

    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  }; //  mousemove 


  EventController.prototype._onmousemove = function (pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape; // 

    if (this.dragging) {
      // 
      if (draggingShape) {
        //  shape  dragenter, dragleave, dragover  drag 
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      } //  draggingShape  draggingShape  drag  canvas 
      //  canvas  drag 


      this._emitEvent('drag', event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;

      if (mousedownPoint) {
        //  drag 
        var mousedownShape = this.mousedownShape;
        var now = event.timeStamp;
        var timeWindow = now - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist = dx * dx + dy * dy;

        if (timeWindow > 120 || dist > CLICK_OFFSET) {
          if (mousedownShape && mousedownShape.get('draggable')) {
            //  draggable  shape  drag 
            draggingShape = this.mousedownShape; //  shape

            draggingShape.set('capture', false); //  dragover,dragenter,dragleave,drop

            this.draggingShape = draggingShape;
            this.dragging = true;

            this._emitEvent('dragstart', event, pointInfo, draggingShape); // 


            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get('draggable')) {
            //  draggable  canvas  drag 
            this.dragging = true;

            this._emitEvent('dragstart', event, pointInfo, null); // 


            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);

            this._emitEvent('mousemove', event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);

          this._emitEvent('mousemove', event, pointInfo, shape);
        }
      } else {
        //  mouse over 
        this._emitMouseoverEvents(event, pointInfo, preShape, shape); // 


        this._emitEvent('mousemove', event, pointInfo, shape);
      }
    }
  }; // 


  EventController.prototype._emitEvent = function (type, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape); //  shape 


    if (shape) {
      eventObj.shape = shape; //  shape 

      emitTargetEvent(shape, type, eventObj);
      var parent_1 = shape.getParent(); // 

      while (parent_1) {
        // 
        parent_1.emitDelegation(type, eventObj); // 

        if (!eventObj.propagationStopped) {
          bubbleEvent(parent_1, type, eventObj);
        }

        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      //  shape  canvas 
      var canvas = this.canvas; //  canvas 

      emitTargetEvent(canvas, type, eventObj);
    }
  };

  EventController.prototype.destroy = function () {
    // 
    this._clearEvents(); // 


    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };

  return EventController;
}();

var _default = EventController;
exports.default = _default;

/***/ }),
/* 741 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _container = _interopRequireDefault(__webpack_require__(379));

var AbstractGroup =
/** @class */
function (_super) {
  (0, _tslib.__extends)(AbstractGroup, _super);

  function AbstractGroup() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AbstractGroup.prototype.isGroup = function () {
    return true;
  };

  AbstractGroup.prototype.isEntityGroup = function () {
    return false;
  };

  AbstractGroup.prototype.clone = function () {
    var clone = _super.prototype.clone.call(this); // 


    var children = this.getChildren();

    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      clone.add(child.clone());
    }

    return clone;
  };

  return AbstractGroup;
}(_container.default);

var _default = AbstractGroup;
exports.default = _default;

/***/ }),
/* 742 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _element = _interopRequireDefault(__webpack_require__(380));

var _matrix = __webpack_require__(240);

var AbstractShape =
/** @class */
function (_super) {
  (0, _tslib.__extends)(AbstractShape, _super);

  function AbstractShape(cfg) {
    return _super.call(this, cfg) || this;
  } // 


  AbstractShape.prototype._isInBBox = function (refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  /**
   * 
   * @protected
   * @param {ShapeAttrs} targetAttrs 
   */


  AbstractShape.prototype.afterAttrsChange = function (targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);

    this.clearCacheBBox();
  }; // 


  AbstractShape.prototype.getBBox = function () {
    var bbox = this.cfg.bbox;

    if (!bbox) {
      bbox = this.calculateBBox();
      this.set('bbox', bbox);
    }

    return bbox;
  }; // 


  AbstractShape.prototype.getCanvasBBox = function () {
    var canvasBBox = this.cfg.canvasBBox;

    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set('canvasBBox', canvasBBox);
    }

    return canvasBBox;
  };

  AbstractShape.prototype.applyMatrix = function (matrix) {
    _super.prototype.applyMatrix.call(this, matrix); // 


    this.set('canvasBBox', null);
  };
  /**
   *  bbox
   * @return {BBox} 
   */


  AbstractShape.prototype.calculateCanvasBBox = function () {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX,
        minY = bbox.minY,
        maxX = bbox.maxX,
        maxY = bbox.maxY;

    if (totalMatrix) {
      var topLeft = (0, _matrix.multiplyVec2)(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = (0, _matrix.multiplyVec2)(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = (0, _matrix.multiplyVec2)(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = (0, _matrix.multiplyVec2)(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }

    var attrs = this.attrs; //  shadow  shadow

    if (attrs.shadowColor) {
      var _a = attrs.shadowBlur,
          shadowBlur = _a === void 0 ? 0 : _a,
          _b = attrs.shadowOffsetX,
          shadowOffsetX = _b === void 0 ? 0 : _b,
          _c = attrs.shadowOffsetY,
          shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY = Math.max(maxY, shadowBottom);
    }

    return {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  /**
   * @protected
   *  bbox
   */


  AbstractShape.prototype.clearCacheBBox = function () {
    this.set('bbox', null);
    this.set('canvasBBox', null);
  }; // 


  AbstractShape.prototype.isClipShape = function () {
    return this.get('isClipShape');
  };
  /**
   * @protected
   * 
   * @param  {number}  refX  x
   * @param  {number}  refY  Y
   * @return {boolean} 
   */


  AbstractShape.prototype.isInShape = function (refX, refY) {
    return false;
  };
  /**
   *  BBox 
   *  false imagemarker  BBox 
   * @return {Boolean}  BBox 
   */


  AbstractShape.prototype.isOnlyHitBox = function () {
    return false;
  }; //  Shape 


  AbstractShape.prototype.isHit = function (x, y) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');
    var vec = [x, y, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0],
        refY = vec[1];

    var inBBox = this._isInBBox(refX, refY); // 


    if (this.isOnlyHitBox()) {
      return inBBox;
    } // 


    if (inBBox && !this.isClipped(refX, refY)) {
      // 
      if (this.isInShape(refX, refY)) {
        return true;
      } // 


      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      } // 


      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }

    return false;
  };

  return AbstractShape;
}(_element.default);

var _default = AbstractShape;
exports.default = _default;

/***/ }),
/* 743 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getBBoxMethod", {
  enumerable: true,
  get: function get() {
    return _register.getMethod;
  }
});

var _register = __webpack_require__(744);

var _rect = _interopRequireDefault(__webpack_require__(745));

var _circle = _interopRequireDefault(__webpack_require__(746));

var _polyline = _interopRequireDefault(__webpack_require__(747));

var _polygon = _interopRequireDefault(__webpack_require__(753));

var _text = _interopRequireDefault(__webpack_require__(754));

var _path = _interopRequireDefault(__webpack_require__(755));

var _line = _interopRequireDefault(__webpack_require__(764));

var _ellipse = _interopRequireDefault(__webpack_require__(765));

(0, _register.register)('rect', _rect.default);
(0, _register.register)('image', _rect.default); // image  rect 

(0, _register.register)('circle', _circle.default);
(0, _register.register)('marker', _circle.default); // marker  circle 

(0, _register.register)('polyline', _polyline.default);
(0, _register.register)('polygon', _polygon.default);
(0, _register.register)('text', _text.default);
(0, _register.register)('path', _path.default);
(0, _register.register)('line', _line.default);
(0, _register.register)('ellipse', _ellipse.default);

/***/ }),
/* 744 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.register = register;
exports.getMethod = getMethod;
var cache = new Map();
/**
 * 
 * @param type 
 * @param method 
 */

function register(type, method) {
  cache.set(type, method);
}
/**
 * 
 * @param type 
 */


function getMethod(type) {
  return cache.get(type);
}

/***/ }),
/* 745 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(shape) {
  var attrs = shape.attr();
  var x = attrs.x,
      y = attrs.y,
      width = attrs.width,
      height = attrs.height;
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}

/***/ }),
/* 746 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(shape) {
  var _a = shape.attr(),
      x = _a.x,
      y = _a.y,
      r = _a.r;

  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}

/***/ }),
/* 747 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _gMath = __webpack_require__(35);

var _util = __webpack_require__(247);

function _default(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }

  var _a = _gMath.Util.getBBoxByArray(xArr, yArr),
      x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height;

  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = (0, _util.mergeArrowBBox)(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

/***/ }),
/* 748 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _line = _interopRequireDefault(__webpack_require__(178));

var _util = __webpack_require__(86);

var _bezier = __webpack_require__(396);

// 
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
} // 


function extrema(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;

  if ((0, _util.isNumberEqual)(a, 0)) {
    return [0.5];
  }

  var rst = (p0 - p1) / a;

  if (rst <= 1 && rst >= 0) {
    return [rst];
  }

  return [];
}

function derivativeAt(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
} // 


function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  // 
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t); // 

  var controlPoint1 = _line.default.pointAt(x1, y1, x2, y2, t); // 


  var controlPoint2 = _line.default.pointAt(x2, y2, x3, y3, t);

  return [[x1, y1, controlPoint1.x, controlPoint1.y, xt, yt], [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]];
} // 


function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return ((0, _util.distance)(x1, y1, x2, y2) + (0, _util.distance)(x2, y2, x3, y3) + (0, _util.distance)(x1, y1, x3, y3)) / 2;
  }

  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}

var _default = {
  box: function box(x1, y1, x2, y2, x3, y3) {
    var xExtrema = extrema(x1, x2, x3)[0];
    var yExtrema = extrema(y1, y2, y3)[0]; //  box 

    var xArr = [x1, x3];
    var yArr = [y1, y3];

    if (xExtrema !== undefined) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema));
    }

    if (yExtrema !== undefined) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema));
    }

    return (0, _util.getBBoxByArray)(xArr, yArr);
  },
  length: function length(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0) {
    return (0, _bezier.nearestPoint)([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return (0, _util.distance)(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function pointAt(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function divide(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt(x1, x2, x3, t);
    var dy = derivativeAt(y1, y2, y3, t);
    var angle = Math.atan2(dy, dx);
    return (0, _util.piMod)(angle);
  }
};
exports.default = _default;

/***/ }),
/* 749 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(86);

var _line = _interopRequireDefault(__webpack_require__(178));

var _bezier = __webpack_require__(396);

function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t; // t * t * t  Math.pow(t, 3) 

  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}

function derivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}

function extrema(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t2;
  var discSqrt;

  if ((0, _util.isNumberEqual)(a, 0)) {
    if (!(0, _util.isNumberEqual)(b, 0)) {
      t1 = -c / b;

      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;

    if ((0, _util.isNumberEqual)(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b + discSqrt) / (2 * a);
      t2 = (-b - discSqrt) / (2 * a);

      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }

      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }

  return extremas;
} // 


function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  // 
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t); // 

  var c1 = _line.default.pointAt(x1, y1, x2, y2, t);

  var c2 = _line.default.pointAt(x2, y2, x3, y3, t);

  var c3 = _line.default.pointAt(x3, y3, x4, y4, t);

  var c12 = _line.default.pointAt(c1.x, c1.y, c2.x, c2.y, t);

  var c23 = _line.default.pointAt(c2.x, c2.y, c3.x, c3.y, t);

  return [[x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt], [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]];
} // 


function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return (0, _bezier.snapLength)([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }

  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}

var _default = {
  extrema: extrema,
  box: function box(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema = extrema(x1, x2, x3, x4);
    var yExtrema = extrema(y1, y2, y3, y4);

    for (var i = 0; i < xExtrema.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));
    }

    for (var i = 0; i < yExtrema.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));
    }

    return (0, _util.getBBoxByArray)(xArr, yArr);
  },
  length: function length(x1, y1, x2, y2, x3, y3, x4, y4) {
    //  8 
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
    return (0, _bezier.nearestPoint)([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length);
  },
  pointDistance: function pointDistance(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);
    return (0, _util.distance)(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function pointAt(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function divide(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function tangentAngle(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt(x1, x2, x3, x4, t);
    var dy = derivativeAt(y1, y2, y3, y4, t);
    return (0, _util.piMod)(Math.atan2(dy, dx));
  }
};
exports.default = _default;

/***/ }),
/* 750 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(86);

var _ellipse = _interopRequireDefault(__webpack_require__(751));

//  x
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle) - ry * Math.sin(xRotation) * Math.cos(angle);
} //  y


function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle) + ry * Math.cos(xRotation) * Math.cos(angle);
} // x 


function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
} // y 


function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
} //  x 


function xAt(cx, cy, rx, ry, xRotation, angle) {
  return rx * Math.cos(xRotation) * Math.cos(angle) - ry * Math.sin(xRotation) * Math.sin(angle) + cx;
} //  y 


function yAt(cx, cy, rx, ry, xRotation, angle) {
  return rx * Math.sin(xRotation) * Math.cos(angle) + ry * Math.cos(xRotation) * Math.sin(angle) + cy;
} // 


function getAngle(rx, ry, x0, y0) {
  var angle = Math.atan2(y0 * rx, x0 * ry); //  0 - 2PI 

  return (angle + Math.PI * 2) % (Math.PI * 2);
} // x,y


function getPoint(rx, ry, angle) {
  return {
    x: rx * Math.cos(angle),
    y: ry * Math.sin(angle)
  };
} // 


function rotate(x, y, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return [x * cos - y * sin, x * sin + y * cos];
}

var _default = {
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @return {object} 
   */
  box: function box(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];

    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;

      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }

    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);

      if (x < minX) {
        minX = x;
      }

      if (x > maxX) {
        maxX = x;
      }
    }

    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];

    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;

      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }

    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);

      if (y < minY) {
        minY = y;
      }

      if (y > maxY) {
        maxY = y;
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },

  /**
   * 
   *  rx, ry, startAngle, endAngle 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   */
  length: function length(cx, cy, rx, ry, xRotation, startAngle, endAngle) {},

  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @param {number} x0          x
   * @param {number} y0          y
   * @return {object} 
   */
  nearestPoint: function nearestPoint(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    //  0,0 
    var relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0],
        y1 = relativeVector[1]; // 

    var relativePoint = _ellipse.default.nearestPoint(0, 0, rx, ry, x1, y1); // 


    var angle = getAngle(rx, ry, relativePoint.x, relativePoint.y); // 

    if (angle < startAngle) {
      // 
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle > endAngle) {
      // 
      relativePoint = getPoint(rx, ry, endAngle);
    } //  xRotation 


    var vector = rotate(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function pointDistance(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return (0, _util.distance)(nearestPoint.x, nearestPoint.y, x0, y0);
  },
  pointAt: function pointAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle),
      y: yAt(cx, cy, rx, ry, xRotation, angle)
    };
  },
  tangentAngle: function tangentAngle(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle);
    return (0, _util.piMod)(Math.atan2(dy, dx));
  }
};
exports.default = _default;

/***/ }),
/* 751 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(86);

/**
 * @fileoverview 
 *  - https://www.mathsisfun.com/geometry/ellipse-perimeter.html
 *  - https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/
 * @author dxq613@gmail.com
 */
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}

var _default = {
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {object} 
   */
  box: function box(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },

  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {number} 
   */
  length: function length(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },

  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {object} 
   */
  nearestPoint: function nearestPoint(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry; // 0

    if (a === 0 || b === 0) {
      return {
        x: x,
        y: y
      };
    } //  0 0 


    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b; // const angle0 = Math.atan2(relativeY, relativeX);

    var t = Math.PI / 4;
    var nearestX; // 

    var nearestY; //  4 

    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }

    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },

  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {number} 
   */
  pointDistance: function pointDistance(x, y, rx, ry, x0, y0) {
    var nearestPoint = this.nearestPoint(x, y, rx, ry, x0, y0);
    return (0, _util.distance)(nearestPoint.x, nearestPoint.y, x0, y0);
  },

  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t x 0
   * @return {object} 
   */
  pointAt: function pointAt(x, y, rx, ry, t) {
    var angle = 2 * Math.PI * t; // 

    return {
      x: x + rx * Math.cos(angle),
      y: y + ry * Math.sin(angle)
    };
  },

  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t  0 - 1 x 0 0-1  null
   * @return {number}  0 - 2PI 
   */
  tangentAngle: function tangentAngle(x, y, rx, ry, t) {
    var angle = 2 * Math.PI * t; // 
    //  x,y  x' = -rx * sin(t); y' = ry * cos(t);

    var tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle)); // 
    // const point = this.pointAt(0, 0, rx, ry, t); // 
    // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));
    // if (angle >= 0 && angle <= Math.PI) {
    //   tangentAngle += Math.PI;
    // }

    return (0, _util.piMod)(tangentAngle);
  }
};
exports.default = _default;

/***/ }),
/* 752 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _segments = __webpack_require__(397);

var _polyline = _interopRequireDefault(__webpack_require__(398));

function getAllPoints(points) {
  var tmp = points.slice(0);

  if (points.length) {
    tmp.push(points[0]);
  }

  return tmp;
}

var _default = {
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  box: function box(points) {
    return _polyline.default.box(points);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  length: function length(points) {
    return (0, _segments.lengthOfSegment)(getAllPoints(points));
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  pointAt: function pointAt(points, t) {
    return (0, _segments.pointAtSegments)(getAllPoints(points), t);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} x  x
   * @param {number} y  y
   * @return {number} 
   */
  pointDistance: function pointDistance(points, x, y) {
    return (0, _segments.distanceAtSegment)(getAllPoints(points), x, y);
  },

  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  tangentAngle: function tangentAngle(points, t) {
    return (0, _segments.angleAtSegments)(getAllPoints(points), t);
  }
};
exports.default = _default;

/***/ }),
/* 753 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _gMath = __webpack_require__(35);

function _default(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }

  return _gMath.Util.getBBoxByArray(xArr, yArr);
}

/***/ }),
/* 754 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _text = __webpack_require__(399);

function _default(shape) {
  var attrs = shape.attr();
  var x = attrs.x,
      y = attrs.y,
      text = attrs.text,
      fontSize = attrs.fontSize,
      lineHeight = attrs.lineHeight;
  var font = attrs.font;

  if (!font) {
    //  font
    font = (0, _text.assembleFont)(attrs);
  }

  var width = (0, _text.getTextWidth)(text, font);
  var bbox;

  if (!width) {
    // width
    bbox = {
      x: x,
      y: y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign,
        textBaseline = attrs.textBaseline;
    var height = (0, _text.getTextHeight)(text, fontSize, lineHeight); // attrs.height
    // left,  bottom

    var point = {
      x: x,
      y: y - height
    };

    if (textAlign) {
      if (textAlign === 'end' || textAlign === 'right') {
        point.x -= width;
      } else if (textAlign === 'center') {
        point.x -= width / 2;
      }
    }

    if (textBaseline) {
      if (textBaseline === 'top') {
        point.y += height;
      } else if (textBaseline === 'middle') {
        point.y += height / 2;
      }
    }

    bbox = {
      x: point.x,
      y: point.y,
      width: width,
      height: height
    };
  }

  return bbox;
}

/***/ }),
/* 755 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _gMath = __webpack_require__(35);

var _pathUtil = __webpack_require__(95);

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(247);

function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint;
    var box = void 0;

    switch (segment.command) {
      case 'Q':
        box = _gMath.Quad.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;

      case 'C':
        box = _gMath.Cubic.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;

      case 'A':
        var arcParams = segment.arcParams;
        box = _gMath.Arc.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;

      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }

    if (box) {
      segment.box = box;
      xArr.push(box.x, box.x + box.width);
      yArr.push(box.y, box.y + box.height);
    }

    if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  } // bbox calculation should ignore NaN for path attribute
  // ref: https://github.com/antvis/g/issues/210


  xArr = xArr.filter(function (item) {
    return !Number.isNaN(item);
  });
  yArr = yArr.filter(function (item) {
    return !Number.isNaN(item);
  });
  var minX = Math.min.apply(null, xArr);
  var minY = Math.min.apply(null, yArr);
  var maxX = Math.max.apply(null, xArr);
  var maxY = Math.max.apply(null, yArr);

  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;

    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }

    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}

function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint,
      currentPoint = segment.currentPoint,
      nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2); //  currentPoint 

  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext))); //  0  PI 
  // :  0  0 

  if (!currentAngle || Math.sin(currentAngle) === 0 || (0, _util.isNumberEqual)(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }

  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1])); // 

  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle; // 
  // 

  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}

function _default(shape) {
  var attrs = shape.attr();
  var path = attrs.path,
      stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0; //  stroke lineWidth 

  var segments = shape.get('segments') || (0, _pathUtil.path2Segments)(path);

  var _a = getPathBox(segments, lineWidth),
      x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height;

  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = (0, _util2.mergeArrowBBox)(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

/***/ }),
/* 756 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = catmullRom2Bezier;

// http://schepers.cc/getting-to-the-point
function catmullRom2Bezier(crp, z) {
  var d = []; // @ts-ignore

  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [{
      x: +crp[i - 2],
      y: +crp[i - 1]
    }, {
      x: +crp[i],
      y: +crp[i + 1]
    }, {
      x: +crp[i + 2],
      y: +crp[i + 3]
    }, {
      x: +crp[i + 4],
      y: +crp[i + 5]
    }];

    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }

    d.push(['C', (-p[0].x + 6 * p[1].x + p[2].x) / 6, (-p[0].y + 6 * p[1].y + p[2].y) / 6, (p[1].x + 6 * p[2].x - p[3].x) / 6, (p[1].y + 6 * p[2].y - p[3].y) / 6, p[2].x, p[2].y]);
  }

  return d;
}

/***/ }),
/* 757 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fillPath;

function decasteljau(points, t) {
  var left = [];
  var right = [];

  function recurse(points, t) {
    if (points.length === 1) {
      left.push(points[0]);
      right.push(points[0]);
    } else {
      var middlePoints = [];

      for (var i = 0; i < points.length - 1; i++) {
        if (i === 0) {
          left.push(points[0]);
        }

        if (i === points.length - 2) {
          right.push(points[i + 1]);
        }

        middlePoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];
      }

      recurse(middlePoints, t);
    }
  }

  if (points.length) {
    recurse(points, t);
  }

  return {
    left: left,
    right: right.reverse()
  };
}

function splitCurve(start, end, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];

  if (end[0] === 'A') {
    points.push(end[6]);
    points.push(end[7]);
  } else if (end[0] === 'C') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
    points.push([end[5], end[6]]);
  } else if (end[0] === 'S' || end[0] === 'Q') {
    points.push([end[1], end[2]]);
    points.push([end[3], end[4]]);
  } else {
    points.push([end[1], end[2]]);
  }

  var leftSegments = points;
  var t = 1 / count;

  for (var i = 0; i < count - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }

  segments.push(leftSegments);
  var result = segments.map(function (segment) {
    var cmd = [];

    if (segment.length === 4) {
      cmd.push('C');
      cmd = cmd.concat(segment[2]);
    }

    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push('Q');
      }

      cmd = cmd.concat(segment[1]);
    }

    if (segment.length === 2) {
      cmd.push('L');
    }

    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}

function splitSegment(start, end, count) {
  if (count === 1) {
    return [[].concat(start)];
  }

  var segments = [];

  if (end[0] === 'L' || end[0] === 'C' || end[0] === 'Q') {
    segments = segments.concat(splitCurve(start, end, count));
  } else {
    var temp = [].concat(start);

    if (temp[0] === 'M') {
      temp[0] = 'L';
    }

    for (var i = 0; i <= count - 1; i++) {
      segments.push(temp);
    }
  }

  return segments;
}

function fillPath(source, target) {
  if (source.length === 1) {
    return source;
  }

  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];

  if (source.length === 1 && source[0][0] === 'M') {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }

    return source;
  }

  for (var i = 0; i < targetLen; i++) {
    var index = Math.floor(ratio * i);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }

  var filled = segmentsToFill.reduce(function (filled, count, i) {
    if (i === sourceLen) {
      return filled.concat(source[sourceLen]);
    }

    return filled.concat(splitSegment(source[i], source[i + 1], count));
  }, []);
  filled.unshift(source[0]);

  if (target[targetLen] === 'Z' || target[targetLen] === 'z') {
    filled.push('Z');
  }

  return filled;
}

/***/ }),
/* 758 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fillPathByDiff;

var _util = __webpack_require__(0);

function getMinDiff(del, add, modify) {
  var type = null;
  var min = modify;

  if (add < min) {
    min = add;
    type = 'add';
  }

  if (del < min) {
    min = del;
    type = 'del';
  }

  return {
    type: type,
    min: min
  };
}
/*
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 * path
 */


var levenshteinDistance = function levenshteinDistance(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment, targetSegment;
  var temp = 0;

  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }

  var dist = [];

  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = {
      min: i
    };
  }

  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = {
      min: j
    };
  }

  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];

    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target[j - 1];

      if ((0, _util.isEqual)(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }

      var del = dist[i - 1][j].min + 1;
      var add = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add, modify);
    }
  }

  return dist;
};

function fillPathByDiff(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1; // sourcetarget
  // @ts-ignore

  if (diffMatrix[sourceLen][targetLen] !== sourceLen) {
    // sourcetarget
    for (var i = 1; i <= sourceLen; i++) {
      var min = diffMatrix[i][i].min;
      minPos = i;

      for (var j = index; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min) {
          min = diffMatrix[i][j].min;
          minPos = j;
        }
      }

      index = minPos;

      if (diffMatrix[i][index].type) {
        changes.push({
          index: i - 1,
          type: diffMatrix[i][index].type
        });
      }
    } // sourcepath


    for (var i = changes.length - 1; i >= 0; i--) {
      index = changes[i].index;

      if (changes[i].type === 'add') {
        // @ts-ignore
        source.splice(index, 0, [].concat(source[index]));
      } else {
        // @ts-ignore
        source.splice(index, 1);
      }
    }
  } // source


  sourceLen = source.length;

  if (sourceLen < targetLen) {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      if (source[sourceLen - 1][0] === 'z' || source[sourceLen - 1][0] === 'Z') {
        // @ts-ignore
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        // @ts-ignore
        source.push(source[sourceLen - 1]);
      }
    }
  }

  return source;
}

/***/ }),
/* 759 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatPath;

/*
 * pathSegment
 * M,L,A,Q,H,V
 * Q, S
 * C
 */
function _getSegmentPoints(segment) {
  var points = [];

  switch (segment[0]) {
    case 'M':
      points.push([segment[1], segment[2]]);
      break;

    case 'L':
      points.push([segment[1], segment[2]]);
      break;

    case 'A':
      points.push([segment[6], segment[7]]);
      break;

    case 'Q':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'T':
      points.push([segment[1], segment[2]]);
      break;

    case 'C':
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;

    case 'S':
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;

    case 'H':
      points.push([segment[1], segment[1]]);
      break;

    case 'V':
      points.push([segment[1], segment[1]]);
      break;

    default:
  }

  return points;
} // count


function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t = 1 / (count + 1);

  var formerEnd = _getSegmentPoints(former)[0];

  for (var i = 1; i <= count; i++) {
    t *= i;
    index = Math.floor(points.length * t);

    if (index === 0) {
      result.unshift([formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    } else {
      result.splice(index, 0, [formerEnd[0] * t + points[index][0] * (1 - t), formerEnd[1] * t + points[index][1] * (1 - t)]);
    }
  }

  return result;
}

function formatPath(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }

  var points;

  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      // fromPathpathSegmenttoPath
      points = _getSegmentPoints(fromPath[i]);

      switch (toPath[i][0]) {
        case 'M':
          fromPath[i] = ['M'].concat(points[0]);
          break;

        case 'L':
          fromPath[i] = ['L'].concat(points[0]);
          break;

        case 'A':
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points[0][0];
          fromPath[i][7] = points[0][1];
          break;

        case 'Q':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['Q'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'T':
          fromPath[i] = ['T'].concat(points[0]);
          break;

        case 'C':
          if (points.length < 3) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['C'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        case 'S':
          if (points.length < 2) {
            if (i > 0) {
              points = _splitPoints(points, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }

          fromPath[i] = ['S'].concat(points.reduce(function (arr, i) {
            return arr.concat(i);
          }, []));
          break;

        default:
          fromPath[i] = toPath[i];
      }
    }
  }

  return fromPath;
}

/***/ }),
/* 760 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pathIntersection;

var _util = __webpack_require__(0);

var _rectPath = _interopRequireDefault(__webpack_require__(402));

var _path2Curve = _interopRequireDefault(__webpack_require__(403));

var base3 = function base3(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};

var bezlen = function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }

  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;

  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }

  return z2 * sum;
};

var curveDim = function curveDim(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;

  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }

    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }

      t = -c / b;

      if (t > 0 && t < 1) {
        tvalues.push(t);
      }

      continue;
    }

    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);

    if (b2ac < 0) {
      continue;
    }

    var t1 = (-b + sqrtb2ac) / (2 * a);

    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }

    var t2 = (-b - sqrtb2ac) / (2 * a);

    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }

  var j = tvalues.length;
  var jlen = j;
  var mt;

  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }

  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};

var intersect = function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }

  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

  if (!denominator) {
    return;
  }

  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);

  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }

  return {
    x: px,
    y: py
  };
};

var isPointInsideBBox = function isPointInsideBBox(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};

var box = function box(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }

  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }

  return {
    x: x,
    y: y,
    width: width,
    w: width,
    height: height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: (0, _rectPath.default)(x, y, width, height),
    vb: [x, y, width, height].join(' ')
  };
};

var isBBoxIntersect = function isBBoxIntersect(bbox1, bbox2) {
  // @ts-ignore
  bbox1 = box(bbox1); // @ts-ignore

  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};

var bezierBBox = function bezierBBox(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!(0, _util.isArray)(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }

  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};

var findDotsAtSegment = function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI; // (mx > nx || my < ny) && (alpha += 180);

  return {
    x: x,
    y: y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha: alpha
  };
};

var interHelper = function interHelper(bez1, bez2, justCount) {
  // @ts-ignore
  var bbox1 = bezierBBox(bez1); // @ts-ignore

  var bbox2 = bezierBBox(bez2);

  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }

  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];

  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }

  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }

  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
      var cj = Math.abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
      var is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);

      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }

        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);

        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            // @ts-ignore
            res++;
          } else {
            // @ts-ignore
            res.push({
              x: is.x,
              y: is.y,
              t1: t1,
              t2: t2
            });
          }
        }
      }
    }
  }

  return res;
};

var interPathHelper = function interPathHelper(path1, path2, justCount) {
  // @ts-ignore
  path1 = (0, _path2Curve.default)(path1); // @ts-ignore

  path2 = (0, _path2Curve.default)(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];

  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi = path1[i];

    if (pi[0] === 'M') {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] === 'C') {
        bez1 = [x1, y1].concat(pi.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }

      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];

        if (pj[0] === 'M') {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === 'C') {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }

          var intr = interHelper(bez1, bez2, justCount);

          if (justCount) {
            // @ts-ignore
            res += intr;
          } else {
            // @ts-ignore
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            } // @ts-ignore


            res = res.concat(intr);
          }
        }
      }
    }
  }

  return res;
};

function pathIntersection(path1, path2) {
  // @ts-ignore
  return interPathHelper(path1, path2);
}

/***/ }),
/* 761 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parsePathArray;
var p2s = /,?([a-z]),?/gi;

function parsePathArray(path) {
  return path.join(',').replace(p2s, '$1');
}

/***/ }),
/* 762 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getSegments;

var _getArcParams = _interopRequireWildcard(__webpack_require__(406));

var _parsePath = _interopRequireDefault(__webpack_require__(401));

// 
function toSymmetry(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}

function getSegments(path) {
  path = (0, _parsePath.default)(path);
  var segments = [];
  var currentPoint = null; // 

  var nextParams = null; //  path 

  var startMovePoint = null; //  M 

  var lastStartMovePointIndex = 0; //  M 

  var count = path.length;

  for (var i = 0; i < count; i++) {
    var params = path[i];
    nextParams = path[i + 1];
    var command = params[0]; // 

    var segment = {
      command: command,
      prePoint: currentPoint,
      params: params,
      startTangent: null,
      endTangent: null
    };

    switch (command) {
      case 'M':
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;

      case 'A':
        var arcParams = (0, _getArcParams.default)(currentPoint, params);
        segment['arcParams'] = arcParams;
        break;

      default:
        break;
    }

    if (command === 'Z') {
      //  Z  M 
      currentPoint = startMovePoint; //  Z M  M 

      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }

    if (nextParams && nextParams[0] === 'Z') {
      //  Z M 
      nextParams = path[lastStartMovePointIndex];

      if (segments[lastStartMovePointIndex]) {
        //  Z M 
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }

    segment['currentPoint'] = currentPoint; //  M  M 

    if (segments[lastStartMovePointIndex] && (0, _getArcParams.isSamePoint)(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }

    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment['nextPoint'] = nextPoint; // Add startTangent and endTangent

    var prePoint = segment.prePoint;

    if (['L', 'H', 'V'].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === 'Q') {
      // 
      var cp = [params[1], params[2]]; //  currentPoint

      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === 'T') {
      var preSegment = segments[i - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);

      if (preSegment.command === 'Q') {
        segment.command = 'Q';
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = 'TL';
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === 'C') {
      // 
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
    } else if (command === 'S') {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];

      if (preSegment.command === 'C') {
        segment.command = 'C'; //  S  C 

        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = 'SQ'; //  S  SQ 

        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === 'A') {
      var d = 0.001;

      var _a = segment['arcParams'] || {},
          _b = _a.cx,
          cx = _b === void 0 ? 0 : _b,
          _c = _a.cy,
          cy = _c === void 0 ? 0 : _c,
          _d = _a.rx,
          rx = _d === void 0 ? 0 : _d,
          _e = _a.ry,
          ry = _e === void 0 ? 0 : _e,
          _f = _a.sweepFlag,
          sweepFlag = _f === void 0 ? 0 : _f,
          _g = _a.startAngle,
          startAngle = _g === void 0 ? 0 : _g,
          _h = _a.endAngle,
          endAngle = _h === void 0 ? 0 : _h;

      if (sweepFlag === 0) {
        d *= -1;
      }

      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }

    segments.push(segment);
  }

  return segments;
}

/***/ }),
/* 763 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isPolygonsIntersect;

var _pointInPolygon = _interopRequireDefault(__webpack_require__(408));

var _getLineIntersect = _interopRequireDefault(__webpack_require__(407));

var _util = __webpack_require__(0);

function parseToLines(points) {
  var lines = [];
  var count = points.length;

  for (var i = 0; i < count - 1; i++) {
    var point = points[i];
    var next = points[i + 1];
    lines.push({
      from: {
        x: point[0],
        y: point[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }

  if (lines.length > 1) {
    var first = points[0];
    var last = points[count - 1];
    lines.push({
      from: {
        x: last[0],
        y: last[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }

  return lines;
}

function lineIntersectPolygon(lines, line) {
  var isIntersect = false;
  (0, _util.each)(lines, function (l) {
    if ((0, _getLineIntersect.default)(l.from, l.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}

function getBBox(points) {
  var xArr = points.map(function (p) {
    return p[0];
  });
  var yArr = points.map(function (p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}

function intersectBBox(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}

function isPolygonsIntersect(points1, points2) {
  //  false
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }

  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2); // 

  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }

  var isIn = false; // 

  (0, _util.each)(points2, function (point) {
    if ((0, _pointInPolygon.default)(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });

  if (isIn) {
    return true;
  } // 


  (0, _util.each)(points1, function (point) {
    if ((0, _pointInPolygon.default)(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });

  if (isIn) {
    return true;
  }

  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  (0, _util.each)(lines2, function (line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}

/***/ }),
/* 764 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _util = __webpack_require__(247);

function _default(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1,
      y1 = attrs.y1,
      x2 = attrs.x2,
      y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX: minX,
    maxX: maxX,
    minY: minY,
    maxY: maxY
  };
  bbox = (0, _util.mergeArrowBBox)(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

/***/ }),
/* 765 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(shape) {
  var attrs = shape.attr();
  var x = attrs.x,
      y = attrs.y,
      rx = attrs.rx,
      ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}

/***/ }),
/* 766 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  getAdjust: true,
  registerAdjust: true,
  Adjust: true
};
Object.defineProperty(exports, "Adjust", {
  enumerable: true,
  get: function get() {
    return _adjust.default;
  }
});
exports.registerAdjust = exports.getAdjust = void 0;

var _adjust = _interopRequireDefault(__webpack_require__(111));

var _interface = __webpack_require__(410);

Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
var ADJUST_MAP = {};
/**
 *  Adjust 
 * @param type
 */

var getAdjust = function getAdjust(type) {
  return ADJUST_MAP[type.toLowerCase()];
};
/**
 *  Adjust
 * @param type
 * @param ctor
 */


exports.getAdjust = getAdjust;

var registerAdjust = function registerAdjust(type, ctor) {
  //  type 
  if (getAdjust(type)) {
    throw new Error("Adjust type '" + type + "' existed.");
  } //  map 


  ADJUST_MAP[type.toLowerCase()] = ctor;
};

exports.registerAdjust = registerAdjust;

/***/ }),
/* 767 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _ = _interopRequireWildcard(__webpack_require__(0));

var _constant = __webpack_require__(248);

var _adjust = _interopRequireDefault(__webpack_require__(111));

var Dodge =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Dodge, _super);

  function Dodge(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.cacheMap = {};
    _this.adjustDataArray = [];
    _this.mergeData = [];
    var _a = cfg.marginRatio,
        marginRatio = _a === void 0 ? _constant.MARGIN_RATIO : _a,
        _b = cfg.dodgeRatio,
        dodgeRatio = _b === void 0 ? _constant.DODGE_RATIO : _b,
        dodgeBy = cfg.dodgeBy,
        intervalPadding = cfg.intervalPadding,
        dodgePadding = cfg.dodgePadding,
        xDimensionLength = cfg.xDimensionLength,
        groupNum = cfg.groupNum,
        defaultSize = cfg.defaultSize,
        maxColumnWidth = cfg.maxColumnWidth,
        minColumnWidth = cfg.minColumnWidth,
        columnWidthRatio = cfg.columnWidthRatio;
    _this.marginRatio = marginRatio;
    _this.dodgeRatio = dodgeRatio;
    _this.dodgeBy = dodgeBy;
    _this.intervalPadding = intervalPadding;
    _this.dodgePadding = dodgePadding;
    _this.xDimensionLegenth = xDimensionLength;
    _this.groupNum = groupNum;
    _this.defaultSize = defaultSize;
    _this.maxColumnWidth = maxColumnWidth;
    _this.minColumnWidth = minColumnWidth;
    _this.columnWidthRatio = columnWidthRatio;
    return _this;
  }

  Dodge.prototype.process = function (groupDataArray) {
    var groupedDataArray = _.clone(groupDataArray); // 


    var mergeData = _.flatten(groupedDataArray);

    var dodgeBy = this.dodgeBy; //  dim 

    var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;
    this.cacheMap = {};
    this.adjustDataArray = adjustDataArray;
    this.mergeData = mergeData;
    this.adjustData(adjustDataArray, mergeData);
    this.adjustDataArray = [];
    this.mergeData = [];
    return groupedDataArray;
  };

  Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {
    var _this = this;

    var map = this.getDistribution(dim);
    var groupData = this.groupData(data, dim); // 

    _.each(groupData, function (group, key) {
      var range; // xField  dodge

      if (values.length === 1) {
        range = {
          pre: values[0] - 1,
          next: values[0] + 1
        };
      } else {
        // 
        range = _this.getAdjustRange(dim, parseFloat(key), values);
      }

      _.each(group, function (d) {
        var value = d[dim];
        var valueArr = map[value];
        var valIndex = valueArr.indexOf(frameIndex);
        d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
      });
    });

    return [];
  };

  Dodge.prototype.getDodgeOffset = function (range, idx, len) {
    var _a = this,
        dodgeRatio = _a.dodgeRatio,
        marginRatio = _a.marginRatio,
        intervalPadding = _a.intervalPadding,
        dodgePadding = _a.dodgePadding;

    var pre = range.pre,
        next = range.next;
    var tickLength = next - pre;
    var position; // 

    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {
      // intervalPadding
      var offset = this.getIntervalOnlyOffset(len, idx);
      position = pre + offset;
    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {
      // dodgePadding
      var offset = this.getDodgeOnlyOffset(len, idx);
      position = pre + offset;
    } else if (!_.isNil(intervalPadding) && !_.isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
      // intervalPaddingdodgePadding
      var offset = this.getIntervalAndDodgeOffset(len, idx);
      position = pre + offset;
    } else {
      // 
      var width = tickLength * dodgeRatio / len;
      var margin = marginRatio * width;
      var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
      position = (pre + next) / 2 + offset;
    }

    return position;
  };

  Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {
    var _a = this,
        defaultSize = _a.defaultSize,
        intervalPadding = _a.intervalPadding,
        xDimensionLegenth = _a.xDimensionLegenth,
        groupNum = _a.groupNum,
        dodgeRatio = _a.dodgeRatio,
        maxColumnWidth = _a.maxColumnWidth,
        minColumnWidth = _a.minColumnWidth,
        columnWidthRatio = _a.columnWidthRatio;

    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len; // columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth

    geomWidth = !_.isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;

    if (!_.isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }

    if (!_.isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }

    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth; // 

    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };

  Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {
    var _a = this,
        defaultSize = _a.defaultSize,
        dodgePadding = _a.dodgePadding,
        xDimensionLegenth = _a.xDimensionLegenth,
        groupNum = _a.groupNum,
        marginRatio = _a.marginRatio,
        maxColumnWidth = _a.maxColumnWidth,
        minColumnWidth = _a.minColumnWidth,
        columnWidthRatio = _a.columnWidthRatio;

    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len; // columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth

    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;

    if (!_.isNil(maxColumnWidth)) {
      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
      geomWidth = Math.min(geomWidth, normalizedMaxWidht);
    }

    if (!_.isNil(minColumnWidth)) {
      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
      geomWidth = Math.max(geomWidth, normalizedMinWidht);
    }

    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth; // 

    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };

  Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {
    var _a = this,
        intervalPadding = _a.intervalPadding,
        dodgePadding = _a.dodgePadding,
        xDimensionLegenth = _a.xDimensionLegenth,
        groupNum = _a.groupNum;

    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
    return offset;
  };

  Dodge.prototype.getDistribution = function (dim) {
    var groupedDataArray = this.adjustDataArray;
    var cacheMap = this.cacheMap;
    var map = cacheMap[dim];

    if (!map) {
      map = {};

      _.each(groupedDataArray, function (data, index) {
        var values = _.valuesOfKey(data, dim);

        if (!values.length) {
          values.push(0);
        }

        _.each(values, function (val) {
          if (!map[val]) {
            map[val] = [];
          }

          map[val].push(index);
        });
      });

      cacheMap[dim] = map;
    }

    return map;
  };

  return Dodge;
}(_adjust.default);

var _default = Dodge;
exports.default = _default;

/***/ }),
/* 768 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _ = _interopRequireWildcard(__webpack_require__(0));

var _constant = __webpack_require__(248);

var _adjust = _interopRequireDefault(__webpack_require__(111));

function randomNumber(min, max) {
  return (max - min) * Math.random() + min;
}

var Jitter =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Jitter, _super);

  function Jitter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Jitter.prototype.process = function (groupDataArray) {
    var groupedDataArray = _.clone(groupDataArray); // 


    var mergeData = _.flatten(groupedDataArray); // 


    this.adjustData(groupedDataArray, mergeData);
    return groupedDataArray;
  };
  /**
   * index dim  jitter 
   * @param dim
   * @param values
   * @param dataArray
   */


  Jitter.prototype.adjustDim = function (dim, values, dataArray) {
    var _this = this; //  dim 


    var groupDataArray = this.groupData(dataArray, dim);
    return _.each(groupDataArray, function (data, dimValue) {
      return _this.adjustGroup(data, dim, parseFloat(dimValue), values);
    });
  }; // 


  Jitter.prototype.getAdjustOffset = function (range) {
    var pre = range.pre,
        next = range.next; // 

    var margin = (next - pre) * _constant.GAP;
    return randomNumber(pre + margin, next - margin);
  }; // adjust group data


  Jitter.prototype.adjustGroup = function (group, dim, dimValue, values) {
    var _this = this; // 


    var range = this.getAdjustRange(dim, dimValue, values);

    _.each(group, function (data) {
      data[dim] = _this.getAdjustOffset(range); // 
    });

    return group;
  };

  return Jitter;
}(_adjust.default);

var _default = Jitter;
exports.default = _default;

/***/ }),
/* 769 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _ = _interopRequireWildcard(__webpack_require__(0));

var _adjust = _interopRequireDefault(__webpack_require__(111));

var Cache = _.Cache;

var Stack =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Stack, _super);

  function Stack(cfg) {
    var _this = _super.call(this, cfg) || this;

    var _a = cfg.adjustNames,
        adjustNames = _a === void 0 ? ['y'] : _a,
        _b = cfg.height,
        height = _b === void 0 ? NaN : _b,
        _c = cfg.size,
        size = _c === void 0 ? 10 : _c,
        _d = cfg.reverseOrder,
        reverseOrder = _d === void 0 ? false : _d;
    _this.adjustNames = adjustNames;
    _this.height = height;
    _this.size = size;
    _this.reverseOrder = reverseOrder;
    return _this;
  }
  /**
   * 
   * @param groupDataArray 
   */


  Stack.prototype.process = function (groupDataArray) {
    var _a = this,
        yField = _a.yField,
        reverseOrder = _a.reverseOrder; //  y  y  stack
    // 


    var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
    return reverseOrder ? this.reverse(d) : d;
  };

  Stack.prototype.reverse = function (groupedDataArray) {
    return groupedDataArray.slice(0).reverse();
  };

  Stack.prototype.processStack = function (groupDataArray) {
    var _a = this,
        xField = _a.xField,
        yField = _a.yField,
        reverseOrder = _a.reverseOrder; // 


    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray; // 

    var positive = new Cache();
    var negative = new Cache();
    return groupedDataArray.map(function (dataArray) {
      return dataArray.map(function (data) {
        var _a;

        var x = _.get(data, xField, 0);

        var y = _.get(data, [yField]);

        var xKey = x.toString(); // todo  _origin y  symmetric stack

        y = _.isArray(y) ? y[1] : y;

        if (!_.isNil(y)) {
          var cache = y >= 0 ? positive : negative;

          if (!cache.has(xKey)) {
            cache.set(xKey, 0);
          }

          var xValue = cache.get(xKey);
          var newXValue = y + xValue; // 

          cache.set(xKey, newXValue);
          return (0, _tslib.__assign)((0, _tslib.__assign)({}, data), (_a = {}, _a[yField] = [xValue, newXValue], _a));
        } // 


        return data;
      });
    });
  };

  Stack.prototype.processOneDimStack = function (groupDataArray) {
    var _this = this;

    var _a = this,
        xField = _a.xField,
        height = _a.height,
        reverseOrder = _a.reverseOrder;

    var yField = 'y'; // 

    var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray; // 

    var cache = new Cache();
    return groupedDataArray.map(function (dataArray) {
      return dataArray.map(function (data) {
        var _a;

        var size = _this.size;
        var xValue = data[xField]; // todo  stack 

        var stackHeight = size * 2 / height;

        if (!cache.has(xValue)) {
          cache.set(xValue, stackHeight / 2); // 
        }

        var stackValue = cache.get(xValue); //  stackHeight

        cache.set(xValue, stackValue + stackHeight);
        return (0, _tslib.__assign)((0, _tslib.__assign)({}, data), (_a = {}, _a[yField] = stackValue, _a));
      });
    });
  };

  return Stack;
}(_adjust.default);

var _default = Stack;
exports.default = _default;

/***/ }),
/* 770 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _ = _interopRequireWildcard(__webpack_require__(0));

var _adjust = _interopRequireDefault(__webpack_require__(111));

var Symmetric =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Symmetric, _super);

  function Symmetric() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Symmetric.prototype.process = function (groupDataArray) {
    var mergeData = _.flatten(groupDataArray);

    var _a = this,
        xField = _a.xField,
        yField = _a.yField; //  x  


    var cache = this.getXValuesMaxMap(mergeData); // 

    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {
      return cache[key];
    }));
    return _.map(groupDataArray, function (dataArray) {
      return _.map(dataArray, function (data) {
        var _a, _b;

        var yValue = data[yField];
        var xValue = data[xField]; // 

        if (_.isArray(yValue)) {
          var off_1 = (max - cache[xValue]) / 2;
          return (0, _tslib.__assign)((0, _tslib.__assign)({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {
            return off_1 + y;
          }), _a));
        } // 


        var offset = (max - yValue) / 2;
        return (0, _tslib.__assign)((0, _tslib.__assign)({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
      });
    });
  }; //  x 


  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {
    var _this = this;

    var _a = this,
        xField = _a.xField,
        yField = _a.yField; //  xField 


    var groupDataArray = _.groupBy(mergeData, function (data) {
      return data[xField];
    }); //  xField 


    return _.mapValues(groupDataArray, function (dataArray) {
      return _this.getDimMaxValue(dataArray, yField);
    });
  };

  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {
    //  value 
    var dimValues = _.map(mergeData, function (data) {
      return _.get(data, dim, []);
    }); // dim value  stack 


    var flattenValues = _.flatten(dimValues); // 


    return Math.max.apply(Math, flattenValues);
  };

  return Symmetric;
}(_adjust.default);

var _default = Symmetric;
exports.default = _default;

/***/ }),
/* 771 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _colorUtil = _interopRequireDefault(__webpack_require__(179));

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(103));

var Color =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Color, _super);

  function Color(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'color';
    _this.names = ['color'];

    if ((0, _util.isString)(_this.values)) {
      _this.linear = true;
    }

    _this.gradient = _colorUtil.default.gradient(_this.values);
    return _this;
  }
  /**
   * @override
   */


  Color.prototype.getLinearValue = function (percent) {
    return this.gradient(percent);
  };

  return Color;
}(_base.default);

var _default = Color;
exports.default = _default;

/***/ }),
/* 772 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _base = _interopRequireDefault(__webpack_require__(103));

var Opacity =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Opacity, _super);

  function Opacity(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'opacity';
    _this.names = ['opacity'];
    return _this;
  }

  return Opacity;
}(_base.default);

var _default = Opacity;
exports.default = _default;

/***/ }),
/* 773 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(103));

var Position =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Position, _super);

  function Position(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.names = ['x', 'y'];
    _this.type = 'position';
    return _this;
  }

  Position.prototype.mapping = function (x, y) {
    var _a = this.scales,
        scaleX = _a[0],
        scaleY = _a[1];

    if ((0, _util.isNil)(x) || (0, _util.isNil)(y)) {
      return [];
    }

    return [(0, _util.isArray)(x) ? x.map(function (xi) {
      return scaleX.scale(xi);
    }) : scaleX.scale(x), (0, _util.isArray)(y) ? y.map(function (yi) {
      return scaleY.scale(yi);
    }) : scaleY.scale(y)];
  };

  return Position;
}(_base.default);

var _default = Position;
exports.default = _default;

/***/ }),
/* 774 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _base = _interopRequireDefault(__webpack_require__(103));

var Shape =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Shape, _super);

  function Shape(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'shape';
    _this.names = ['shape'];
    return _this;
  }
  /**
   * @override
   */


  Shape.prototype.getLinearValue = function (percent) {
    var idx = Math.round((this.values.length - 1) * percent);
    return this.values[idx];
  };

  return Shape;
}(_base.default);

var _default = Shape;
exports.default = _default;

/***/ }),
/* 775 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _base = _interopRequireDefault(__webpack_require__(103));

var Size =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Size, _super);

  function Size(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.type = 'size';
    _this.names = ['size'];
    return _this;
  }

  return Size;
}(_base.default);

var _default = Size;
exports.default = _default;

/***/ }),
/* 776 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  getAttribute: true,
  registerAttribute: true,
  Attribute: true
};
Object.defineProperty(exports, "Attribute", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
exports.registerAttribute = exports.getAttribute = void 0;

var _base = _interopRequireDefault(__webpack_require__(103));

var _interface = __webpack_require__(411);

Object.keys(_interface).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _interface[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _interface[key];
    }
  });
});
//  attribute map
var ATTRIBUTE_MAP = {};
/**
 *  Attribute 
 * @param type
 */

var getAttribute = function getAttribute(type) {
  return ATTRIBUTE_MAP[type.toLowerCase()];
};

exports.getAttribute = getAttribute;

var registerAttribute = function registerAttribute(type, ctor) {
  //  type 
  if (getAttribute(type)) {
    throw new Error("Attribute type '" + type + "' existed.");
  } //  map 


  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};

exports.registerAttribute = registerAttribute;

/***/ }),
/* 777 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _time = __webpack_require__(180);

var _base = _interopRequireDefault(__webpack_require__(413));

/**
 * 
 * @class
 */
var TimeCat =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TimeCat, _super);

  function TimeCat() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'timeCat';
    return _this;
  }
  /**
   * @override
   */


  TimeCat.prototype.translate = function (value) {
    value = (0, _time.toTimeStamp)(value);
    var index = this.values.indexOf(value);

    if (index === -1) {
      if ((0, _util.isNumber)(value) && value < this.values.length) {
        index = value;
      } else {
        index = NaN;
      }
    }

    return index;
  };
  /**
   *  getText
   * @override
   */


  TimeCat.prototype.getText = function (value, tickIndex) {
    var index = this.translate(value);

    if (index > -1) {
      var result = this.values[index];
      var formatter = this.formatter;
      result = formatter ? formatter(result, tickIndex) : (0, _time.timeFormat)(result, this.mask);
      return result;
    }

    return value;
  };

  TimeCat.prototype.initCfg = function () {
    this.tickMethod = 'time-cat';
    this.mask = 'YYYY-MM-DD';
    this.tickCount = 7; //  7 14 30 
  };

  TimeCat.prototype.setDomain = function () {
    var values = this.values; // 

    (0, _util.each)(values, function (v, i) {
      values[i] = (0, _time.toTimeStamp)(v);
    });
    values.sort(function (v1, v2) {
      return v1 - v2;
    });

    _super.prototype.setDomain.call(this);
  };

  return TimeCat;
}(_base.default);

var _default = TimeCat;
exports.default = _default;

/***/ }),
/* 778 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assign = assign;
exports.parse = parse;
exports.setGlobalDateMasks = exports.setGlobalDateI18n = exports.defaultI18n = exports.format = exports.default = void 0;
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "[1-9]\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;

function shorten(arr, sLen) {
  var newArr = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }

  return newArr;
}

var monthUpdate = function monthUpdate(arrName) {
  return function (v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function (v) {
      return v.toLowerCase();
    });
    var index = lowerCaseArr.indexOf(v.toLowerCase());

    if (index > -1) {
      return index;
    }

    return null;
  };
};

function assign(origObj) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
    var obj = args_1[_a];

    for (var key in obj) {
      // @ts-ignore ex
      origObj[key] = obj[key];
    }
  }

  return origObj;
}

var dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort: dayNamesShort,
  dayNames: dayNames,
  monthNamesShort: monthNamesShort,
  monthNames: monthNames,
  amPm: ["am", "pm"],
  DoFn: function DoFn(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
exports.defaultI18n = defaultI18n;
var globalI18n = assign({}, defaultI18n);

var setGlobalDateI18n = function setGlobalDateI18n(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};

exports.setGlobalDateI18n = setGlobalDateI18n;

var regexEscape = function regexEscape(str) {
  return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};

var pad = function pad(val, len) {
  if (len === void 0) {
    len = 2;
  }

  val = String(val);

  while (val.length < len) {
    val = "0" + val;
  }

  return val;
};

var formatFlags = {
  D: function D(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function DD(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function Do(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function d(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function dd(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function ddd(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function dddd(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function M(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function MM(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function MMM(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function MMMM(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function YY(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function YYYY(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function h(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function hh(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function H(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function HH(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function m(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function mm(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function s(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function ss(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function S(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function SS(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function SSS(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function a(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function A(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function ZZ(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function Z(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};

var monthParse = function monthParse(v) {
  return +v - 1;
};

var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = ["isPm", word, function (v, i18n) {
  var val = v.toLowerCase();

  if (val === i18n.amPm[0]) {
    return 0;
  } else if (val === i18n.amPm[1]) {
    return 1;
  }

  return null;
}];
var timezoneOffset = ["timezoneOffset", "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?", function (v) {
  var parts = (v + "").match(/([+-]|\d\d)/gi);

  if (parts) {
    var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
    return parts[0] === "+" ? minutes : -minutes;
  }

  return 0;
}];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function (v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: ["year", twoDigits, function (v) {
    var now = new Date();
    var cent = +("" + now.getFullYear()).substr(0, 2);
    return +("" + (+v > 68 ? cent - 1 : cent) + v);
  }],
  h: ["hour", twoDigitsOptional, undefined, "isPm"],
  hh: ["hour", twoDigits, undefined, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function (v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function (v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
}; // Some common format strings

var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};

var setGlobalDateMasks = function setGlobalDateMasks(masks) {
  return assign(globalMasks, masks);
};
/***
 * Format a date
 * @method format
 * @param {Date|number} dateObj
 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
 * @returns {string} Formatted date string
 */


exports.setGlobalDateMasks = setGlobalDateMasks;

var format = function format(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }

  if (i18n === void 0) {
    i18n = {};
  }

  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }

  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }

  mask = globalMasks[mask] || mask;
  var literals = []; // Make literals inactive by replacing them with @@@

  mask = mask.replace(literal, function ($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n); // Apply formatting rules

  mask = mask.replace(token, function ($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  }); // Inline literal values back into the formatted value

  return mask.replace(/@@@/g, function () {
    return literals.shift();
  });
};
/**
 * Parse a date string into a Javascript Date object /
 * @method parse
 * @param {string} dateStr Date string
 * @param {string} format Date parse format
 * @param {i18n} I18nSettingsOptional Full or subset of I18N settings
 * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format
 */


exports.format = format;

function parse(dateStr, format, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }

  if (typeof format !== "string") {
    throw new Error("Invalid format in fecha parse");
  } // Check to see if the format is actually a mask


  format = globalMasks[format] || format; // Avoid regular expression denial of service, fail early for really long strings
  // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS

  if (dateStr.length > 1000) {
    return null;
  } // Default to the beginning of the year.


  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = []; // Replace all the literals with @@@. Hopefully a string that won't exist in the format

  var newFormat = format.replace(literal, function ($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {}; // Change every token that we find into the correct regex

  newFormat = regexEscape(newFormat).replace(token, function ($0) {
    var info = parseFlags[$0];
    var field = info[0],
        regex = info[1],
        requiredField = info[3]; // Check if the person has specified the same field twice. This will lead to confusing results.

    if (specifiedFields[field]) {
      throw new Error("Invalid format. " + field + " specified twice in format");
    }

    specifiedFields[field] = true; // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified

    if (requiredField) {
      requiredFields[requiredField] = true;
    }

    parseInfo.push(info);
    return "(" + regex + ")";
  }); // Check all the required fields are present

  Object.keys(requiredFields).forEach(function (field) {
    if (!specifiedFields[field]) {
      throw new Error("Invalid format. " + field + " is required in specified format");
    }
  }); // Add back all the literals after

  newFormat = newFormat.replace(/@@@/g, function () {
    return literals.shift();
  }); // Check if the date string matches the format. If it doesn't return null

  var matches = dateStr.match(new RegExp(newFormat, "i"));

  if (!matches) {
    return null;
  }

  var combinedI18nSettings = assign(assign({}, globalI18n), i18n); // For each match, call the parser function for that date part

  for (var i = 1; i < matches.length; i++) {
    var _a = parseInfo[i - 1],
        field = _a[0],
        parser = _a[2];
    var value = parser ? parser(matches[i], combinedI18nSettings) : +matches[i]; // If the parser can't make sense of the value, return null

    if (value == null) {
      return null;
    }

    dateInfo[field] = value;
  }

  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }

  var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
  var validateFields = [["month", "getMonth"], ["day", "getDate"], ["hour", "getHours"], ["minute", "getMinutes"], ["second", "getSeconds"]];

  for (var i = 0, len = validateFields.length; i < len; i++) {
    // Check to make sure the date field is within the allowed range. Javascript dates allows values
    // outside the allowed range. If the values don't match the value was invalid
    if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {
      return null;
    }
  }

  if (dateInfo.timezoneOffset == null) {
    return dateWithoutTZ;
  }

  return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
}

var fecha = {
  format: format,
  parse: parse,
  defaultI18n: defaultI18n,
  setGlobalDateI18n: setGlobalDateI18n,
  setGlobalDateMasks: setGlobalDateMasks
};
var _default = fecha;
exports.default = _default;

/***/ }),
/* 779 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _util = __webpack_require__(0);

/**
 * 
 * https://github.com/d3/d3-array/blob/master/src/bisector.js
 */
function _default(getter) {
  /**
   * x: 
   * lo: 
   * hi: 
   */
  return function (a, x, _lo, _hi) {
    var lo = (0, _util.isNil)(_lo) ? 0 : _lo;
    var hi = (0, _util.isNil)(_hi) ? a.length : _hi;

    while (lo < hi) {
      var mid = lo + hi >>> 1;

      if (getter(a[mid]) > x) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }

    return lo;
  };
}

/***/ }),
/* 780 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _math = __webpack_require__(182);

var _base = _interopRequireDefault(__webpack_require__(181));

/**
 * Log 
 */
var Log =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Log, _super);

  function Log() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'log';
    return _this;
  }
  /**
   * @override
   */


  Log.prototype.invert = function (value) {
    var base = this.base;
    var max = (0, _math.log)(base, this.max);
    var rangeMin = this.rangeMin();
    var range = this.rangeMax() - rangeMin;
    var min;
    var positiveMin = this.positiveMin;

    if (positiveMin) {
      if (value === 0) {
        return 0;
      }

      min = (0, _math.log)(base, positiveMin / base);
      var appendPercent = 1 / (max - min) * range; // 0  positiveMin

      if (value < appendPercent) {
        //  0 - positiveMin 
        return value / appendPercent * positiveMin;
      }
    } else {
      min = (0, _math.log)(base, this.min);
    }

    var percent = (value - rangeMin) / range;
    var tmp = percent * (max - min) + min;
    return Math.pow(base, tmp);
  };

  Log.prototype.initCfg = function () {
    this.tickMethod = 'log';
    this.base = 10;
    this.tickCount = 6;
    this.nice = true;
  }; // 


  Log.prototype.setDomain = function () {
    _super.prototype.setDomain.call(this);

    var min = this.min;

    if (min < 0) {
      throw new Error('When you use log scale, the minimum value must be greater than zero!');
    }

    if (min === 0) {
      this.positiveMin = (0, _math.getLogPositiveMin)(this.values, this.base, this.max);
    }
  }; // 


  Log.prototype.getScalePercent = function (value) {
    var max = this.max;
    var min = this.min;

    if (max === min) {
      return 0;
    } // 00


    if (value <= 0) {
      return 0;
    }

    var base = this.base;
    var positiveMin = this.positiveMin; // min == 0, 0tick0

    if (positiveMin) {
      min = positiveMin * 1 / base;
    }

    var percent; //  value /  

    if (value < positiveMin) {
      percent = value / positiveMin / ((0, _math.log)(base, max) - (0, _math.log)(base, min));
    } else {
      percent = ((0, _math.log)(base, value) - (0, _math.log)(base, min)) / ((0, _math.log)(base, max) - (0, _math.log)(base, min));
    }

    return percent;
  };

  return Log;
}(_base.default);

var _default = Log;
exports.default = _default;

/***/ }),
/* 781 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _math = __webpack_require__(182);

var _base = _interopRequireDefault(__webpack_require__(181));

/**
 * Pow 
 */
var Pow =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Pow, _super);

  function Pow() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'pow';
    return _this;
  }
  /**
   * @override
   */


  Pow.prototype.invert = function (value) {
    var percent = this.getInvertPercent(value);
    var exponent = this.exponent;
    var max = (0, _math.calBase)(exponent, this.max);
    var min = (0, _math.calBase)(exponent, this.min);
    var tmp = percent * (max - min) + min;
    var factor = tmp >= 0 ? 1 : -1;
    return Math.pow(tmp, exponent) * factor;
  };

  Pow.prototype.initCfg = function () {
    this.tickMethod = 'pow';
    this.exponent = 2;
    this.tickCount = 5;
    this.nice = true;
  }; // value


  Pow.prototype.getScalePercent = function (value) {
    var max = this.max;
    var min = this.min;

    if (max === min) {
      return 0;
    }

    var exponent = this.exponent;
    var percent = ((0, _math.calBase)(exponent, value) - (0, _math.calBase)(exponent, min)) / ((0, _math.calBase)(exponent, max) - (0, _math.calBase)(exponent, min));
    return percent;
  };

  return Pow;
}(_base.default);

var _default = Pow;
exports.default = _default;

/***/ }),
/* 782 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _time = __webpack_require__(180);

var _linear = _interopRequireDefault(__webpack_require__(414));

/**
 * 
 * @class
 */
var Time =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Time, _super);

  function Time() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'time';
    return _this;
  }
  /**
   * @override
   */


  Time.prototype.getText = function (value, index) {
    var numberValue = this.translate(value);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index) : (0, _time.timeFormat)(numberValue, this.mask);
  };
  /**
   * @override
   */


  Time.prototype.scale = function (value) {
    var v = value;

    if ((0, _util.isString)(v) || (0, _util.isDate)(v)) {
      v = this.translate(v);
    }

    return _super.prototype.scale.call(this, v);
  };
  /**
   * 
   * @override
   */


  Time.prototype.translate = function (v) {
    return (0, _time.toTimeStamp)(v);
  };

  Time.prototype.initCfg = function () {
    this.tickMethod = 'time-pretty';
    this.mask = 'YYYY-MM-DD';
    this.tickCount = 7;
    this.nice = false;
  };

  Time.prototype.setDomain = function () {
    var values = this.values; //  min, max this.min, this.max

    var minConfig = this.getConfig('min');
    var maxConfig = this.getConfig('max'); //  min,max 

    if (!(0, _util.isNil)(minConfig) || !(0, _util.isNumber)(minConfig)) {
      this.min = this.translate(this.min);
    }

    if (!(0, _util.isNil)(maxConfig) || !(0, _util.isNumber)(maxConfig)) {
      this.max = this.translate(this.max);
    } //  min, max 


    if (values && values.length) {
      // 
      var timeStamps_1 = [];
      var min_1 = Infinity; // 

      var secondMin_1 = min_1; // 

      var max_1 = 0; // min,max,secondMin

      (0, _util.each)(values, function (v) {
        var timeStamp = (0, _time.toTimeStamp)(v);

        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v + " in time scale!");
        }

        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }

        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }

        timeStamps_1.push(timeStamp);
      }); // 

      if (values.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }

      if ((0, _util.isNil)(minConfig)) {
        this.min = min_1;
      }

      if ((0, _util.isNil)(maxConfig)) {
        this.max = max_1;
      }
    }
  };

  return Time;
}(_linear.default);

var _default = Time;
exports.default = _default;

/***/ }),
/* 783 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _quantize = _interopRequireDefault(__webpack_require__(415));

var Quantile =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Quantile, _super);

  function Quantile() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'quantile';
    return _this;
  }

  Quantile.prototype.initCfg = function () {
    this.tickMethod = 'quantile';
    this.tickCount = 5;
    this.nice = true;
  };

  return Quantile;
}(_quantize.default);

var _default = Quantile;
exports.default = _default;

/***/ }),
/* 784 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScale = getClass;
exports.registerScale = registerClass;
Object.defineProperty(exports, "Scale", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});

var _base = _interopRequireDefault(__webpack_require__(139));

var map = {};

function getClass(key) {
  return map[key];
}

function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }

  map[key] = cls;
}

/***/ }),
/* 785 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(139));

/**
 * identity scalescale/invert
 * Rhttps://github.com/r-lib/scales/blob/master/R/pal-identity.r
 * d3https://github.com/d3/d3-scale/blob/master/src/identity.js
 */
var Identity =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Identity, _super);

  function Identity() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'identity';
    _this.isIdentity = true;
    return _this;
  }

  Identity.prototype.calculateTicks = function () {
    return this.values;
  };

  Identity.prototype.scale = function (value) {
    //  identity  dodge
    if (this.values[0] !== value && (0, _util.isNumber)(value)) {
      return value;
    }

    return this.range[0];
  };

  Identity.prototype.invert = function (value) {
    var range = this.range;

    if (value < range[0] || value > range[1]) {
      return NaN;
    }

    return this.values[0];
  };

  return Identity;
}(_base.default);

var _default = Identity;
exports.default = _default;

/***/ }),
/* 786 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "getTickMethod", {
  enumerable: true,
  get: function get() {
    return _register.getTickMethod;
  }
});
Object.defineProperty(exports, "registerTickMethod", {
  enumerable: true,
  get: function get() {
    return _register.registerTickMethod;
  }
});

var _cat = _interopRequireDefault(__webpack_require__(416));

var _d3Linear = _interopRequireDefault(__webpack_require__(787));

var _linear = _interopRequireDefault(__webpack_require__(789));

var _log = _interopRequireDefault(__webpack_require__(790));

var _pow = _interopRequireDefault(__webpack_require__(791));

var _quantile = _interopRequireDefault(__webpack_require__(792));

var _rPrettry = _interopRequireDefault(__webpack_require__(793));

var _register = __webpack_require__(412);

var _time = _interopRequireDefault(__webpack_require__(794));

var _timeCat = _interopRequireDefault(__webpack_require__(795));

var _timePretty = _interopRequireDefault(__webpack_require__(796));

(0, _register.registerTickMethod)('cat', _cat.default);
(0, _register.registerTickMethod)('time-cat', _timeCat.default);
(0, _register.registerTickMethod)('wilkinson-extended', _linear.default);
(0, _register.registerTickMethod)('r-pretty', _rPrettry.default);
(0, _register.registerTickMethod)('time', _time.default);
(0, _register.registerTickMethod)('time-pretty', _timePretty.default);
(0, _register.registerTickMethod)('log', _log.default);
(0, _register.registerTickMethod)('pow', _pow.default);
(0, _register.registerTickMethod)('quantile', _quantile.default);
(0, _register.registerTickMethod)('d3-linear', _d3Linear.default);

/***/ }),
/* 787 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = d3LinearTickMethod;

var _util = __webpack_require__(0);

var _d3Linear = _interopRequireDefault(__webpack_require__(788));

var _interval = _interopRequireDefault(__webpack_require__(250));

var _strictLimit = _interopRequireDefault(__webpack_require__(251));

function d3LinearTickMethod(cfg) {
  var min = cfg.min,
      max = cfg.max,
      tickInterval = cfg.tickInterval,
      minLimit = cfg.minLimit,
      maxLimit = cfg.maxLimit;
  var ticks = (0, _d3Linear.default)(cfg);

  if (!(0, _util.isNil)(minLimit) || !(0, _util.isNil)(maxLimit)) {
    return (0, _strictLimit.default)(cfg, (0, _util.head)(ticks), (0, _util.last)(ticks));
  }

  if (tickInterval) {
    return (0, _interval.default)(min, max, tickInterval).ticks;
  }

  return ticks;
}

/***/ }),
/* 788 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = d3Linear;
exports.D3Linear = void 0;

function d3Linear(cfg) {
  var min = cfg.min,
      max = cfg.max,
      nice = cfg.nice,
      tickCount = cfg.tickCount;
  var linear = new D3Linear();
  linear.domain([min, max]);

  if (nice) {
    linear.nice(tickCount);
  }

  return linear.ticks(tickCount);
}

var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2); // https://github.com/d3/d3-scale

var D3Linear =
/** @class */
function () {
  function D3Linear() {
    this._domain = [0, 1];
  }

  D3Linear.prototype.domain = function (domain) {
    if (domain) {
      this._domain = Array.from(domain, Number);
      return this;
    }

    return this._domain.slice();
  };

  D3Linear.prototype.nice = function (count) {
    var _a, _b;

    if (count === void 0) {
      count = DEFAULT_COUNT;
    }

    var d = this._domain.slice();

    var i0 = 0;
    var i1 = this._domain.length - 1;
    var start = this._domain[i0];
    var stop = this._domain[i1];
    var step;

    if (stop < start) {
      _a = [stop, start], start = _a[0], stop = _a[1];
      _b = [i1, i0], i0 = _b[0], i1 = _b[1];
    }

    step = tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      this.domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      this.domain(d);
    }

    return this;
  };

  D3Linear.prototype.ticks = function (count) {
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }

    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
  };

  return D3Linear;
}();

exports.D3Linear = D3Linear;

function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;

  if (start === stop && count > 0) {
    return [start];
  } // tslint:disable-next-line


  if (reverse = stop < start) {
    n = start, start = stop, stop = n;
  } // tslint:disable-next-line


  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }

  if (reverse) {
    ticks.reverse();
  }

  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

/***/ }),
/* 789 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linear;

var _util = __webpack_require__(0);

var _extended = _interopRequireDefault(__webpack_require__(417));

var _interval = _interopRequireDefault(__webpack_require__(250));

var _strictLimit = _interopRequireDefault(__webpack_require__(251));

/**
 *  ticks wilkinson extended 
 * @param cfg 
 * @returns  ticks
 */
function linear(cfg) {
  var min = cfg.min,
      max = cfg.max,
      tickCount = cfg.tickCount,
      nice = cfg.nice,
      tickInterval = cfg.tickInterval,
      minLimit = cfg.minLimit,
      maxLimit = cfg.maxLimit;
  var ticks = (0, _extended.default)(min, max, tickCount, nice).ticks;

  if (!(0, _util.isNil)(minLimit) || !(0, _util.isNil)(maxLimit)) {
    return (0, _strictLimit.default)(cfg, (0, _util.head)(ticks), (0, _util.last)(ticks));
  }

  if (tickInterval) {
    return (0, _interval.default)(min, max, tickInterval).ticks;
  }

  return ticks;
}

/***/ }),
/* 790 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateLogTicks;

var _math = __webpack_require__(182);

/**
 *  log  ticks min = 0 
 * @param cfg 
 * @returns  ticks
 */
function calculateLogTicks(cfg) {
  var base = cfg.base,
      tickCount = cfg.tickCount,
      min = cfg.min,
      max = cfg.max,
      values = cfg.values;
  var minTick;
  var maxTick = (0, _math.log)(base, max);

  if (min > 0) {
    minTick = Math.floor((0, _math.log)(base, min));
  } else {
    var positiveMin = (0, _math.getLogPositiveMin)(values, base, max);
    minTick = Math.floor((0, _math.log)(base, positiveMin));
  }

  var count = maxTick - minTick;
  var avg = Math.ceil(count / tickCount);
  var ticks = [];

  for (var i = minTick; i < maxTick + avg; i = i + avg) {
    ticks.push(Math.pow(base, i));
  }

  if (min <= 0) {
    //  <= 0  0
    ticks.unshift(0);
  }

  return ticks;
}

/***/ }),
/* 791 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculatePowTicks;

var _math = __webpack_require__(182);

var _pretty = _interopRequireDefault(__webpack_require__(418));

/**
 *  Pow  ticks
 * @param cfg 
 * @returns  ticks
 */
function calculatePowTicks(cfg) {
  var exponent = cfg.exponent,
      tickCount = cfg.tickCount;
  var max = Math.ceil((0, _math.calBase)(exponent, cfg.max));
  var min = Math.floor((0, _math.calBase)(exponent, cfg.min));
  var ticks = (0, _pretty.default)(min, max, tickCount).ticks;
  return ticks.map(function (tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent) * factor;
  });
}

/***/ }),
/* 792 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateTicks;

/**
 *  https://github.com/simple-statistics/simple-statistics/blob/master/src/quantile_sorted.js
 * @param x  
 * @param p  
 */
function quantileSorted(x, p) {
  var idx = x.length * p;
  /*if (x.length === 0) { // 
    throw new Error('quantile requires at least one value.');
  } else if (p < 0 || p > 1) {
    throw new Error('quantiles must be between 0 and 1');
  } else */

  if (p === 1) {
    // If p is 1, directly return the last element
    return x[x.length - 1];
  } else if (p === 0) {
    // If p is 0, directly return the first element
    return x[0];
  } else if (idx % 1 !== 0) {
    // If p is not integer, return the next element in array
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    // If the list has even-length, we'll take the average of this number
    // and the next value, if there is one
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    // Finally, in the simple case of an integer value
    // with an odd-length list, return the x value at the index.
    return x[idx];
  }
}

function calculateTicks(cfg) {
  var tickCount = cfg.tickCount,
      values = cfg.values;

  if (!values || !values.length) {
    return [];
  }

  var sorted = values.slice().sort(function (a, b) {
    return a - b;
  });
  var ticks = [];

  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p));
  }

  return ticks;
}

/***/ }),
/* 793 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = linearPretty;

var _util = __webpack_require__(0);

var _interval = _interopRequireDefault(__webpack_require__(250));

var _pretty = _interopRequireDefault(__webpack_require__(418));

var _strictLimit = _interopRequireDefault(__webpack_require__(251));

/**
 *  ticks R's pretty 
 * @param cfg 
 * @returns  ticks
 */
function linearPretty(cfg) {
  var min = cfg.min,
      max = cfg.max,
      tickCount = cfg.tickCount,
      tickInterval = cfg.tickInterval,
      minLimit = cfg.minLimit,
      maxLimit = cfg.maxLimit;
  var ticks = (0, _pretty.default)(min, max, tickCount).ticks;

  if (!(0, _util.isNil)(minLimit) || !(0, _util.isNil)(maxLimit)) {
    return (0, _strictLimit.default)(cfg, (0, _util.head)(ticks), (0, _util.last)(ticks));
  }

  if (tickInterval) {
    return (0, _interval.default)(min, max, tickInterval).ticks;
  }

  return ticks;
}

/***/ }),
/* 794 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateTimeTicks;

var _time = __webpack_require__(180);

function calculateTimeTicks(cfg) {
  var min = cfg.min,
      max = cfg.max,
      minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount; //  tickInterval  tickCount 

  if (tickInterval) {
    tickCount = Math.ceil((max - min) / tickInterval);
  } else {
    tickInterval = (0, _time.getTickInterval)(min, max, tickCount)[1];
    var count = (max - min) / tickInterval;
    var ratio = count / tickCount;

    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    } // 


    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }

  var ticks = [];

  for (var i = min; i < max + tickInterval; i += tickInterval) {
    ticks.push(i);
  }

  return ticks;
}

/***/ }),
/* 795 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculateTimeCatTicks;

var _util = __webpack_require__(0);

var _cat = _interopRequireDefault(__webpack_require__(416));

/**
 *  ticks, 
 * @param cfg 
 * @returns  ticks
 */
function calculateTimeCatTicks(cfg) {
  var ticks = (0, _cat.default)(cfg);
  var lastValue = (0, _util.last)(cfg.values);

  if (lastValue !== (0, _util.last)(ticks)) {
    ticks.push(lastValue);
  }

  return ticks;
}

/***/ }),
/* 796 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = timePretty;

var _time = __webpack_require__(180);

function getYear(date) {
  return new Date(date).getFullYear();
}

function createYear(year) {
  return new Date(year, 0, 1).getTime();
}

function getMonth(date) {
  return new Date(date).getMonth();
}

function diffMonth(min, max) {
  var minYear = getYear(min);
  var maxYear = getYear(max);
  var minMonth = getMonth(min);
  var maxMonth = getMonth(max);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}

function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}

function diffDay(min, max) {
  return Math.ceil((max - min) / _time.DAY);
}

function diffHour(min, max) {
  return Math.ceil((max - min) / _time.HOUR);
}

function diffMinus(min, max) {
  return Math.ceil((max - min) / (60 * 1000));
}
/**
 *  time  ticks month, year  pretty 
 * @param cfg 
 * @returns  ticks
 */


function timePretty(cfg) {
  var min = cfg.min,
      max = cfg.max,
      minTickInterval = cfg.minTickInterval,
      tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = []; //  tickInterval  tickCount 

  if (!tickInterval) {
    tickInterval = (max - min) / tickCount; // 

    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }

  var minYear = getYear(min); //  1 

  if (tickInterval > _time.YEAR) {
    var maxYear = getYear(max);
    var yearInterval = Math.ceil(tickInterval / _time.YEAR);

    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > _time.MONTH) {
    // 
    var monthInterval = Math.ceil(tickInterval / _time.MONTH);
    var mmMoth = getMonth(min);
    var dMonths = diffMonth(min, max);

    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > _time.DAY) {
    // 
    var date = new Date(min);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / _time.DAY);
    var ddays = diffDay(min, max);

    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > _time.HOUR) {
    // 
    var date = new Date(min);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / _time.HOUR);
    var dHours = diffHour(min, max);

    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > _time.MINUTE) {
    // 
    var dMinus = diffMinus(min, max);
    var minutes = Math.ceil(tickInterval / _time.MINUTE);

    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min + i * _time.MINUTE);
    }
  } else {
    // 
    var interval = tickInterval;

    if (interval < _time.SECOND) {
      interval = _time.SECOND;
    }

    var minSecond = Math.floor(min / _time.SECOND) * _time.SECOND;

    var dSeconds = Math.ceil((max - min) / _time.SECOND);
    var seconds = Math.ceil(interval / _time.SECOND);

    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * _time.SECOND);
    }
  } //  tickInterval ticks
  // 


  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ") >= 512, may cause performance issues, even out of memory. Because of the configure \"tickInterval\"(in milliseconds, current is " + tickInterval + ") is too small, increase the value to solve the problem!");
  }

  return ticks;
}

/***/ }),
/* 797 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Coordinate", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "getCoordinate", {
  enumerable: true,
  get: function get() {
    return _factory.getCoordinate;
  }
});
Object.defineProperty(exports, "registerCoordinate", {
  enumerable: true,
  get: function get() {
    return _factory.registerCoordinate;
  }
});

var _base = _interopRequireDefault(__webpack_require__(183));

var _cartesian = _interopRequireDefault(__webpack_require__(798));

var _helix = _interopRequireDefault(__webpack_require__(799));

var _polar = _interopRequireDefault(__webpack_require__(800));

var _factory = __webpack_require__(801);

(0, _factory.registerCoordinate)('rect', _cartesian.default);
(0, _factory.registerCoordinate)('cartesian', _cartesian.default);
(0, _factory.registerCoordinate)('polar', _polar.default);
(0, _factory.registerCoordinate)('helix', _helix.default);

/***/ }),
/* 798 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _base = _interopRequireDefault(__webpack_require__(183));

/**
 * 
 * https://www.zhihu.com/question/20665303
 */
var Cartesian =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Cartesian, _super);

  function Cartesian(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.isRect = true;
    _this.type = 'cartesian';

    _this.initial();

    return _this;
  }

  Cartesian.prototype.initial = function () {
    _super.prototype.initial.call(this);

    var start = this.start;
    var end = this.end;
    this.x = {
      start: start.x,
      end: end.x
    };
    this.y = {
      start: start.y,
      end: end.y
    };
  };

  Cartesian.prototype.convertPoint = function (point) {
    var _a;

    var x = point.x,
        y = point.y; // 

    if (this.isTransposed) {
      _a = [y, x], x = _a[0], y = _a[1];
    }

    return {
      x: this.convertDim(x, 'x'),
      y: this.convertDim(y, 'y')
    };
  };

  Cartesian.prototype.invertPoint = function (point) {
    var _a;

    var x = this.invertDim(point.x, 'x');
    var y = this.invertDim(point.y, 'y');

    if (this.isTransposed) {
      _a = [y, x], x = _a[0], y = _a[1];
    }

    return {
      x: x,
      y: y
    };
  };

  return Cartesian;
}(_base.default);

var _default = Cartesian;
exports.default = _default;

/***/ }),
/* 799 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _matrixUtil = __webpack_require__(33);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(183));

/**
 * 
 */
var Helix =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Helix, _super);

  function Helix(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.isHelix = true;
    _this.type = 'helix';
    var _a = cfg.startAngle,
        startAngle = _a === void 0 ? 1.25 * Math.PI : _a,
        _b = cfg.endAngle,
        endAngle = _b === void 0 ? 7.25 * Math.PI : _b,
        _c = cfg.innerRadius,
        innerRadius = _c === void 0 ? 0 : _c,
        radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;

    _this.initial();

    return _this;
  }

  Helix.prototype.initial = function () {
    _super.prototype.initial.call(this);

    var index = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1; // 

    var maxRadius = Math.min(this.width, this.height) / 2;

    if (this.radius && this.radius >= 0 && this.radius <= 1) {
      maxRadius = maxRadius * this.radius;
    }

    this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index);
    this.a = this.d / (Math.PI * 2); // 

    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * maxRadius,
      end: this.innerRadius * maxRadius + this.d * 0.99
    };
  };
  /**
   * 
   * @param point 
   * @return      
   */


  Helix.prototype.convertPoint = function (point) {
    var _a;

    var x = point.x,
        y = point.y;

    if (this.isTransposed) {
      _a = [y, x], x = _a[0], y = _a[1];
    }

    var thi = this.convertDim(x, 'x');
    var r = this.a * thi;
    var newY = this.convertDim(y, 'y');
    return {
      x: this.center.x + Math.cos(thi) * (r + newY),
      y: this.center.y + Math.sin(thi) * (r + newY)
    };
  };
  /**
   * 
   * @param point 
   * @return      
   */


  Helix.prototype.invertPoint = function (point) {
    var _a;

    var d = this.d + this.y.start;

    var v = _matrixUtil.vec2.subtract([0, 0], [point.x, point.y], [this.center.x, this.center.y]);

    var thi = _matrixUtil.ext.angleTo(v, [1, 0], true);

    var rMin = thi * this.a; // r

    if (_matrixUtil.vec2.length(v) < rMin) {
      // rrMin
      rMin = _matrixUtil.vec2.length(v);
    }

    var index = Math.floor((_matrixUtil.vec2.length(v) - rMin) / d); // index

    thi = 2 * index * Math.PI + thi;
    var r = this.a * thi;
    var newY = _matrixUtil.vec2.length(v) - r;
    newY = (0, _util.isNumberEqual)(newY, 0) ? 0 : newY;
    var x = this.invertDim(thi, 'x');
    var y = this.invertDim(newY, 'y');
    x = (0, _util.isNumberEqual)(x, 0) ? 0 : x;
    y = (0, _util.isNumberEqual)(y, 0) ? 0 : y;

    if (this.isTransposed) {
      _a = [y, x], x = _a[0], y = _a[1];
    }

    return {
      x: x,
      y: y
    };
  };

  return Helix;
}(_base.default);

var _default = Helix;
exports.default = _default;

/***/ }),
/* 800 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(59);

var _matrixUtil = __webpack_require__(33);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(183));

var Polar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Polar, _super);

  function Polar(cfg) {
    var _this = _super.call(this, cfg) || this;

    _this.isPolar = true;
    _this.type = 'polar';
    var _a = cfg.startAngle,
        startAngle = _a === void 0 ? -Math.PI / 2 : _a,
        _b = cfg.endAngle,
        endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b,
        _c = cfg.innerRadius,
        innerRadius = _c === void 0 ? 0 : _c,
        radius = cfg.radius;
    _this.startAngle = startAngle;
    _this.endAngle = endAngle;
    _this.innerRadius = innerRadius;
    _this.radius = radius;

    _this.initial();

    return _this;
  }

  Polar.prototype.initial = function () {
    _super.prototype.initial.call(this);

    while (this.endAngle < this.startAngle) {
      this.endAngle += Math.PI * 2;
    }

    var oneBox = this.getOneBox();
    var oneWidth = oneBox.maxX - oneBox.minX;
    var oneHeight = oneBox.maxY - oneBox.minY;
    var left = Math.abs(oneBox.minX) / oneWidth;
    var top = Math.abs(oneBox.minY) / oneHeight;
    var maxRadius;

    if (this.height / oneHeight > this.width / oneWidth) {
      // width 
      maxRadius = this.width / oneWidth;
      this.circleCenter = {
        x: this.center.x - (0.5 - left) * this.width,
        y: this.center.y - (0.5 - top) * maxRadius * oneHeight
      };
    } else {
      // height 
      maxRadius = this.height / oneHeight;
      this.circleCenter = {
        x: this.center.x - (0.5 - left) * maxRadius * oneWidth,
        y: this.center.y - (0.5 - top) * this.height
      };
    }

    this.polarRadius = this.radius;

    if (!this.radius) {
      this.polarRadius = maxRadius;
    } else if (this.radius > 0 && this.radius <= 1) {
      this.polarRadius = maxRadius * this.radius;
    } else if (this.radius <= 0 || this.radius > maxRadius) {
      this.polarRadius = maxRadius;
    }

    this.x = {
      start: this.startAngle,
      end: this.endAngle
    };
    this.y = {
      start: this.innerRadius * this.polarRadius,
      end: this.polarRadius
    };
  };

  Polar.prototype.getRadius = function () {
    return this.polarRadius;
  };

  Polar.prototype.convertPoint = function (point) {
    var _a;

    var center = this.getCenter();
    var x = point.x,
        y = point.y;

    if (this.isTransposed) {
      _a = [y, x], x = _a[0], y = _a[1];
    }

    x = this.convertDim(x, 'x');
    y = this.convertDim(y, 'y');
    return {
      x: center.x + Math.cos(x) * y,
      y: center.y + Math.sin(x) * y
    };
  };

  Polar.prototype.invertPoint = function (point) {
    var center = this.getCenter();
    var vPoint = [point.x - center.x, point.y - center.y];
    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];

    _matrixUtil.ext.leftRotate(m, m, this.startAngle);

    var vStart3 = [1, 0, 0];

    _matrixUtil.vec3.transformMat3(vStart3, vStart3, m);

    var vStart2 = [vStart3[0], vStart3[1]];

    var angle = _matrixUtil.ext.angleTo(vStart2, vPoint, this.endAngle < this.startAngle);

    if ((0, _util.isNumberEqual)(angle, Math.PI * 2)) {
      angle = 0;
    }

    var radius = _matrixUtil.vec2.length(vPoint);

    var xPercent = angle / (this.endAngle - this.startAngle);
    xPercent = this.endAngle - this.startAngle > 0 ? xPercent : -xPercent;
    var yPercent = this.invertDim(radius, 'y');
    var rst = {
      x: 0,
      y: 0
    };
    rst.x = this.isTransposed ? yPercent : xPercent;
    rst.y = this.isTransposed ? xPercent : yPercent;
    return rst;
  };

  Polar.prototype.getCenter = function () {
    return this.circleCenter;
  };

  Polar.prototype.getOneBox = function () {
    var startAngle = this.startAngle;
    var endAngle = this.endAngle;

    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
      return {
        minX: -1,
        maxX: 1,
        minY: -1,
        maxY: 1
      };
    }

    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];

    for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
      xs.push(Math.cos(i));
      ys.push(Math.sin(i));
    }

    return {
      minX: Math.min.apply(Math, xs),
      maxX: Math.max.apply(Math, xs),
      minY: Math.min.apply(Math, ys),
      maxY: Math.max.apply(Math, ys)
    };
  };

  return Polar;
}(_base.default);

var _default = Polar;
exports.default = _default;

/***/ }),
/* 801 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerCoordinate = exports.getCoordinate = void 0;
//  Coordinate map
var COORDINATE_MAP = {};
/**
 *  coordinate 
 * @param type
 */

var getCoordinate = function getCoordinate(type) {
  return COORDINATE_MAP[type.toLowerCase()];
};
/**
 *  coordinate 
 * @param type
 * @param ctor
 */


exports.getCoordinate = getCoordinate;

var registerCoordinate = function registerCoordinate(type, ctor) {
  //  map 
  COORDINATE_MAP[type.toLowerCase()] = ctor;
};

exports.registerCoordinate = registerCoordinate;

/***/ }),
/* 802 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Text", {
  enumerable: true,
  get: function get() {
    return _text.default;
  }
});
Object.defineProperty(exports, "Arc", {
  enumerable: true,
  get: function get() {
    return _arc.default;
  }
});
Object.defineProperty(exports, "Region", {
  enumerable: true,
  get: function get() {
    return _region.default;
  }
});
Object.defineProperty(exports, "Image", {
  enumerable: true,
  get: function get() {
    return _image.default;
  }
});
Object.defineProperty(exports, "DataMarker", {
  enumerable: true,
  get: function get() {
    return _dataMarker.default;
  }
});
Object.defineProperty(exports, "DataRegion", {
  enumerable: true,
  get: function get() {
    return _dataRegion.default;
  }
});
Object.defineProperty(exports, "RegionFilter", {
  enumerable: true,
  get: function get() {
    return _regionFilter.default;
  }
});
Object.defineProperty(exports, "Shape", {
  enumerable: true,
  get: function get() {
    return _shape.default;
  }
});
Object.defineProperty(exports, "Html", {
  enumerable: true,
  get: function get() {
    return _html.default;
  }
});

var _line = _interopRequireDefault(__webpack_require__(803));

var _text = _interopRequireDefault(__webpack_require__(805));

var _arc = _interopRequireDefault(__webpack_require__(806));

var _region = _interopRequireDefault(__webpack_require__(807));

var _image = _interopRequireDefault(__webpack_require__(808));

var _dataMarker = _interopRequireDefault(__webpack_require__(809));

var _dataRegion = _interopRequireDefault(__webpack_require__(810));

var _regionFilter = _interopRequireDefault(__webpack_require__(811));

var _shape = _interopRequireDefault(__webpack_require__(812));

var _html = _interopRequireDefault(__webpack_require__(813));

/***/ }),
/* 803 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _graphic = __webpack_require__(185);

var _theme = _interopRequireDefault(__webpack_require__(60));

var _util2 = __webpack_require__(44);

var LineAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LineAnnotation, _super);

  function LineAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  LineAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'line',
      locationType: 'region',
      start: null,
      end: null,
      style: {},
      text: null,
      defaultCfg: {
        style: {
          fill: _theme.default.textColor,
          fontSize: 12,
          textAlign: 'center',
          textBaseline: 'bottom',
          fontFamily: _theme.default.fontFamily
        },
        text: {
          position: 'center',
          autoRotate: true,
          content: null,
          offsetX: 0,
          offsetY: 0,
          style: {
            stroke: _theme.default.lineColor,
            lineWidth: 1
          }
        }
      }
    });
  };

  LineAnnotation.prototype.renderInner = function (group) {
    this.renderLine(group);

    if (this.get('text')) {
      this.renderLabel(group);
    }
  }; // 


  LineAnnotation.prototype.renderLine = function (group) {
    var start = this.get('start');
    var end = this.get('end');
    var style = this.get('style');
    this.addShape(group, {
      type: 'line',
      id: this.getElementId('line'),
      name: 'annotation-line',
      attrs: (0, _tslib.__assign)({
        x1: start.x,
        y1: start.y,
        x2: end.x,
        y2: end.y
      }, style)
    });
  }; //  label 


  LineAnnotation.prototype.getLabelPoint = function (start, end, position) {
    var percent;

    if (position === 'start') {
      percent = 0;
    } else if (position === 'center') {
      percent = 0.5;
    } else if ((0, _util.isString)(position) && position.indexOf('%') !== -1) {
      percent = parseInt(position, 10) / 100;
    } else if ((0, _util.isNumber)(position)) {
      percent = position;
    } else {
      percent = 1;
    }

    if (percent > 1 || percent < 0) {
      percent = 1;
    }

    return {
      x: (0, _util2.getValueByPercent)(start.x, end.x, percent),
      y: (0, _util2.getValueByPercent)(start.y, end.y, percent)
    };
  }; //  label


  LineAnnotation.prototype.renderLabel = function (group) {
    var text = this.get('text');
    var start = this.get('start');
    var end = this.get('end');
    var position = text.position,
        content = text.content,
        style = text.style,
        offsetX = text.offsetX,
        offsetY = text.offsetY,
        autoRotate = text.autoRotate,
        maxLength = text.maxLength,
        autoEllipsis = text.autoEllipsis,
        ellipsisPosition = text.ellipsisPosition,
        background = text.background,
        _a = text.isVertical,
        isVertical = _a === void 0 ? false : _a;
    var point = this.getLabelPoint(start, end, position);
    var x = point.x + offsetX;
    var y = point.y + offsetY;
    var cfg = {
      id: this.getElementId('line-text'),
      name: 'annotation-line-text',
      x: x,
      y: y,
      content: content,
      style: style,
      maxLength: maxLength,
      autoEllipsis: autoEllipsis,
      ellipsisPosition: ellipsisPosition,
      background: background,
      isVertical: isVertical
    }; // 

    if (autoRotate) {
      var vector = [end.x - start.x, end.y - start.y];
      cfg.rotate = Math.atan2(vector[1], vector[0]);
    }

    (0, _graphic.renderTag)(group, cfg);
  };

  return LineAnnotation;
}(_groupComponent.default);

var _default = LineAnnotation;
exports.default = _default;

/***/ }),
/* 804 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.strLen = strLen;
exports.charAtLength = charAtLength;
exports.ellipsisString = ellipsisString;
var ELLIPSIS_CODE = "\u2026";
/**  */

function strLen(str) {
  var len = 0;

  for (var i = 0; i < str.length; i++) {
    len += charAtLength(str, i);
  }

  return len;
}
/** ASCII */


function charAtLength(str, i) {
  if (str.charCodeAt(i) > 0 && str.charCodeAt(i) < 128) {
    return 1;
  } else {
    return 2;
  }
}
/**  */


function ellipsisString(str, reseveLength, position) {
  if (position === void 0) {
    position = 'tail';
  }

  var count = str.length;
  var rst = '';

  if (position === 'tail') {
    for (var i = 0, index = 0; i < reseveLength;) {
      var charLength = charAtLength(str, index);

      if (i + charLength <= reseveLength) {
        rst += str[index];
        i += charAtLength(str, index);
        index++;
      } else {
        break;
      }
    }

    rst += ELLIPSIS_CODE;
  } else if (position === 'head') {
    for (var i = 0, index = count - 1; i < reseveLength;) {
      var charLength = charAtLength(str, index);

      if (i + charLength <= reseveLength) {
        rst += str[index];
        i += charAtLength(str, index);
        index--;
      } else {
        break;
      }
    }

    rst = ELLIPSIS_CODE + rst;
  } else {
    var startStr = '';
    var endStr = '';

    for (var i = 0, startIndex = 0, endIndex = count - 1; i < reseveLength;) {
      var startCodeLen = charAtLength(str, startIndex);
      var hasAdd = false; // 

      if (startCodeLen + i <= reseveLength) {
        startStr += str[startIndex];
        startIndex++;
        i += startCodeLen;
        hasAdd = true;
      }

      var endCodeLen = charAtLength(str, endIndex);

      if (endCodeLen + i <= reseveLength) {
        endStr = str[endIndex] + endStr;
        i += endCodeLen;
        endIndex--;
        hasAdd = true;
      }

      if (!hasAdd) {
        // 
        break;
      }
    }

    rst = startStr + ELLIPSIS_CODE + endStr;
  }

  return rst;
}

/***/ }),
/* 805 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _graphic = __webpack_require__(185);

var _matrix = __webpack_require__(87);

var _theme = _interopRequireDefault(__webpack_require__(60));

var TextAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TextAnnotation, _super);

  function TextAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  TextAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'text',
      locationType: 'point',
      x: 0,
      y: 0,
      content: '',
      rotate: null,
      style: {},
      background: null,
      maxLength: null,
      autoEllipsis: true,
      isVertical: false,
      ellipsisPosition: 'tail',
      defaultCfg: {
        style: {
          fill: _theme.default.textColor,
          fontSize: 12,
          textAlign: 'center',
          textBaseline: 'middle',
          fontFamily: _theme.default.fontFamily
        }
      }
    });
  }; //  setLocation  text


  TextAnnotation.prototype.setLocation = function (location) {
    this.set('x', location.x);
    this.set('y', location.y);
    this.resetLocation();
  };

  TextAnnotation.prototype.renderInner = function (group) {
    var _a = this.getLocation(),
        x = _a.x,
        y = _a.y;

    var content = this.get('content');
    var style = this.get('style');
    var id = this.getElementId('text');
    var name = this.get('name') + "-text";
    var maxLength = this.get('maxLength');
    var autoEllipsis = this.get('autoEllipsis');
    var isVertical = this.get('isVertical');
    var ellipsisPosition = this.get('ellipsisPosition');
    var background = this.get('background');
    var rotate = this.get('rotate');
    var cfg = {
      id: id,
      name: name,
      x: x,
      y: y,
      content: content,
      style: style,
      maxLength: maxLength,
      autoEllipsis: autoEllipsis,
      isVertical: isVertical,
      ellipsisPosition: ellipsisPosition,
      background: background,
      rotate: rotate
    };
    (0, _graphic.renderTag)(group, cfg);
  };

  TextAnnotation.prototype.resetLocation = function () {
    var textGroup = this.getElementByLocalId('text-group');

    if (textGroup) {
      var _a = this.getLocation(),
          x = _a.x,
          y = _a.y;

      var rotate = this.get('rotate');
      (0, _matrix.applyTranslate)(textGroup, x, y);
      (0, _matrix.applyRotate)(textGroup, rotate, x, y);
    }
  };

  return TextAnnotation;
}(_groupComponent.default);

var _default = TextAnnotation;
exports.default = _default;

/***/ }),
/* 806 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _util = __webpack_require__(44);

var ArcAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ArcAnnotation, _super);

  function ArcAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  ArcAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'arc',
      locationType: 'circle',
      center: null,
      radius: 100,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      style: {
        stroke: '#999',
        lineWidth: 1
      }
    });
  };

  ArcAnnotation.prototype.renderInner = function (group) {
    this.renderArc(group);
  };

  ArcAnnotation.prototype.getArcPath = function () {
    var _a = this.getLocation(),
        center = _a.center,
        radius = _a.radius,
        startAngle = _a.startAngle,
        endAngle = _a.endAngle;

    var startPoint = (0, _util.getCirclePoint)(center, radius, startAngle);
    var endPoint = (0, _util.getCirclePoint)(center, radius, endAngle);
    var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
    var path = [['M', startPoint.x, startPoint.y]];

    if (endAngle - startAngle === Math.PI * 2) {
      // 
      var middlePoint = (0, _util.getCirclePoint)(center, radius, startAngle + Math.PI);
      path.push(['A', radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
      path.push(['A', radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    } else {
      path.push(['A', radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
    }

    return path;
  }; //  arc


  ArcAnnotation.prototype.renderArc = function (group) {
    //   get('center') 
    var path = this.getArcPath();
    var style = this.get('style');
    this.addShape(group, {
      type: 'path',
      id: this.getElementId('arc'),
      name: 'annotation-arc',
      attrs: (0, _tslib.__assign)({
        path: path
      }, style)
    });
  };

  return ArcAnnotation;
}(_groupComponent.default);

var _default = ArcAnnotation;
exports.default = _default;

/***/ }),
/* 807 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _theme = _interopRequireDefault(__webpack_require__(60));

var _util = __webpack_require__(44);

var RegionAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RegionAnnotation, _super);

  function RegionAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  RegionAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'region',
      locationType: 'region',
      start: null,
      end: null,
      style: {},
      defaultCfg: {
        style: {
          lineWidth: 0,
          fill: _theme.default.regionColor,
          opacity: 0.4
        }
      }
    });
  };

  RegionAnnotation.prototype.renderInner = function (group) {
    this.renderRegion(group);
  };

  RegionAnnotation.prototype.renderRegion = function (group) {
    var start = this.get('start');
    var end = this.get('end');
    var style = this.get('style');
    var bbox = (0, _util.regionToBBox)({
      start: start,
      end: end
    });
    this.addShape(group, {
      type: 'rect',
      id: this.getElementId('region'),
      name: 'annotation-region',
      attrs: (0, _tslib.__assign)({
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      }, style)
    });
  };

  return RegionAnnotation;
}(_groupComponent.default);

var _default = RegionAnnotation;
exports.default = _default;

/***/ }),
/* 808 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _util = __webpack_require__(44);

var ImageAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ImageAnnotation, _super);

  function ImageAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * @protected
   * 
   * @returns {object} 
   */


  ImageAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'image',
      locationType: 'region',
      start: null,
      end: null,
      src: null,
      style: {}
    });
  };

  ImageAnnotation.prototype.renderInner = function (group) {
    this.renderImage(group);
  };

  ImageAnnotation.prototype.getImageAttrs = function () {
    var start = this.get('start');
    var end = this.get('end');
    var style = this.get('style');
    var bbox = (0, _util.regionToBBox)({
      start: start,
      end: end
    });
    var src = this.get('src');
    return (0, _tslib.__assign)({
      x: bbox.x,
      y: bbox.y,
      img: src,
      width: bbox.width,
      height: bbox.height
    }, style);
  }; // 


  ImageAnnotation.prototype.renderImage = function (group) {
    this.addShape(group, {
      type: 'image',
      id: this.getElementId('image'),
      name: 'annotation-image',
      attrs: this.getImageAttrs()
    });
  };

  return ImageAnnotation;
}(_groupComponent.default);

var _default = ImageAnnotation;
exports.default = _default;

/***/ }),
/* 809 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _graphic = __webpack_require__(185);

var _matrix = __webpack_require__(87);

var _theme = _interopRequireDefault(__webpack_require__(60));

var DataMarkerAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DataMarkerAnnotation, _super);

  function DataMarkerAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   * @returns {object} 
   */


  DataMarkerAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'dataMarker',
      locationType: 'point',
      x: 0,
      y: 0,
      point: {},
      line: {},
      text: {},
      direction: 'upward',
      autoAdjust: true,
      coordinateBBox: null,
      defaultCfg: {
        point: {
          display: true,
          style: {
            r: 3,
            fill: '#FFFFFF',
            stroke: '#1890FF',
            lineWidth: 2
          }
        },
        line: {
          display: true,
          length: 20,
          style: {
            stroke: _theme.default.lineColor,
            lineWidth: 1
          }
        },
        text: {
          content: '',
          display: true,
          style: {
            fill: _theme.default.textColor,
            opacity: 0.65,
            fontSize: 12,
            textAlign: 'start',
            fontFamily: _theme.default.fontFamily
          }
        }
      }
    });
  };

  DataMarkerAnnotation.prototype.renderInner = function (group) {
    if ((0, _util.get)(this.get('line'), 'display')) {
      this.renderLine(group);
    }

    if ((0, _util.get)(this.get('text'), 'display')) {
      this.renderText(group);
    }

    if ((0, _util.get)(this.get('point'), 'display')) {
      this.renderPoint(group);
    }

    if (this.get('autoAdjust')) {
      this.autoAdjust(group);
    }
  };

  DataMarkerAnnotation.prototype.applyOffset = function () {
    this.moveElementTo(this.get('group'), {
      x: this.get('x') + this.get('offsetX'),
      y: this.get('y') + this.get('offsetY')
    });
  };

  DataMarkerAnnotation.prototype.renderPoint = function (group) {
    var point = this.getShapeAttrs().point;
    this.addShape(group, {
      type: 'circle',
      id: this.getElementId('point'),
      name: 'annotation-point',
      attrs: point
    });
  };

  DataMarkerAnnotation.prototype.renderLine = function (group) {
    var line = this.getShapeAttrs().line;
    this.addShape(group, {
      type: 'path',
      id: this.getElementId('line'),
      name: 'annotation-line',
      attrs: line
    });
  };

  DataMarkerAnnotation.prototype.renderText = function (group) {
    var textAttrs = this.getShapeAttrs().text;
    var x = textAttrs.x,
        y = textAttrs.y,
        text = textAttrs.text,
        style = (0, _tslib.__rest)(textAttrs, ["x", "y", "text"]);

    var _a = this.get('text'),
        background = _a.background,
        maxLength = _a.maxLength,
        autoEllipsis = _a.autoEllipsis,
        isVertival = _a.isVertival,
        ellipsisPosition = _a.ellipsisPosition;

    var tagCfg = {
      x: x,
      y: y,
      id: this.getElementId('text'),
      name: 'annotation-text',
      content: text,
      style: style,
      background: background,
      maxLength: maxLength,
      autoEllipsis: autoEllipsis,
      isVertival: isVertival,
      ellipsisPosition: ellipsisPosition
    };
    (0, _graphic.renderTag)(group, tagCfg);
  };

  DataMarkerAnnotation.prototype.autoAdjust = function (group) {
    var direction = this.get('direction');
    var x = this.get('x');
    var y = this.get('y');
    var lineLength = (0, _util.get)(this.get('line'), 'length', 0);
    var coordinateBBox = this.get('coordinateBBox');

    var _a = group.getBBox(),
        minX = _a.minX,
        maxX = _a.maxX,
        minY = _a.minY,
        maxY = _a.maxY;

    var textGroup = group.findById(this.getElementId('text-group'));
    var textShape = group.findById(this.getElementId('text'));
    var lineShape = group.findById(this.getElementId('line'));

    if (!coordinateBBox) {
      return;
    }

    if (textGroup) {
      if (x + minX <= coordinateBBox.minX) {
        // 
        var overflow = coordinateBBox.minX - (x + minX);
        (0, _matrix.applyTranslate)(textGroup, textGroup.attr('x') + overflow, textGroup.attr('y'));
      }

      if (x + maxX >= coordinateBBox.maxX) {
        // 
        var overflow = x + maxX - coordinateBBox.maxX;
        (0, _matrix.applyTranslate)(textGroup, textGroup.attr('x') - overflow, textGroup.attr('y'));
      }
    }

    if (direction === 'upward' && y + minY <= coordinateBBox.minY || direction !== 'upward' && y + maxY >= coordinateBBox.maxY) {
      // 
      var textBaseline = void 0;
      var factor = void 0;

      if (direction === 'upward' && y + minY <= coordinateBBox.minY) {
        textBaseline = 'top';
        factor = 1;
      } else {
        textBaseline = 'bottom';
        factor = -1;
      }

      textShape.attr('textBaseline', textBaseline);

      if (lineShape) {
        lineShape.attr('path', [['M', 0, 0], ['L', 0, lineLength * factor]]);
      }

      (0, _matrix.applyTranslate)(textGroup, textGroup.attr('x'), (lineLength + 2) * factor);
    }
  };

  DataMarkerAnnotation.prototype.getShapeAttrs = function () {
    var lineDisplay = (0, _util.get)(this.get('line'), 'display');
    var pointStyle = (0, _util.get)(this.get('point'), 'style', {});
    var lineStyle = (0, _util.get)(this.get('line'), 'style', {});
    var textStyle = (0, _util.get)(this.get('text'), 'style', {});
    var direction = this.get('direction');
    var lineLength = lineDisplay ? (0, _util.get)(this.get('line'), 'length', 0) : 0;
    var factor = direction === 'upward' ? -1 : 1;
    return {
      point: (0, _tslib.__assign)({
        x: 0,
        y: 0
      }, pointStyle),
      line: (0, _tslib.__assign)({
        path: [['M', 0, 0], ['L', 0, lineLength * factor]]
      }, lineStyle),
      text: (0, _tslib.__assign)({
        x: 0,
        y: (lineLength + 2) * factor,
        text: (0, _util.get)(this.get('text'), 'content', ''),
        textBaseline: direction === 'upward' ? 'bottom' : 'top'
      }, textStyle)
    };
  };

  return DataMarkerAnnotation;
}(_groupComponent.default);

var _default = DataMarkerAnnotation;
exports.default = _default;

/***/ }),
/* 810 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _theme = _interopRequireDefault(__webpack_require__(60));

var _util2 = __webpack_require__(44);

var _graphic = __webpack_require__(185);

var DataRegionAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DataRegionAnnotation, _super);

  function DataRegionAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   * @returns {object} 
   */


  DataRegionAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'dataRegion',
      locationType: 'points',
      points: [],
      lineLength: 0,
      region: {},
      text: {},
      defaultCfg: {
        region: {
          style: {
            lineWidth: 0,
            fill: _theme.default.regionColor,
            opacity: 0.4
          }
        },
        text: {
          content: '',
          style: {
            textAlign: 'center',
            textBaseline: 'bottom',
            fontSize: 12,
            fill: _theme.default.textColor,
            fontFamily: _theme.default.fontFamily
          }
        }
      }
    });
  };

  DataRegionAnnotation.prototype.renderInner = function (group) {
    var regionStyle = (0, _util.get)(this.get('region'), 'style', {});
    var textStyle = (0, _util.get)(this.get('text'), 'style', {});
    var lineLength = this.get('lineLength') || 0;
    var points = this.get('points');

    if (!points.length) {
      return;
    }

    var bbox = (0, _util2.pointsToBBox)(points); // render region

    var path = [];
    path.push(['M', points[0].x, bbox.minY - lineLength]);
    points.forEach(function (point) {
      path.push(['L', point.x, point.y]);
    });
    path.push(['L', points[points.length - 1].x, points[points.length - 1].y - lineLength]);
    this.addShape(group, {
      type: 'path',
      id: this.getElementId('region'),
      name: 'annotation-region',
      attrs: (0, _tslib.__assign)({
        path: path
      }, regionStyle)
    }); // render text

    var textCfg = (0, _tslib.__assign)({
      id: this.getElementId('text'),
      name: 'annotation-text',
      x: (bbox.minX + bbox.maxX) / 2,
      y: bbox.minY - lineLength
    }, this.get('text'));
    (0, _graphic.renderTag)(group, textCfg);
  };

  return DataRegionAnnotation;
}(_groupComponent.default);

var _default = DataRegionAnnotation;
exports.default = _default;

/***/ }),
/* 811 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _util2 = __webpack_require__(44);

var RegionFilterAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RegionFilterAnnotation, _super);

  function RegionFilterAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   * @returns {object} 
   */


  RegionFilterAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'regionFilter',
      locationType: 'region',
      start: null,
      end: null,
      color: null,
      shape: []
    });
  };

  RegionFilterAnnotation.prototype.renderInner = function (group) {
    var _this = this;

    var start = this.get('start');
    var end = this.get('end'); // 1. add region layer

    var layer = this.addGroup(group, {
      id: this.getElementId('region-filter'),
      capture: false
    }); // 2. clone shape & color it

    (0, _util.each)(this.get('shapes'), function (shape, shapeIdx) {
      var type = shape.get('type');
      var attrs = (0, _util.clone)(shape.attr());

      _this.adjustShapeAttrs(attrs);

      _this.addShape(layer, {
        id: _this.getElementId("shape-" + type + "-" + shapeIdx),
        capture: false,
        type: type,
        attrs: attrs
      });
    }); // 3. clip

    var clipBBox = (0, _util2.regionToBBox)({
      start: start,
      end: end
    });
    layer.setClip({
      type: 'rect',
      attrs: {
        x: clipBBox.minX,
        y: clipBBox.minY,
        width: clipBBox.width,
        height: clipBBox.height
      }
    });
  };

  RegionFilterAnnotation.prototype.adjustShapeAttrs = function (attr) {
    var color = this.get('color');

    if (attr.fill) {
      attr.fill = attr.fillStyle = color;
    }

    attr.stroke = attr.strokeStyle = color;
  };

  return RegionFilterAnnotation;
}(_groupComponent.default);

var _default = RegionFilterAnnotation;
exports.default = _default;

/***/ }),
/* 812 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var ShapeAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ShapeAnnotation, _super);

  function ShapeAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ShapeAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'shape',
      draw: _util.noop
    });
  };

  ShapeAnnotation.prototype.renderInner = function (group) {
    var render = this.get('render');

    if ((0, _util.isFunction)(render)) {
      render(group);
    }
  };

  return ShapeAnnotation;
}(_groupComponent.default);

var _default = ShapeAnnotation;
exports.default = _default;

/***/ }),
/* 813 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _domUtil = __webpack_require__(112);

var _util = __webpack_require__(0);

var _htmlComponent = _interopRequireDefault(__webpack_require__(186));

var _util2 = __webpack_require__(44);

var HtmlAnnotation =
/** @class */
function (_super) {
  (0, _tslib.__extends)(HtmlAnnotation, _super);

  function HtmlAnnotation() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  HtmlAnnotation.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'annotation',
      type: 'html',
      locationType: 'point',
      x: 0,
      y: 0,
      containerTpl: "<div class=\"g2-html-annotation\"></div>",
      alignX: 'left',
      alignY: 'top',
      html: '',
      zIndex: 7
    });
  };

  HtmlAnnotation.prototype.render = function () {
    var container = this.getContainer();
    var html = this.get('html');
    (0, _util2.clearDom)(container);
    var rst = (0, _util.isFunction)(html) ? html(container) : html;

    if ((0, _util.isElement)(rst)) {
      container.appendChild(rst);
    } else if ((0, _util.isString)(rst)) {
      container.appendChild((0, _domUtil.createDom)(rst));
    }

    this.resetPosition();
  };

  HtmlAnnotation.prototype.resetPosition = function () {
    var container = this.getContainer();

    var _a = this.getLocation(),
        x = _a.x,
        y = _a.y;

    var alignX = this.get('alignX');
    var alignY = this.get('alignY');
    var offsetX = this.get('offsetX');
    var offsetY = this.get('offsetY');
    var domWidth = (0, _domUtil.getOuterWidth)(container);
    var domHeight = (0, _domUtil.getOuterHeight)(container);
    var position = {
      x: x,
      y: y
    };

    if (alignX === 'middle') {
      position.x -= Math.round(domWidth / 2);
    } else if (alignX === 'right') {
      position.x -= Math.round(domWidth);
    }

    if (alignY === 'middle') {
      position.y -= Math.round(domHeight / 2);
    } else if (alignY === 'bottom') {
      position.y -= Math.round(domHeight);
    }

    if (offsetX) {
      position.x += offsetX;
    }

    if (offsetY) {
      position.y += offsetY;
    }

    (0, _domUtil.modifyCSS)(container, {
      position: 'absolute',
      left: position.x + "px",
      top: position.y + "px",
      zIndex: this.get('zIndex')
    });
  };

  return HtmlAnnotation;
}(_htmlComponent.default);

var _default = HtmlAnnotation;
exports.default = _default;

/***/ }),
/* 814 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = addEventListener;

function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === 'function') {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      }; // @ts-ignore
    }

    if (typeof target.attachEvent === 'function') {
      // @ts-ignore
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          // @ts-ignore
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  }
}

/***/ }),
/* 815 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createDom;

/**
 * DOM 
 * @param  {String} str Dom 
 * @return {HTMLElement}  DOM 
 */
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;

function initConstants() {
  TABLE = document.createElement('table');
  TABLE_TR = document.createElement('tr');
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement('tbody'),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    '*': document.createElement('div')
  };
}

function createDom(str) {
  if (!TABLE) {
    initConstants();
  }

  var name = FRAGMENT_REG.test(str) && RegExp.$1;

  if (!name || !(name in CONTAINERS)) {
    name = '*';
  }

  var container = CONTAINERS[name];
  str = str.replace(/(^\s*)|(\s*$)/g, '');
  container.innerHTML = '' + str;
  var dom = container.childNodes[0];
  container.removeChild(dom);
  return dom;
}

/***/ }),
/* 816 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterHeight;

var _getStyle = _interopRequireDefault(__webpack_require__(141));

var _getHeight = _interopRequireDefault(__webpack_require__(420));

function getOuterHeight(el, defaultValue) {
  var height = (0, _getHeight.default)(el, defaultValue);
  var bTop = parseFloat((0, _getStyle.default)(el, 'borderTopWidth')) || 0;
  var pTop = parseFloat((0, _getStyle.default)(el, 'paddingTop')) || 0;
  var pBottom = parseFloat((0, _getStyle.default)(el, 'paddingBottom')) || 0;
  var bBottom = parseFloat((0, _getStyle.default)(el, 'borderBottomWidth')) || 0;
  var mTop = parseFloat((0, _getStyle.default)(el, 'marginTop')) || 0;
  var mBottom = parseFloat((0, _getStyle.default)(el, 'marginBottom')) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}

/***/ }),
/* 817 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getOuterWidth;

var _getStyle = _interopRequireDefault(__webpack_require__(141));

var _getWidth = _interopRequireDefault(__webpack_require__(421));

function getOuterWidth(el, defaultValue) {
  var width = (0, _getWidth.default)(el, defaultValue);
  var bLeft = parseFloat((0, _getStyle.default)(el, 'borderLeftWidth')) || 0;
  var pLeft = parseFloat((0, _getStyle.default)(el, 'paddingLeft')) || 0;
  var pRight = parseFloat((0, _getStyle.default)(el, 'paddingRight')) || 0;
  var bRight = parseFloat((0, _getStyle.default)(el, 'borderRightWidth')) || 0;
  var mRight = parseFloat((0, _getStyle.default)(el, 'marginRight')) || 0;
  var mLeft = parseFloat((0, _getStyle.default)(el, 'marginLeft')) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}

/***/ }),
/* 818 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getRatio;

function getRatio() {
  return window.devicePixelRatio ? window.devicePixelRatio : 2;
}

/***/ }),
/* 819 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = modifyCSS;

function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }

  return dom;
}

/***/ }),
/* 820 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});

var _line = _interopRequireDefault(__webpack_require__(821));

var _circle = _interopRequireDefault(__webpack_require__(826));

var _base = _interopRequireDefault(__webpack_require__(253));

/***/ }),
/* 821 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _matrixUtil = __webpack_require__(33);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(253));

var OverlapUtil = _interopRequireWildcard(__webpack_require__(822));

var Line =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Line, _super);

  function Line() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Line.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'line',
      locationType: 'region',

      /**
       * , x, y
       * @type {object}
       */
      start: null,

      /**
       * , x, y
       * @type {object}
       */
      end: null
    });
  }; //  path


  Line.prototype.getLinePath = function () {
    var start = this.get('start');
    var end = this.get('end');
    var path = [];
    path.push(['M', start.x, start.y]);
    path.push(['L', end.x, end.y]);
    return path;
  }; //  layout bbox line 


  Line.prototype.getInnerLayoutBBox = function () {
    var start = this.get('start');
    var end = this.get('end');

    var bbox = _super.prototype.getInnerLayoutBBox.call(this);

    var minX = Math.min(start.x, end.x, bbox.x);
    var minY = Math.min(start.y, end.y, bbox.y);
    var maxX = Math.max(start.x, end.x, bbox.maxX);
    var maxY = Math.max(start.y, end.y, bbox.maxY);
    return {
      x: minX,
      y: minY,
      minX: minX,
      minY: minY,
      maxX: maxX,
      maxY: maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  Line.prototype.isVertical = function () {
    var start = this.get('start');
    var end = this.get('end');
    return (0, _util.isNumberEqual)(start.x, end.x);
  };

  Line.prototype.isHorizontal = function () {
    var start = this.get('start');
    var end = this.get('end');
    return (0, _util.isNumberEqual)(start.y, end.y);
  };

  Line.prototype.getTickPoint = function (tickValue) {
    var self = this;
    var start = self.get('start');
    var end = self.get('end');
    var regionX = end.x - start.x;
    var regionY = end.y - start.y;
    return {
      x: start.x + regionX * tickValue,
      y: start.y + regionY * tickValue
    };
  }; // 


  Line.prototype.getSideVector = function (offset) {
    var axisVector = this.getAxisVector();

    var normal = _matrixUtil.vec2.normalize([0, 0], axisVector);

    var factor = this.get('verticalFactor');
    var verticalVector = [normal[1], normal[0] * -1]; // 

    return _matrixUtil.vec2.scale([0, 0], verticalVector, offset * factor);
  }; // 


  Line.prototype.getAxisVector = function () {
    var start = this.get('start');
    var end = this.get('end');
    return [end.x - start.x, end.y - start.y];
  };

  Line.prototype.processOverlap = function (labelGroup) {
    var _this = this;

    var isVertical = this.isVertical();
    var isHorizontal = this.isHorizontal(); // 

    if (!isVertical && !isHorizontal) {
      return;
    }

    var labelCfg = this.get('label');
    var titleCfg = this.get('title');
    var verticalLimitLength = this.get('verticalLimitLength');
    var labelOffset = labelCfg.offset;
    var limitLength = verticalLimitLength;
    var titleHeight = 0;
    var titleSpacing = 0;

    if (titleCfg) {
      titleHeight = titleCfg.style.fontSize;
      titleSpacing = titleCfg.spacing;
    }

    if (limitLength) {
      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
    }

    var overlapOrder = this.get('overlapOrder');
    (0, _util.each)(overlapOrder, function (name) {
      if (labelCfg[name] && _this.canProcessOverlap(name)) {
        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
      }
    });

    if (titleCfg) {
      if ((0, _util.isNil)(titleCfg.offset)) {
        //  title  offset
        var bbox = labelGroup.getCanvasBBox();
        var length_1 = isVertical ? bbox.width : bbox.height; //  offset

        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
      }
    }
  };
  /**
   *  overlap
   * @param name
   */


  Line.prototype.canProcessOverlap = function (name) {
    var labelCfg = this.get('label'); //  autoRotate

    if (name === 'autoRotate') {
      return (0, _util.isNil)(labelCfg.rotate);
    } //  overlap 


    return true;
  };

  Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {
    var _this = this;

    var isVertical = this.isVertical();
    var hasAdjusted = false;
    var util = OverlapUtil[name];

    if (value === true) {
      var labelCfg = this.get('label'); // true  overlap 

      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);
    } else if ((0, _util.isFunction)(value)) {
      //  
      hasAdjusted = value(isVertical, labelGroup, limitLength);
    } else if ((0, _util.isObject)(value)) {
      // object   type  cfg
      var overlapCfg = value;

      if (util[overlapCfg.type]) {
        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);
      }
    } else if (util[value]) {
      //  overlap 
      hasAdjusted = util[value](isVertical, labelGroup, limitLength);
    }

    if (name === 'autoRotate') {
      // 
      if (hasAdjusted) {
        var labels = labelGroup.getChildren();
        var verticalFactor_1 = this.get('verticalFactor');
        (0, _util.each)(labels, function (label) {
          var textAlign = label.attr('textAlign');

          if (textAlign === 'center') {
            // 
            var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';
            label.attr('textAlign', newAlign);
          }
        });
      }
    } else if (name === 'autoHide') {
      var children = labelGroup.getChildren().slice(0); // 

      (0, _util.each)(children, function (label) {
        if (!label.get('visible')) {
          if (_this.get('isRegister')) {
            // 
            _this.unregisterElement(label);
          }

          label.remove(); //  label 
        }
      });
    }
  };

  return Line;
}(_base.default);

var _default = Line;
exports.default = _default;

/***/ }),
/* 822 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoRotate = exports.autoHide = exports.autoEllipsis = void 0;

var autoEllipsis = _interopRequireWildcard(__webpack_require__(823));

exports.autoEllipsis = autoEllipsis;

var autoHide = _interopRequireWildcard(__webpack_require__(824));

exports.autoHide = autoHide;

var autoRotate = _interopRequireWildcard(__webpack_require__(825));

exports.autoRotate = autoRotate;

/***/ }),
/* 823 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefault = getDefault;
exports.ellipsisHead = ellipsisHead;
exports.ellipsisTail = ellipsisTail;
exports.ellipsisMiddle = ellipsisMiddle;

var _util = __webpack_require__(0);

var _label = __webpack_require__(140);

function ellipseLabels(isVertical, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsised = false;
  (0, _util.each)(children, function (label) {
    var rst = (0, _label.ellipsisLabel)(isVertical, label, limitLength, position);
    ellipsised = ellipsised || rst;
  });
  return ellipsised;
}

function getDefault() {
  return ellipsisTail;
}

function ellipsisHead(isVertical, labelGroup, limitLength) {
  return ellipseLabels(isVertical, labelGroup, limitLength, 'head');
}

function ellipsisTail(isVertical, labelGroup, limitLength) {
  return ellipseLabels(isVertical, labelGroup, limitLength, 'tail');
}

function ellipsisMiddle(isVertical, labelGroup, limitLength) {
  return ellipseLabels(isVertical, labelGroup, limitLength, 'middle');
}

/***/ }),
/* 824 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefault = getDefault;
exports.reserveFirst = reserveFirst;
exports.reserveLast = reserveLast;
exports.reserveBoth = reserveBoth;
exports.equidistance = equidistance;
exports.equidistanceWithReverseBoth = equidistanceWithReverseBoth;

var _label = __webpack_require__(140);

var _matrix = __webpack_require__(87);

var _util = __webpack_require__(44);

// 
function isRotate(label) {
  var matrix = label.attr('matrix');
  return matrix && matrix[0] !== 1; // 
}

function getRotateAngle(label) {
  var angle = isRotate(label) ? (0, _matrix.getAngleByMatrix)(label.attr('matrix')) : 0;
  return angle % 360;
} // autohide 
// function isOutLimit(isVertical: boolean, label: IElement, limitLength: number) {
//   if (!limitLength) {
//     //  limitLength  false
//     return false;
//   }
//   const canvasBBox = label.getCanvasBBox();
//   let isOut = false;
//   if (isVertical) {
//     isOut = canvasBBox.width > limitLength;
//   } else {
//     isOut = canvasBBox.height > limitLength;
//   }
//   return isOut;
// }
// 


function isOverlap(isVertical, first, second, minGap) {
  var overlap = false;
  var angle = getRotateAngle(first);
  var distance = isVertical ? Math.abs(second.attr('y') - first.attr('y')) : Math.abs(second.attr('x') - first.attr('x'));
  var prevBBox = (isVertical ? second.attr('y') > first.attr('y') : second.attr('x') > first.attr('x')) ? first.getBBox() : second.getBBox();

  if (isVertical) {
    var ratio = Math.abs(Math.cos(angle));

    if ((0, _util.near)(ratio, 0, Math.PI / 180)) {
      overlap = prevBBox.width + minGap > distance;
    } else {
      overlap = prevBBox.height / ratio + minGap > distance;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle));

    if ((0, _util.near)(ratio, 0, Math.PI / 180)) {
      overlap = prevBBox.width + minGap > distance;
    } else {
      overlap = prevBBox.height / ratio + minGap > distance;
    }
  }

  return overlap;
} // 


function reserveOne(isVertical, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice() // 
  .filter(function (item) {
    return item.get('visible');
  });

  if (!labels.length) {
    return false;
  }

  var hasHide = false;

  if (reversed) {
    // 
    labels.reverse();
  }

  var count = labels.length;
  var first = labels[0];
  var prev = first;

  for (var i = 1; i < count; i++) {
    var label = labels[i];
    var curBBox = label.getBBox(); //  isOutLimit(isVertical, label, limitLength) ||

    var isHide = isOverlap(isVertical, prev, label, minGap);

    if (isHide) {
      label.hide();
      hasHide = true;
    } else {
      prev = label;
    }
  }

  return hasHide;
} //  label/tick 


function parityHide(isVertical, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice(); // 

  if (labels.length < 2) {
    //  2  2 
    return false;
  }

  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count = labels.length;
  var angle = getRotateAngle(first);
  var distance = isVertical ? Math.abs(second.attr('y') - first.attr('y')) : Math.abs(second.attr('x') - first.attr('x'));
  var interval = 0; // 

  if (isVertical) {
    // 
    var ratio = Math.abs(Math.cos(angle));

    if ((0, _util.near)(ratio, 0, Math.PI / 180)) {
      var maxWidth = (0, _label.getMaxLabelWidth)(labels);
      interval = (maxWidth + minGap) / distance;
    } else {
      interval = (firstBBox.height / ratio + minGap) / distance;
    }
  } else {
    // 
    var ratio = Math.abs(Math.sin(angle));

    if ((0, _util.near)(ratio, 0, Math.PI / 180)) {
      var maxWidth = (0, _label.getMaxLabelWidth)(labels);
      interval = (maxWidth + minGap) / distance;
    } else {
      interval = (firstBBox.height / ratio + minGap) / distance;
    }
  } // interval > 1  label 


  if (interval > 1) {
    interval = Math.ceil(interval);

    for (var i = 0; i < count; i++) {
      if (i % interval !== 0) {
        //  label
        labels[i].hide();
        hasHide = true;
      }
    }
  }

  return hasHide;
}

function getDefault() {
  return equidistance;
}
/**
 *  label  limitLength 
 * @param {boolean} isVertical  
 * @param {IGroup}  labelsGroup label 
 * @param {number} limitLength autoHide 
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 
 */


function reserveFirst(isVertical, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical, labelsGroup, false, autoHideCfg);
}
/**
 *  label  limitLength 
 * @param {boolean} isVertical  
 * @param {IGroup}  labelsGroup label 
 * @param {number} limitLength autoHide 
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 
 */


function reserveLast(isVertical, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical, labelsGroup, true, autoHideCfg);
}
/**
 *  label  limitLength 
 * @param {boolean} isVertical  
 * @param {IGroup}  labelsGroup label 
 * @param {number} limitLength autoHide 
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 
 */


function reserveBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice(); // 

  if (labels.length <= 2) {
    //  2 
    return false;
  }

  var hasHide = false;
  var count = labels.length;
  var first = labels[0];
  var last = labels[count - 1];
  var preLabel = first; // 

  for (var i = 1; i < count - 1; i++) {
    var label = labels[i];
    var curBBox = label.getBBox(); //  isOutLimit(isVertical, label, limitLength) ||

    var isHide = isOverlap(isVertical, preLabel, label, minGap);

    if (isHide) {
      label.hide();
      hasHide = true;
    } else {
      preLabel = label;
    }
  }

  var overlap = isOverlap(isVertical, preLabel, last, minGap);

  if (overlap) {
    // 
    preLabel.hide();
    hasHide = true;
  }

  return hasHide;
}
/**
 *  label    limitLength 
 * @param {boolean} isVertical  
 * @param {IGroup}  labelsGroup label 
 * @param {number} limitLength autoHide 
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 
 */


function equidistance(isVertical, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg); //   timeCat  tick

  if (reserveOne(isVertical, labelsGroup, false)) {
    hasHide = true;
  }

  return hasHide;
}
/**
 *  equidistance  labels 
 * @param isVertical
 * @param labelsGroup
 * @param {number} limitLength autoHide 
 * @param {AxisLabelAutoHideCfg} autoHideCfg autoHide overlap 
 */


function equidistanceWithReverseBoth(isVertical, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice(); // 

  var hasHide = parityHide(isVertical, labelsGroup, autoHideCfg);

  if (labels.length > 2) {
    var first = labels[0];
    var last = labels[labels.length - 1]; // 

    if (!first.get('visible')) {
      first.show();

      if (reserveOne(isVertical, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    } // 


    if (!last.get('visible')) {
      last.show();

      if (reserveOne(isVertical, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }

  return hasHide;
}

/***/ }),
/* 825 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefault = getDefault;
exports.fixedAngle = fixedAngle;
exports.unfixedAngle = unfixedAngle;

var _util = __webpack_require__(0);

var _label = __webpack_require__(140);

var _matrix = __webpack_require__(87);

var _theme = _interopRequireDefault(__webpack_require__(60));

// 
function setLabelsAngle(labels, angle) {
  (0, _util.each)(labels, function (label) {
    var x = label.attr('x');
    var y = label.attr('y');
    var matrix = (0, _matrix.getMatrixByAngle)({
      x: x,
      y: y
    }, angle);
    label.attr('matrix', matrix);
  });
} // 


function labelRotate(isVertical, labelsGroup, limitLength, getAngle) {
  var labels = labelsGroup.getChildren();

  if (!labels.length) {
    return false;
  }

  if (!isVertical && labels.length < 2) {
    // 
    return false;
  }

  var maxWidth = (0, _label.getMaxLabelWidth)(labels);
  var isOverlap = false;

  if (isVertical) {
    // limitLength  0  null 
    isOverlap = !!limitLength && maxWidth > limitLength;
  } else {
    //  limitLength 
    var tickWidth = Math.abs(labels[1].attr('x') - labels[0].attr('x'));
    isOverlap = maxWidth > tickWidth;
  }

  if (isOverlap) {
    var angle = getAngle(limitLength, maxWidth);
    setLabelsAngle(labels, angle);
  }

  return isOverlap;
}

function getDefault() {
  return fixedAngle;
}
/**
 * 
 * @param  {boolean} isVertical  
 * @param  {IGroup}  labelsGroup  group
 * @param  {number}  limitLength 
 * @param  {number}  customRotate 
 * @return {boolean}             
 */


function fixedAngle(isVertical, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical, labelsGroup, limitLength, function () {
    if ((0, _util.isNumber)(customRotate)) {
      return customRotate;
    }

    return isVertical ? _theme.default.verticalAxisRotate : _theme.default.horizontalAxisRotate;
  });
}
/**
 * 
 * @param  {boolean} isVertical  
 * @param  {IGroup}  labelsGroup  group
 * @param  {number}  limitLength 
 * @return {boolean}             
 */


function unfixedAngle(isVertical, labelsGroup, limitLength) {
  return labelRotate(isVertical, labelsGroup, limitLength, function (length, maxWidth) {
    if (!length) {
      //  limitLength
      return isVertical ? _theme.default.verticalAxisRotate : _theme.default.horizontalAxisRotate;
    }

    if (isVertical) {
      //  limitLength > maxWidth  overlap
      return -Math.acos(length / maxWidth);
    } else {
      var angle = 0;

      if (length > maxWidth) {
        // asin  -1 1
        angle = Math.PI / 4;
      } else {
        angle = Math.asin(length / maxWidth);

        if (angle > Math.PI / 4) {
          //  Math.PI / 4 
          angle = Math.PI / 4;
        }
      }

      return angle;
    }
  });
}

/***/ }),
/* 826 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _matrixUtil = __webpack_require__(33);

var _base = _interopRequireDefault(__webpack_require__(253));

var Circle =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Circle, _super);

  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Circle.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'circle',
      locationType: 'circle',
      center: null,
      radius: null,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2
    });
  };

  Circle.prototype.getLinePath = function () {
    var center = this.get('center');
    var x = center.x;
    var y = center.y;
    var rx = this.get('radius');
    var ry = rx;
    var startAngle = this.get('startAngle');
    var endAngle = this.get('endAngle');
    var path = [];

    if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
      path = [['M', x, y - ry], ['A', rx, ry, 0, 1, 1, x, y + ry], ['A', rx, ry, 0, 1, 1, x, y - ry], ['Z']];
    } else {
      var startPoint = this.getCirclePoint(startAngle);
      var endPoint = this.getCirclePoint(endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path = [['M', x, y], ['L', startPoint.x, startPoint.y], ['A', rx, ry, 0, large, sweep, endPoint.x, endPoint.y], ['L', x, y]];
    }

    return path;
  };

  Circle.prototype.getTickPoint = function (tickValue) {
    var startAngle = this.get('startAngle');
    var endAngle = this.get('endAngle');
    var angle = startAngle + (endAngle - startAngle) * tickValue;
    return this.getCirclePoint(angle);
  }; // 


  Circle.prototype.getSideVector = function (offset, point) {
    var center = this.get('center');
    var vector = [point.x - center.x, point.y - center.y];
    var factor = this.get('verticalFactor');

    var vecLen = _matrixUtil.vec2.length(vector);

    _matrixUtil.vec2.scale(vector, vector, factor * offset / vecLen);

    return vector;
  }; // 


  Circle.prototype.getAxisVector = function (point) {
    var center = this.get('center');
    var vector = [point.x - center.x, point.y - center.y];
    return [vector[1], -1 * vector[0]]; // 
  }; // 


  Circle.prototype.getCirclePoint = function (angle, radius) {
    var center = this.get('center');
    radius = radius || this.get('radius');
    return {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius
    };
  };

  return Circle;
}(_base.default);

var _default = Circle;
exports.default = _default;

/***/ }),
/* 827 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Html", {
  enumerable: true,
  get: function get() {
    return _html.default;
  }
});

var _line = _interopRequireDefault(__webpack_require__(828));

var _circle = _interopRequireDefault(__webpack_require__(829));

var _base = _interopRequireDefault(__webpack_require__(254));

var _html = _interopRequireDefault(__webpack_require__(830));

/***/ }),
/* 828 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(44);

var _base = _interopRequireDefault(__webpack_require__(254));

var LineCrosshair =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LineCrosshair, _super);

  function LineCrosshair() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  LineCrosshair.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'line',
      locationType: 'region',
      start: null,
      end: null
    });
  }; // 


  LineCrosshair.prototype.getRotateAngle = function () {
    var _a = this.getLocation(),
        start = _a.start,
        end = _a.end;

    var position = this.get('text').position;
    var angle = Math.atan2(end.y - start.y, end.x - start.x);
    var tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;
    return tangentAngle;
  };

  LineCrosshair.prototype.getTextPoint = function () {
    var _a = this.getLocation(),
        start = _a.start,
        end = _a.end;

    var _b = this.get('text'),
        position = _b.position,
        offset = _b.offset;

    return (0, _util.getTextPoint)(start, end, position, offset);
  };

  LineCrosshair.prototype.getLinePath = function () {
    var _a = this.getLocation(),
        start = _a.start,
        end = _a.end;

    return [['M', start.x, start.y], ['L', end.x, end.y]];
  };

  return LineCrosshair;
}(_base.default);

var _default = LineCrosshair;
exports.default = _default;

/***/ }),
/* 829 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(44);

var _base = _interopRequireDefault(__webpack_require__(254));

var LineCrosshair =
/** @class */
function (_super) {
  (0, _tslib.__extends)(LineCrosshair, _super);

  function LineCrosshair() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  LineCrosshair.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'circle',
      locationType: 'circle',
      center: null,
      radius: 100,
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2
    });
  };

  LineCrosshair.prototype.getRotateAngle = function () {
    var _a = this.getLocation(),
        startAngle = _a.startAngle,
        endAngle = _a.endAngle;

    var position = this.get('text').position;
    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
    return tangentAngle;
  };

  LineCrosshair.prototype.getTextPoint = function () {
    var text = this.get('text');
    var position = text.position,
        offset = text.offset;

    var _a = this.getLocation(),
        center = _a.center,
        radius = _a.radius,
        startAngle = _a.startAngle,
        endAngle = _a.endAngle;

    var angle = position === 'start' ? startAngle : endAngle;
    var tangentAngle = this.getRotateAngle() - Math.PI;
    var point = (0, _util.getCirclePoint)(center, radius, angle); //  offset
    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];
    // const offsetVector = vec2.scale([], tangent, offset);

    var offsetX = Math.cos(tangentAngle) * offset;
    var offsetY = Math.sin(tangentAngle) * offset;
    return {
      x: point.x + offsetX,
      y: point.y + offsetY
    };
  };

  LineCrosshair.prototype.getLinePath = function () {
    var _a = this.getLocation(),
        center = _a.center,
        radius = _a.radius,
        startAngle = _a.startAngle,
        endAngle = _a.endAngle;

    var path = null;

    if (endAngle - startAngle === Math.PI * 2) {
      // 
      var x = center.x,
          y = center.y;
      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];
    } else {
      var startPoint = (0, _util.getCirclePoint)(center, radius, startAngle);
      var endPoint = (0, _util.getCirclePoint)(center, radius, endAngle);
      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
      var sweep = startAngle > endAngle ? 0 : 1;
      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];
    }

    return path;
  };

  return LineCrosshair;
}(_base.default);

var _default = LineCrosshair;
exports.default = _default;

/***/ }),
/* 830 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _domUtil = __webpack_require__(112);

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(44);

var _htmlComponent = _interopRequireDefault(__webpack_require__(186));

var CssConst = _interopRequireWildcard(__webpack_require__(423));

var _htmlTheme = _interopRequireDefault(__webpack_require__(831));

var HtmlCrosshair =
/** @class */
function (_super) {
  (0, _tslib.__extends)(HtmlCrosshair, _super);

  function HtmlCrosshair() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  HtmlCrosshair.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'crosshair',
      type: 'html',
      locationType: 'region',
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      },
      capture: false,
      text: null,
      containerTpl: "<div class=\"" + CssConst.CONTAINER_CLASS + "\"></div>",
      crosshairTpl: "<div class=\"" + CssConst.CROSSHAIR_LINE + "\"></div>",
      textTpl: "<span class=\"" + CssConst.CROSSHAIR_TEXT + "\">{content}</span>",
      domStyles: null,
      containerClassName: CssConst.CONTAINER_CLASS,
      defaultStyles: _htmlTheme.default,
      defaultCfg: {
        text: {
          position: 'start',
          content: null,
          align: 'center',
          offset: 10
        }
      }
    });
  };

  HtmlCrosshair.prototype.render = function () {
    this.resetText();
    this.resetPosition();
  }; //  crosshair


  HtmlCrosshair.prototype.initCrossHair = function () {
    var container = this.getContainer();
    var crosshairTpl = this.get('crosshairTpl');
    var crosshairEl = (0, _domUtil.createDom)(crosshairTpl);
    container.appendChild(crosshairEl);
    this.applyStyle(CssConst.CROSSHAIR_LINE, crosshairEl);
    this.set('crosshairEl', crosshairEl);
  }; // 


  HtmlCrosshair.prototype.getTextPoint = function () {
    var _a = this.getLocation(),
        start = _a.start,
        end = _a.end;

    var _b = this.get('text'),
        position = _b.position,
        offset = _b.offset;

    return (0, _util2.getTextPoint)(start, end, position, offset);
  }; //  text


  HtmlCrosshair.prototype.resetText = function () {
    var text = this.get('text');
    var textEl = this.get('textEl');

    if (text) {
      var content = text.content;

      if (!textEl) {
        var container = this.getContainer();
        var textTpl = (0, _util.substitute)(this.get('textTpl'), text);
        textEl = (0, _domUtil.createDom)(textTpl);
        container.appendChild(textEl);
        this.applyStyle(CssConst.CROSSHAIR_TEXT, textEl);
        this.set('textEl', textEl);
      }

      textEl.innerHTML = content;
    } else if (textEl) {
      textEl.remove();
    }
  }; // 


  HtmlCrosshair.prototype.isVertical = function (start, end) {
    return start.x === end.x;
  }; // 


  HtmlCrosshair.prototype.resetPosition = function () {
    var crosshairEl = this.get('crosshairEl');

    if (!crosshairEl) {
      this.initCrossHair();
      crosshairEl = this.get('crosshairEl');
    }

    var start = this.get('start');
    var end = this.get('end');
    var minX = Math.min(start.x, end.x);
    var minY = Math.min(start.y, end.y);

    if (this.isVertical(start, end)) {
      (0, _domUtil.modifyCSS)(crosshairEl, {
        width: '1px',
        height: (0, _util2.toPx)(Math.abs(end.y - start.y))
      });
    } else {
      (0, _domUtil.modifyCSS)(crosshairEl, {
        height: '1px',
        width: (0, _util2.toPx)(Math.abs(end.x - start.x))
      });
    }

    (0, _domUtil.modifyCSS)(crosshairEl, {
      top: (0, _util2.toPx)(minY),
      left: (0, _util2.toPx)(minX)
    });
    this.alignText();
  };

  HtmlCrosshair.prototype.alignText = function () {
    //  text 
    var textEl = this.get('textEl');

    if (textEl) {
      var align = this.get('text').align;
      var clientWidth = textEl.clientWidth;
      var point = this.getTextPoint();

      switch (align) {
        case 'center':
          point.x = point.x - clientWidth / 2;
          break;

        case 'right':
          point.x = point.x - clientWidth;

        case 'left':
          break;
      }

      (0, _domUtil.modifyCSS)(textEl, {
        top: (0, _util2.toPx)(point.y),
        left: (0, _util2.toPx)(point.x)
      });
    }
  };

  HtmlCrosshair.prototype.updateInner = function (cfg) {
    if ((0, _util.hasKey)(cfg, 'text')) {
      this.resetText();
    }

    _super.prototype.updateInner.call(this, cfg);
  };

  return HtmlCrosshair;
}(_htmlComponent.default);

var _default = HtmlCrosshair;
exports.default = _default;

/***/ }),
/* 831 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _theme = _interopRequireDefault(__webpack_require__(60));

var CssConst = _interopRequireWildcard(__webpack_require__(423));

var _a;

var _default = (_a = {}, // css style for tooltip
_a["" + CssConst.CONTAINER_CLASS] = {
  position: 'relative'
}, _a["" + CssConst.CROSSHAIR_LINE] = {
  position: 'absolute',
  backgroundColor: 'rgba(0, 0, 0, 0.25)'
}, _a["" + CssConst.CROSSHAIR_TEXT] = {
  position: 'absolute',
  color: _theme.default.textColor,
  fontFamily: _theme.default.fontFamily
}, _a);

exports.default = _default;

/***/ }),
/* 832 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});
Object.defineProperty(exports, "Circle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "Line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});

var _base = _interopRequireDefault(__webpack_require__(255));

var _circle = _interopRequireDefault(__webpack_require__(833));

var _line = _interopRequireDefault(__webpack_require__(834));

/***/ }),
/* 833 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(255));

function distance(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

var Circle =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Circle, _super);

  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Circle.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'circle',

      /**
       * 
       * @type {object}
       */
      center: null,

      /**
       * 
       * @type {true}
       */
      closed: true
    });
  };

  Circle.prototype.getGridPath = function (points, reversed) {
    var lineType = this.getLineType();
    var closed = this.get('closed');
    var path = [];

    if (points.length) {
      // 
      if (lineType === 'circle') {
        var center = this.get('center');
        var firstPoint = points[0];
        var radius_1 = distance(center.x, center.y, firstPoint.x, firstPoint.y);
        var sweepFlag_1 = reversed ? 0 : 1; // 

        if (closed) {
          // 
          path.push(['M', center.x, center.y - radius_1]);
          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y + radius_1]);
          path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, center.x, center.y - radius_1]);
          path.push(['Z']);
        } else {
          (0, _util.each)(points, function (point, index) {
            if (index === 0) {
              path.push(['M', point.x, point.y]);
            } else {
              path.push(['A', radius_1, radius_1, 0, 0, sweepFlag_1, point.x, point.y]);
            }
          });
        }
      } else {
        (0, _util.each)(points, function (point, index) {
          if (index === 0) {
            path.push(['M', point.x, point.y]);
          } else {
            path.push(['L', point.x, point.y]);
          }
        });

        if (closed) {
          path.push(['Z']);
        }
      }
    }

    return path;
  };

  return Circle;
}(_base.default);

var _default = Circle;
exports.default = _default;

/***/ }),
/* 834 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(255));

var Line =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Line, _super);

  function Line() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Line.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'line'
    });
  };

  Line.prototype.getGridPath = function (points) {
    var path = [];
    (0, _util.each)(points, function (point, index) {
      if (index === 0) {
        path.push(['M', point.x, point.y]);
      } else {
        path.push(['L', point.x, point.y]);
      }
    });
    return path;
  };

  return Line;
}(_base.default);

var _default = Line;
exports.default = _default;

/***/ }),
/* 835 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Category", {
  enumerable: true,
  get: function get() {
    return _category.default;
  }
});
Object.defineProperty(exports, "Continuous", {
  enumerable: true,
  get: function get() {
    return _continuous.default;
  }
});
Object.defineProperty(exports, "Base", {
  enumerable: true,
  get: function get() {
    return _base.default;
  }
});

var _category = _interopRequireDefault(__webpack_require__(836));

var _continuous = _interopRequireDefault(__webpack_require__(837));

var _base = _interopRequireDefault(__webpack_require__(256));

/***/ }),
/* 836 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _label = __webpack_require__(140);

var _matrix = __webpack_require__(87);

var _state = __webpack_require__(422);

var _theme = _interopRequireDefault(__webpack_require__(60));

var _base = _interopRequireDefault(__webpack_require__(256));

var Category =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Category, _super);

  function Category() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.currentPageIndex = 1;
    _this.totalPagesCnt = 1;
    _this.pageWidth = 0;
    _this.pageHeight = 0;
    _this.startX = 0;
    _this.startY = 0;

    _this.onNavigationBack = function () {
      var itemGroup = _this.getElementByLocalId('item-group');

      if (_this.currentPageIndex > 1) {
        _this.currentPageIndex -= 1;

        _this.updateNavigation();

        var matrix = _this.getCurrentNavigationMatrix();

        if (_this.get('animate')) {
          itemGroup.animate({
            matrix: matrix
          }, 100);
        } else {
          itemGroup.attr({
            matrix: matrix
          });
        }
      }
    };

    _this.onNavigationAfter = function () {
      var itemGroup = _this.getElementByLocalId('item-group');

      if (_this.currentPageIndex < _this.totalPagesCnt) {
        _this.currentPageIndex += 1;

        _this.updateNavigation();

        var matrix = _this.getCurrentNavigationMatrix();

        if (_this.get('animate')) {
          itemGroup.animate({
            matrix: matrix
          }, 100);
        } else {
          itemGroup.attr({
            matrix: matrix
          });
        }
      }
    };

    return _this;
  }

  Category.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'legend',
      type: 'category',
      itemSpacing: 24,
      itemMarginBottom: 8,
      maxItemWidth: null,
      itemWidth: null,
      itemHeight: null,
      itemName: {},
      itemValue: null,
      maxWidth: null,
      maxHeight: null,
      marker: {},
      items: [],
      itemStates: {},
      itemBackground: {},
      defaultCfg: {
        title: {
          spacing: 5,
          style: {
            fill: _theme.default.textColor,
            fontSize: 12,
            textAlign: 'start',
            textBaseline: 'top'
          }
        },
        background: {
          padding: 5,
          style: {
            stroke: _theme.default.lineColor
          }
        },
        itemBackground: {
          style: {
            opacity: 0,
            fill: '#fff'
          }
        },
        itemName: {
          spacing: 16,
          style: {
            fill: _theme.default.textColor,
            fontSize: 12,
            textAlign: 'start',
            textBaseline: 'middle'
          }
        },
        marker: {
          spacing: 8,
          style: {
            r: 6,
            symbol: 'circle'
          }
        },
        itemValue: {
          alignRight: false,
          formatter: null,
          style: {
            fill: _theme.default.textColor,
            fontSize: 12,
            textAlign: 'start',
            textBaseline: 'middle'
          }
        },
        itemStates: {
          active: {
            nameStyle: {
              opacity: 0.8
            }
          },
          unchecked: {
            nameStyle: {
              fill: _theme.default.uncheckedColor
            },
            markerStyle: {
              fill: _theme.default.uncheckedColor,
              stroke: _theme.default.uncheckedColor
            }
          },
          inactive: {
            nameStyle: {
              fill: _theme.default.uncheckedColor
            },
            markerStyle: {
              opacity: 0.2
            }
          }
        }
      }
    });
  }; //  IList 


  Category.prototype.isList = function () {
    return true;
  };
  /**
   * 
   * @return {ListItem[]} 
   */


  Category.prototype.getItems = function () {
    return this.get('items');
  };
  /**
   * 
   * @param {ListItem[]} items 
   */


  Category.prototype.setItems = function (items) {
    this.update({
      items: items
    });
  };
  /**
   * 
   * @param {ListItem} item 
   * @param {object}   cfg  
   */


  Category.prototype.updateItem = function (item, cfg) {
    (0, _util.mix)(item, cfg);
    this.clear(); // 

    this.render();
  };
  /**
   * 
   */


  Category.prototype.clearItems = function () {
    var itemGroup = this.getElementByLocalId('item-group');
    itemGroup && itemGroup.clear();
  };
  /**
   * 
   * @param {ListItem} item  
   * @param {string}   state 
   * @param {boolean}  value , true, false
   */


  Category.prototype.setItemState = function (item, state, value) {
    item[state] = value;
    var itemElement = this.getElementByLocalId("item-" + item.id);

    if (itemElement) {
      var items = this.getItems();
      var index = items.indexOf(item);
      var offsetGroup = this.createOffScreenGroup(); //  group

      var newElement = this.drawItem(item, index, this.getItemHeight(), offsetGroup);
      this.updateElements(newElement, itemElement); // 

      this.clearUpdateStatus(itemElement); //  bug
    }
  };
  /**
   * 
   * @param {ListItem} item  
   * @param {boolean} state 
   */


  Category.prototype.hasState = function (item, state) {
    return !!item[state];
  };

  Category.prototype.getItemStates = function (item) {
    var itemStates = this.get('itemStates');
    var rst = [];
    (0, _util.each)(itemStates, function (v, k) {
      if (item[k]) {
        // item.selected
        rst.push(k);
      }
    });
    return rst;
  };
  /**
   * 
   * @param {string} state 
   */


  Category.prototype.clearItemsState = function (state) {
    var _this = this;

    var items = this.getItemsByState(state);
    (0, _util.each)(items, function (item) {
      _this.setItemState(item, state, false);
    });
  };
  /**
   * 
   * @param  {string}     state [description]
   * @return {ListItem[]}       [description]
   */


  Category.prototype.getItemsByState = function (state) {
    var _this = this;

    var items = this.getItems();
    return (0, _util.filter)(items, function (item) {
      return _this.hasState(item, state);
    });
  }; //  legend 


  Category.prototype.drawLegendContent = function (group) {
    this.processItems();
    this.drawItems(group);
  }; //  id


  Category.prototype.processItems = function () {
    var items = this.get('items');
    (0, _util.each)(items, function (item) {
      if (!item.id) {
        //  id name
        item.id = item.name;
      }
    });
  }; // 


  Category.prototype.drawItems = function (group) {
    var _this = this;

    var itemContainerGroup = this.addGroup(group, {
      id: this.getElementId('item-container-group'),
      name: 'legend-item-container-group'
    });
    var itemGroup = this.addGroup(itemContainerGroup, {
      id: this.getElementId('item-group'),
      name: 'legend-item-group'
    });
    var itemHeight = this.getItemHeight();
    var itemWidth = this.get('itemWidth');
    var itemSpacing = this.get('itemSpacing');
    var itemMarginBottom = this.get('itemMarginBottom');
    var currentPoint = this.get('currentPoint');
    var startX = currentPoint.x;
    var startY = currentPoint.y;
    var layout = this.get('layout');
    var items = this.get('items');
    var wrapped = false;
    var pageWidth = 0;
    var maxWidth = this.get('maxWidth'); //  layout : 'horizontal' 

    var maxHeight = this.get('maxHeight'); // 
    // 

    (0, _util.each)(items, function (item, index) {
      var subGroup = _this.drawItem(item, index, itemHeight, itemGroup);

      var bbox = subGroup.getBBox();
      var width = itemWidth || bbox.width;

      if (width > pageWidth) {
        pageWidth = width;
      }

      if (layout === 'horizontal') {
        // 
        if (maxWidth && maxWidth < currentPoint.x + width - startX) {
          // 
          wrapped = true;
          currentPoint.x = startX;
          currentPoint.y += itemHeight + itemMarginBottom;
        }

        _this.moveElementTo(subGroup, currentPoint);

        currentPoint.x += width + itemSpacing;
      } else {
        // 
        if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
          // 
          wrapped = true;
          currentPoint.x += pageWidth + itemSpacing;
          currentPoint.y = startY;
          pageWidth = 0;
        }

        _this.moveElementTo(subGroup, currentPoint);

        currentPoint.y += itemHeight + itemMarginBottom; // itemSpacing 
      }
    });

    if (wrapped && this.get('flipPage')) {
      this.pageHeight = 0;
      this.pageWidth = 0;
      this.totalPagesCnt = 1;
      this.startX = startX;
      this.startY = startY;
      this.adjustNavigation(group, itemGroup);
    }
  }; //  name 


  Category.prototype.getItemHeight = function () {
    var itemHeight = this.get('itemHeight');

    if (!itemHeight) {
      var nameCfg = this.get('itemName');

      if (nameCfg) {
        itemHeight = nameCfg.style.fontSize;
      }
    }

    return itemHeight;
  }; //  marker


  Category.prototype.drawMarker = function (container, markerCfg, item, itemHeight) {
    var markerAttrs = (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({
      x: 0,
      y: itemHeight / 2
    }, markerCfg.style), {
      symbol: (0, _util.get)(item.marker, 'symbol', 'circle')
    }), (0, _util.get)(item.marker, 'style', {}));
    var shape = this.addShape(container, {
      type: 'marker',
      id: this.getElementId("item-" + item.id + "-marker"),
      name: 'legend-item-marker',
      attrs: markerAttrs
    });
    var bbox = shape.getBBox();
    shape.attr('x', bbox.width / 2); // marker 

    var _a = shape.attr(),
        stroke = _a.stroke,
        fill = _a.fill;

    if (stroke) {
      shape.set('isStroke', true);
    }

    if (fill) {
      shape.set('isFill', true);
    }

    return shape;
  }; // 


  Category.prototype.drawItemText = function (container, textName, cfg, item, itemHeight, xPosition, index) {
    var formatter = cfg.formatter;
    var attrs = (0, _tslib.__assign)({
      x: xPosition,
      y: itemHeight / 2,
      text: formatter ? formatter(item[textName], item, index) : item[textName]
    }, cfg.style);
    return this.addShape(container, {
      type: 'text',
      id: this.getElementId("item-" + item.id + "-" + textName),
      name: "legend-item-" + textName,
      attrs: attrs
    });
  }; // 


  Category.prototype.drawItem = function (item, index, itemHeight, itemGroup) {
    var groupId = "item-" + item.id; //  Group  setClip

    var subContainer = this.addGroup(itemGroup, {
      name: 'legend-item-container',
      id: this.getElementId("item-container-" + groupId),
      delegateObject: {
        item: item,
        index: index
      }
    });
    var subGroup = this.addGroup(subContainer, {
      name: 'legend-item',
      id: this.getElementId(groupId),
      delegateObject: {
        item: item,
        index: index
      }
    });
    var marker = this.get('marker');
    var itemName = this.get('itemName');
    var itemValue = this.get('itemValue');
    var itemBackground = this.get('itemBackground');
    var itemWidth = this.getLimitItemWidth();
    var curX = 0; //  x 

    if (marker) {
      var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
      curX = markerShape.getBBox().maxX + marker.spacing;
    }

    if (itemName) {
      var nameShape = this.drawItemText(subGroup, 'name', itemName, item, itemHeight, curX, index);

      if (itemWidth) {
        //  item 
        (0, _label.ellipsisLabel)(true, nameShape, (0, _util.clamp)(itemWidth - curX, 0, itemWidth));
      }

      curX = nameShape.getBBox().maxX + itemName.spacing;
    }

    if (itemValue) {
      var valueShape = this.drawItemText(subGroup, 'value', itemValue, item, itemHeight, curX, index);

      if (itemWidth) {
        if (itemValue.alignRight) {
          valueShape.attr({
            textAlign: 'right',
            x: itemWidth
          });
          (0, _label.ellipsisLabel)(true, valueShape, (0, _util.clamp)(itemWidth - curX, 0, itemWidth), 'head');
        } else {
          (0, _label.ellipsisLabel)(true, valueShape, (0, _util.clamp)(itemWidth - curX, 0, itemWidth));
        }
      }
    } // 


    if (itemBackground) {
      var bbox = subGroup.getBBox();
      var backShape = this.addShape(subGroup, {
        type: 'rect',
        name: 'legend-item-background',
        id: this.getElementId(groupId + "-background"),
        attrs: (0, _tslib.__assign)({
          x: 0,
          y: 0,
          width: bbox.width,
          height: itemHeight
        }, itemBackground.style)
      });
      backShape.toBack();
    }

    this.applyItemStates(item, subGroup);
    return subGroup;
  }; //  items


  Category.prototype.adjustNavigation = function (container, itemGroup) {
    var _this = this;

    var startX = this.startX;
    var startY = this.startY;
    var layout = this.get('layout');
    var subGroups = itemGroup.findAll(function (item) {
      return item.get('name') === 'legend-item';
    });
    var maxWidth = this.get('maxWidth');
    var maxHeight = this.get('maxHeight');
    var itemWidth = this.get('itemWidth');
    var itemSpacing = this.get('itemSpacing');
    var itemHeight = this.getItemHeight();
    var navigation = this.drawNavigation(container, layout, '00/00', 12);
    var navigationBBox = navigation.getBBox();
    var currentPoint = {
      x: startX,
      y: startY
    };
    var pages = 1;
    var widthLimit = 0;
    var pageWidth = 0;
    var maxItemWidth = 0;

    if (layout === 'horizontal') {
      this.pageHeight = itemHeight;
      (0, _util.each)(subGroups, function (item) {
        var bbox = item.getBBox();
        var width = itemWidth || bbox.width;

        if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
          if (pages === 1) {
            widthLimit = currentPoint.x + itemSpacing;
            _this.pageWidth = widthLimit;

            _this.moveElementTo(navigation, {
              x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
              y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
            });
          }

          pages += 1;
          currentPoint.x = startX;
          currentPoint.y += itemHeight;
        }

        _this.moveElementTo(item, currentPoint);

        item.getParent().setClip({
          type: 'rect',
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: width + itemSpacing,
            height: itemHeight
          }
        });
        currentPoint.x += width + itemSpacing;
      });
    } else {
      var itemMarginBottom_1 = this.get('itemMarginBottom');
      (0, _util.each)(subGroups, function (item) {
        var bbox = item.getBBox();

        if (bbox.width > pageWidth) {
          pageWidth = bbox.width;
        }
      });
      maxItemWidth = pageWidth;
      pageWidth += itemSpacing;

      if (maxWidth) {
        // maxWidth 
        pageWidth = Math.min(maxWidth, pageWidth);
        maxItemWidth = Math.min(maxWidth, maxItemWidth);
      }

      this.pageWidth = pageWidth;
      this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom_1);
      var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom_1));
      (0, _util.each)(subGroups, function (item, index) {
        if (index !== 0 && index % cntPerPage_1 === 0) {
          pages += 1;
          currentPoint.x += pageWidth;
          currentPoint.y = startY;
        }

        _this.moveElementTo(item, currentPoint);

        item.getParent().setClip({
          type: 'rect',
          attrs: {
            x: currentPoint.x,
            y: currentPoint.y,
            width: pageWidth,
            height: itemHeight
          }
        });
        currentPoint.y += itemHeight + itemMarginBottom_1;
      });
      this.totalPagesCnt = pages;
      this.moveElementTo(navigation, {
        x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
        y: maxHeight - navigationBBox.height - navigationBBox.minY
      });
    }

    if (this.pageHeight && this.pageWidth) {
      //  clip clip  itemContainerGroup itemGroup  matrix
      itemGroup.getParent().setClip({
        type: 'rect',
        attrs: {
          x: this.startX,
          y: this.startY,
          width: this.pageWidth,
          height: this.pageHeight
        }
      });
    }

    this.totalPagesCnt = pages;

    if (this.currentPageIndex > this.totalPagesCnt) {
      this.currentPageIndex = 1;
    }

    this.updateNavigation(navigation); // update initial matrix

    itemGroup.attr('matrix', this.getCurrentNavigationMatrix());
  };

  Category.prototype.drawNavigation = function (group, layout, text, size) {
    var currentPoint = {
      x: 0,
      y: 0
    };
    var subGroup = this.addGroup(group, {
      id: this.getElementId('navigation-group'),
      name: 'legend-navigation'
    });
    var leftArrow = this.drawArrow(subGroup, currentPoint, 'navigation-arrow-left', layout === 'horizontal' ? 'up' : 'left', size);
    leftArrow.on('click', this.onNavigationBack);
    var leftArrowBBox = leftArrow.getBBox();
    currentPoint.x += leftArrowBBox.width + 2;
    var textShape = this.addShape(subGroup, {
      type: 'text',
      id: this.getElementId('navigation-text'),
      name: 'navigation-text',
      attrs: {
        x: currentPoint.x,
        y: currentPoint.y + size / 2,
        text: text,
        fontSize: 12,
        fill: '#ccc',
        textBaseline: 'middle'
      }
    });
    var textBBox = textShape.getBBox();
    currentPoint.x += textBBox.width + 2;
    var rightArrow = this.drawArrow(subGroup, currentPoint, 'navigation-arrow-right', layout === 'horizontal' ? 'down' : 'right', size);
    rightArrow.on('click', this.onNavigationAfter);
    return subGroup;
  };

  Category.prototype.updateNavigation = function (navigation) {
    var text = this.currentPageIndex + "/" + this.totalPagesCnt;
    var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId('navigation-text');
    var leftArrow = navigation ? navigation.findById(this.getElementId('navigation-arrow-left')) : this.getElementByLocalId('navigation-arrow-left');
    var rightArrow = navigation ? navigation.findById(this.getElementId('navigation-arrow-right')) : this.getElementByLocalId('navigation-arrow-right');
    var origBBox = textShape.getBBox();
    textShape.attr('text', text);
    var newBBox = textShape.getBBox();
    textShape.attr('x', textShape.attr('x') - (newBBox.width - origBBox.width) / 2);
    leftArrow.attr('opacity', this.currentPageIndex === 1 ? 0.45 : 1);
    leftArrow.attr('cursor', this.currentPageIndex === 1 ? 'not-allowed' : 'pointer');
    rightArrow.attr('opacity', this.currentPageIndex === this.totalPagesCnt ? 0.45 : 1);
    rightArrow.attr('cursor', this.currentPageIndex === this.totalPagesCnt ? 'not-allowed' : 'pointer');
  };

  Category.prototype.drawArrow = function (group, currentPoint, name, direction, size) {
    var x = currentPoint.x,
        y = currentPoint.y;
    var rotateMap = {
      right: 90 * Math.PI / 180,
      left: (360 - 90) * Math.PI / 180,
      up: 0,
      down: 180 * Math.PI / 180
    };
    var shape = this.addShape(group, {
      type: 'path',
      id: this.getElementId(name),
      name: name,
      attrs: {
        path: [['M', x + size / 2, y], ['L', x, y + size], ['L', x + size, y + size], ['Z']],
        fill: '#000',
        cursor: 'pointer'
      }
    });
    shape.attr('matrix', (0, _matrix.getMatrixByAngle)({
      x: x + size / 2,
      y: y + size / 2
    }, rotateMap[direction]));
    return shape;
  };

  Category.prototype.getCurrentNavigationMatrix = function () {
    var _a = this,
        currentPageIndex = _a.currentPageIndex,
        pageWidth = _a.pageWidth,
        pageHeight = _a.pageHeight;

    var layout = this.get('layout');
    var translate = layout === 'horizontal' ? {
      x: 0,
      y: pageHeight * (1 - currentPageIndex)
    } : {
      x: pageWidth * (1 - currentPageIndex),
      y: 0
    };
    return (0, _matrix.getMatrixByTranslate)(translate);
  }; // 


  Category.prototype.applyItemStates = function (item, subGroup) {
    var states = this.getItemStates(item);
    var hasStates = states.length > 0;

    if (hasStates) {
      var children = subGroup.getChildren();
      var itemStates_1 = this.get('itemStates');
      (0, _util.each)(children, function (element) {
        var name = element.get('name');
        var elName = name.split('-')[2]; // marker, name, value

        var statesStyle = (0, _state.getStatesStyle)(item, elName, itemStates_1);

        if (statesStyle) {
          element.attr(statesStyle);

          if (elName === 'marker' && !(element.get('isStroke') && element.get('isFill'))) {
            //  marker  stroke  fill  unchecked 
            if (element.get('isStroke')) {
              element.attr('fill', null);
            }

            if (element.get('isFill')) {
              element.attr('stroke', null);
            }
          }
        }
      });
    }
  }; //  itemWidth 


  Category.prototype.getLimitItemWidth = function () {
    var itemWidth = this.get('itemWidth');
    var maxItemWidth = this.get('maxItemWidth');

    if (maxItemWidth) {
      // 
      if (itemWidth) {
        maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
      }
    } else if (itemWidth) {
      maxItemWidth = itemWidth;
    }

    return maxItemWidth;
  };

  return Category;
}(_base.default);

var _default = Category;
exports.default = _default;

/***/ }),
/* 837 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _theme = _interopRequireDefault(__webpack_require__(60));

var _util2 = __webpack_require__(44);

var _base = _interopRequireDefault(__webpack_require__(256));

var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;

var ContinueLegend =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ContinueLegend, _super);

  function ContinueLegend() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ContinueLegend.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      type: 'continue',
      min: 0,
      max: 100,
      value: null,
      colors: [],
      track: {},
      rail: {},
      label: {},
      handler: {},
      slidable: true,
      tip: null,
      step: null,
      maxWidth: null,
      maxHeight: null,
      defaultCfg: {
        label: {
          align: 'rail',
          spacing: 5,
          formatter: null,
          style: {
            fontSize: 12,
            fill: _theme.default.textColor,
            textBaseline: 'middle',
            fontFamily: _theme.default.fontFamily
          }
        },
        handler: {
          size: 10,
          style: {
            fill: '#fff',
            stroke: '#333'
          }
        },
        track: {},
        rail: {
          type: 'color',
          size: 20,
          defaultLength: 100,
          style: {
            fill: '#DCDEE2'
          }
        },
        title: {
          spacing: 5,
          style: {
            fill: _theme.default.textColor,
            fontSize: 12,
            textAlign: 'start',
            textBaseline: 'top'
          }
        }
      }
    });
  };

  ContinueLegend.prototype.isSlider = function () {
    return true;
  }; //  IList 


  ContinueLegend.prototype.getValue = function () {
    return this.getCurrentValue();
  };

  ContinueLegend.prototype.getRange = function () {
    return {
      min: this.get('min'),
      max: this.get('max')
    };
  }; //  range


  ContinueLegend.prototype.setRange = function (min, max) {
    this.update({
      min: min,
      max: max
    });
  };

  ContinueLegend.prototype.setValue = function (value) {
    var originValue = this.getValue();
    this.set('value', value);
    var group = this.get('group');
    this.resetTrackClip();

    if (this.get('slidable')) {
      this.resetHandlers(group);
    }

    this.delegateEmit('valuechanged', {
      originValue: originValue,
      value: value
    });
  };

  ContinueLegend.prototype.initEvent = function () {
    var group = this.get('group');
    this.bindSliderEvent(group);
    this.bindRailEvent(group);
    this.bindTrackEvent(group);
  };

  ContinueLegend.prototype.drawLegendContent = function (group) {
    this.drawRail(group);
    this.drawLabels(group);
    this.fixedElements(group); // 

    this.resetTrack(group);
    this.resetTrackClip(group);

    if (this.get('slidable')) {
      this.resetHandlers(group);
    }
  };

  ContinueLegend.prototype.bindSliderEvent = function (group) {
    this.bindHandlersEvent(group);
  };

  ContinueLegend.prototype.bindHandlersEvent = function (group) {
    var _this = this;

    group.on('legend-handler-min:drag', function (ev) {
      var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);

      var currentValue = _this.getCurrentValue();

      var maxValue = currentValue[1];

      if (maxValue < minValue) {
        // 
        maxValue = minValue;
      }

      _this.setValue([minValue, maxValue]);
    });
    group.on('legend-handler-max:drag', function (ev) {
      var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);

      var currentValue = _this.getCurrentValue();

      var minValue = currentValue[0];

      if (minValue > maxValue) {
        // 
        minValue = maxValue;
      }

      _this.setValue([minValue, maxValue]);
    });
  };

  ContinueLegend.prototype.bindRailEvent = function (group) {};

  ContinueLegend.prototype.bindTrackEvent = function (group) {
    var _this = this;

    var prePoint = null;
    group.on('legend-track:dragstart', function (ev) {
      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group.on('legend-track:drag', function (ev) {
      if (!prePoint) {
        return;
      }

      var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);

      var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);

      var currentValue = _this.getCurrentValue();

      var curDiff = currentValue[1] - currentValue[0];

      var range = _this.getRange();

      var dValue = curValue - preValue;

      if (dValue < 0) {
        // , 
        if (currentValue[0] + dValue > range.min) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.min, range.min + curDiff]);
        } //  && ||

      } else if (dValue > 0) {
        if (dValue > 0 && currentValue[1] + dValue < range.max) {
          _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
        } else {
          _this.setValue([range.max - curDiff, range.max]);
        }
      }

      prePoint = {
        x: ev.x,
        y: ev.y
      };
    });
    group.on('legend-track:dragend', function (ev) {
      prePoint = null;
    });
  };

  ContinueLegend.prototype.drawLabels = function (group) {
    this.drawLabel('min', group);
    this.drawLabel('max', group);
  };

  ContinueLegend.prototype.drawLabel = function (name, group) {
    var labelCfg = this.get('label');
    var style = labelCfg.style;
    var labelAlign = labelCfg.align;
    var value = this.get(name);
    var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
    var localId = "label-" + name;
    this.addShape(group, {
      type: 'text',
      id: this.getElementId(localId),
      name: "legend-label-" + name,
      attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
        x: 0,
        y: 0,
        text: value
      }, style), alignAttrs)
    });
  }; // 


  ContinueLegend.prototype.getLabelAlignAttrs = function (name, align) {
    var isVertical = this.isVertical();
    var textAlign = 'center';
    var textBaseline = 'middle';

    if (isVertical) {
      // 
      textAlign = 'start';

      if (align !== 'rail') {
        if (name === 'min') {
          textBaseline = 'top';
        } else {
          textBaseline = 'bottom';
        }
      } else {
        textBaseline = 'top';
      }
    } else {
      if (align !== 'rail') {
        textBaseline = 'top';

        if (name === 'min') {
          textAlign = 'start';
        } else {
          textAlign = 'end';
        }
      } else {
        textAlign = 'start';
        textBaseline = 'middle';
      }
    }

    return {
      textAlign: textAlign,
      textBaseline: textBaseline
    };
  };

  ContinueLegend.prototype.getRailPath = function (x, y, w, h) {
    var railCfg = this.get('rail');
    var size = railCfg.size,
        defaultLength = railCfg.defaultLength,
        type = railCfg.type;
    var isVertical = this.isVertical();
    var length = defaultLength;
    var width = w;
    var height = h;

    if (!width) {
      width = isVertical ? size : length;
    }

    if (!height) {
      height = isVertical ? length : size;
    }

    var path = [];

    if (type === 'color') {
      path.push(['M', x, y]);
      path.push(['L', x + width, y]);
      path.push(['L', x + width, y + height]);
      path.push(['L', x, y + height]);
      path.push(['Z']);
    } else {
      path.push(['M', x + width, y]);
      path.push(['L', x + width, y + height]);
      path.push(['L', x, y + height]);
      path.push(['Z']);
    }

    return path;
  };

  ContinueLegend.prototype.drawRail = function (group) {
    var railCfg = this.get('rail');
    var style = railCfg.style;
    this.addShape(group, {
      type: 'path',
      id: this.getElementId('rail'),
      name: 'legend-rail',
      attrs: (0, _tslib.__assign)({
        path: this.getRailPath(0, 0)
      }, style)
    });
  }; // 


  ContinueLegend.prototype.getTrackColor = function (colors) {
    var count = colors.length;

    if (!count) {
      return null;
    }

    if (count === 1) {
      return colors[0];
    }

    var color; //  l(0) 0:colors[0] 0.5:colors[1] 1:colors[2];

    if (this.isVertical()) {
      // 
      color = 'l(90)';
    } else {
      color = 'l(0)';
    }

    for (var i = 0; i < count; i++) {
      var percent = i / (count - 1);
      color += " " + percent + ":" + colors[i];
    }

    return color;
  };

  ContinueLegend.prototype.getTrackPath = function (group) {
    var railShape = this.getRailShape(group);
    var path = railShape.attr('path');
    return (0, _util.clone)(path);
  };

  ContinueLegend.prototype.getClipTrackAttrs = function (group) {
    var value = this.getCurrentValue();
    var min = value[0],
        max = value[1];
    var railBBox = this.getRailBBox(group);
    var startPoint = this.getPointByValue(min, group);
    var endPoint = this.getPointByValue(max, group);
    var isVertical = this.isVertical();
    var x;
    var y;
    var width;
    var height;

    if (isVertical) {
      x = railBBox.minX;
      y = startPoint.y;
      width = railBBox.width;
      height = endPoint.y - startPoint.y;
    } else {
      x = startPoint.x;
      y = railBBox.minY;
      width = endPoint.x - startPoint.x;
      height = railBBox.height;
    }

    return {
      x: x,
      y: y,
      width: width,
      height: height
    };
  }; //  track  path  


  ContinueLegend.prototype.getTrackAttrs = function (group) {
    var trackCfg = this.get('track');
    var colors = this.get('colors');
    var path = this.getTrackPath(group);
    return (0, _util.mix)({
      path: path,
      fill: this.getTrackColor(colors)
    }, trackCfg.style);
  };

  ContinueLegend.prototype.resetTrackClip = function (group) {
    var container = group || this.get('group');
    var trackId = this.getElementId('track');
    var trackShape = container.findById(trackId);
    var clipShape = trackShape.getClip();
    var attrs = this.getClipTrackAttrs(group);

    if (!clipShape) {
      trackShape.setClip({
        type: 'rect',
        attrs: attrs
      });
    } else {
      clipShape.attr(attrs);
    }
  };

  ContinueLegend.prototype.resetTrack = function (group) {
    var trackId = this.getElementId('track');
    var trackShape = group.findById(trackId);
    var trackAttrs = this.getTrackAttrs(group);

    if (trackShape) {
      trackShape.attr(trackAttrs);
    } else {
      this.addShape(group, {
        type: 'path',
        id: trackId,
        draggable: this.get('slidable'),
        name: 'legend-track',
        attrs: trackAttrs
      });
    }
  };

  ContinueLegend.prototype.getPointByValue = function (value, group) {
    var _a = this.getRange(),
        min = _a.min,
        max = _a.max;

    var percent = (value - min) / (max - min);
    var bbox = this.getRailBBox(group);
    var isVertcal = this.isVertical();
    var point = {
      x: 0,
      y: 0
    };

    if (isVertcal) {
      point.x = bbox.minX + bbox.width / 2;
      point.y = (0, _util2.getValueByPercent)(bbox.minY, bbox.maxY, percent);
    } else {
      point.x = (0, _util2.getValueByPercent)(bbox.minX, bbox.maxX, percent);
      point.y = bbox.minY + bbox.height / 2;
    }

    return point;
  };

  ContinueLegend.prototype.getRailShape = function (group) {
    var container = group || this.get('group');
    return container.findById(this.getElementId('rail'));
  }; // 


  ContinueLegend.prototype.getRailBBox = function (group) {
    var railShape = this.getRailShape(group);
    var bbox = railShape.getBBox();
    return bbox;
  };

  ContinueLegend.prototype.getRailCanvasBBox = function () {
    var container = this.get('group');
    var railShape = container.findById(this.getElementId('rail'));
    var bbox = railShape.getCanvasBBox();
    return bbox;
  }; // 


  ContinueLegend.prototype.isVertical = function () {
    return this.get('layout') === 'vertical';
  }; // 


  ContinueLegend.prototype.getValueByCanvasPoint = function (x, y) {
    var _a = this.getRange(),
        min = _a.min,
        max = _a.max;

    var bbox = this.getRailCanvasBBox(); //  x, y 

    var isVertcal = this.isVertical();
    var step = this.get('step');
    var percent;

    if (isVertcal) {
      //  y
      percent = (y - bbox.minY) / bbox.height;
    } else {
      //  x
      percent = (x - bbox.minX) / bbox.width;
    }

    var value = (0, _util2.getValueByPercent)(min, max, percent);

    if (step) {
      var count = Math.round((value - min) / step);
      value = min + count * step; // 
    }

    if (value > max) {
      value = max;
    }

    if (value < min) {
      value = min;
    }

    return value;
  }; // 


  ContinueLegend.prototype.getCurrentValue = function () {
    var value = this.get('value');

    if (!value) {
      // 
      value = [this.get('min'), this.get('max')];
    }

    return value;
  }; //  handler


  ContinueLegend.prototype.resetHandlers = function (group) {
    var currentValue = this.getCurrentValue();
    var min = currentValue[0],
        max = currentValue[1];
    this.resetHandler(group, 'min', min);
    this.resetHandler(group, 'max', max);
  }; //  path


  ContinueLegend.prototype.getHandlerPath = function (handlerCfg, point) {
    var isVertical = this.isVertical();
    var path = [];
    var width = handlerCfg.size;
    var x = point.x,
        y = point.y;
    var height = width * HANDLER_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;

    if (isVertical) {
      /**
       *  handler x,y
       *  /----|
       *    -- |
       *    -- |
       *  \----|
       */
      var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
      path.push(['M', x, y]);
      path.push(['L', triangleX, y + halfWidth]);
      path.push(['L', x + height, y + halfWidth]);
      path.push(['L', x + height, y - halfWidth]);
      path.push(['L', triangleX, y - halfWidth]);
      path.push(['Z']); // 

      path.push(['M', triangleX, y + oneSixthWidth]);
      path.push(['L', x + height - 2, y + oneSixthWidth]);
      path.push(['M', triangleX, y - oneSixthWidth]);
      path.push(['L', x + height - 2, y - oneSixthWidth]);
    } else {
      /**
       *  x,y
       *  /   \
       * | | | |
       * | | | |
       *  -----
       */
      var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
      path.push(['M', x, y]);
      path.push(['L', x - halfWidth, triangleY]);
      path.push(['L', x - halfWidth, y + height]);
      path.push(['L', x + halfWidth, y + height]);
      path.push(['L', x + halfWidth, triangleY]);
      path.push(['Z']); // 

      path.push(['M', x - oneSixthWidth, triangleY]);
      path.push(['L', x - oneSixthWidth, y + height - 2]);
      path.push(['M', x + oneSixthWidth, triangleY]);
      path.push(['L', x + oneSixthWidth, y + height - 2]);
    }

    return path;
  }; //  handler 


  ContinueLegend.prototype.resetHandler = function (group, name, value) {
    var point = this.getPointByValue(value, group);
    var handlerCfg = this.get('handler');
    var path = this.getHandlerPath(handlerCfg, point);
    var id = this.getElementId("handler-" + name);
    var handlerShape = group.findById(id);
    var isVertical = this.isVertical();

    if (handlerShape) {
      handlerShape.attr('path', path);
    } else {
      this.addShape(group, {
        type: 'path',
        name: "legend-handler-" + name,
        draggable: true,
        id: id,
        attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
          path: path
        }, handlerCfg.style), {
          cursor: isVertical ? 'ns-resize' : 'ew-resize'
        })
      });
    }
  }; //  maxWidth, maxHeight  rail 
  // 


  ContinueLegend.prototype.fixedElements = function (group) {
    var railShape = group.findById(this.getElementId('rail'));
    var minLabel = group.findById(this.getElementId('label-min'));
    var maxLabel = group.findById(this.getElementId('label-max'));
    var startPoint = this.getDrawPoint();

    if (this.isVertical()) {
      // 
      this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
    } else {
      // 
      this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
    }
  };

  ContinueLegend.prototype.fitRailLength = function (minLabelBBox, maxLabelBBox, railBBox, railShape) {
    var isVertical = this.isVertical();
    var lengthField = isVertical ? 'height' : 'width';
    var labelCfg = this.get('label');
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var maxLength = this.get("max" + (0, _util.upperFirst)(lengthField)); // get('maxWidth')

    if (maxLength) {
      var elementsLength = labelAlign === 'rail' ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
      var diff = elementsLength - maxLength;

      if (diff > 0) {
        // 
        this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff);
      }
    }
  };

  ContinueLegend.prototype.changeRailLength = function (railShape, lengthField, length) {
    var bbox = railShape.getBBox();
    var path;

    if (lengthField === 'height') {
      path = this.getRailPath(bbox.x, bbox.y, bbox.width, length);
    } else {
      path = this.getRailPath(bbox.x, bbox.y, length, bbox.height);
    }

    railShape.attr('path', path);
  };

  ContinueLegend.prototype.changeRailPosition = function (railShape, x, y) {
    var bbox = railShape.getBBox();
    var path = this.getRailPath(x, y, bbox.width, bbox.height);
    railShape.attr('path', path);
  };

  ContinueLegend.prototype.fixedHorizontal = function (minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get('label');
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    var railHeight = railBBox.height; //  rail 

    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();

    if (labelAlign === 'rail') {
      //  rail 
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railHeight / 2
      });
      this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
        y: startPoint.y + railHeight / 2
      });
    } else if (labelAlign === 'top') {
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
    } else {
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height + spacing
      });
      maxLabel.attr({
        x: startPoint.x + railBBox.width,
        y: startPoint.y + railBBox.height + spacing
      });
    }
  };

  ContinueLegend.prototype.fixedVertail = function (minLabel, maxLabel, railShape, startPoint) {
    var labelCfg = this.get('label');
    var labelAlign = labelCfg.align;
    var spacing = labelCfg.spacing;
    var railBBox = railShape.getBBox();
    var minLabelBBox = minLabel.getBBox();
    var maxLabelBBox = maxLabel.getBBox();
    this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
    railBBox = railShape.getBBox();

    if (labelAlign === 'rail') {
      //  rail 
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
      });
    } else if (labelAlign === 'right') {
      minLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x, startPoint.y);
      maxLabel.attr({
        x: startPoint.x + railBBox.width + spacing,
        y: startPoint.y + railBBox.height
      });
    } else {
      // left
      var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
      minLabel.attr({
        x: startPoint.x,
        y: startPoint.y
      });
      this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
      maxLabel.attr({
        x: startPoint.x,
        y: startPoint.y + railBBox.height
      });
    }
  };

  return ContinueLegend;
}(_base.default);

var _default = ContinueLegend;
exports.default = _default;

/***/ }),
/* 838 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Html", {
  enumerable: true,
  get: function get() {
    return _html.default;
  }
});

var _html = _interopRequireDefault(__webpack_require__(839));

/***/ }),
/* 839 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _colorUtil = _interopRequireDefault(__webpack_require__(179));

var _domUtil = __webpack_require__(112);

var _util = __webpack_require__(0);

var _htmlComponent = _interopRequireDefault(__webpack_require__(186));

var _util2 = __webpack_require__(44);

var CssConst = _interopRequireWildcard(__webpack_require__(257));

var _htmlTheme = _interopRequireDefault(__webpack_require__(840));

var _align = __webpack_require__(841);

function hasOneKey(obj, keys) {
  var result = false;
  (0, _util.each)(keys, function (key) {
    if ((0, _util.hasKey)(obj, key)) {
      result = true;
      return false;
    }
  });
  return result;
}

var Tooltip =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Tooltip, _super);

  function Tooltip() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Tooltip.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'tooltip',
      type: 'html',
      x: 0,
      y: 0,
      items: [],
      customContent: null,
      containerTpl: "<div class=\"" + CssConst.CONTAINER_CLASS + "\"><div class=\"" + CssConst.TITLE_CLASS + "\"></div><ul class=\"" + CssConst.LIST_CLASS + "\"></ul></div>",
      itemTpl: "<li class=\"" + CssConst.LIST_ITEM_CLASS + "\" data-index={index}>\n          <span class=\"" + CssConst.MARKER_CLASS + "\" style=\"background:{color}\"></span>\n          <span class=\"" + CssConst.NAME_CLASS + "\">{name}</span>:\n          <span class=\"" + CssConst.VALUE_CLASS + "\">{value}</span>\n        </li>",
      xCrosshairTpl: "<div class=\"" + CssConst.CROSSHAIR_X + "\"></div>",
      yCrosshairTpl: "<div class=\"" + CssConst.CROSSHAIR_Y + "\"></div>",
      title: null,
      showTitle: true,

      /**
       * tooltip 
       * @type {Region}
       */
      region: null,
      // crosshair 
      crosshairsRegion: null,
      containerClassName: CssConst.CONTAINER_CLASS,
      // x, y, xy
      crosshairs: null,
      offset: 10,
      position: 'right',
      domStyles: null,
      defaultStyles: _htmlTheme.default
    });
  }; // tooltip  titleitems  corosshairs


  Tooltip.prototype.render = function () {
    if (this.get('customContent')) {
      this.renderCustomContent();
    } else {
      this.resetTitle();
      this.renderItems();
    } // 


    this.resetPosition();
  }; // 


  Tooltip.prototype.clear = function () {
    //  crosshair  container 
    this.clearCrosshairs();
    this.setTitle(''); // 

    this.clearItemDoms();
  };

  Tooltip.prototype.show = function () {
    var container = this.getContainer();

    if (!container || this.destroyed) {
      // 
      return;
    }

    this.set('visible', true);
    (0, _domUtil.modifyCSS)(container, {
      visibility: 'visible'
    });
    this.setCrossHairsVisible(true);
  };

  Tooltip.prototype.hide = function () {
    var container = this.getContainer(); // relative: https://github.com/antvis/g2/issues/1221

    if (!container || this.destroyed) {
      return;
    }

    this.set('visible', false);
    (0, _domUtil.modifyCSS)(container, {
      visibility: 'hidden'
    });
    this.setCrossHairsVisible(false);
  }; //  IPointLocation 


  Tooltip.prototype.getLocation = function () {
    return {
      x: this.get('x'),
      y: this.get('y')
    };
  }; //  IPointLocation 


  Tooltip.prototype.setLocation = function (point) {
    this.set('x', point.x);
    this.set('y', point.y);
    this.resetPosition();
  };

  Tooltip.prototype.setCrossHairsVisible = function (visible) {
    var display = visible ? '' : 'none';
    var xCrosshairDom = this.get('xCrosshairDom');
    var yCrosshairDom = this.get('yCrosshairDom');
    xCrosshairDom && (0, _domUtil.modifyCSS)(xCrosshairDom, {
      display: display
    });
    yCrosshairDom && (0, _domUtil.modifyCSS)(yCrosshairDom, {
      display: display
    });
  }; //  customContent  customContent  container


  Tooltip.prototype.initContainer = function () {
    _super.prototype.initContainer.call(this);

    if (this.get('customContent')) {
      if (this.get('container')) {
        this.get('container').remove();
      }

      var container = this.getHtmlContentNode();
      this.get('parent').appendChild(container);
      this.set('container', container);
      this.resetStyles();
      this.applyStyles();
    }
  }; //  DOM  DOM 


  Tooltip.prototype.updateInner = function (cfg) {
    if (this.get('customContent')) {
      this.renderCustomContent();
    } else {
      // 
      if (hasOneKey(cfg, ['title', 'showTitle'])) {
        this.resetTitle();
      } // 


      if ((0, _util.hasKey)(cfg, 'items')) {
        this.renderItems();
      }
    }

    _super.prototype.updateInner.call(this, cfg);
  };

  Tooltip.prototype.initDom = function () {
    this.cacheDoms();
  }; //  DOM


  Tooltip.prototype.removeDom = function () {
    _super.prototype.removeDom.call(this);

    this.clearCrosshairs();
  }; // 


  Tooltip.prototype.resetPosition = function () {
    var x = this.get('x');
    var y = this.get('y');
    var offset = this.get('offset');

    var _a = this.getOffset(),
        offsetX = _a.offsetX,
        offsetY = _a.offsetY;

    var position = this.get('position');
    var region = this.get('region');
    var container = this.getContainer();
    var bbox = this.getBBox();
    var width = bbox.width,
        height = bbox.height;
    var limitBox;

    if (region) {
      // 
      limitBox = (0, _util2.regionToBBox)(region);
    }

    var point = (0, _align.getAlignPoint)(x, y, offset, width, height, position, limitBox);
    (0, _domUtil.modifyCSS)(container, {
      left: (0, _util2.toPx)(point.x + offsetX),
      top: (0, _util2.toPx)(point.y + offsetY)
    });
    this.resetCrosshairs();
  }; //  customContent 


  Tooltip.prototype.renderCustomContent = function () {
    var node = this.getHtmlContentNode();
    var parent = this.get('parent');
    var curContainer = this.get('container');

    if (curContainer && curContainer.parentNode === parent) {
      parent.replaceChild(node, curContainer);
    } else {
      parent.appendChild(node);
    }

    this.set('container', node);
    this.resetStyles();
    this.applyStyles();
  };

  Tooltip.prototype.getHtmlContentNode = function () {
    var node;
    var customContent = this.get('customContent');

    if (customContent) {
      var elem = customContent(this.get('title'), this.get('items'));

      if ((0, _util.isElement)(elem)) {
        node = elem;
      } else {
        node = (0, _domUtil.createDom)(elem);
      }
    }

    return node;
  }; //  DOM


  Tooltip.prototype.cacheDoms = function () {
    var container = this.getContainer();
    var titleDom = container.getElementsByClassName(CssConst.TITLE_CLASS)[0];
    var listDom = container.getElementsByClassName(CssConst.LIST_CLASS)[0];
    this.set('titleDom', titleDom);
    this.set('listDom', listDom);
  }; //  title


  Tooltip.prototype.resetTitle = function () {
    var title = this.get('title');
    var showTitle = this.get('showTitle');

    if (showTitle && title) {
      this.setTitle(title);
    } else {
      this.setTitle('');
    }
  }; //  title 


  Tooltip.prototype.setTitle = function (text) {
    var titleDom = this.get('titleDom');

    if (titleDom) {
      titleDom.innerText = text;
    }
  }; //  crosshair


  Tooltip.prototype.resetCrosshairs = function () {
    var crosshairsRegion = this.get('crosshairsRegion');
    var crosshairs = this.get('crosshairs');

    if (!crosshairsRegion || !crosshairs) {
      //  crosshair region 
      this.clearCrosshairs();
    } else {
      var crosshairBox = (0, _util2.regionToBBox)(crosshairsRegion);
      var xCrosshairDom = this.get('xCrosshairDom');
      var yCrosshairDom = this.get('yCrosshairDom');

      if (crosshairs === 'x') {
        this.resetCrosshair('x', crosshairBox); //  x  crosshairy 

        if (yCrosshairDom) {
          yCrosshairDom.remove();
          this.set('yCrosshairDom', null);
        }
      } else if (crosshairs === 'y') {
        this.resetCrosshair('y', crosshairBox); //  y  crosshairx 

        if (xCrosshairDom) {
          xCrosshairDom.remove();
          this.set('xCrosshairDom', null);
        }
      } else {
        this.resetCrosshair('x', crosshairBox);
        this.resetCrosshair('y', crosshairBox);
      }

      this.setCrossHairsVisible(this.get('visible'));
    }
  }; //  crosshair  x,y


  Tooltip.prototype.resetCrosshair = function (name, bbox) {
    var croshairDom = this.checkCrosshair(name);
    var value = this.get(name);

    if (name === 'x') {
      (0, _domUtil.modifyCSS)(croshairDom, {
        left: (0, _util2.toPx)(value),
        top: (0, _util2.toPx)(bbox.y),
        height: (0, _util2.toPx)(bbox.height)
      });
    } else {
      (0, _domUtil.modifyCSS)(croshairDom, {
        top: (0, _util2.toPx)(value),
        left: (0, _util2.toPx)(bbox.x),
        width: (0, _util2.toPx)(bbox.width)
      });
    }
  }; //  crosshair  dom 


  Tooltip.prototype.checkCrosshair = function (name) {
    var domName = name + "CrosshairDom";
    var tplName = name + "CrosshairTpl";
    var constName = "CROSSHAIR_" + name.toUpperCase();
    var styleName = CssConst[constName];
    var croshairDom = this.get(domName);
    var parent = this.get('parent');

    if (!croshairDom) {
      croshairDom = (0, _domUtil.createDom)(this.get(tplName)); // 

      this.applyStyle(styleName, croshairDom); // 

      parent.appendChild(croshairDom); //  tooltip 

      this.set(domName, croshairDom);
    }

    return croshairDom;
  };

  Tooltip.prototype.renderItems = function () {
    this.clearItemDoms();
    var items = this.get('items');
    var itemTpl = this.get('itemTpl');
    var listDom = this.get('listDom');

    if (listDom) {
      (0, _util.each)(items, function (item) {
        var color = _colorUtil.default.toCSSGradient(item.color);

        var substituteObj = (0, _tslib.__assign)((0, _tslib.__assign)({}, item), {
          color: color
        });
        var domStr = (0, _util.substitute)(itemTpl, substituteObj);
        var itemDom = (0, _domUtil.createDom)(domStr);
        listDom.appendChild(itemDom);
      });
      this.applyChildrenStyles(listDom, this.get('domStyles'));
    }
  };

  Tooltip.prototype.clearItemDoms = function () {
    if (this.get('listDom')) {
      (0, _util2.clearDom)(this.get('listDom'));
    }
  };

  Tooltip.prototype.clearCrosshairs = function () {
    var xCrosshairDom = this.get('xCrosshairDom');
    var yCrosshairDom = this.get('yCrosshairDom');
    xCrosshairDom && xCrosshairDom.remove();
    yCrosshairDom && yCrosshairDom.remove();
    this.set('xCrosshairDom', null);
    this.set('yCrosshairDom', null);
  };

  return Tooltip;
}(_htmlComponent.default);

var _default = Tooltip;
exports.default = _default;

/***/ }),
/* 840 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _theme = _interopRequireDefault(__webpack_require__(60));

var CssConst = _interopRequireWildcard(__webpack_require__(257));

var _a;

var _default = (_a = {}, // css style for tooltip
_a["" + CssConst.CONTAINER_CLASS] = {
  position: 'absolute',
  visibility: 'visible',
  // @2018-07-25 by blue.lb 
  // whiteSpace: 'nowrap',
  zIndex: 8,
  transition: 'visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), ' + 'left 0.4s cubic-bezier(0.23, 1, 0.32, 1), ' + 'top 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
  backgroundColor: 'rgba(255, 255, 255, 0.9)',
  boxShadow: '0px 0px 10px #aeaeae',
  borderRadius: '3px',
  color: 'rgb(87, 87, 87)',
  fontSize: '12px',
  fontFamily: _theme.default.fontFamily,
  lineHeight: '20px',
  padding: '10px 10px 6px 10px'
}, _a["" + CssConst.TITLE_CLASS] = {
  marginBottom: '4px'
}, _a["" + CssConst.LIST_CLASS] = {
  margin: '0px',
  listStyleType: 'none',
  padding: '0px'
}, _a["" + CssConst.LIST_ITEM_CLASS] = {
  listStyleType: 'none',
  marginBottom: '4px'
}, _a["" + CssConst.MARKER_CLASS] = {
  width: '8px',
  height: '8px',
  borderRadius: '50%',
  display: 'inline-block',
  marginRight: '8px'
}, _a["" + CssConst.VALUE_CLASS] = {
  display: 'inline-block',
  float: 'right',
  marginLeft: '30px'
}, _a["" + CssConst.CROSSHAIR_X] = {
  position: 'absolute',
  width: '1px',
  backgroundColor: 'rgba(0, 0, 0, 0.25)'
}, _a["" + CssConst.CROSSHAIR_Y] = {
  position: 'absolute',
  height: '1px',
  backgroundColor: 'rgba(0, 0, 0, 0.25)'
}, _a);

exports.default = _default;

/***/ }),
/* 841 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOutSides = getOutSides;
exports.getPointByPosition = getPointByPosition;
exports.getAlignPoint = getAlignPoint;

// 
function getOutSides(x, y, width, height, limitBox) {
  var hits = {
    left: x < limitBox.x,
    right: x + width > limitBox.x + limitBox.width,
    top: y < limitBox.y,
    bottom: y + height > limitBox.y + limitBox.height
  };
  return hits;
}

function getPointByPosition(x, y, offset, width, height, position) {
  var px = x;
  var py = y;

  switch (position) {
    case 'left':
      // left center
      px = x - width - offset;
      py = y - height / 2;
      break;

    case 'right':
      px = x + offset;
      py = y - height / 2;
      break;

    case 'top':
      px = x - width / 2;
      py = y - height - offset;
      break;

    case 'bottom':
      // bottom
      px = x - width / 2;
      py = y + offset;
      break;

    default:
      // auto,  top-right
      px = x + offset;
      py = y - height - offset;
      break;
  }

  return {
    x: px,
    y: py
  };
}

function getAlignPoint(x, y, offset, width, height, position, limitBox) {
  var point = getPointByPosition(x, y, offset, width, height, position);

  if (limitBox) {
    var outSides = getOutSides(point.x, point.y, width, height, limitBox);

    if (position === 'auto') {
      //  auto tooltip 
      if (outSides.right) {
        point.x = Math.max(0, x - width - offset);
      }

      if (outSides.top) {
        point.y = Math.max(0, y - height - offset);
      }
    } else if (position === 'top' || position === 'bottom') {
      if (outSides.left) {
        // 
        point.x = limitBox.x;
      }

      if (outSides.right) {
        // 
        point.x = limitBox.x + limitBox.width - width;
      }

      if (position === 'top' && outSides.top) {
        // 
        point.y = y + offset;
      }

      if (position === 'bottom' && outSides.bottom) {
        point.y = y - height - offset;
      }
    } else {
      // 
      if (outSides.top) {
        point.y = limitBox.y;
      }

      if (outSides.bottom) {
        point.y = limitBox.y + limitBox.height - height;
      }

      if (position === 'left' && outSides.left) {
        point.x = x + offset;
      }

      if (position === 'right' && outSides.right) {
        point.x = x - width - offset;
      }
    }
  }

  return point;
}

/***/ }),
/* 842 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Slider", {
  enumerable: true,
  get: function get() {
    return _slider.Slider;
  }
});

var _slider = __webpack_require__(843);

/***/ }),
/* 843 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Slider = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _trend = __webpack_require__(844);

var _constant = __webpack_require__(847);

var _handler = __webpack_require__(848);

var Slider =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Slider, _super);

  function Slider() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.onMouseDown = function (target) {
      return function (e) {
        _this.currentTarget = target; // 

        var event = e.originalEvent; // 2. 

        event.stopPropagation();
        event.preventDefault(); // 

        _this.prevX = (0, _util.get)(event, 'touches.0.pageX', event.pageX);
        _this.prevY = (0, _util.get)(event, 'touches.0.pageY', event.pageY); // 3.  move  up 

        var containerDOM = _this.getContainerDOM();

        containerDOM.addEventListener('mousemove', _this.onMouseMove);
        containerDOM.addEventListener('mouseup', _this.onMouseUp);
        containerDOM.addEventListener('mouseleave', _this.onMouseUp); // 

        containerDOM.addEventListener('touchmove', _this.onMouseMove);
        containerDOM.addEventListener('touchend', _this.onMouseUp);
        containerDOM.addEventListener('touchcancel', _this.onMouseUp);
      };
    };

    _this.onMouseMove = function (event) {
      var width = _this.cfg.width;
      var originValue = [_this.get('start'), _this.get('end')]; //  emit 

      event.stopPropagation();
      event.preventDefault();
      var x = (0, _util.get)(event, 'touches.0.pageX', event.pageX);
      var y = (0, _util.get)(event, 'touches.0.pageY', event.pageY); //  slider  x

      var offsetX = x - _this.prevX;

      var offsetXRange = _this.adjustOffsetRange(offsetX / width); //  start end range 


      _this.updateStartEnd(offsetXRange); //  ui


      _this.updateUI(_this.getElementByLocalId('foreground'), _this.getElementByLocalId('minText'), _this.getElementByLocalId('maxText'));

      _this.prevX = x;
      _this.prevY = y;

      _this.draw(); //  startend  end >= start


      _this.emit(_constant.SLIDER_CHANGE, [_this.get('start'), _this.get('end')].sort());

      _this.delegateEmit('valuechanged', {
        originValue: originValue,
        value: [_this.get('start'), _this.get('end')]
      });
    };

    _this.onMouseUp = function () {
      // 
      if (_this.currentTarget) {
        _this.currentTarget = undefined;
      }

      var containerDOM = _this.getContainerDOM();

      if (containerDOM) {
        containerDOM.removeEventListener('mousemove', _this.onMouseMove);
        containerDOM.removeEventListener('mouseup', _this.onMouseUp); //  canvas 

        containerDOM.removeEventListener('mouseleave', _this.onMouseUp); // 

        containerDOM.removeEventListener('touchmove', _this.onMouseMove);
        containerDOM.removeEventListener('touchend', _this.onMouseUp);
        containerDOM.removeEventListener('touchcancel', _this.onMouseUp);
      }
    };

    return _this;
  }

  Slider.prototype.setRange = function (min, max) {
    this.set('minLimit', min);
    this.set('maxLimit', max);
    var oldStart = this.get('start');
    var oldEnd = this.get('end');
    var newStart = (0, _util.clamp)(oldStart, min, max);
    var newEnd = (0, _util.clamp)(oldEnd, min, max);

    if (!this.get('isInit') && (oldStart !== newStart || oldEnd !== newEnd)) {
      this.setValue([newStart, newEnd]);
    }
  };

  Slider.prototype.getRange = function () {
    return {
      min: this.get('minLimit') || 0,
      max: this.get('maxLimit') || 1
    };
  };

  Slider.prototype.setValue = function (value) {
    var range = this.getRange();

    if ((0, _util.isArray)(value) && value.length === 2) {
      var originValue = [this.get('start'), this.get('end')];
      this.update({
        start: (0, _util.clamp)(value[0], range.min, range.max),
        end: (0, _util.clamp)(value[1], range.min, range.max)
      });

      if (!this.get('updateAutoRender')) {
        this.render();
      }

      this.delegateEmit('valuechanged', {
        originValue: originValue,
        value: value
      });
    }
  };

  Slider.prototype.getValue = function () {
    return [this.get('start'), this.get('end')];
  };

  Slider.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'slider',
      x: 0,
      y: 0,
      width: 100,
      height: 16,
      backgroundStyle: {},
      foregroundStyle: {},
      handlerStyle: {},
      textStyle: {},
      defaultCfg: {
        backgroundStyle: _constant.BACKGROUND_STYLE,
        foregroundStyle: _constant.FOREGROUND_STYLE,
        handlerStyle: _constant.HANDLER_STYLE,
        textStyle: _constant.TEXT_STYLE
      }
    });
  };

  Slider.prototype.update = function (cfg) {
    var start = cfg.start,
        end = cfg.end;
    var validCfg = (0, _tslib.__assign)({}, cfg);

    if (!(0, _util.isNil)(start)) {
      validCfg.start = (0, _util.clamp)(start, 0, 1);
    }

    if (!(0, _util.isNil)(end)) {
      validCfg.end = (0, _util.clamp)(end, 0, 1);
    }

    _super.prototype.update.call(this, validCfg);

    this.minHandler = this.getChildComponentById(this.getElementId('minHandler'));
    this.maxHandler = this.getChildComponentById(this.getElementId('maxHandler'));
    this.trend = this.getChildComponentById(this.getElementId('trend'));
  };

  Slider.prototype.init = function () {
    this.set('start', (0, _util.clamp)(this.get('start'), 0, 1));
    this.set('end', (0, _util.clamp)(this.get('end'), 0, 1));

    _super.prototype.init.call(this);
  };

  Slider.prototype.render = function () {
    _super.prototype.render.call(this);

    this.updateUI(this.getElementByLocalId('foreground'), this.getElementByLocalId('minText'), this.getElementByLocalId('maxText'));
  };

  Slider.prototype.renderInner = function (group) {
    var _a = this.cfg,
        start = _a.start,
        end = _a.end,
        width = _a.width,
        height = _a.height,
        _b = _a.trendCfg,
        trendCfg = _b === void 0 ? {} : _b,
        minText = _a.minText,
        maxText = _a.maxText,
        _c = _a.backgroundStyle,
        backgroundStyle = _c === void 0 ? {} : _c,
        _d = _a.foregroundStyle,
        foregroundStyle = _d === void 0 ? {} : _d,
        _e = _a.textStyle,
        textStyle = _e === void 0 ? {} : _e,
        _f = _a.handlerStyle,
        handlerStyle = _f === void 0 ? {} : _f;
    var min = start * width;
    var max = end * width; // 

    if ((0, _util.size)((0, _util.get)(trendCfg, 'data'))) {
      this.trend = this.addComponent(group, (0, _tslib.__assign)({
        component: _trend.Trend,
        id: this.getElementId('trend'),
        x: 0,
        y: 0,
        width: width,
        height: height
      }, trendCfg));
    } // 1. 


    this.addShape(group, {
      id: this.getElementId('background'),
      type: 'rect',
      attrs: (0, _tslib.__assign)({
        x: 0,
        y: 0,
        width: width,
        height: height
      }, backgroundStyle)
    }); // 2. 

    var minTextShape = this.addShape(group, {
      id: this.getElementId('minText'),
      type: 'text',
      attrs: (0, _tslib.__assign)({
        // x: 0,
        y: height / 2,
        textAlign: 'right',
        text: minText,
        silent: false
      }, textStyle)
    });
    var maxTextShape = this.addShape(group, {
      id: this.getElementId('maxText'),
      type: 'text',
      attrs: (0, _tslib.__assign)({
        // x: 0,
        y: height / 2,
        textAlign: 'left',
        text: maxText,
        silent: false
      }, textStyle)
    }); // 3.  

    var foregroundShape = this.addShape(group, {
      id: this.getElementId('foreground'),
      name: 'foreground',
      type: 'rect',
      attrs: (0, _tslib.__assign)({
        // x: 0,
        y: 0,
        // width: 0,
        height: height
      }, foregroundStyle)
    }); // 
    // const handlerWidth = get(handlerStyle, 'width', 10);

    var handlerHeight = (0, _util.get)(handlerStyle, 'height', 24); // 4. 

    this.minHandler = this.addComponent(group, (0, _tslib.__assign)({
      component: _handler.Handler,
      id: this.getElementId('minHandler'),
      name: 'handler-min',
      x: 0,
      y: (height - handlerHeight) / 2,
      width: width,
      height: handlerHeight,
      cursor: 'ew-resize'
    }, handlerStyle));
    this.maxHandler = this.addComponent(group, (0, _tslib.__assign)({
      component: _handler.Handler,
      id: this.getElementId('maxHandler'),
      name: 'handler-max',
      x: 0,
      y: (height - handlerHeight) / 2,
      width: width,
      height: handlerHeight,
      cursor: 'ew-resize'
    }, handlerStyle));
  };

  Slider.prototype.applyOffset = function () {
    this.moveElementTo(this.get('group'), {
      x: this.get('x'),
      y: this.get('y')
    });
  };

  Slider.prototype.initEvent = function () {
    this.bindEvents();
  };

  Slider.prototype.updateUI = function (foregroundShape, minTextShape, maxTextShape) {
    var _a = this.cfg,
        start = _a.start,
        end = _a.end,
        width = _a.width,
        minText = _a.minText,
        maxText = _a.maxText,
        handlerStyle = _a.handlerStyle,
        height = _a.height;
    var min = start * width;
    var max = end * width;

    if (this.trend) {
      this.trend.update({
        width: width,
        height: height
      });

      if (!this.get('updateAutoRender')) {
        this.trend.render();
      }
    } // 1. foreground


    foregroundShape.attr('x', min);
    foregroundShape.attr('width', max - min); // 

    var handlerWidth = (0, _util.get)(handlerStyle, 'width', _constant.DEFAULT_HANDLER_WIDTH); // 

    minTextShape.attr('text', minText);
    maxTextShape.attr('text', maxText);

    var _b = this._dodgeText([min, max], minTextShape, maxTextShape),
        minAttrs = _b[0],
        maxAttrs = _b[1]; // 2. 


    if (this.minHandler) {
      this.minHandler.update({
        x: min - handlerWidth / 2
      });

      if (!this.get('updateAutoRender')) {
        this.minHandler.render();
      }
    }

    (0, _util.each)(minAttrs, function (v, k) {
      return minTextShape.attr(k, v);
    }); // 3. 

    if (this.maxHandler) {
      this.maxHandler.update({
        x: max - handlerWidth / 2
      });

      if (!this.get('updateAutoRender')) {
        this.maxHandler.render();
      }
    }

    (0, _util.each)(maxAttrs, function (v, k) {
      return maxTextShape.attr(k, v);
    });
  };

  Slider.prototype.bindEvents = function () {
    var group = this.get('group');
    group.on('handler-min:mousedown', this.onMouseDown('minHandler'));
    group.on('handler-min:touchstart', this.onMouseDown('minHandler')); // 2. 

    group.on('handler-max:mousedown', this.onMouseDown('maxHandler'));
    group.on('handler-max:touchstart', this.onMouseDown('maxHandler')); // 3. 

    var foreground = group.findById(this.getElementId('foreground'));
    foreground.on('mousedown', this.onMouseDown('foreground'));
    foreground.on('touchstart', this.onMouseDown('foreground'));
  };
  /**
   *  offsetRange
   * @param offsetRange
   */


  Slider.prototype.adjustOffsetRange = function (offsetRange) {
    var _a = this.cfg,
        start = _a.start,
        end = _a.end; // 

    switch (this.currentTarget) {
      case 'minHandler':
        {
          var min = 0 - start;
          var max = 1 - start;
          return Math.min(max, Math.max(min, offsetRange));
        }

      case 'maxHandler':
        {
          var min = 0 - end;
          var max = 1 - end;
          return Math.min(max, Math.max(min, offsetRange));
        }

      case 'foreground':
        {
          var min = 0 - start;
          var max = 1 - end;
          return Math.min(max, Math.max(min, offsetRange));
        }
    }
  };

  Slider.prototype.updateStartEnd = function (offsetRange) {
    var _a = this.cfg,
        start = _a.start,
        end = _a.end; // 

    switch (this.currentTarget) {
      case 'minHandler':
        start += offsetRange;
        break;

      case 'maxHandler':
        end += offsetRange;
        break;

      case 'foreground':
        start += offsetRange;
        end += offsetRange;
        break;
    }

    this.set('start', start);
    this.set('end', end);
  };
  /**
   *  text 
   * 
   * @param range
   */


  Slider.prototype._dodgeText = function (range, minTextShape, maxTextShape) {
    var _a, _b;

    var _c = this.cfg,
        handlerStyle = _c.handlerStyle,
        width = _c.width;
    var PADDING = 2;
    var handlerWidth = (0, _util.get)(handlerStyle, 'width', _constant.DEFAULT_HANDLER_WIDTH);
    var min = range[0],
        max = range[1];
    var sorted = false; //  min max 

    if (min > max) {
      _a = [max, min], min = _a[0], max = _a[1];
      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
      sorted = true;
    } // 


    var minBBox = minTextShape.getBBox();
    var maxBBox = maxTextShape.getBBox();
    var minAttrs = minBBox.width > min - PADDING ? {
      x: min + handlerWidth / 2 + PADDING,
      textAlign: 'left'
    } : {
      x: min - handlerWidth / 2 - PADDING,
      textAlign: 'right'
    };
    var maxAttrs = maxBBox.width > width - max - PADDING ? {
      x: max - handlerWidth / 2 - PADDING,
      textAlign: 'right'
    } : {
      x: max + handlerWidth / 2 + PADDING,
      textAlign: 'left'
    };
    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
  };

  Slider.prototype.draw = function () {
    var container = this.get('container');
    var canvas = container && container.get('canvas');

    if (canvas) {
      canvas.draw();
    }
  };

  Slider.prototype.getContainerDOM = function () {
    var container = this.get('container');
    var canvas = container && container.get('canvas');
    return canvas && canvas.get('container');
  };

  return Slider;
}(_groupComponent.default);

exports.Slider = Slider;
var _default = Slider;
exports.default = _default;

/***/ }),
/* 844 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Trend = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var _constant = __webpack_require__(845);

var _path = __webpack_require__(846);

var Trend =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Trend, _super);

  function Trend() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Trend.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'trend',
      x: 0,
      y: 0,
      width: 200,
      height: 16,
      smooth: true,
      isArea: false,
      data: [],
      backgroundStyle: _constant.BACKGROUND_STYLE,
      lineStyle: _constant.LINE_STYLE,
      areaStyle: _constant.AREA_STYLE
    });
  };

  Trend.prototype.renderInner = function (group) {
    var _a = this.cfg,
        width = _a.width,
        height = _a.height,
        data = _a.data,
        smooth = _a.smooth,
        isArea = _a.isArea,
        backgroundStyle = _a.backgroundStyle,
        lineStyle = _a.lineStyle,
        areaStyle = _a.areaStyle; // 

    this.addShape(group, {
      id: this.getElementId('background'),
      type: 'rect',
      attrs: (0, _tslib.__assign)({
        x: 0,
        y: 0,
        width: width,
        height: height
      }, backgroundStyle)
    });
    var path = (0, _path.dataToPath)(data, width, height, smooth); // 

    this.addShape(group, {
      id: this.getElementId('line'),
      type: 'path',
      attrs: (0, _tslib.__assign)({
        path: path
      }, lineStyle)
    }); // area
    //  path 

    if (isArea) {
      var areaPath = (0, _path.linePathToAreaPath)(path, width, height, data);
      this.addShape(group, {
        id: this.getElementId('area'),
        type: 'path',
        attrs: (0, _tslib.__assign)({
          path: areaPath
        }, areaStyle)
      });
    }
  };

  Trend.prototype.applyOffset = function () {
    var _a = this.cfg,
        x = _a.x,
        y = _a.y; // 

    this.moveElementTo(this.get('group'), {
      x: x,
      y: y
    });
  };

  return Trend;
}(_groupComponent.default);

exports.Trend = Trend;
var _default = Trend;
exports.default = _default;

/***/ }),
/* 845 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AREA_STYLE = exports.LINE_STYLE = exports.BACKGROUND_STYLE = void 0;
var BACKGROUND_STYLE = {
  // fill: 'red',
  opacity: 0
};
exports.BACKGROUND_STYLE = BACKGROUND_STYLE;
var LINE_STYLE = {
  stroke: '#C5C5C5',
  strokeOpacity: 0.85
};
exports.LINE_STYLE = LINE_STYLE;
var AREA_STYLE = {
  fill: '#CACED4',
  opacity: 0.85
};
exports.AREA_STYLE = AREA_STYLE;

/***/ }),
/* 846 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getLinePath = getLinePath;
exports.getSmoothLinePath = getSmoothLinePath;
exports.dataToPath = dataToPath;
exports.getAreaLineY = getAreaLineY;
exports.linePathToAreaPath = linePathToAreaPath;

var _tslib = __webpack_require__(1);

var _pathUtil = __webpack_require__(95);

var _scale = __webpack_require__(108);

var _util = __webpack_require__(0);

/**
 *  path
 * @param points
 */
function pointsToPath(points) {
  return (0, _util.map)(points, function (p, idx) {
    var command = idx === 0 ? 'M' : 'L';
    var x = p[0],
        y = p[1];
    return [command, x, y];
  });
}
/**
 *  path
 * @param points
 */


function getLinePath(points) {
  return pointsToPath(points);
}
/**
 * 
 * @param points
 */


function getSmoothLinePath(points) {
  if (points.length <= 2) {
    // 
    return getLinePath(points);
  }

  var data = [];
  (0, _util.each)(points, function (p) {
    // 
    if (!(0, _util.isEqual)(p, data.slice(data.length - 2))) {
      data.push(p[0], p[1]);
    }
  }); // const constraint = [ // 
  //   [ 0, 0 ],
  //   [ 1, 1 ],
  // ];

  var path = (0, _pathUtil.catmullRom2Bezier)(data, false);

  var _a = (0, _util.head)(points),
      x = _a[0],
      y = _a[1];

  path.unshift(['M', x, y]);
  return path;
}
/**
 *  path scale 
 * @param data
 * @param width
 * @param height
 * @param smooth
 */


function dataToPath(data, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  } //  scale  y 


  var y = new _scale.Linear({
    values: data
  });
  var x = new _scale.Category({
    values: (0, _util.map)(data, function (v, idx) {
      return idx;
    })
  });
  var points = (0, _util.map)(data, function (v, idx) {
    return [x.scale(idx) * width, height - y.scale(v) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
/**
 *  area  px 
 * @param data
 * @param width
 * @param height
 */


function getAreaLineY(data, height) {
  var y = new _scale.Linear({
    values: data
  });
  var lineY = Math.max(0, y.min);
  return height - y.scale(lineY) * height;
}
/**
 *  path  area path
 * @param path
 * @param width
 * @param height
 */


function linePathToAreaPath(path, width, height, data) {
  var areaPath = (0, _tslib.__spreadArrays)(path);
  var lineYPx = getAreaLineY(data, height);
  areaPath.push(['L', width, lineYPx]);
  areaPath.push(['L', 0, lineYPx]);
  areaPath.push(['Z']);
  return areaPath;
}

/***/ }),
/* 847 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SLIDER_CHANGE = exports.TEXT_STYLE = exports.HANDLER_STYLE = exports.DEFAULT_HANDLER_WIDTH = exports.FOREGROUND_STYLE = exports.BACKGROUND_STYLE = void 0;

/**
 * 
 */
var BACKGROUND_STYLE = {
  fill: '#416180',
  opacity: 0.05
};
exports.BACKGROUND_STYLE = BACKGROUND_STYLE;
var FOREGROUND_STYLE = {
  fill: '#5B8FF9',
  opacity: 0.15,
  cursor: 'move'
};
exports.FOREGROUND_STYLE = FOREGROUND_STYLE;
var DEFAULT_HANDLER_WIDTH = 10;
exports.DEFAULT_HANDLER_WIDTH = DEFAULT_HANDLER_WIDTH;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
exports.HANDLER_STYLE = HANDLER_STYLE;
var TEXT_STYLE = {
  textBaseline: 'middle',
  fill: '#000',
  opacity: 0.45
};
exports.TEXT_STYLE = TEXT_STYLE;
var SLIDER_CHANGE = 'sliderchange';
exports.SLIDER_CHANGE = SLIDER_CHANGE;

/***/ }),
/* 848 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Handler = void 0;

var _tslib = __webpack_require__(1);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var DEFAULT_STYLE = {
  fill: '#F7F7F7',
  stroke: '#BFBFBF',
  radius: 2,
  opacity: 1,
  cursor: 'ew-resize',
  // 
  highLightFill: '#FFF'
};

var Handler =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Handler, _super);

  function Handler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Handler.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'handler',
      x: 0,
      y: 0,
      width: 10,
      height: 24,
      style: DEFAULT_STYLE
    });
  };

  Handler.prototype.renderInner = function (group) {
    var _a = this.cfg,
        width = _a.width,
        height = _a.height,
        style = _a.style;
    var fill = style.fill,
        stroke = style.stroke,
        radius = style.radius,
        opacity = style.opacity,
        cursor = style.cursor; // 

    this.addShape(group, {
      type: 'rect',
      id: this.getElementId('background'),
      attrs: {
        x: 0,
        y: 0,
        width: width,
        height: height,
        fill: fill,
        stroke: stroke,
        radius: radius,
        opacity: opacity,
        cursor: cursor
      }
    }); // 

    var x1 = 1 / 3 * width;
    var x2 = 2 / 3 * width;
    var y1 = 1 / 4 * height;
    var y2 = 3 / 4 * height;
    this.addShape(group, {
      id: this.getElementId('line-left'),
      type: 'line',
      attrs: {
        x1: x1,
        y1: y1,
        x2: x1,
        y2: y2,
        stroke: stroke,
        cursor: cursor
      }
    });
    this.addShape(group, {
      id: this.getElementId('line-right'),
      type: 'line',
      attrs: {
        x1: x2,
        y1: y1,
        x2: x2,
        y2: y2,
        stroke: stroke,
        cursor: cursor
      }
    });
  };

  Handler.prototype.applyOffset = function () {
    this.moveElementTo(this.get('group'), {
      x: this.get('x'),
      y: this.get('y')
    });
  };

  Handler.prototype.initEvent = function () {
    this.bindEvents();
  };

  Handler.prototype.bindEvents = function () {
    var _this = this;

    this.get('group').on('mouseenter', function () {
      var highLightFill = _this.get('style').highLightFill;

      _this.getElementByLocalId('background').attr('fill', highLightFill);

      _this.draw();
    });
    this.get('group').on('mouseleave', function () {
      var fill = _this.get('style').fill;

      _this.getElementByLocalId('background').attr('fill', fill);

      _this.draw();
    });
  };

  Handler.prototype.draw = function () {
    var canvas = this.get('container').get('canvas');

    if (canvas) {
      canvas.draw();
    }
  };

  return Handler;
}(_groupComponent.default);

exports.Handler = Handler;
var _default = Handler;
exports.default = _default;

/***/ }),
/* 849 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _scrollbar = __webpack_require__(850);

Object.keys(_scrollbar).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _scrollbar[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _scrollbar[key];
    }
  });
});

/***/ }),
/* 850 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scrollbar = exports.DEFAULT_THEME = void 0;

var _tslib = __webpack_require__(1);

var _domUtil = __webpack_require__(112);

var _util = __webpack_require__(0);

var _groupComponent = _interopRequireDefault(__webpack_require__(43));

var DEFAULT_STYLE = {
  trackColor: 'rgba(0,0,0,0)',
  thumbColor: 'rgba(0,0,0,0.15)',
  size: 8,
  lineCap: 'round'
};
var DEFAULT_THEME = {
  // 
  default: DEFAULT_STYLE,
  //  hover 
  hover: {
    thumbColor: 'rgba(0,0,0,0.2)'
  }
};
exports.DEFAULT_THEME = DEFAULT_THEME;

var Scrollbar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Scrollbar, _super);

  function Scrollbar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.clearEvents = _util.noop;

    _this.onStartEvent = function (isMobile) {
      return function (e) {
        _this.isMobile = isMobile;
        e.originalEvent.preventDefault();
        var clientX = isMobile ? (0, _util.get)(e.originalEvent, 'touches.0.clientX') : e.clientX;
        var clientY = isMobile ? (0, _util.get)(e.originalEvent, 'touches.0.clientY') : e.clientY; // 

        _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;

        _this.bindLaterEvent();
      };
    };

    _this.bindLaterEvent = function () {
      var containerDOM = _this.getContainerDOM();

      var events = [];

      if (_this.isMobile) {
        events = [(0, _domUtil.addEventListener)(containerDOM, 'touchmove', _this.onMouseMove), (0, _domUtil.addEventListener)(containerDOM, 'touchend', _this.onMouseUp), (0, _domUtil.addEventListener)(containerDOM, 'touchcancel', _this.onMouseUp)];
      } else {
        events = [(0, _domUtil.addEventListener)(containerDOM, 'mousemove', _this.onMouseMove), (0, _domUtil.addEventListener)(containerDOM, 'mouseup', _this.onMouseUp), //  canvas containerDom  mouseup
        (0, _domUtil.addEventListener)(containerDOM, 'mouseleave', _this.onMouseUp)];
      }

      _this.clearEvents = function () {
        events.forEach(function (e) {
          e.remove();
        });
      };
    }; // 
    //  dom  dom 


    _this.onMouseMove = function (e) {
      var _a = _this.cfg,
          isHorizontal = _a.isHorizontal,
          thumbOffset = _a.thumbOffset;
      e.preventDefault();
      var clientX = _this.isMobile ? (0, _util.get)(e, 'touches.0.clientX') : e.clientX;
      var clientY = _this.isMobile ? (0, _util.get)(e, 'touches.0.clientY') : e.clientY; // 

      var endPos = isHorizontal ? clientX : clientY; // ,  diffDis,  container dom

      var diff = endPos - _this.startPos; //  _startPos

      _this.startPos = endPos;

      _this.updateThumbOffset(thumbOffset + diff);
    };

    _this.onMouseUp = function (e) {
      e.preventDefault();

      _this.clearEvents();
    }; // ,


    _this.onTrackClick = function (e) {
      var _a = _this.cfg,
          isHorizontal = _a.isHorizontal,
          x = _a.x,
          y = _a.y,
          thumbLen = _a.thumbLen;

      var containerDOM = _this.getContainerDOM();

      var rect = containerDOM.getBoundingClientRect();
      var clientX = e.clientX,
          clientY = e.clientY;
      var offset = isHorizontal ? clientX - rect.left - x - thumbLen / 2 : clientY - rect.top - y - thumbLen / 2;

      var newOffset = _this.validateRange(offset);

      _this.updateThumbOffset(newOffset);
    };

    _this.onThumbMouseOver = function () {
      var thumbColor = _this.cfg.theme.hover.thumbColor;

      _this.getElementByLocalId('thumb').attr('stroke', thumbColor);

      _this.draw();
    };

    _this.onThumbMouseOut = function () {
      var thumbColor = _this.cfg.theme.default.thumbColor;

      _this.getElementByLocalId('thumb').attr('stroke', thumbColor);

      _this.draw();
    };

    return _this;
  }

  Scrollbar.prototype.setRange = function (min, max) {
    this.set('minLimit', min);
    this.set('maxLimit', max);
    var curValue = this.getValue();
    var newValue = (0, _util.clamp)(curValue, min, max);

    if (curValue !== newValue && !this.get('isInit')) {
      this.setValue(newValue);
    }
  };

  Scrollbar.prototype.getRange = function () {
    var min = this.get('minLimit') || 0;
    var max = this.get('maxLimit') || 1;
    return {
      min: min,
      max: max
    };
  };

  Scrollbar.prototype.setValue = function (value) {
    var range = this.getRange();
    var originalValue = this.getValue();
    this.update({
      thumbOffset: (this.get('trackLen') - this.get('thumbLen')) * (0, _util.clamp)(value, range.min, range.max)
    });
    this.delegateEmit('valuechange', {
      originalValue: originalValue,
      value: this.getValue()
    });
  };

  Scrollbar.prototype.getValue = function () {
    return (0, _util.clamp)(this.get('thumbOffset') / (this.get('trackLen') - this.get('thumbLen')), 0, 1);
  };

  Scrollbar.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      name: 'scrollbar',
      isHorizontal: true,
      minThumbLen: 20,
      thumbOffset: 0,
      theme: DEFAULT_THEME
    });
  };

  Scrollbar.prototype.renderInner = function (group) {
    this.renderTrackShape(group);
    this.renderThumbShape(group);
  };

  Scrollbar.prototype.applyOffset = function () {
    this.moveElementTo(this.get('group'), {
      x: this.get('x'),
      y: this.get('y')
    });
  };

  Scrollbar.prototype.initEvent = function () {
    this.bindEvents();
  }; //  shape


  Scrollbar.prototype.renderTrackShape = function (group) {
    var _a = this.cfg,
        trackLen = _a.trackLen,
        _b = _a.theme,
        theme = _b === void 0 ? {
      default: {}
    } : _b;
    var _c = theme.default,
        lineCap = _c.lineCap,
        trackColor = _c.trackColor,
        size = _c.size;
    var attrs = this.get('isHorizontal') ? {
      x1: 0 + size / 2,
      y1: size / 2,
      x2: trackLen - size / 2,
      y2: size / 2,
      lineWidth: size,
      stroke: trackColor,
      lineCap: lineCap
    } : {
      x1: size / 2,
      y1: 0 + size / 2,
      x2: size / 2,
      y2: trackLen - size / 2,
      lineWidth: size,
      stroke: trackColor,
      lineCap: lineCap
    };
    return this.addShape(group, {
      id: this.getElementId('track'),
      name: 'track',
      type: 'line',
      attrs: attrs
    });
  }; //  shape


  Scrollbar.prototype.renderThumbShape = function (group) {
    var _a = this.cfg,
        thumbOffset = _a.thumbOffset,
        thumbLen = _a.thumbLen,
        _b = _a.theme,
        theme = _b === void 0 ? {
      default: {}
    } : _b;
    var _c = theme.default,
        size = _c.size,
        lineCap = _c.lineCap,
        thumbColor = _c.thumbColor;
    var attrs = this.get('isHorizontal') ? {
      x1: thumbOffset + size / 2,
      y1: size / 2,
      x2: thumbOffset + thumbLen - size / 2,
      y2: size / 2,
      lineWidth: size,
      stroke: thumbColor,
      lineCap: lineCap,
      cursor: 'default'
    } : {
      x1: size / 2,
      y1: thumbOffset + size / 2,
      x2: size / 2,
      y2: thumbOffset + thumbLen - size / 2,
      lineWidth: size,
      stroke: thumbColor,
      lineCap: lineCap,
      cursor: 'default'
    };
    return this.addShape(group, {
      id: this.getElementId('thumb'),
      name: 'thumb',
      type: 'line',
      attrs: attrs
    });
  };

  Scrollbar.prototype.bindEvents = function () {
    var group = this.get('group');
    group.on('mousedown', this.onStartEvent(false));
    group.on('mouseup', this.onMouseUp);
    group.on('touchstart', this.onStartEvent(true));
    group.on('touchend', this.onMouseUp);
    var trackShape = group.findById(this.getElementId('track'));
    trackShape.on('click', this.onTrackClick);
    var thumbShape = group.findById(this.getElementId('thumb'));
    thumbShape.on('mouseover', this.onThumbMouseOver);
    thumbShape.on('mouseout', this.onThumbMouseOut);
  };

  Scrollbar.prototype.getContainerDOM = function () {
    var container = this.get('container');
    var canvas = container && container.get('canvas');
    return canvas && canvas.get('container');
  };

  Scrollbar.prototype.validateRange = function (offset) {
    var _a = this.cfg,
        thumbLen = _a.thumbLen,
        trackLen = _a.trackLen;
    var newOffset = offset;

    if (offset + thumbLen > trackLen) {
      newOffset = trackLen - thumbLen;
    } else if (offset + thumbLen < thumbLen) {
      newOffset = 0;
    }

    return newOffset;
  };

  Scrollbar.prototype.draw = function () {
    var container = this.get('container');
    var canvas = container && container.get('canvas');

    if (canvas) {
      canvas.draw();
    }
  };

  Scrollbar.prototype.updateThumbOffset = function (offset) {
    var _a = this.cfg,
        thumbOffset = _a.thumbOffset,
        isHorizontal = _a.isHorizontal,
        thumbLen = _a.thumbLen,
        size = _a.size;
    var newOffset = this.validateRange(offset);

    if (newOffset === thumbOffset) {
      //  offset 
      return;
    }

    var thumbShape = this.getElementByLocalId('thumb');

    if (isHorizontal) {
      thumbShape.attr({
        x1: newOffset + size / 2,
        x2: newOffset + thumbLen - size / 2
      });
    } else {
      thumbShape.attr({
        y1: newOffset + size / 2,
        y2: newOffset + thumbLen - size / 2
      });
    }

    this.emitOffsetChange(newOffset);
  };

  Scrollbar.prototype.emitOffsetChange = function (offset) {
    var _a = this.cfg,
        originalValue = _a.thumbOffset,
        trackLen = _a.trackLen,
        thumbLen = _a.thumbLen;
    this.cfg.thumbOffset = offset; // 

    this.emit('scrollchange', {
      thumbOffset: offset,
      ratio: (0, _util.clamp)(offset / (trackLen - thumbLen), 0, 1)
    });
    this.delegateEmit('valuechange', {
      originalValue: originalValue,
      value: offset
    });
  };

  return Scrollbar;
}(_groupComponent.default);

exports.Scrollbar = Scrollbar;

/***/ }),
/* 851 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 852 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 853 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNormalizedValue = void 0;

var stat_1 = __webpack_require__(854);
/**
 * parse the value position
 * @param val
 * @param scale
 */


function getNormalizedValue(val, scale) {
  var scaled;

  switch (val) {
    case 'start':
      return 0;

    case 'end':
      return 1;

    case 'median':
      {
        scaled = scale.isCategory ? stat_1.getMedian(scale.values.map(function (_, idx) {
          return idx;
        })) : stat_1.getMedian(scale.values);
        break;
      }

    case 'mean':
      {
        scaled = scale.isCategory ? (scale.values.length - 1) / 2 : stat_1.getMean(scale.values);
        break;
      }

    case 'min':
      scaled = scale.isCategory ? 0 : scale[val];
      break;

    case 'max':
      scaled = scale.isCategory ? scale.values.length - 1 : scale[val];
      break;

    default:
      scaled = val;
      break;
  }

  return scale.scale(scaled);
}

exports.getNormalizedValue = getNormalizedValue;

/***/ }),
/* 854 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMean = exports.getMedian = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);
/**
 * 
 * @param array
 */


function getMedian(array) {
  var arr = tslib_1.__spreadArrays(array); // 


  arr.sort(function (a, b) {
    return a - b;
  });
  var len = arr.length; // median
  // 0

  if (len === 0) {
    return 0;
  } // 


  if (len % 2 === 1) {
    return arr[(len - 1) / 2];
  } // 


  return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}

exports.getMedian = getMedian;
/**
 * 
 * @param array
 */

function getMean(array) {
  var sum = util_1.reduce(array, function (r, num) {
    return r += isNaN(num) || !util_1.isNumber(num) ? 0 : num;
  }, 0);
  return array.length === 0 ? 0 : sum / array.length;
}

exports.getMean = getMean;

/***/ }),
/* 855 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69);

var util_1 = __webpack_require__(52);

var Circle =
/** @class */
function (_super) {
  tslib_1.__extends(Circle, _super);

  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Circle.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      r: 0
    });
  };

  Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = util_1.distance(cx, cy, x, y); // 

    if (isFill && isStroke) {
      return absDistance <= r + halfLineWidth;
    }

    if (isFill) {
      return absDistance <= r;
    }

    if (isStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }

    return false;
  };

  Circle.prototype.createPath = function (context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
    context.closePath();
  };

  return Circle;
}(base_1.default);

exports.default = Circle;

/***/ }),
/* 856 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69); //  x*x/rx*rx + y*y/ry*ry;


function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}

var Ellipse =
/** @class */
function (_super) {
  tslib_1.__extends(Ellipse, _super);

  function Ellipse() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Ellipse.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      rx: 0,
      ry: 0
    });
  };

  Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx,
        ry = attrs.ry;
    var squareX = (x - cx) * (x - cx);
    var squareY = (y - cy) * (y - cy); //  x*x/rx*rx + y*y/ry*ry = 1;

    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }

    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }

    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }

    return false;
  };

  Ellipse.prototype.createPath = function (context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context.beginPath(); // 

    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      // 
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.translate(cx, cy);
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r, 0, Math.PI * 2);
      context.restore();
      context.closePath();
    }
  };

  return Ellipse;
}(base_1.default);

exports.default = Ellipse;

/***/ }),
/* 857 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69);

var util_1 = __webpack_require__(52);

function isCanvas(dom) {
  return dom instanceof HTMLElement && util_1.isString(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';
}

var ImageShape =
/** @class */
function (_super) {
  tslib_1.__extends(ImageShape, _super);

  function ImageShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ImageShape.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  };

  ImageShape.prototype.initAttrs = function (attrs) {
    this._setImage(attrs.img);
  }; // image  stroke


  ImageShape.prototype.isStroke = function () {
    return false;
  }; // 
  //  isInStrokeOrPath 


  ImageShape.prototype.isOnlyHitBox = function () {
    return true;
  };

  ImageShape.prototype._afterLoading = function () {
    if (this.get('toDraw') === true) {
      var canvas = this.get('canvas');

      if (canvas) {
        // 
        canvas.draw();
      } else {
        // 
        this.createPath(this.get('context'));
      }
    }
  };

  ImageShape.prototype._setImage = function (img) {
    var _this = this;

    var attrs = this.attrs;

    if (util_1.isString(img)) {
      var image_1 = new Image();

      image_1.onload = function () {
        // 
        if (_this.destroyed) {
          return false;
        } // 
        //  img 
        // this.set('imgSrc', img);
        //  _setImage 


        _this.attr('img', image_1);

        _this.set('loading', false);

        _this._afterLoading();

        var callback = _this.get('callback');

        if (callback) {
          callback.call(_this);
        }
      }; // 


      image_1.crossOrigin = 'Anonymous';
      image_1.src = img; // loading 

      this.set('loading', true);
    } else if (img instanceof Image) {
      //  image 
      if (!attrs.width) {
        attrs.width = img.width;
      }

      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      //  canvas 
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute('width'));
      }

      if (!attrs.height) {
        attrs.height, Number(img.getAttribute('height'));
      }
    }
  };

  ImageShape.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue); // 


    if (name === 'img') {
      // && this.get('imgSrc') !== value
      this._setImage(value);
    }
  };

  ImageShape.prototype.createPath = function (context) {
    // 
    if (this.get('loading')) {
      this.set('toDraw', true); // 

      this.set('context', context);
      return;
    }

    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y,
        width = attrs.width,
        height = attrs.height,
        sx = attrs.sx,
        sy = attrs.sy,
        swidth = attrs.swidth,
        sheight = attrs.sheight;
    var img = attrs.img;

    if (img instanceof Image || isCanvas(img)) {
      if (!util_1.isNil(sx) && !util_1.isNil(sy) && !util_1.isNil(swidth) && !util_1.isNil(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
      } else {
        context.drawImage(img, x, y, width, height);
      }
    }
  };

  return ImageShape;
}(base_1.default);

exports.default = ImageShape;

/***/ }),
/* 858 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */


var g_math_1 = __webpack_require__(35);

var base_1 = __webpack_require__(69);

var line_1 = __webpack_require__(188);

var ArrowUtil = __webpack_require__(187);

var Line =
/** @class */
function (_super) {
  tslib_1.__extends(Line, _super);

  function Line() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Line.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      startArrow: false,
      endArrow: false
    });
  };

  Line.prototype.initAttrs = function (attrs) {
    this.setArrow();
  }; // 


  Line.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue); //  line  attrs attr attr 


    this.setArrow();
  };

  Line.prototype.setArrow = function () {
    var attrs = this.attr();
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2,
        startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;

    if (startArrow) {
      ArrowUtil.addStartArrow(this, attrs, x2, y2, x1, y1);
    }

    if (endArrow) {
      ArrowUtil.addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };

  Line.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }

    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return line_1.default(x1, y1, x2, y2, lineWidth, x, y);
  };

  Line.prototype.createPath = function (context) {
    var attrs = this.attr();
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2,
        startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };

    if (startArrow && startArrow.d) {
      startArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }

    if (endArrow && endArrow.d) {
      endArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }

    context.beginPath(); // 

    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };

  Line.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get length of line
   * @return {number} length
   */


  Line.prototype.getTotalLength = function () {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return g_math_1.Line.length(x1, y1, x2, y2);
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Line.prototype.getPoint = function (ratio) {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return g_math_1.Line.pointAt(x1, y1, x2, y2, ratio);
  };

  return Line;
}(base_1.default);

exports.default = Line;

/***/ }),
/* 859 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview Marker
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var path_util_1 = __webpack_require__(95);

var base_1 = __webpack_require__(69);

var util_2 = __webpack_require__(52);

var draw_1 = __webpack_require__(143);

var Symbols = {
  // 
  circle: function circle(x, y, r) {
    return [['M', x - r, y], ['A', r, r, 0, 1, 0, x + r, y], ['A', r, r, 0, 1, 0, x - r, y]];
  },
  // 
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  // 
  diamond: function diamond(x, y, r) {
    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
  },
  // 
  triangle: function triangle(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];
  },
  // 
  'triangle-down': function triangleDown(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
  }
};

var Marker =
/** @class */
function (_super) {
  tslib_1.__extends(Marker, _super);

  function Marker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Marker.prototype.initAttrs = function (attrs) {
    this._resetParamsCache();
  }; //  path 


  Marker.prototype._resetParamsCache = function () {
    //  path 
    // 
    this.set('paramsCache', {}); // 
  }; //  path


  Marker.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {
      // path 
      this._resetParamsCache();
    }
  }; // 
  //  isInStrokeOrPath 


  Marker.prototype.isOnlyHitBox = function () {
    return true;
  };

  Marker.prototype._getR = function (attrs) {
    //  r  radius  r
    return util_1.isNil(attrs.r) ? attrs.radius : attrs.r;
  };

  Marker.prototype._getPath = function () {
    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y;
    var symbol = attrs.symbol || 'circle';

    var r = this._getR(attrs);

    var method;
    var path;

    if (util_2.isFunction(symbol)) {
      method = symbol;
      path = method(x, y, r); //  path 

      path = path_util_1.path2Absolute(path);
    } else {
      //  symbol  path  path 
      method = Marker.Symbols[symbol];

      if (!method) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }

      path = method(x, y, r);
    }

    return path;
  };

  Marker.prototype.createPath = function (context) {
    var path = this._getPath();

    var paramsCache = this.get('paramsCache');
    draw_1.drawPath(this, context, {
      path: path
    }, paramsCache);
  };

  Marker.Symbols = Symbols;
  return Marker;
}(base_1.default);

exports.default = Marker;

/***/ }),
/* 860 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_math_1 = __webpack_require__(35);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(69);

var path_util_1 = __webpack_require__(95);

var draw_1 = __webpack_require__(143);

var point_in_path_1 = __webpack_require__(427);

var polygon_1 = __webpack_require__(428);

var path_1 = __webpack_require__(861);

var ArrowUtil = __webpack_require__(187); // 


function isInPolygons(polygons, x, y) {
  var isHit = false;

  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = polygon_1.default(points, x, y);

    if (isHit) {
      break;
    }
  }

  return isHit;
}

var Path =
/** @class */
function (_super) {
  tslib_1.__extends(Path, _super);

  function Path() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Path.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  Path.prototype.initAttrs = function (attrs) {
    this._setPathArr(attrs.path);

    this.setArrow();
  }; //  path


  Path.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (name === 'path') {
      this._setPathArr(value);
    } //  line  attrs attr attr 


    this.setArrow();
  }; //  path 


  Path.prototype._setPathArr = function (path) {
    //  path 
    this.attrs.path = path_util_1.path2Absolute(path);
    var hasArc = path_1.default.hasArc(path); //  path 
    // 

    this.set('hasArc', hasArc);
    this.set('paramsCache', {}); // 

    this.set('segments', null); //  path

    this.set('curve', null);
    this.set('tCache', null);
    this.set('totalLength', null);
  };

  Path.prototype.getSegments = function () {
    var segments = this.get('segements');

    if (!segments) {
      segments = path_util_1.path2Segments(this.attr('path'));
      this.set('segments', segments);
    }

    return segments;
  };

  Path.prototype.setArrow = function () {
    var attrs = this.attr();
    var startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;

    if (startArrow) {
      var tangent = this.getStartTangent();
      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }

    if (endArrow) {
      var tangent = this.getEndTangent();
      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };

  Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc = this.get('hasArc');
    var isHit = false;

    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = path_1.default.isPointInStroke(segments, lineWidth, x, y, length_1);
    }

    if (!isHit && isFill) {
      if (hasArc) {
        //  canvas  api 
        isHit = point_in_path_1.default(this, x, y);
      } else {
        var path = this.attr('path');
        var extractResutl = path_1.default.extractPolygons(path); // 

        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
      }
    }

    return isHit;
  };

  Path.prototype.createPath = function (context) {
    var attrs = this.attr();
    var paramsCache = this.get('paramsCache'); // 

    draw_1.drawPath(this, context, attrs, paramsCache);
  };

  Path.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get total length of path
   * @return {number} length
   */


  Path.prototype.getTotalLength = function () {
    var totalLength = this.get('totalLength');

    if (!util_1.isNil(totalLength)) {
      return totalLength;
    }

    this._calculateCurve();

    this._setTcache();

    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Path.prototype.getPoint = function (ratio) {
    var tCache = this.get('tCache');

    if (!tCache) {
      this._calculateCurve();

      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    var curve = this.get('curve');

    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }

      return null;
    }

    util_1.each(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var seg = curve[index];

    if (util_1.isNil(seg) || util_1.isNil(index)) {
      return null;
    }

    var l = seg.length;
    var nextSeg = curve[index + 1];
    return g_math_1.Cubic.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };

  Path.prototype._calculateCurve = function () {
    var path = this.attr().path;
    this.set('curve', path_1.default.pathToCurve(path));
  };

  Path.prototype._setTcache = function () {
    var totalLength = 0;
    var tempLength = 0; //  curve : [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]

    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l;
    var curve = this.get('curve');

    if (!curve) {
      return;
    }

    util_1.each(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        totalLength += g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set('totalLength', totalLength);

    if (totalLength === 0) {
      this.set('tCache', []);
      return;
    }

    util_1.each(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = g_math_1.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); //  path segmentL  0 

        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  Path.prototype.getStartTangent = function () {
    var segments = this.getSegments();
    var result;

    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];

      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }

    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  Path.prototype.getEndTangent = function () {
    var segments = this.getSegments();
    var length = segments.length;
    var result;

    if (length > 1) {
      var startPoint = segments[length - 2].currentPoint;
      var endPoint = segments[length - 1].currentPoint;
      var tangent = segments[length - 1].endTangent;
      result = [];

      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }

    return result;
  };

  return Path;
}(base_1.default);

exports.default = Path;

/***/ }),
/* 861 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * @fileoverview path 
 * @author dxq613@gmail.com
 */


var g_base_1 = __webpack_require__(27);

var g_math_1 = __webpack_require__(35);

var g_math_2 = __webpack_require__(35);

var matrix_util_1 = __webpack_require__(33);

var vec3 = __webpack_require__(176);

var util_1 = __webpack_require__(52);

var line_1 = __webpack_require__(188);

var arc_1 = __webpack_require__(429);

var transform = matrix_util_1.ext.transform;

function hasArc(path) {
  var hasArc = false;
  var count = path.length;

  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];

    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
      hasArc = true;
      break;
    }
  }

  return hasArc;
}

function isPointInStroke(segments, lineWidth, x, y, length) {
  var isHit = false;
  var halfWidth = lineWidth / 2;

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint,
        box = segment.box; // 

    if (box && !util_1.inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {
      continue;
    }

    switch (segment.command) {
      // L  Z  M 
      case 'L':
      case 'Z':
        isHit = line_1.default(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;

      case 'Q':
        var qDistance = g_math_1.Quad.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;

      case 'C':
        var cDistance = g_math_2.Cubic.pointDistance(prePoint[0], // ,  C 
        prePoint[1], params[1], // 'C' 12 34 56 
        params[2], params[3], params[4], params[5], params[6], x, y, length);
        isHit = cDistance <= lineWidth / 2;
        break;

      case 'A':
        // 
        var arcParams = segment.arcParams;
        var cx = arcParams.cx,
            cy = arcParams.cy,
            rx = arcParams.rx,
            ry = arcParams.ry,
            startAngle = arcParams.startAngle,
            endAngle = arcParams.endAngle,
            xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform(null, [['t', -cx, -cy], ['r', -xRotation], ['s', 1 / scaleX, 1 / scaleY]]);
        vec3.transformMat3(p, p, m);
        isHit = arc_1.default(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;

      default:
        break;
    }

    if (isHit) {
      break;
    }
  }

  return isHit;
}
/**
 *  path 
 * @param {Array} path 
 * @returns {Array} 
 */


function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = []; //  'M'

  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];

    if (cmd === 'M') {
      //  'M' 
      if (points.length) {
        //  'Z'
        polylines.push(points);
        points = []; // 
      }

      points.push([params[1], params[2]]);
    } else if (cmd === 'Z') {
      if (points.length) {
        // 
        polygons.push(points);
        points = []; // 
      } //  'Z'

    } else {
      points.push([params[1], params[2]]);
    }
  } //  points  polygons  polyline
  //  M Z 


  if (points.length > 0) {
    polylines.push(points);
  }

  return {
    polygons: polygons,
    polylines: polylines
  };
}

exports.default = tslib_1.__assign({
  hasArc: hasArc,
  extractPolygons: extractPolygons,
  isPointInStroke: isPointInStroke
}, g_base_1.PathUtil);

/***/ }),
/* 862 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69);

var polyline_1 = __webpack_require__(430);

var polygon_1 = __webpack_require__(428);

var Polygon =
/** @class */
function (_super) {
  tslib_1.__extends(Polygon, _super);

  function Polygon() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Polygon.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var points = this.attr().points;
    var isHit = false;

    if (isStroke) {
      isHit = polyline_1.default(points, lineWidth, x, y, true);
    }

    if (!isHit && isFill) {
      isHit = polygon_1.default(points, x, y); // isPointInPath(shape, x, y);
    }

    return isHit;
  };

  Polygon.prototype.createPath = function (context) {
    var attrs = this.attr();
    var points = attrs.points;

    if (points.length < 2) {
      return;
    }

    context.beginPath();

    for (var i = 0; i < points.length; i++) {
      var point = points[i];

      if (i === 0) {
        context.moveTo(point[0], point[1]);
      } else {
        context.lineTo(point[0], point[1]);
      }
    }

    context.closePath();
  };

  return Polygon;
}(base_1.default);

exports.default = Polygon;

/***/ }),
/* 863 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_math_1 = __webpack_require__(35);

var g_math_2 = __webpack_require__(35);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(69);

var polyline_1 = __webpack_require__(430);

var ArrowUtil = __webpack_require__(187);

var PolyLine =
/** @class */
function (_super) {
  tslib_1.__extends(PolyLine, _super);

  function PolyLine() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PolyLine.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  PolyLine.prototype.initAttrs = function (attrs) {
    this.setArrow();
  }; //  points


  PolyLine.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    this.setArrow();

    if (['points'].indexOf(name) !== -1) {
      this._resetCache();
    }
  };

  PolyLine.prototype._resetCache = function () {
    this.set('totalLength', null);
    this.set('tCache', null);
  };

  PolyLine.prototype.setArrow = function () {
    var attrs = this.attr();
    var _a = this.attrs,
        points = _a.points,
        startArrow = _a.startArrow,
        endArrow = _a.endArrow;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1];

    if (startArrow) {
      ArrowUtil.addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
    }

    if (endArrow) {
      ArrowUtil.addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);
    }
  }; //  fill


  PolyLine.prototype.isFill = function () {
    return false;
  };

  PolyLine.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    //  stroke , 
    if (!isStroke || !lineWidth) {
      return false;
    }

    var points = this.attr().points;
    return polyline_1.default(points, lineWidth, x, y, false);
  }; // 


  PolyLine.prototype.isStroke = function () {
    return true;
  };

  PolyLine.prototype.createPath = function (context) {
    var _a = this.attr(),
        points = _a.points,
        startArrow = _a.startArrow,
        endArrow = _a.endArrow;

    var length = points.length;

    if (points.length < 2) {
      return;
    }

    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1]; // 

    if (startArrow && startArrow.d) {
      var distance = ArrowUtil.getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
      x1 += distance.dx;
      y1 += distance.dy;
    }

    if (endArrow && endArrow.d) {
      var distance = ArrowUtil.getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);
      x2 -= distance.dx;
      y2 -= distance.dy;
    }

    context.beginPath();
    context.moveTo(x1, y1);

    for (var i = 0; i < length - 1; i++) {
      var point = points[i];
      context.lineTo(point[0], point[1]);
    }

    context.lineTo(x2, y2);
  };

  PolyLine.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get length of polyline
   * @return {number} length
   */


  PolyLine.prototype.getTotalLength = function () {
    var points = this.attr().points; // get totalLength from cache

    var totalLength = this.get('totalLength');

    if (!util_1.isNil(totalLength)) {
      return totalLength;
    }

    this.set('totalLength', g_math_2.Polyline.length(points));
    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  PolyLine.prototype.getPoint = function (ratio) {
    var points = this.attr().points; // get tCache from cache

    var tCache = this.get('tCache');

    if (!tCache) {
      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    util_1.each(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return g_math_1.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };

  PolyLine.prototype._setTcache = function () {
    var points = this.attr().points;

    if (!points || points.length === 0) {
      return;
    }

    var totalLength = this.getTotalLength();

    if (totalLength <= 0) {
      return;
    }

    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    util_1.each(points, function (p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = g_math_1.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  PolyLine.prototype.getStartTangent = function () {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  PolyLine.prototype.getEndTangent = function () {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };

  return PolyLine;
}(base_1.default);

exports.default = PolyLine;

/***/ }),
/* 864 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69);

var parse_1 = __webpack_require__(425);

var util_1 = __webpack_require__(52);

var rect_1 = __webpack_require__(865);

var rect_radius_1 = __webpack_require__(866);

var point_in_path_1 = __webpack_require__(427);

var Rect =
/** @class */
function (_super) {
  tslib_1.__extends(Rect, _super);

  function Rect() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Rect.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0
    });
  };

  Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius; // 

    if (!radius) {
      var halfWidth = lineWidth / 2; // 

      if (isFill && isStroke) {
        return util_1.inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
      } // 


      if (isFill) {
        return util_1.inBox(minX, minY, width, height, x, y);
      }

      if (isStroke) {
        return rect_1.default(minX, minY, width, height, lineWidth, x, y);
      }
    } else {
      var isHit = false;

      if (isStroke) {
        isHit = rect_radius_1.default(minX, minY, width, height, radius, lineWidth, x, y);
      } // 
      // 


      if (!isHit && isFill) {
        isHit = point_in_path_1.default(this, x, y);
      }

      return isHit;
    }
  };

  Rect.prototype.createPath = function (context) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context.beginPath();

    if (radius === 0) {
      // rect
      context.rect(x, y, width, height);
    } else {
      var _a = parse_1.parseRadius(radius),
          r1 = _a[0],
          r2 = _a[1],
          r3 = _a[2],
          r4 = _a[3];

      context.moveTo(x + r1, y);
      context.lineTo(x + width - r2, y);
      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      context.lineTo(x + width, y + height - r3);
      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      context.lineTo(x + r4, y + height);
      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      context.lineTo(x, y + r1);
      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  };

  return Rect;
}(base_1.default);

exports.default = Rect;

/***/ }),
/* 865 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(52);

function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2; // 

  return util_1.inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 
  util_1.inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 
  util_1.inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 
  util_1.inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y); // 
}

exports.default = inRect;

/***/ }),
/* 866 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var line_1 = __webpack_require__(188);

var arc_1 = __webpack_require__(429);

function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return line_1.default(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || line_1.default(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || line_1.default(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || line_1.default(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc_1.default(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc_1.default(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc_1.default(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc_1.default(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

exports.default = rectWithRadius;

/***/ }),
/* 867 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(69);

var util_1 = __webpack_require__(52);

var g_base_1 = __webpack_require__(27);

var Text =
/** @class */
function (_super) {
  tslib_1.__extends(Text, _super);

  function Text() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // 


  Text.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      text: null,
      fontSize: 12,
      fontFamily: 'sans-serif',
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontVariant: 'normal',
      textAlign: 'start',
      textBaseline: 'bottom'
    });
  }; // 


  Text.prototype.isOnlyHitBox = function () {
    return true;
  }; //  font text 


  Text.prototype.initAttrs = function (attrs) {
    this._assembleFont();

    if (attrs.text) {
      this._setText(attrs.text);
    }
  }; // 


  Text.prototype._assembleFont = function () {
    var attrs = this.attrs;
    attrs.font = g_base_1.assembleFont(attrs);
  }; // 


  Text.prototype._setText = function (text) {
    var textArr = null;

    if (util_1.isString(text) && text.indexOf('\n') !== -1) {
      textArr = text.split('\n');
    }

    this.set('textArr', textArr);
  }; //  fonttext


  Text.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (name.startsWith('font')) {
      this._assembleFont();
    }

    if (name === 'text') {
      this._setText(value);
    }
  }; //  text 
  // createPath(context) {
  // }
  // 


  Text.prototype._getSpaceingY = function () {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }; // 


  Text.prototype._drawTextArr = function (context, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x = attrs.x;
    var y = attrs.y;
    var fontSize = attrs.fontSize * 1;

    var spaceingY = this._getSpaceingY();

    var height = g_base_1.getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    util_1.each(textArr, function (subText, index) {
      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;

      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === 'top') subY += height - fontSize;

      if (isFill) {
        context.fillText(subText, x, subY);
      } else {
        context.strokeText(subText, x, subY);
      }
    });
  }; // 


  Text.prototype._drawText = function (context, isFill) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var textArr = this.get('textArr');

    if (textArr) {
      this._drawTextArr(context, textArr, isFill);
    } else {
      var text = attrs.text;

      if (isFill) {
        context.fillText(text, x, y);
      } else {
        context.strokeText(text, x, y);
      }
    }
  }; // 


  Text.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        opacity = _a.opacity,
        strokeOpacity = _a.strokeOpacity,
        fillOpacity = _a.fillOpacity;

    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!util_1.isNil(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = opacity;
        }

        this.stroke(context);
      }
    }

    if (this.isFill()) {
      if (!util_1.isNil(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }

    this.afterDrawPath(context);
  }; // 


  Text.prototype.fill = function (context) {
    this._drawText(context, true);
  }; // 


  Text.prototype.stroke = function (context) {
    this._drawText(context, false);
  };

  return Text;
}(base_1.default);

exports.default = Text;

/***/ }),
/* 868 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var hit_1 = __webpack_require__(869);

var Shape = __webpack_require__(142);

var group_1 = __webpack_require__(258);

var util_1 = __webpack_require__(52);

var draw_1 = __webpack_require__(143);

var Canvas =
/** @class */
function (_super) {
  tslib_1.__extends(Canvas, _super);

  function Canvas() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Canvas.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this); //  canvas


    cfg['renderer'] = 'canvas'; //  draw 

    cfg['autoDraw'] = true; // 

    cfg['localRefresh'] = true;
    cfg['refreshElements'] = []; // 

    cfg['clipView'] = true; //  false

    cfg['quickHit'] = false;
    return cfg;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Canvas.prototype.onCanvasChange = function (changeType) {
    /**
     *  changeType
     * 1. attr: 
     * 2. sort: 
     * 3. changeSize: 
     */
    if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {
      this.set('refreshElements', [this]);
      this.draw();
    }
  };

  Canvas.prototype.getShapeBase = function () {
    return Shape;
  };

  Canvas.prototype.getGroupBase = function () {
    return group_1.default;
  };
  /**
   * 
   */


  Canvas.prototype.getPixelRatio = function () {
    var pixelRatio = this.get('pixelRatio') || util_1.getPixelRatio(); //  1  1 1 

    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };

  Canvas.prototype.getViewRange = function () {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  }; // 


  Canvas.prototype.createDom = function () {
    var element = document.createElement('canvas');
    var context = element.getContext('2d'); //  context 

    this.set('context', context);
    return element;
  };

  Canvas.prototype.setDOMSize = function (width, height) {
    _super.prototype.setDOMSize.call(this, width, height);

    var context = this.get('context');
    var el = this.get('el');
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height; //  canvas  context.scale 

    if (pixelRatio > 1) {
      context.scale(pixelRatio, pixelRatio);
    }
  }; // 


  Canvas.prototype.clear = function () {
    _super.prototype.clear.call(this);

    this._clearFrame(); // 


    var context = this.get('context');
    var element = this.get('el');
    context.clearRect(0, 0, element.width, element.height);
  };

  Canvas.prototype.getShape = function (x, y) {
    var shape;

    if (this.get('quickHit')) {
      shape = hit_1.getShape(this, x, y);
    } else {
      shape = _super.prototype.getShape.call(this, x, y, null);
    }

    return shape;
  }; // 


  Canvas.prototype._getRefreshRegion = function () {
    var elements = this.get('refreshElements');
    var viewRegion = this.getViewRange();
    var region; // 

    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = draw_1.getMergedRegion(elements);

      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1; // 

        var clipView = this.get('clipView'); //  view 

        if (clipView) {
          region = draw_1.mergeView(region, viewRegion);
        }
      }
    }

    return region;
  };
  /**
   * 
   * @param {IElement} element 
   */


  Canvas.prototype.refreshElement = function (element) {
    var refreshElements = this.get('refreshElements');
    refreshElements.push(element); // if (this.get('autoDraw')) {
    //   this._startDraw();
    // }
  }; // 


  Canvas.prototype._clearFrame = function () {
    var drawFrame = this.get('drawFrame');

    if (drawFrame) {
      // 
      util_1.clearAnimationFrame(drawFrame);
      this.set('drawFrame', null);
      this.set('refreshElements', []);
    }
  }; // 


  Canvas.prototype.draw = function () {
    var drawFrame = this.get('drawFrame');

    if (this.get('autoDraw') && drawFrame) {
      return;
    }

    this._startDraw();
  }; // 


  Canvas.prototype._drawAll = function () {
    var context = this.get('context');
    var element = this.get('el');
    var children = this.getChildren();
    context.clearRect(0, 0, element.width, element.height);
    draw_1.applyAttrsToContext(context, this);
    draw_1.drawChildren(context, children); //  https://github.com/antvis/g/issues/422 

    this.set('refreshElements', []);
  }; // 


  Canvas.prototype._drawRegion = function () {
    var context = this.get('context');
    var refreshElements = this.get('refreshElements');
    var children = this.getChildren();

    var region = this._getRefreshRegion(); //  region 
    //  localRefresh , draw


    if (region) {
      // 
      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY); //  clip

      context.save();
      context.beginPath();
      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.clip();
      draw_1.applyAttrsToContext(context, this); //  10 10W  group  90ms  5-6 ms

      draw_1.checkRefresh(this, children, region); // 

      draw_1.drawChildren(context, children, region);
      context.restore();
    } else if (refreshElements.length) {
      //  elements  region 
      // 1.  group
      // 2.  elements 
      // 3. group  elements 
      //  hasChanged 
      draw_1.clearChanged(refreshElements);
    }

    util_1.each(refreshElements, function (element) {
      if (element.get('hasChanged')) {
        //  Group  draw()  hasChanged 
        //  hasChanged  Group 
        element.set('hasChanged', false);
      }
    });
    this.set('refreshElements', []);
  }; // 


  Canvas.prototype._startDraw = function () {
    var _this = this;

    var drawFrame = this.get('drawFrame');

    if (!drawFrame) {
      drawFrame = util_1.requestAnimationFrame(function () {
        if (_this.get('localRefresh')) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }

        _this.set('drawFrame', null);
      });
      this.set('drawFrame', drawFrame);
    }
  };

  Canvas.prototype.skipDraw = function () {};

  return Canvas;
}(g_base_1.AbstractCanvas);

exports.default = Canvas;

/***/ }),
/* 869 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShape = void 0;

var g_base_1 = __webpack_require__(27);

function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = g_base_1.invert(matrix);
    return g_base_1.multiplyVec2(invertMatrix, v);
  }

  return v;
}

function getRefXY(element, x, y) {
  // @ts-ignore
  var totalMatrix = element.getTotalMatrix();

  if (totalMatrix) {
    var _a = invertFromMatrix([x, y, 1], totalMatrix),
        refX = _a[0],
        refY = _a[1];

    return [refX, refY];
  }

  return [x, y];
} // 


function preTest(element, x, y) {
  // @ts-ignore
  if (element.isCanvas && element.isCanvas()) {
    return true;
  } //  null
  // @ts-ignore


  if (!g_base_1.isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }

  if (element.cfg.clipShape) {
    //  clip
    var _a = getRefXY(element, x, y),
        refX = _a[0],
        refY = _a[1];

    if (element.isClipped(refX, refY)) {
      return false;
    }
  } // @ts-ignore 


  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox(); //  bbox
  //  const bbox = element.cfg.cacheCanvasBBox;
  // / isInView 
  //  element.getCanvasBBox(); 
  // if (!bbox) {
  //   return false;
  // }

  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }

  return true;
} //  g-base  getShape


function getShape(container, x, y) {
  //  null
  if (!preTest(container, x, y)) {
    return null;
  }

  var shape = null;
  var children = container.getChildren();
  var count = children.length;

  for (var i = count - 1; i >= 0; i--) {
    var child = children[i];

    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;

      var _a = getRefXY(child, x, y),
          refX = _a[0],
          refY = _a[1]; // @ts-ignore


      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }

    if (shape) {
      break;
    }
  }

  return shape;
}

exports.getShape = getShape;

/***/ }),
/* 870 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview circle
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Circle =
/** @class */
function (_super) {
  tslib_1.__extends(Circle, _super);

  function Circle() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'circle';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Circle.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      r: 0
    });
  };

  Circle.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      //  x, y cx, cy
      if (attr === 'x' || attr === 'y') {
        el.setAttribute("c" + attr, value);
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Circle;
}(base_1.default);

exports.default = Circle;

/***/ }),
/* 871 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview dom
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Dom =
/** @class */
function (_super) {
  tslib_1.__extends(Dom, _super);

  function Dom() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dom';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  Dom.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });

    if (typeof attrs['html'] === 'function') {
      var element = attrs['html'].call(this, attrs);

      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;

        for (var i = children.length - 1; i >= 0; i--) {
          el.removeChild(children[i]);
        }

        el.appendChild(element); // append to el if it's an element
      } else {
        el.innerHTML = element; // set innerHTML
      }
    } else {
      el.innerHTML = attrs['html']; // set innerHTML
    }
  };

  return Dom;
}(base_1.default);

exports.default = Dom;

/***/ }),
/* 872 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview ellipse
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Ellipse =
/** @class */
function (_super) {
  tslib_1.__extends(Ellipse, _super);

  function Ellipse() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'ellipse';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Ellipse.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      rx: 0,
      ry: 0
    });
  };

  Ellipse.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      //  x, y cx, cy
      if (attr === 'x' || attr === 'y') {
        el.setAttribute("c" + attr, value);
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Ellipse;
}(base_1.default);

exports.default = Ellipse;

/***/ }),
/* 873 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview image
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Image =
/** @class */
function (_super) {
  tslib_1.__extends(Image, _super);

  function Image() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'image';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  Image.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  };

  Image.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'img') {
        _this._setImage(attrs.img);
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Image.prototype.setAttr = function (name, value) {
    this.attrs[name] = value;

    if (name === 'img') {
      this._setImage(value);
    }
  };

  Image.prototype._setImage = function (img) {
    var attrs = this.attr();
    var el = this.get('el');

    if (util_1.isString(img)) {
      el.setAttribute('href', img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute('width', img.width);
        this.attr('width', img.width);
      }

      if (!attrs.height) {
        el.setAttribute('height', img.height);
        this.attr('height', img.height);
      }

      el.setAttribute('href', img.src);
    } else if (img instanceof HTMLElement && util_1.isString(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
      // @ts-ignore
      el.setAttribute('href', img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement('canvas');
      canvas.setAttribute('width', "" + img.width);
      canvas.setAttribute('height', "" + img.height);
      canvas.getContext('2d').putImageData(img, 0, 0);

      if (!attrs.width) {
        el.setAttribute('width', "" + img.width);
        this.attr('width', img.width);
      }

      if (!attrs.height) {
        el.setAttribute('height', "" + img.height);
        this.attr('height', img.height);
      }

      el.setAttribute('href', canvas.toDataURL());
    }
  };

  return Image;
}(base_1.default);

exports.default = Image;

/***/ }),
/* 874 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * @fileoverview line
 * @author dengfuping_develop@163.com
 */


var g_math_1 = __webpack_require__(35);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Line =
/** @class */
function (_super) {
  tslib_1.__extends(Line, _super);

  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'line';
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }

  Line.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      startArrow: false,
      endArrow: false
    });
  };

  Line.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'startArrow' || attr === 'endArrow') {
        if (value) {
          var id = util_1.isObject(value) ? context.addArrow(attrs, constant_1.SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, constant_1.SVG_ATTR_MAP[attr]);
          el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(constant_1.SVG_ATTR_MAP[attr]);
        }
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };
  /**
   * Use math calculation to get length of line
   * @return {number} length
   */


  Line.prototype.getTotalLength = function () {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return g_math_1.Line.length(x1, y1, x2, y2);
  };
  /**
   * Use math calculation to get point according to ratio as same sa Canvas version
   * @param {number} ratio
   * @return {Point} point
   */


  Line.prototype.getPoint = function (ratio) {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return g_math_1.Line.pointAt(x1, y1, x2, y2, ratio);
  };

  return Line;
}(base_1.default);

exports.default = Line;

/***/ }),
/* 875 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview marker
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(63);

var symbols_1 = __webpack_require__(876);

var Marker =
/** @class */
function (_super) {
  tslib_1.__extends(Marker, _super);

  function Marker() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'marker';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Marker.prototype.createPath = function (context) {
    var el = this.get('el');
    el.setAttribute('d', this._assembleMarker());
  };

  Marker.prototype._assembleMarker = function () {
    var d = this._getPath();

    if (util_1.isArray(d)) {
      return d.map(function (path) {
        return path.join(' ');
      }).join('');
    }

    return d;
  };

  Marker.prototype._getPath = function () {
    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y; //  r  radius  r

    var r = attrs.r || attrs.radius;
    var symbol = attrs.symbol || 'circle';
    var method;

    if (util_1.isFunction(symbol)) {
      method = symbol;
    } else {
      method = symbols_1.default.get(symbol);
    }

    if (!method) {
      console.warn(method + " symbol is not exist.");
      return null;
    }

    return method(x, y, r);
  }; // 


  Marker.symbolsFactory = symbols_1.default;
  return Marker;
}(base_1.default);

exports.default = Marker;

/***/ }),
/* 876 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var Symbols = {
  // 
  circle: function circle(x, y, r) {
    return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
  },
  // 
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  // 
  diamond: function diamond(x, y, r) {
    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
  },
  // 
  triangle: function triangle(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];
  },
  // 
  triangleDown: function triangleDown(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
  }
};
exports.default = {
  get: function get(type) {
    return Symbols[type];
  },
  register: function register(type, func) {
    Symbols[type] = func;
  },
  remove: function remove(type) {
    delete Symbols[type];
  },
  getAll: function getAll() {
    return Symbols;
  }
};

/***/ }),
/* 877 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Path =
/** @class */
function (_super) {
  tslib_1.__extends(Path, _super);

  function Path() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'path';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Path.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  Path.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'path' && util_1.isArray(value)) {
        el.setAttribute('d', _this._formatPath(value));
      } else if (attr === 'startArrow' || attr === 'endArrow') {
        if (value) {
          var id = util_1.isObject(value) ? context.addArrow(attrs, constant_1.SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, constant_1.SVG_ATTR_MAP[attr]);
          el.setAttribute(constant_1.SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(constant_1.SVG_ATTR_MAP[attr]);
        }
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Path.prototype._formatPath = function (value) {
    var newValue = value.map(function (path) {
      return path.join(' ');
    }).join('');

    if (~newValue.indexOf('NaN')) {
      return '';
    }

    return newValue;
  };
  /**
   * Get total length of path
   *  SVGPathElement.getTotalLength()  path 
   *  Canvas 
   * @return {number} length
   */


  Path.prototype.getTotalLength = function () {
    var el = this.get('el');
    return el ? el.getTotalLength() : null;
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Path.prototype.getPoint = function (ratio) {
    var el = this.get('el');
    var totalLength = this.getTotalLength(); // @see https://github.com/antvis/g/issues/634

    if (totalLength === 0) {
      return null;
    }

    var point = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point ? {
      x: point.x,
      y: point.y
    } : null;
  };

  return Path;
}(base_1.default);

exports.default = Path;

/***/ }),
/* 878 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);
/**
 * @fileoverview polygon
 * @author dengfuping_develop@163.com
 */


var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Polygon =
/** @class */
function (_super) {
  tslib_1.__extends(Polygon, _super);

  function Polygon() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'polygon';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Polygon.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'points' && util_1.isArray(value) && value.length >= 2) {
        el.setAttribute('points', value.map(function (point) {
          return point[0] + "," + point[1];
        }).join(' '));
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Polygon;
}(base_1.default);

exports.default = Polygon;

/***/ }),
/* 879 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_math_1 = __webpack_require__(35);

var g_math_2 = __webpack_require__(35);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var Polyline =
/** @class */
function (_super) {
  tslib_1.__extends(Polyline, _super);

  function Polyline() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'polyline';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Polyline.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  }; //  points


  Polyline.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (['points'].indexOf(name) !== -1) {
      this._resetCache();
    }
  };

  Polyline.prototype._resetCache = function () {
    this.set('totalLength', null);
    this.set('tCache', null);
  };

  Polyline.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'points' && util_1.isArray(value) && value.length >= 2) {
        el.setAttribute('points', value.map(function (point) {
          return point[0] + "," + point[1];
        }).join(' '));
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };
  /**
   * Get length of polyline
   * @return {number} length
   */


  Polyline.prototype.getTotalLength = function () {
    var points = this.attr().points; // get totalLength from cache

    var totalLength = this.get('totalLength');

    if (!util_1.isNil(totalLength)) {
      return totalLength;
    }

    this.set('totalLength', g_math_1.Polyline.length(points));
    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Polyline.prototype.getPoint = function (ratio) {
    var points = this.attr().points; // get tCache from cache

    var tCache = this.get('tCache');

    if (!tCache) {
      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    util_1.each(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return g_math_2.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };

  Polyline.prototype._setTcache = function () {
    var points = this.attr().points;

    if (!points || points.length === 0) {
      return;
    }

    var totalLength = this.getTotalLength();

    if (totalLength <= 0) {
      return;
    }

    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    util_1.each(points, function (p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = g_math_2.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  Polyline.prototype.getStartTangent = function () {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  Polyline.prototype.getEndTangent = function () {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };

  return Polyline;
}(base_1.default);

exports.default = Polyline;

/***/ }),
/* 880 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview rect
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(63);

var constant_1 = __webpack_require__(53);

var format_1 = __webpack_require__(881);

var Rect =
/** @class */
function (_super) {
  tslib_1.__extends(Rect, _super);

  function Rect() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'rect';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Rect.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0
    });
  };

  Rect.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el'); //  path 

    var completed = false; //  path 

    var pathRelatedAttrs = ['x', 'y', 'width', 'height', 'radius'];
    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute('d', _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Rect.prototype._assembleRect = function (attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    var radius = attrs.radius;

    if (!radius) {
      return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
    }

    var r = format_1.parseRadius(radius);

    if (util_1.isArray(radius)) {
      if (radius.length === 1) {
        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
      } else if (radius.length === 2) {
        r.r1 = r.r3 = radius[0];
        r.r2 = r.r4 = radius[1];
      } else if (radius.length === 3) {
        r.r1 = radius[0];
        r.r2 = r.r4 = radius[1];
        r.r3 = radius[2];
      } else {
        r.r1 = radius[0];
        r.r2 = radius[1];
        r.r3 = radius[2];
        r.r4 = radius[3];
      }
    } else {
      r.r1 = r.r2 = r.r3 = r.r4 = radius;
    }

    var d = [["M " + (x + r.r1) + "," + y], ["l " + (w - r.r1 - r.r2) + ",0"], ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2], ["l 0," + (h - r.r2 - r.r3)], ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3], ["l " + (r.r3 + r.r4 - w) + ",0"], ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4], ["l 0," + (r.r4 + r.r1 - h)], ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1], ['z']];
    return d.join(' ');
  };

  return Rect;
}(base_1.default);

exports.default = Rect;

/***/ }),
/* 881 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parsePath = exports.parseRadius = void 0;

var util_1 = __webpack_require__(0);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
var regexDot = /[^\s,]+/gi;

function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;

  if (util_1.isArray(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }

  return {
    r1: r1,
    r2: r2,
    r3: r3,
    r4: r4
  };
}

exports.parseRadius = parseRadius;

function parsePath(path) {
  path = path || [];

  if (util_1.isArray(path)) {
    return path;
  }

  if (util_1.isString(path)) {
    path = path.match(regexTags);
    util_1.each(path, function (item, index) {
      item = item.match(regexDot);

      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }

      util_1.each(item, function (sub, i) {
        if (!isNaN(sub)) {
          item[i] = +sub;
        }
      });
      path[index] = item;
    });
    return path;
  }
}

exports.parsePath = parsePath;

/***/ }),
/* 882 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview text
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var detect_browser_1 = __webpack_require__(239);

var svg_1 = __webpack_require__(144);

var constant_1 = __webpack_require__(53);

var base_1 = __webpack_require__(63);

var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: 'before-edge',
  middle: 'central',
  bottom: 'after-edge',
  alphabetic: 'baseline',
  hanging: 'hanging'
}; // for FireFox

var BASELINE_MAP_FOR_FIREFOX = {
  top: 'text-before-edge',
  middle: 'central',
  bottom: 'text-after-edge',
  alphabetic: 'alphabetic',
  hanging: 'hanging'
};
var ANCHOR_MAP = {
  left: 'left',
  start: 'left',
  center: 'middle',
  right: 'end',
  end: 'end'
};

var Text =
/** @class */
function (_super) {
  tslib_1.__extends(Text, _super);

  function Text() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'text';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Text.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return tslib_1.__assign(tslib_1.__assign({}, attrs), {
      x: 0,
      y: 0,
      text: null,
      fontSize: 12,
      fontFamily: 'sans-serif',
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontVariant: 'normal',
      textAlign: 'start',
      textBaseline: 'bottom'
    });
  };

  Text.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');

    this._setFont();

    util_1.each(targetAttrs || attrs, function (value, attr) {
      if (attr === 'text') {
        _this._setText("" + value);
      } else if (attr === 'matrix' && value) {
        svg_1.setTransform(_this);
      } else if (constant_1.SVG_ATTR_MAP[attr]) {
        el.setAttribute(constant_1.SVG_ATTR_MAP[attr], value);
      }
    });
    el.setAttribute('paint-order', 'stroke');
    el.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');
  };

  Text.prototype._setFont = function () {
    var el = this.get('el');

    var _a = this.attr(),
        textBaseline = _a.textBaseline,
        textAlign = _a.textAlign;

    var browser = detect_browser_1.detect();

    if (browser && browser.name === 'firefox') {
      // compatible with FireFox browser, ref: https://github.com/antvis/g/issues/119
      el.setAttribute('dominant-baseline', BASELINE_MAP_FOR_FIREFOX[textBaseline] || 'alphabetic');
    } else {
      el.setAttribute('alignment-baseline', BASELINE_MAP[textBaseline] || 'baseline');
    }

    el.setAttribute('text-anchor', ANCHOR_MAP[textAlign] || 'left');
  };

  Text.prototype._setText = function (text) {
    var el = this.get('el');

    var _a = this.attr(),
        x = _a.x,
        _b = _a.textBaseline,
        baseline = _b === void 0 ? 'bottom' : _b;

    if (!text) {
      el.innerHTML = '';
    } else if (~text.indexOf('\n')) {
      var textArr = text.split('\n');
      var textLen_1 = textArr.length - 1;
      var arr_1 = '';
      util_1.each(textArr, function (segment, i) {
        if (i === 0) {
          if (baseline === 'alphabetic') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -textLen_1 + "em\">" + segment + "</tspan>";
          } else if (baseline === 'top') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"0.9em\">" + segment + "</tspan>";
          } else if (baseline === 'middle') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -(textLen_1 - 1) / 2 + "em\">" + segment + "</tspan>";
          } else if (baseline === 'bottom') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"-" + (textLen_1 + LETTER_SPACING) + "em\">" + segment + "</tspan>";
          } else if (baseline === 'hanging') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + (-(textLen_1 - 1) - LETTER_SPACING) + "em\">" + segment + "</tspan>";
          }
        } else {
          arr_1 += "<tspan x=\"" + x + "\" dy=\"1em\">" + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text;
    }
  };

  return Text;
}(base_1.default);

exports.default = Text;

/***/ }),
/* 883 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g_base_1 = __webpack_require__(27);

var constant_1 = __webpack_require__(53);

var draw_1 = __webpack_require__(259);

var svg_1 = __webpack_require__(144);

var dom_1 = __webpack_require__(70);

var Shape = __webpack_require__(189);

var group_1 = __webpack_require__(260);

var defs_1 = __webpack_require__(884);

var Canvas =
/** @class */
function (_super) {
  tslib_1.__extends(Canvas, _super);

  function Canvas(cfg) {
    return _super.call(this, tslib_1.__assign(tslib_1.__assign({}, cfg), {
      autoDraw: true,
      //  canvas
      renderer: 'svg'
    })) || this;
  }

  Canvas.prototype.getShapeBase = function () {
    return Shape;
  };

  Canvas.prototype.getGroupBase = function () {
    return group_1.default;
  }; //  Container  shape  SVG  dom 


  Canvas.prototype.getShape = function (x, y, ev) {
    var target = ev.target || ev.srcElement;

    if (!constant_1.SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;

      while (parent_1 && !constant_1.SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }

      target = parent_1;
    }

    return this.find(function (child) {
      return child.get('el') === target;
    });
  }; // 


  Canvas.prototype.createDom = function () {
    var element = dom_1.createSVGElement('svg');
    var context = new defs_1.default(element);
    element.setAttribute('width', "" + this.get('width'));
    element.setAttribute('height', "" + this.get('height')); //  context 

    this.set('context', context);
    return element;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Canvas.prototype.onCanvasChange = function (changeType) {
    var context = this.get('context');
    var el = this.get('el');

    if (changeType === 'sort') {
      var children_1 = this.get('children');

      if (children_1 && children_1.length) {
        dom_1.sortDom(this, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      // el maybe null for canvas
      if (el) {
        //  SVG 
        el.innerHTML = '';
        var defsEl = context.el; //  defs 

        defsEl.innerHTML = ''; //  defs  el 

        el.appendChild(defsEl);
      }
    } else if (changeType === 'matrix') {
      svg_1.setTransform(this);
    } else if (changeType === 'clip') {
      svg_1.setClip(this, context);
    } else if (changeType === 'changeSize') {
      el.setAttribute('width', "" + this.get('width'));
      el.setAttribute('height', "" + this.get('height'));
    }
  }; //  draw 


  Canvas.prototype.draw = function () {
    var context = this.get('context');
    var children = this.getChildren();
    svg_1.setClip(this, context);

    if (children.length) {
      draw_1.drawChildren(context, children);
    }
  };

  return Canvas;
}(g_base_1.AbstractCanvas);

exports.default = Canvas;

/***/ }),
/* 884 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview defs
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var gradient_1 = __webpack_require__(885);

var shadow_1 = __webpack_require__(886);

var arrow_1 = __webpack_require__(887);

var clip_1 = __webpack_require__(888);

var pattern_1 = __webpack_require__(889);

var dom_1 = __webpack_require__(70);

var Defs =
/** @class */
function () {
  function Defs(canvas) {
    var el = dom_1.createSVGElement('defs');
    var id = util_1.uniqueId('defs_');
    el.id = id;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }

  Defs.prototype.find = function (type, attr) {
    var children = this.children;
    var result = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].match(type, attr)) {
        result = children[i].id;
        break;
      }
    }

    return result;
  };

  Defs.prototype.findById = function (id) {
    var children = this.children;
    var flag = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].id === id) {
        flag = children[i];
        break;
      }
    }

    return flag;
  };

  Defs.prototype.add = function (item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };

  Defs.prototype.getDefaultArrow = function (attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;

    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }

    var arrow = new arrow_1.default(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };

  Defs.prototype.addGradient = function (cfg) {
    var gradient = new gradient_1.default(cfg);
    this.el.appendChild(gradient.el);
    this.add(gradient);
    return gradient.id;
  };

  Defs.prototype.addArrow = function (attrs, name) {
    var arrow = new arrow_1.default(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };

  Defs.prototype.addShadow = function (cfg) {
    var shadow = new shadow_1.default(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };

  Defs.prototype.addPattern = function (cfg) {
    var pattern = new pattern_1.default(cfg);
    this.el.appendChild(pattern.el);
    this.add(pattern);
    return pattern.id;
  };

  Defs.prototype.addClip = function (cfg) {
    var clip = new clip_1.default(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };

  return Defs;
}();

exports.default = Defs;

/***/ }),
/* 885 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview gradient
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var dom_1 = __webpack_require__(70);

var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;

function addStop(steps) {
  var arr = steps.match(regexColorStop);

  if (!arr) {
    return '';
  }

  var stops = '';
  arr.sort(function (a, b) {
    a = a.split(':');
    b = b.split(':');
    return Number(a[0]) - Number(b[0]);
  });
  util_1.each(arr, function (item) {
    item = item.split(':');
    stops += "<stop offset=\"" + item[0] + "\" stop-color=\"" + item[1] + "\"></stop>";
  });
  return stops;
}

function parseLineGradient(color, el) {
  var arr = regexLG.exec(color);
  var angle = util_1.mod(util_1.toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;

  if (angle >= 0 && angle < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute('x1', start.x);
  el.setAttribute('y1', start.y);
  el.setAttribute('x2', x);
  el.setAttribute('y2', y);
  el.innerHTML = addStop(steps);
}

function parseRadialGradient(color, self) {
  var arr = regexRG.exec(color);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self.setAttribute('cx', cx);
  self.setAttribute('cy', cy);
  self.setAttribute('r', r);
  self.innerHTML = addStop(steps);
}

var Gradient =
/** @class */
function () {
  function Gradient(cfg) {
    this.cfg = {};
    var el = null;
    var id = util_1.uniqueId('gradient_');

    if (cfg.toLowerCase()[0] === 'l') {
      el = dom_1.createSVGElement('linearGradient');
      parseLineGradient(cfg, el);
    } else {
      el = dom_1.createSVGElement('radialGradient');
      parseRadialGradient(cfg, el);
    }

    el.setAttribute('id', id);
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    return this;
  }

  Gradient.prototype.match = function (type, attr) {
    return this.cfg === attr;
  };

  return Gradient;
}();

exports.default = Gradient;

/***/ }),
/* 886 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview shadow
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var dom_1 = __webpack_require__(70);

var ATTR_MAP = {
  shadowColor: 'color',
  shadowOpacity: 'opacity',
  shadowBlur: 'blur',
  shadowOffsetX: 'dx',
  shadowOffsetY: 'dy'
};
var SHADOW_DIMENSION = {
  x: '-40%',
  y: '-40%',
  width: '200%',
  height: '200%'
};

var Shadow =
/** @class */
function () {
  function Shadow(cfg) {
    this.type = 'filter';
    this.cfg = {};
    this.type = 'filter';
    var el = dom_1.createSVGElement('filter'); // expand the filter region to fill in shadows

    util_1.each(SHADOW_DIMENSION, function (v, k) {
      el.setAttribute(k, v);
    });
    this.el = el;
    this.id = util_1.uniqueId('filter_');
    this.el.id = this.id;
    this.cfg = cfg;

    this._parseShadow(cfg, el);

    return this;
  }

  Shadow.prototype.match = function (type, cfg) {
    if (this.type !== type) {
      return false;
    }

    var flag = true;
    var config = this.cfg;
    util_1.each(Object.keys(config), function (attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };

  Shadow.prototype.update = function (name, value) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value;

    this._parseShadow(config, this.el);

    return this;
  };

  Shadow.prototype._parseShadow = function (config, el) {
    var child = "<feDropShadow\n      dx=\"" + (config.dx || 0) + "\"\n      dy=\"" + (config.dy || 0) + "\"\n      stdDeviation=\"" + (config.blur ? config.blur / 10 : 0) + "\"\n      flood-color=\"" + (config.color ? config.color : '#000') + "\"\n      flood-opacity=\"" + (config.opacity ? config.opacity : 1) + "\"\n      />";
    el.innerHTML = child;
  };

  return Shadow;
}();

exports.default = Shadow;

/***/ }),
/* 887 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview arrow
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var dom_1 = __webpack_require__(70);

var Arrow =
/** @class */
function () {
  function Arrow(attrs, type) {
    this.cfg = {};
    var el = dom_1.createSVGElement('marker');
    var id = util_1.uniqueId('marker_');
    el.setAttribute('id', id);
    var shape = dom_1.createSVGElement('path');
    shape.setAttribute('stroke', attrs.stroke || 'none');
    shape.setAttribute('fill', attrs.fill || 'none');
    el.appendChild(shape);
    el.setAttribute('overflow', 'visible');
    el.setAttribute('orient', 'auto-start-reverse');
    this.el = el;
    this.child = shape;
    this.id = id;
    var cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];
    this.stroke = attrs.stroke || '#000';

    if (cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this.cfg = cfg; // when arrow config exists

      this._setMarker(attrs.lineWidth, shape);
    }

    return this;
  }

  Arrow.prototype.match = function () {
    return false;
  };

  Arrow.prototype._setDefaultPath = function (type, el) {
    var parent = this.el; //  10 60 

    el.setAttribute('d', "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute('refX', "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute('refY', "" + 5);
  };

  Arrow.prototype._setMarker = function (r, el) {
    var parent = this.el;
    var path = this.cfg.path;
    var d = this.cfg.d;

    if (util_1.isArray(path)) {
      path = path.map(function (segment) {
        return segment.join(' ');
      }).join('');
    }

    el.setAttribute('d', path);
    parent.appendChild(el);

    if (d) {
      parent.setAttribute('refX', "" + d / r);
    }
  };

  Arrow.prototype.update = function (fill) {
    var child = this.child;

    if (child.attr) {
      child.attr('fill', fill);
    } else {
      child.setAttribute('fill', fill);
    }
  };

  return Arrow;
}();

exports.default = Arrow;

/***/ }),
/* 888 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview clip
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var dom_1 = __webpack_require__(70);

var Clip =
/** @class */
function () {
  function Clip(cfg) {
    this.type = 'clip';
    this.cfg = {};
    var el = dom_1.createSVGElement('clipPath');
    this.el = el;
    this.id = util_1.uniqueId('clip_');
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }

  Clip.prototype.match = function () {
    return false;
  };

  Clip.prototype.remove = function () {
    var el = this.el;
    el.parentNode.removeChild(el);
  };

  return Clip;
}();

exports.default = Clip;

/***/ }),
/* 889 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @fileoverview pattern
 * @author dengfuping_develop@163.com
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var dom_1 = __webpack_require__(70);

var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;

var Pattern =
/** @class */
function () {
  function Pattern(cfg) {
    this.cfg = {};
    var el = dom_1.createSVGElement('pattern');
    el.setAttribute('patternUnits', 'userSpaceOnUse');
    var child = dom_1.createSVGElement('image');
    el.appendChild(child);
    var id = util_1.uniqueId('pattern_');
    el.id = id;
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    var arr = regexPR.exec(cfg);
    var source = arr[2];
    child.setAttribute('href', source);
    var img = new Image();

    if (!source.match(/^data:/i)) {
      img.crossOrigin = 'Anonymous';
    }

    img.src = source;

    function onload() {
      el.setAttribute('width', "" + img.width);
      el.setAttribute('height', "" + img.height);
    }

    if (img.complete) {
      onload();
    } else {
      img.onload = onload; // Fix onload() bug in IE9

      img.src = img.src;
    }

    return this;
  }

  Pattern.prototype.match = function (type, attr) {
    return this.cfg === attr;
  };

  return Pattern;
}();

exports.default = Pattern;

/***/ }),
/* 890 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var engine_1 = __webpack_require__(431);

var dom_1 = __webpack_require__(309);

var view_1 = tslib_1.__importDefault(__webpack_require__(432));
/**
 * Chart  G2 
 */


var Chart =
/** @class */
function (_super) {
  tslib_1.__extends(Chart, _super); // @ts-ignore


  function Chart(props) {
    var _this = this;

    var container = props.container,
        width = props.width,
        height = props.height,
        _a = props.autoFit,
        autoFit = _a === void 0 ? false : _a,
        padding = props.padding,
        appendPadding = props.appendPadding,
        _b = props.renderer,
        renderer = _b === void 0 ? 'canvas' : _b,
        pixelRatio = props.pixelRatio,
        _c = props.localRefresh,
        localRefresh = _c === void 0 ? true : _c,
        _d = props.visible,
        visible = _d === void 0 ? true : _d,
        _e = props.supportCSSTransform,
        supportCSSTransform = _e === void 0 ? false : _e,
        _f = props.defaultInteractions,
        defaultInteractions = _f === void 0 ? ['tooltip', 'legend-filter', 'legend-active', 'continuous-filter', 'ellipsis-text'] : _f,
        options = props.options,
        limitInPlot = props.limitInPlot,
        theme = props.theme,
        syncViewPadding = props.syncViewPadding;
    var ele = util_1.isString(container) ? document.getElementById(container) : container; //  div 

    var wrapperElement = dom_1.createDom('<div style="position:relative;"></div>');
    ele.appendChild(wrapperElement); // if autoFit, use the container size, to avoid the graph render twice.

    var size = dom_1.getChartSize(ele, autoFit, width, height);
    var G = engine_1.getEngine(renderer);
    var canvas = new G.Canvas(tslib_1.__assign({
      container: wrapperElement,
      pixelRatio: pixelRatio,
      localRefresh: localRefresh,
      supportCSSTransform: supportCSSTransform
    }, size)); //  view 

    _this = _super.call(this, {
      parent: null,
      canvas: canvas,
      // create 3 group layers for views.
      backgroundGroup: canvas.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.BG
      }),
      middleGroup: canvas.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.MID
      }),
      foregroundGroup: canvas.addGroup({
        zIndex: constant_1.GROUP_Z_INDEX.FORE
      }),
      padding: padding,
      appendPadding: appendPadding,
      visible: visible,
      options: options,
      limitInPlot: limitInPlot,
      theme: theme,
      syncViewPadding: syncViewPadding
    }) || this;
    /**
     * when container size changed, change chart size props, and re-render.
     */

    _this.onResize = util_1.debounce(function () {
      _this.forceFit();
    }, 300);
    _this.ele = ele;
    _this.canvas = canvas;
    _this.width = size.width;
    _this.height = size.height;
    _this.autoFit = autoFit;
    _this.localRefresh = localRefresh;
    _this.renderer = renderer;
    _this.wrapperElement = wrapperElement; // 

    _this.updateCanvasStyle();

    _this.bindAutoFit();

    _this.initDefaultInteractions(defaultInteractions);

    return _this;
  }

  Chart.prototype.initDefaultInteractions = function (interactions) {
    var _this = this;

    util_1.each(interactions, function (interaction) {
      _this.interaction(interaction);
    });
  };
  /**
   * 
   * @param width 
   * @param height 
   * @returns
   */


  Chart.prototype.changeSize = function (width, height) {
    //  changeSize 
    if (this.width === width && this.height === height) {
      return this;
    }

    this.emit(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
    this.width = width;
    this.height = height;
    this.canvas.changeSize(width, height); // 

    this.render(true);
    this.emit(constant_1.VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
    return this;
  };
  /**
   *  G.Canvas 
   * @returns void
   */


  Chart.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.unbindAutoFit();
    this.canvas.destroy();
    dom_1.removeDom(this.wrapperElement);
    this.wrapperElement = null;
  };
  /**
   * 
   * @param visible true false 
   * @returns
   */


  Chart.prototype.changeVisible = function (visible) {
    _super.prototype.changeVisible.call(this, visible); //  visible 


    this.wrapperElement.style.display = visible ? '' : 'none';
    return this;
  };
  /**
   *  resize 
   */


  Chart.prototype.forceFit = function () {
    // skip if already destroyed
    if (!this.destroyed) {
      //  true autoFit = falseforceFit() 
      var _a = dom_1.getChartSize(this.ele, true, this.width, this.height),
          width = _a.width,
          height = _a.height;

      this.changeSize(width, height);
    }
  };

  Chart.prototype.updateCanvasStyle = function () {
    dom_1.modifyCSS(this.canvas.get('el'), {
      display: 'inline-block',
      verticalAlign: 'middle'
    });
  };

  Chart.prototype.bindAutoFit = function () {
    if (this.autoFit) {
      window.addEventListener('resize', this.onResize);
    }
  };

  Chart.prototype.unbindAutoFit = function () {
    if (this.autoFit) {
      window.removeEventListener('resize', this.onResize);
    }
  };

  return Chart;
}(view_1.default);

exports.default = Chart;

/***/ }),
/* 891 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var register_1 = __webpack_require__(202);

var context_1 = tslib_1.__importDefault(__webpack_require__(893));

var interaction_1 = tslib_1.__importDefault(__webpack_require__(433)); //  action


function parseAction(actionStr, context) {
  var arr = actionStr.split(':');
  var actionName = arr[0]; //  action  action

  var action = context.getAction(actionName) || register_1.createAction(actionName, context);

  if (!action) {
    throw new Error("There is no action named " + actionName);
  }

  var methodName = arr[1];
  return {
    action: action,
    methodName: methodName
  };
} //  Action


function executeAction(actionObject) {
  var action = actionObject.action,
      methodName = actionObject.methodName;

  if (action[methodName]) {
    action[methodName]();
  } else {
    throw new Error("Action(" + action.name + ") doesn't have a method called " + methodName);
  }
}

var STEP_NAMES = {
  START: 'start',
  SHOW_ENABLE: 'showEnable',
  END: 'end',
  ROLLBACK: 'rollback',
  PROCESSING: 'processing'
};
/**
 * 
 */

var GrammarInteraction =
/** @class */
function (_super) {
  tslib_1.__extends(GrammarInteraction, _super);

  function GrammarInteraction(view, steps) {
    var _this = _super.call(this, view, steps) || this;

    _this.callbackCaches = {}; // 

    _this.emitCaches = {};
    _this.steps = steps;
    return _this;
  }
  /**
   * 
   */


  GrammarInteraction.prototype.init = function () {
    this.initContext();

    _super.prototype.init.call(this);
  };
  /**
   * 
   */


  GrammarInteraction.prototype.destroy = function () {
    _super.prototype.destroy.call(this); // 


    this.steps = null;

    if (this.context) {
      this.context.destroy();
      this.context = null;
    }

    this.callbackCaches = null;
    this.view = null;
  };
  /**
   * 
   */


  GrammarInteraction.prototype.initEvents = function () {
    var _this = this;

    util_1.each(this.steps, function (stepArr, stepName) {
      util_1.each(stepArr, function (step) {
        var callback = _this.getActionCallback(stepName, step);

        if (callback) {
          //  callback callback 
          _this.bindEvent(step.trigger, callback);
        }
      });
    });
  };
  /**
   * 
   */


  GrammarInteraction.prototype.clearEvents = function () {
    var _this = this;

    util_1.each(this.steps, function (stepArr, stepName) {
      util_1.each(stepArr, function (step) {
        var callback = _this.getActionCallback(stepName, step);

        if (callback) {
          _this.offEvent(step.trigger, callback);
        }
      });
    });
  }; //  action


  GrammarInteraction.prototype.initContext = function () {
    var view = this.view;
    var context = new context_1.default(view);
    this.context = context;
    var steps = this.steps; //  Action

    util_1.each(steps, function (subSteps) {
      util_1.each(subSteps, function (step) {
        if (util_1.isFunction(step.action)) {
          //  CallbackAction
          step.actionObject = {
            action: register_1.createCallbackAction(step.action, context),
            methodName: 'execute'
          };
        } else if (util_1.isString(step.action)) {
          // 
          step.actionObject = parseAction(step.action, context);
        } else if (util_1.isArray(step.action)) {
          // 
          var actionArr = step.action;
          step.actionObject = [];
          util_1.each(actionArr, function (actionStr) {
            step.actionObject.push(parseAction(actionStr, context));
          });
        } //  action  actionObject

      });
    });
  }; // 


  GrammarInteraction.prototype.isAllowStep = function (stepName) {
    var currentStepName = this.currentStepName;
    var steps = this.steps; // 

    if (currentStepName === stepName) {
      return true;
    }

    if (stepName === STEP_NAMES.SHOW_ENABLE) {
      // 
      return true;
    }

    if (stepName === STEP_NAMES.PROCESSING) {
      //  start  processing
      return currentStepName === STEP_NAMES.START;
    }

    if (stepName === STEP_NAMES.START) {
      //  processing start end 
      return currentStepName !== STEP_NAMES.PROCESSING;
    }

    if (stepName === STEP_NAMES.END) {
      return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
    }

    if (stepName === STEP_NAMES.ROLLBACK) {
      if (steps[STEP_NAMES.END]) {
        //  end,  end 
        return currentStepName === STEP_NAMES.END;
      } else if (currentStepName === STEP_NAMES.START) {
        //  end, 
        return true;
      }
    }

    return false;
  }; // 


  GrammarInteraction.prototype.isAllowExecute = function (stepName, step) {
    if (this.isAllowStep(stepName)) {
      var key = this.getKey(stepName, step); // 

      if (step.once && this.emitCaches[key]) {
        return false;
      } //  isEnable 


      if (step.isEnable) {
        return step.isEnable(this.context);
      }

      return true; //  isEnable 
    }

    return false;
  };

  GrammarInteraction.prototype.enterStep = function (stepName) {
    this.currentStepName = stepName;
    this.emitCaches = {}; // 
  }; // 


  GrammarInteraction.prototype.afterExecute = function (stepName, step) {
    // show enable  step
    if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
      this.enterStep(stepName);
    }

    var key = this.getKey(stepName, step); // 

    this.emitCaches[key] = true;
  }; // 


  GrammarInteraction.prototype.getKey = function (stepName, step) {
    return stepName + step.trigger + step.action;
  }; //  step 


  GrammarInteraction.prototype.getActionCallback = function (stepName, step) {
    var _this = this;

    var context = this.context;
    var callbackCaches = this.callbackCaches;
    var actionObject = step.actionObject;

    if (step.action && actionObject) {
      var key = this.getKey(stepName, step);

      if (!callbackCaches[key]) {
        //  action 
        var actionCallback = function actionCallback(event) {
          context.event = event; //  event

          if (_this.isAllowExecute(stepName, step)) {
            // 
            if (util_1.isArray(actionObject)) {
              util_1.each(actionObject, function (obj) {
                context.event = event; //  context.event 

                executeAction(obj);
              });
            } else {
              context.event = event; //  context.event 

              executeAction(actionObject);
            }

            _this.afterExecute(stepName, step);

            if (step.callback) {
              context.event = event; //  context.event 

              step.callback(context);
            }
          } else {
            // 
            context.event = null;
          }
        }; //  debounce


        if (step.debounce) {
          callbackCaches[key] = util_1.debounce(actionCallback, step.debounce.wait, step.debounce.immediate);
        } else if (step.throttle) {
          //  throttle
          callbackCaches[key] = util_1.throttle(actionCallback, step.throttle.wait, {
            leading: step.throttle.leading,
            trailing: step.throttle.trailing
          });
        } else {
          // 
          callbackCaches[key] = actionCallback;
        }
      }

      return callbackCaches[key];
    }

    return null;
  };

  GrammarInteraction.prototype.bindEvent = function (eventName, callback) {
    var nameArr = eventName.split(':');

    if (nameArr[0] === 'window') {
      window.addEventListener(nameArr[1], callback);
    } else if (nameArr[0] === 'document') {
      document.addEventListener(nameArr[1], callback);
    } else {
      this.view.on(eventName, callback);
    }
  };

  GrammarInteraction.prototype.offEvent = function (eventName, callback) {
    var nameArr = eventName.split(':');

    if (nameArr[0] === 'window') {
      window.removeEventListener(nameArr[1], callback);
    } else if (nameArr[0] === 'document') {
      document.removeEventListener(nameArr[1], callback);
    } else {
      this.view.off(eventName, callback);
    }
  };

  return GrammarInteraction;
}(interaction_1.default);

exports.default = GrammarInteraction;

/***/ }),
/* 892 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));
/**  Action */


var CallbackAction =
/** @class */
function (_super) {
  tslib_1.__extends(CallbackAction, _super);

  function CallbackAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   */


  CallbackAction.prototype.execute = function () {
    if (this.callback) {
      this.callback(this.context);
    }
  };
  /**
   * 
   */


  CallbackAction.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.callback = null;
  };

  return CallbackAction;
}(base_1.default);

exports.default = CallbackAction;

/***/ }),
/* 893 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);
/**
 * 
 */


var Context =
/** @class */
function () {
  function Context(view) {
    /**  Action */
    this.actions = [];
    /**  */

    this.event = null;
    this.cacheMap = {};
    this.view = view;
  }
  /**
   * 
   * @param params 
   *  - 
   *  - 
   */


  Context.prototype.cache = function () {
    var params = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }

    if (params.length === 1) {
      return this.cacheMap[params[0]];
    } else if (params.length === 2) {
      this.cacheMap[params[0]] = params[1];
    }
  };
  /**
   *  Action
   * @param name Action 
   */


  Context.prototype.getAction = function (name) {
    return this.actions.find(function (action) {
      return action.name === name;
    });
  };
  /**
   *  Action
   * @param action Action 
   */


  Context.prototype.addAction = function (action) {
    this.actions.push(action);
  };
  /**
   *  Action
   * @param action Action 
   */


  Context.prototype.removeAction = function (action) {
    var actions = this.actions;
    var index = this.actions.indexOf(action);

    if (index >= 0) {
      actions.splice(index, 1);
    }
  };
  /**
   * 
   */


  Context.prototype.getCurrentPoint = function () {
    var event = this.event;

    if (event) {
      if (event.target instanceof HTMLElement) {
        var canvas = this.view.getCanvas();
        var point = canvas.getPointByClient(event.clientX, event.clientY);
        return point;
      } else {
        return {
          x: event.x,
          y: event.y
        };
      }
    }

    return null;
  };
  /**
   *  shape
   * @returns current shape
   */


  Context.prototype.getCurrentShape = function () {
    return util_1.get(this.event, ['gEvent', 'shape']);
  };
  /**
   *  View 
   */


  Context.prototype.isInPlot = function () {
    var point = this.getCurrentPoint();

    if (point) {
      return this.view.isPointInPlot(point);
    }

    return false;
  };
  /**
   * 
   * @param name shape  name
   */


  Context.prototype.isInShape = function (name) {
    var shape = this.getCurrentShape(); //  shape  parent 

    if (shape) {
      return shape.get('name') === name;
    }

    return false;
  };
  /**
   * 
   * @param name 
   */


  Context.prototype.isInComponent = function (name) {
    var components = util_2.getComponents(this.view);
    var point = this.getCurrentPoint();

    if (point) {
      return !!components.find(function (component) {
        var bbox = component.getBBox();

        if (name) {
          return component.get('name') === name && util_2.isInBox(bbox, point);
        } else {
          return util_2.isInBox(bbox, point);
        }
      });
    }

    return false;
  };
  /**
   * 
   */


  Context.prototype.destroy = function () {
    this.view = null;
    this.event = null; //  action 

    util_1.each(this.actions.slice(), function (action) {
      action.destroy();
    });
    this.actions = null;
    this.cacheMap = null;
  };

  return Context;
}();

exports.default = Context;

/***/ }),
/* 894 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTheme = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var create_by_style_sheet_1 = __webpack_require__(109);

var light_1 = __webpack_require__(131);

function createTheme(themeCfg) {
  var _a = themeCfg.styleSheet,
      styleSheetCfg = _a === void 0 ? {} : _a,
      themeObject = tslib_1.__rest(themeCfg, ["styleSheet"]); //   ( light )


  var styleSheet = light_1.createLightStyleSheet(styleSheetCfg); //  

  return util_1.deepMix({}, create_by_style_sheet_1.createThemeByStyleSheet(styleSheet), themeObject);
}

exports.createTheme = createTheme;

/***/ }),
/* 895 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var dependents_1 = __webpack_require__(68);
/**
 * coordinate controller
 * 1. 
 * 2. 
 */


var CoordinateController =
/** @class */
function () {
  function CoordinateController(option) {
    // 
    this.option = this.wrapperOption(option);
  }
  /**
   * 
   * @param option
   */


  CoordinateController.prototype.update = function (option) {
    this.option = this.wrapperOption(option);
    return this;
  };
  /**
   *  action
   * @param actionName
   */


  CoordinateController.prototype.hasAction = function (actionName) {
    var actions = this.option.actions;
    return util_1.some(actions, function (action) {
      return action[0] === actionName;
    });
  };
  /**
   * 
   * @param start 
   * @param end   
   * @return 
   */


  CoordinateController.prototype.create = function (start, end) {
    var _a = this.option,
        type = _a.type,
        cfg = _a.cfg;
    var isTheta = type === 'theta'; // 1. 

    var props = tslib_1.__assign({
      start: start,
      end: end
    }, cfg); // 2. 


    var C = dependents_1.getCoordinate(isTheta ? 'polar' : type);
    this.coordinate = new C(props); // @ts-ignore FIXME coordinate  type 

    this.coordinate.type = type; // 3.  action

    if (isTheta) {
      //  transpose action
      if (!this.hasAction('transpose')) {
        this.transpose();
      }
    } // 4.  action


    this.execActions();
    return this.coordinate;
  };
  /**
   * 
   * @param start 
   * @param end   
   * @return 
   */


  CoordinateController.prototype.adjust = function (start, end) {
    this.coordinate.update({
      start: start,
      end: end
    }); // 
    // 1.  matrix
    // 2.  matrix  action

    this.coordinate.resetMatrix();
    this.execActions(['scale', 'rotate', 'translate']);
    return this.coordinate;
  };
  /**
   * 
   * @param angle
   */


  CoordinateController.prototype.rotate = function (angle) {
    this.option.actions.push(['rotate', angle]);
    return this;
  };
  /**
   * 
   * @param dim
   */


  CoordinateController.prototype.reflect = function (dim) {
    this.option.actions.push(['reflect', dim]);
    return this;
  };
  /**
   * scale
   * @param sx
   * @param sy
   */


  CoordinateController.prototype.scale = function (sx, sy) {
    this.option.actions.push(['scale', sx, sy]);
    return this;
  };
  /**
   * 
   */


  CoordinateController.prototype.transpose = function () {
    this.option.actions.push(['transpose']);
    return this;
  };
  /**
   * 
   */


  CoordinateController.prototype.getOption = function () {
    return this.option;
  };
  /**
   *  coordinate 
   */


  CoordinateController.prototype.getCoordinate = function () {
    return this.coordinate;
  };
  /**
   * 
   * @param option
   */


  CoordinateController.prototype.wrapperOption = function (option) {
    return tslib_1.__assign({
      type: 'rect',
      actions: [],
      cfg: {}
    }, option);
  };
  /**
   * coordinate  actions
   * @params includeActions  action
   */


  CoordinateController.prototype.execActions = function (includeActions) {
    var _this = this;

    var actions = this.option.actions;
    util_1.each(actions, function (action) {
      var _a;

      var actionName = action[0],
          args = action.slice(1);
      var shouldExec = util_1.isNil(includeActions) ? true : includeActions.includes(actionName);

      if (shouldExec) {
        (_a = _this.coordinate)[actionName].apply(_a, args);
      }
    });
  };

  return CoordinateController;
}();

exports.default = CoordinateController;

/***/ }),
/* 896 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @ignore
 * G2  layout 
 * 
 *
 * 1.  padding = 'auto' direction  padding 
 * 2.  padding  direction  padding 
 * 3. 
 *
 *  12  view 
 * @param view
 */

function defaultLayout(view) {
  var axis = view.getController('axis');
  var legend = view.getController('legend');
  var annotation = view.getController('annotation');
  var slider = view.getController('slider');
  var scrollbar = view.getController('scrollbar'); //  coordinate 

  [axis, slider, scrollbar, legend, annotation].forEach(function (controller) {
    if (controller) {
      controller.layout();
    }
  });
}

exports.default = defaultLayout;

/***/ }),
/* 897 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScalePool = void 0;
/**
 * view  scale 
 */

var util_1 = __webpack_require__(0);

var scale_1 = __webpack_require__(145);
/** @ignore */


var ScalePool =
/** @class */
function () {
  function ScalePool() {
    /**  scales */
    this.scales = new Map();
    /**  scale  key: scaleKeyArray */

    this.syncScales = new Map();
  }
  /**
   *  scale
   * @param field
   * @param data
   * @param scaleDef
   * @param key
   */


  ScalePool.prototype.createScale = function (field, data, scaleDef, key) {
    var finalScaleDef = scaleDef;
    var cacheScaleMeta = this.getScaleMeta(key);

    if (data.length === 0 && cacheScaleMeta) {
      //  key  scale  scale 
      var cacheScale = cacheScaleMeta.scale;
      var cacheScaleDef = {
        type: cacheScale.type
      };

      if (cacheScale.isCategory) {
        //  values
        cacheScaleDef.values = cacheScale.values;
      }

      finalScaleDef = util_1.deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
    }

    var scale = scale_1.createScaleByField(field, data, finalScaleDef); // 

    this.cacheScale(scale, scaleDef, key);
    return scale;
  };
  /**
   *  scale
   */


  ScalePool.prototype.sync = function (coordinate, theme) {
    var _this = this; //  syncScales  syncKey  scale 


    this.syncScales.forEach(function (scaleKeys, syncKey) {
      // min, max, values, ranges
      var min = Number.MAX_SAFE_INTEGER;
      var max = Number.MIN_SAFE_INTEGER;
      var values = []; // 1. values 

      util_1.each(scaleKeys, function (key) {
        var scale = _this.getScale(key);

        max = util_1.isNumber(scale.max) ? Math.max(max, scale.max) : max;
        min = util_1.isNumber(scale.min) ? Math.min(min, scale.min) : min; // 

        util_1.each(scale.values, function (v) {
          if (!values.includes(v)) {
            values.push(v);
          }
        });
      }); // 2. 

      util_1.each(scaleKeys, function (key) {
        var scale = _this.getScale(key);

        if (scale.isContinuous) {
          scale.change({
            min: min,
            max: max,
            values: values
          });
        } else if (scale.isCategory) {
          var range = scale.range;

          var cacheScaleMeta = _this.getScaleMeta(key); //  value  range  to fix https://github.com/antvis/G2/issues/2996


          if (values && !util_1.get(cacheScaleMeta, ['scaleDef', 'range'])) {
            //  range
            range = scale_1.getDefaultCategoryScaleRange(util_1.deepMix({}, scale, {
              values: values
            }), coordinate, theme);
          }

          scale.change({
            values: values,
            range: range
          });
        }
      });
    });
  };
  /**
   *  scale
   * @param scale
   * @param scaleDef
   * @param key
   */


  ScalePool.prototype.cacheScale = function (scale, scaleDef, key) {
    // 1.  scales
    var sm = this.getScaleMeta(key); // 

    if (sm && sm.scale.type === scale.type) {
      scale_1.syncScale(sm.scale, scale);
      sm.scaleDef = scaleDef; //  scaleDef
    } else {
      sm = {
        key: key,
        scale: scale,
        scaleDef: scaleDef
      };
      this.scales.set(key, sm);
    } // 2.  syncScales Record<sync, string[]> 


    var syncKey = this.getSyncKey(sm);
    sm.syncKey = syncKey; //  sync  key
    //  scale  syncScales  sync 

    this.removeFromSyncScales(key); //  sync  sync

    if (syncKey) {
      //  syncKey
      var scaleKeys = this.syncScales.get(syncKey);

      if (!scaleKeys) {
        scaleKeys = [];
        this.syncScales.set(syncKey, scaleKeys);
      }

      scaleKeys.push(key);
    }
  };
  /**
   *  key  scale
   * @param key
   */


  ScalePool.prototype.getScale = function (key) {
    var scaleMeta = this.getScaleMeta(key);

    if (!scaleMeta) {
      var field = util_1.last(key.split('-'));
      var scaleKeys = this.syncScales.get(field);

      if (scaleKeys && scaleKeys.length) {
        scaleMeta = this.getScaleMeta(scaleKeys[0]);
      }
    }

    return scaleMeta && scaleMeta.scale;
  };
  /**
   *  view  scale 
   * @param key
   */


  ScalePool.prototype.deleteScale = function (key) {
    var scaleMeta = this.getScaleMeta(key);

    if (scaleMeta) {
      var syncKey = scaleMeta.syncKey;
      var scaleKeys = this.syncScales.get(syncKey); // 

      if (scaleKeys && scaleKeys.length) {
        var idx = scaleKeys.indexOf(key);

        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
        }
      }
    } //  scale 


    this.scales.delete(key);
  };
  /**
   * 
   */


  ScalePool.prototype.clear = function () {
    this.scales.clear();
    this.syncScales.clear();
  };
  /**
   *  sync scale 
   * @param key
   */


  ScalePool.prototype.removeFromSyncScales = function (key) {
    var _this = this;

    this.syncScales.forEach(function (scaleKeys, syncKey) {
      var idx = scaleKeys.indexOf(key);

      if (idx !== -1) {
        scaleKeys.splice(idx, 1); // 

        if (scaleKeys.length === 0) {
          _this.syncScales.delete(syncKey);
        }

        return false; // 
      }
    });
  };
  /**
   * get sync key
   * @param sm
   */


  ScalePool.prototype.getSyncKey = function (sm) {
    var scale = sm.scale,
        scaleDef = sm.scaleDef;
    var field = scale.field;
    var sync = util_1.get(scaleDef, ['sync']); //  sync = true syncKey

    return sync === true ? field : sync === false ? undefined : sync;
  };
  /**
   *  key  scale
   * @param key
   */


  ScalePool.prototype.getScaleMeta = function (key) {
    return this.scales.get(key);
  };

  return ScalePool;
}();

exports.ScalePool = ScalePool;

/***/ }),
/* 898 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculatePadding = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var constant_1 = __webpack_require__(20);

var bbox_1 = __webpack_require__(77);

var padding_1 = __webpack_require__(267);

var padding_cal_1 = __webpack_require__(436);
/**
 * @ignore
 *  view  padding 
 * @param view
 */


function calculatePadding(view) {
  var padding = view.padding; //  auto padding

  if (!padding_1.isAutoPadding(padding)) {
    return new (padding_cal_1.PaddingCal.bind.apply(padding_cal_1.PaddingCal, tslib_1.__spreadArrays([void 0], padding_1.parsePadding(padding))))();
  } //  auto padding padding


  var viewBBox = view.viewBBox;
  var paddingCal = new padding_cal_1.PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  util_1.each(view.getComponents(), function (co) {
    var type = co.type;

    if (type === constant_1.COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([constant_1.COMPONENT_TYPE.LEGEND, constant_1.COMPONENT_TYPE.SLIDER, constant_1.COMPONENT_TYPE.SCROLLBAR].includes(type)) {
      paddingComponents.push(co);
    } else if (type !== constant_1.COMPONENT_TYPE.GRID && type !== constant_1.COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  }); //  padding 

  util_1.each(axisComponents, function (co) {
    var component = co.component;
    var bboxObject = component.getLayoutBBox();
    var componentBBox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox); //  axis 

    paddingCal.max(exceed);
  }); //  padding 

  util_1.each(paddingComponents, function (co) {
    var component = co.component,
        direction = co.direction;
    var bboxObject = component.getLayoutBBox();
    var componentPadding = component.get('padding');
    var componentBBox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding); //  padding

    paddingCal.inc(componentBBox, direction);
  }); // 

  util_1.each(otherComponents, function (co) {
    var component = co.component,
        direction = co.direction;
    var bboxObject = component.getLayoutBBox();
    var componentBBox = new bbox_1.BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height); //  padding

    paddingCal.inc(componentBBox, direction);
  });
  return paddingCal;
}

exports.calculatePadding = calculatePadding;

/***/ }),
/* 899 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultSyncViewPadding = void 0;
/**
 *  syncViewPadding 
 * @param chart
 * @param views
 * @param PC: PaddingCalCtor
 */

function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance(); //  view  autoPadding 

  views.forEach(function (v) {
    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
  });
}

exports.defaultSyncViewPadding = defaultSyncViewPadding;

/***/ }),
/* 900 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.group = void 0;

var util_1 = __webpack_require__(0);
/** @ignore */


function group(data, fields, appendConditions) {
  if (appendConditions === void 0) {
    appendConditions = {};
  }

  if (!fields) {
    return [data];
  }

  var groups = util_1.groupToMap(data, fields);
  var array = [];

  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values = appendConditions[fields[0]];

    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
      var value = values_1[_i];
      var arr = groups["_" + value];

      if (arr) {
        //  values  arr  null
        array.push(arr);
      }
    }
  } else {
    for (var k in groups) {
      if (groups.hasOwnProperty(k)) {
        var eachGroup = groups[k];
        array.push(eachGroup);
      }
    }
  }

  return array;
}

exports.group = group;

/***/ }),
/* 901 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseFields = void 0;

var util_1 = __webpack_require__(0);
/** @ignore */


function parseFields(field) {
  if (util_1.isArray(field)) {
    return field;
  }

  return field.split('*');
}

exports.parseFields = parseFields;

/***/ }),
/* 902 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var animate_1 = __webpack_require__(96);

var label_1 = __webpack_require__(271);

var util_2 = __webpack_require__(114);

var graphics_1 = __webpack_require__(45);

var transform_1 = __webpack_require__(115);

var constant_1 = __webpack_require__(20);

var update_label_1 = __webpack_require__(903);
/**
 * Geometry labels 
 */


var Labels =
/** @class */
function () {
  function Labels(cfg) {
    /**  shape  shape id */
    this.shapesMap = {};
    this.lastShapesMap = {};
    var layout = cfg.layout,
        container = cfg.container;
    this.layout = layout;
    this.container = container;
  }
  /**
   * 
   */


  Labels.prototype.render = function (items, shapes, isUpdate) {
    var _this = this;

    if (isUpdate === void 0) {
      isUpdate = false;
    }

    this.shapesMap = {};
    var container = this.container;
    var offscreenGroup = this.createOffscreenGroup(); // 

    if (items.length) {
      //  items 
      // step 1:  group  shapes
      for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
        var item = items_1[_i];

        if (item) {
          this.renderLabel(item, offscreenGroup);
        }
      } // step 2:  labels


      this.doLayout(items, shapes); // step 3.1:  labelLine

      this.renderLabelLine(items); // step 3.2:  labelBackground

      this.renderLabelBackground(items); // step 4:  label

      this.adjustLabel(items);
    } // 


    var lastShapesMap = this.lastShapesMap;
    var shapesMap = this.shapesMap;
    util_1.each(shapesMap, function (shape, id) {
      if (shape.destroyed) {
        // label doLayout
        delete shapesMap[id];
      } else {
        if (lastShapesMap[id]) {
          // 
          var data = shape.get('data');
          var origin_1 = shape.get('origin');
          var coordinate = shape.get('coordinate');
          var currentAnimateCfg = shape.get('animateCfg');
          var currentShape = lastShapesMap[id]; //  shape

          update_label_1.updateLabel(currentShape, shapesMap[id], {
            data: data,
            origin: origin_1,
            animateCfg: currentAnimateCfg,
            coordinate: coordinate
          });
          _this.shapesMap[id] = currentShape; // 
        } else {
          //  shape
          container.add(shape);
          var animateCfg = util_1.get(shape.get('animateCfg'), isUpdate ? 'enter' : 'appear');

          if (animateCfg) {
            animate_1.doAnimate(shape, animateCfg, {
              toAttrs: tslib_1.__assign({}, shape.attr()),
              coordinate: shape.get('coordinate')
            });
          }
        }

        delete lastShapesMap[id];
      }
    }); // 

    util_1.each(lastShapesMap, function (deleteShape) {
      var animateCfg = util_1.get(deleteShape.get('animateCfg'), 'leave');

      if (animateCfg) {
        animate_1.doAnimate(deleteShape, animateCfg, {
          toAttrs: null,
          coordinate: deleteShape.get('coordinate')
        });
      } else {
        deleteShape.remove(true); // 
      }
    });
    this.lastShapesMap = shapesMap;
    offscreenGroup.destroy();
  };
  /**  labels */


  Labels.prototype.clear = function () {
    this.container.clear();
    this.shapesMap = {};
    this.lastShapesMap = {};
  };
  /**  */


  Labels.prototype.destroy = function () {
    this.container.destroy();
    this.shapesMap = null;
    this.lastShapesMap = null;
  };

  Labels.prototype.renderLabel = function (cfg, container) {
    var id = cfg.id,
        elementId = cfg.elementId,
        data = cfg.data,
        mappingData = cfg.mappingData,
        coordinate = cfg.coordinate,
        animate = cfg.animate,
        content = cfg.content;
    var shapeAppendCfg = {
      id: id,
      elementId: elementId,
      data: data,
      origin: tslib_1.__assign(tslib_1.__assign({}, mappingData), {
        data: mappingData[constant_1.FIELD_ORIGIN]
      }),
      coordinate: coordinate
    };
    var labelGroup = container.addGroup(tslib_1.__assign({
      name: 'label',
      //  this.animate === false  cfg.animate === false/null 
      animateCfg: this.animate === false || animate === null || animate === false ? false : util_1.deepMix({}, this.animate, animate)
    }, shapeAppendCfg));
    var labelShape;

    if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
      //  content  Group  Shape textAlign  labelGroup
      var _a = content.getCanvasBBox(),
          width = _a.width,
          height = _a.height;

      var textAlign = util_1.get(cfg, 'textAlign', 'left');
      var x = cfg.x;
      var y = cfg.y - height / 2;

      if (textAlign === 'center') {
        x = x - width / 2;
      } else if (textAlign === 'right' || textAlign === 'end') {
        x = x - width;
      }

      transform_1.translate(content, x, y); //  label  x, y 

      labelShape = content;
      labelGroup.add(content);
    } else {
      var fill = util_1.get(cfg, ['style', 'fill']);
      labelShape = labelGroup.addShape('text', tslib_1.__assign({
        attrs: tslib_1.__assign(tslib_1.__assign({
          x: cfg.x,
          y: cfg.y,
          textAlign: cfg.textAlign,
          textBaseline: util_1.get(cfg, 'textBaseline', 'middle'),
          text: cfg.content
        }, cfg.style), {
          fill: util_1.isNull(fill) ? cfg.color : fill
        })
      }, shapeAppendCfg));
    }

    if (cfg.rotate) {
      transform_1.rotate(labelShape, cfg.rotate);
    }

    this.shapesMap[id] = labelGroup;
  }; // typelabel


  Labels.prototype.doLayout = function (items, shapes) {
    var _this = this;

    if (this.layout) {
      var layouts = util_1.isArray(this.layout) ? this.layout : [this.layout];
      util_1.each(layouts, function (layout) {
        var layoutFn = label_1.getGeometryLabelLayout(util_1.get(layout, 'type', ''));

        if (layoutFn) {
          var labelShapes_1 = [];
          var geometryShapes_1 = [];
          util_1.each(_this.shapesMap, function (labelShape, id) {
            labelShapes_1.push(labelShape);
            geometryShapes_1.push(shapes[labelShape.get('elementId')]);
          });
          layoutFn(items, labelShapes_1, geometryShapes_1, _this.region, layout.cfg);
        }
      });
    }
  };

  Labels.prototype.renderLabelLine = function (labelItems) {
    var _this = this;

    util_1.each(labelItems, function (labelItem) {
      var coordinate = util_1.get(labelItem, 'coordinate');

      if (!labelItem || !coordinate) {
        return;
      }

      var center = coordinate.getCenter();
      var radius = coordinate.getRadius();

      if (!labelItem.labelLine) {
        // labelLine: null | false label  labelLine
        return;
      }

      var labelLineCfg = util_1.get(labelItem, 'labelLine', {});
      var id = labelItem.id;
      var path = labelLineCfg.path;

      if (!path) {
        var start = graphics_1.polarToCartesian(center.x, center.y, radius, labelItem.angle);
        path = [['M', start.x, start.y], ['L', labelItem.x, labelItem.y]];
      }

      var labelGroup = _this.shapesMap[id];

      if (!labelGroup.destroyed) {
        labelGroup.addShape('path', {
          capture: false,
          attrs: tslib_1.__assign({
            path: path,
            stroke: labelItem.color ? labelItem.color : util_1.get(labelItem, ['style', 'fill'], '#000'),
            fill: null
          }, labelLineCfg.style),
          id: id,
          origin: labelItem.mappingData,
          data: labelItem.data,
          coordinate: labelItem.coordinate
        });
      }
    });
  };
  /**
   * 
   * @param labelItems
   */


  Labels.prototype.renderLabelBackground = function (labelItems) {
    var _this = this;

    util_1.each(labelItems, function (labelItem) {
      var coordinate = util_1.get(labelItem, 'coordinate');
      var background = util_1.get(labelItem, 'background');

      if (!background || !coordinate) {
        return;
      }

      var id = labelItem.id;
      var labelGroup = _this.shapesMap[id];

      if (!labelGroup.destroyed) {
        var labelContentShape = labelGroup.getChildren()[0];

        if (labelContentShape) {
          var _a = util_2.getlLabelBackgroundInfo(labelGroup, labelItem, background.padding),
              rotation = _a.rotation,
              box = tslib_1.__rest(_a, ["rotation"]);

          var backgroundShape = labelGroup.addShape('rect', {
            attrs: tslib_1.__assign(tslib_1.__assign({}, box), background.style || {}),
            id: id,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
          backgroundShape.setZIndex(-1);

          if (rotation) {
            var matrix = labelContentShape.getMatrix();
            backgroundShape.setMatrix(matrix);
          }
        }
      }
    });
  };

  Labels.prototype.createOffscreenGroup = function () {
    var container = this.container;
    var GroupClass = container.getGroupBase(); // 

    var newGroup = new GroupClass({});
    return newGroup;
  };

  Labels.prototype.adjustLabel = function (items) {
    var _this = this;

    util_1.each(items, function (item) {
      if (item) {
        var id = item.id;
        var labelGroup = _this.shapesMap[id];

        if (!labelGroup.destroyed) {
          // fix:  label content  group  content group   spider label  2  textShape  gorup
          var labelShapes = labelGroup.findAll(function (ele) {
            return ele.get('type') !== 'path';
          });
          util_1.each(labelShapes, function (labelShape) {
            if (labelShape) {
              if (item.offsetX) {
                labelShape.attr('x', labelShape.attr('x') + item.offsetX);
              }

              if (item.offsetY) {
                labelShape.attr('y', labelShape.attr('y') + item.offsetY);
              }
            }
          });
        }
      }
    });
  };

  return Labels;
}();

exports.default = Labels;

/***/ }),
/* 903 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.updateLabel = void 0;

var util_1 = __webpack_require__(0);

var animate_1 = __webpack_require__(96);

var graphics_1 = __webpack_require__(45);
/**
 * @desc  label ( id  idx )
 * @done shape 
 * @done shape delete
 * @done shape append
 *
 * @param fromShape old labelShape
 * @param toShape new labelShape
 * @param cfg
 */


function updateLabel(fromShape, toShape, cfg) {
  var data = cfg.data,
      origin = cfg.origin,
      animateCfg = cfg.animateCfg,
      coordinate = cfg.coordinate;
  var updateAnimateCfg = util_1.get(animateCfg, 'update');
  fromShape.set('data', data);
  fromShape.set('origin', origin);
  fromShape.set('animateCfg', animateCfg);
  fromShape.set('coordinate', coordinate);
  fromShape.set('visible', toShape.get('visible'));
  fromShape.getChildren().forEach(function (fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);

    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set('data', data);
      fromChild.set('origin', origin);
      fromChild.set('animateCfg', animateCfg);
      fromChild.set('coordinate', coordinate);
      var newAttrs = graphics_1.getReplaceAttrs(fromChild, toChild);

      if (updateAnimateCfg) {
        animate_1.doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate: coordinate
        });
      } else {
        fromChild.attr(newAttrs);
      }

      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  }); // append

  util_1.each(toShape.getChildren(), function (child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}

exports.updateLabel = updateLabel;

/***/ }),
/* 904 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMappingValue = void 0;

var tslib_1 = __webpack_require__(1);
/**
 * @ignore
 * get the mapping value by attribute, if mapping value is nil, return def
 * @param attr
 * @param value
 * @param def
 * @returns get mapping value
 */


function getMappingValue(attr, value, def) {
  if (!attr) {
    return def;
  }

  var r; // 

  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill('');
    r = attr.mapping.apply(attr, tslib_1.__spreadArrays([value], restArgs)).join('');
  } else {
    r = attr.mapping(value).join('');
  }

  return r || def;
}

exports.getMappingValue = getMappingValue;

/***/ }),
/* 905 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPrototypeOf = __webpack_require__(4);

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

module.exports = _superPropBase;

/***/ }),
/* 906 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _antv_g2_lib_animate_animation_fade__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(220);
/* harmony import */ var _antv_g2_lib_animate_animation_fade__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_fade__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(172);
/* harmony import */ var _antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(166);
/* harmony import */ var _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _antv_g2_lib_animate_animation_position_update__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(310);
/* harmony import */ var _antv_g2_lib_animate_animation_position_update__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_position_update__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _antv_g2_lib_animate_animation_scale_in__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(221);
/* harmony import */ var _antv_g2_lib_animate_animation_scale_in__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_scale_in__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _antv_g2_lib_animate_animation_sector_path_update__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(311);
/* harmony import */ var _antv_g2_lib_animate_animation_sector_path_update__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_sector_path_update__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _antv_g2_lib_animate_animation_wave_in__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(312);
/* harmony import */ var _antv_g2_lib_animate_animation_wave_in__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_wave_in__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _antv_g2_lib_animate_animation_zoom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(222);
/* harmony import */ var _antv_g2_lib_animate_animation_zoom__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_animate_animation_zoom__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(24);
/* harmony import */ var _antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__);
// 









Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('fade-in', _antv_g2_lib_animate_animation_fade__WEBPACK_IMPORTED_MODULE_0__["fadeIn"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('fade-out', _antv_g2_lib_animate_animation_fade__WEBPACK_IMPORTED_MODULE_0__["fadeOut"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('grow-in-x', _antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1__["growInX"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('grow-in-xy', _antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1__["growInXY"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('grow-in-y', _antv_g2_lib_animate_animation_grow_in__WEBPACK_IMPORTED_MODULE_1__["growInY"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('scale-in-x', _antv_g2_lib_animate_animation_scale_in__WEBPACK_IMPORTED_MODULE_4__["scaleInX"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('scale-in-y', _antv_g2_lib_animate_animation_scale_in__WEBPACK_IMPORTED_MODULE_4__["scaleInY"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('wave-in', _antv_g2_lib_animate_animation_wave_in__WEBPACK_IMPORTED_MODULE_6__["waveIn"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('zoom-in', _antv_g2_lib_animate_animation_zoom__WEBPACK_IMPORTED_MODULE_7__["zoomIn"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('zoom-out', _antv_g2_lib_animate_animation_zoom__WEBPACK_IMPORTED_MODULE_7__["zoomOut"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('position-update', _antv_g2_lib_animate_animation_position_update__WEBPACK_IMPORTED_MODULE_3__["positionUpdate"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('sector-path-update', _antv_g2_lib_animate_animation_sector_path_update__WEBPACK_IMPORTED_MODULE_5__["sectorPathUpdate"]);
Object(_antv_g2_lib_core__WEBPACK_IMPORTED_MODULE_8__["registerAnimation"])('path-in', _antv_g2_lib_animate_animation_path_in__WEBPACK_IMPORTED_MODULE_2__["pathIn"]);

/***/ }),
/* 907 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doScaleAnimate = exports.transformShape = void 0;

var matrix_util_1 = __webpack_require__(33);
/**
 * @ignore
 * 
 * @param shape 
 * @param vector 
 * @param direct 
 */


function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var x = vector[0],
      y = vector[1];
  shape.applyToMatrix([x, y, 1]);

  if (direct === 'x') {
    shape.setMatrix(matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 1], ['t', x, y]]));
    scaledMatrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 1], ['t', x, y]]);
  } else if (direct === 'y') {
    shape.setMatrix(matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 0.01], ['t', x, y]]));
    scaledMatrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 1, 100], ['t', x, y]]);
  } else if (direct === 'xy') {
    shape.setMatrix(matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 0.01, 0.01], ['t', x, y]]));
    scaledMatrix = matrix_util_1.ext.transform(shape.getMatrix(), [['t', -x, -y], ['s', 100, 100], ['t', x, y]]);
  }

  return scaledMatrix;
}

exports.transformShape = transformShape;
/**
 * 
 * @param element 
 * @param animateCfg 
 * @param coordinate 
 * @param yMinPoint y 
 * @param type 
 */

function doScaleAnimate(element, animateCfg, coordinate, yMinPoint, type) {
  var start = coordinate.start,
      end = coordinate.end;
  var width = coordinate.getWidth();
  var height = coordinate.getHeight();
  var x;
  var y;

  if (type === 'y') {
    x = start.x + width / 2;
    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type === 'x') {
    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y = start.y + height / 2;
  } else if (type === 'xy') {
    if (coordinate.isPolar) {
      x = coordinate.getCenter().x;
      y = coordinate.getCenter().y;
    } else {
      x = (start.x + end.x) / 2;
      y = (start.y + end.y) / 2;
    }
  }

  var endMatrix = transformShape(element, [x, y], type);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}

exports.doScaleAnimate = doScaleAnimate;

/***/ }),
/* 908 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

var _util = __webpack_require__(54);

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var Circle =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Circle, _super);

  function Circle() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Circle.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      r: 0
    });
  };

  Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = (0, _util.distance)(cx, cy, x, y); // 

    if (isFill && isStroke) {
      return absDistance <= r + halfLineWidth;
    }

    if (isFill) {
      return absDistance <= r;
    }

    if (isStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }

    return false;
  };

  Circle.prototype.createPath = function (context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
    context.closePath();
  };

  return Circle;
}(_base.default);

var _default = Circle;
exports.default = _default;

/***/ }),
/* 909 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
//  x*x/rx*rx + y*y/ry*ry;
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}

var Ellipse =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Ellipse, _super);

  function Ellipse() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Ellipse.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      rx: 0,
      ry: 0
    });
  };

  Ellipse.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx,
        ry = attrs.ry;
    var squareX = (x - cx) * (x - cx);
    var squareY = (y - cy) * (y - cy); //  x*x/rx*rx + y*y/ry*ry = 1;

    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }

    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }

    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }

    return false;
  };

  Ellipse.prototype.createPath = function (context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context.beginPath(); // 

    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      // 
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.translate(cx, cy);
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r, 0, Math.PI * 2);
      context.restore();
      context.closePath();
    }
  };

  return Ellipse;
}(_base.default);

var _default = Ellipse;
exports.default = _default;

/***/ }),
/* 910 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

var _util = __webpack_require__(54);

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
function isCanvas(dom) {
  return dom instanceof HTMLElement && (0, _util.isString)(dom.nodeName) && dom.nodeName.toUpperCase() === 'CANVAS';
}

var ImageShape =
/** @class */
function (_super) {
  (0, _tslib.__extends)(ImageShape, _super);

  function ImageShape() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ImageShape.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  };

  ImageShape.prototype.initAttrs = function (attrs) {
    this._setImage(attrs.img);
  }; // image  stroke


  ImageShape.prototype.isStroke = function () {
    return false;
  }; // 
  //  isInStrokeOrPath 


  ImageShape.prototype.isOnlyHitBox = function () {
    return true;
  };

  ImageShape.prototype._afterLoading = function () {
    if (this.get('toDraw') === true) {
      var canvas = this.get('canvas');

      if (canvas) {
        // 
        canvas.draw();
      } else {
        // 
        this.createPath(this.get('context'));
      }
    }
  };

  ImageShape.prototype._setImage = function (img) {
    var _this = this;

    var attrs = this.attrs;

    if ((0, _util.isString)(img)) {
      var image_1 = new Image();

      image_1.onload = function () {
        // 
        if (_this.destroyed) {
          return false;
        } // 
        //  img 
        // this.set('imgSrc', img);
        //  _setImage 


        _this.attr('img', image_1);

        _this.set('loading', false);

        _this._afterLoading();

        var callback = _this.get('callback');

        if (callback) {
          callback.call(_this);
        }
      }; // 


      image_1.crossOrigin = 'Anonymous';
      image_1.src = img; // loading 

      this.set('loading', true);
    } else if (img instanceof Image) {
      //  image 
      if (!attrs.width) {
        attrs.width = img.width;
      }

      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      //  canvas 
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute('width'));
      }

      if (!attrs.height) {
        attrs.height, Number(img.getAttribute('height'));
      }
    }
  };

  ImageShape.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue); // 


    if (name === 'img') {
      // && this.get('imgSrc') !== value
      this._setImage(value);
    }
  };

  ImageShape.prototype.createPath = function (context) {
    // 
    if (this.get('loading')) {
      this.set('toDraw', true); // 

      this.set('context', context);
      return;
    }

    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y,
        width = attrs.width,
        height = attrs.height,
        sx = attrs.sx,
        sy = attrs.sy,
        swidth = attrs.swidth,
        sheight = attrs.sheight;
    var img = attrs.img;

    if (img instanceof Image || isCanvas(img)) {
      if (!(0, _util.isNil)(sx) && !(0, _util.isNil)(sy) && !(0, _util.isNil)(swidth) && !(0, _util.isNil)(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
      } else {
        context.drawImage(img, x, y, width, height);
      }
    }
  };

  return ImageShape;
}(_base.default);

var _default = ImageShape;
exports.default = _default;

/***/ }),
/* 911 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gMath = __webpack_require__(35);

var _base = _interopRequireDefault(__webpack_require__(71));

var _line = _interopRequireDefault(__webpack_require__(191));

var ArrowUtil = _interopRequireWildcard(__webpack_require__(190));

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var Line =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Line, _super);

  function Line() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Line.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      startArrow: false,
      endArrow: false
    });
  };

  Line.prototype.initAttrs = function (attrs) {
    this.setArrow();
  }; // 


  Line.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue); //  line  attrs attr attr 


    this.setArrow();
  };

  Line.prototype.setArrow = function () {
    var attrs = this.attr();
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2,
        startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;

    if (startArrow) {
      ArrowUtil.addStartArrow(this, attrs, x2, y2, x1, y1);
    }

    if (endArrow) {
      ArrowUtil.addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };

  Line.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }

    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return (0, _line.default)(x1, y1, x2, y2, lineWidth, x, y);
  };

  Line.prototype.createPath = function (context) {
    var attrs = this.attr();
    var x1 = attrs.x1,
        y1 = attrs.y1,
        x2 = attrs.x2,
        y2 = attrs.y2,
        startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };

    if (startArrow && startArrow.d) {
      startArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }

    if (endArrow && endArrow.d) {
      endArrowDistance = ArrowUtil.getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }

    context.beginPath(); // 

    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };

  Line.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get length of line
   * @return {number} length
   */


  Line.prototype.getTotalLength = function () {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return _gMath.Line.length(x1, y1, x2, y2);
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Line.prototype.getPoint = function (ratio) {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return _gMath.Line.pointAt(x1, y1, x2, y2, ratio);
  };

  return Line;
}(_base.default);

var _default = Line;
exports.default = _default;

/***/ }),
/* 912 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _pathUtil = __webpack_require__(95);

var _base = _interopRequireDefault(__webpack_require__(71));

var _util2 = __webpack_require__(54);

var _draw = __webpack_require__(149);

/**
 * @fileoverview Marker
 * @author dxq613@gmail.com
 */
var Symbols = {
  // 
  circle: function circle(x, y, r) {
    return [['M', x - r, y], ['A', r, r, 0, 1, 0, x + r, y], ['A', r, r, 0, 1, 0, x - r, y]];
  },
  // 
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  // 
  diamond: function diamond(x, y, r) {
    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
  },
  // 
  triangle: function triangle(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['Z']];
  },
  // 
  'triangle-down': function triangleDown(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
  }
};

var Marker =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Marker, _super);

  function Marker() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Marker.prototype.initAttrs = function (attrs) {
    this._resetParamsCache();
  }; //  path 


  Marker.prototype._resetParamsCache = function () {
    //  path 
    // 
    this.set('paramsCache', {}); // 
  }; //  path


  Marker.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (['symbol', 'x', 'y', 'r', 'radius'].indexOf(name) !== -1) {
      // path 
      this._resetParamsCache();
    }
  }; // 
  //  isInStrokeOrPath 


  Marker.prototype.isOnlyHitBox = function () {
    return true;
  };

  Marker.prototype._getR = function (attrs) {
    //  r  radius  r
    return (0, _util.isNil)(attrs.r) ? attrs.radius : attrs.r;
  };

  Marker.prototype._getPath = function () {
    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y;
    var symbol = attrs.symbol || 'circle';

    var r = this._getR(attrs);

    var method;
    var path;

    if ((0, _util2.isFunction)(symbol)) {
      method = symbol;
      path = method(x, y, r); //  path 

      path = (0, _pathUtil.path2Absolute)(path);
    } else {
      //  symbol  path  path 
      method = Marker.Symbols[symbol];

      if (!method) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }

      path = method(x, y, r);
    }

    return path;
  };

  Marker.prototype.createPath = function (context) {
    var path = this._getPath();

    var paramsCache = this.get('paramsCache');
    (0, _draw.drawPath)(this, context, {
      path: path
    }, paramsCache);
  };

  Marker.Symbols = Symbols;
  return Marker;
}(_base.default);

var _default = Marker;
exports.default = _default;

/***/ }),
/* 913 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gMath = __webpack_require__(35);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(71));

var _pathUtil = __webpack_require__(95);

var _draw = __webpack_require__(149);

var _pointInPath = _interopRequireDefault(__webpack_require__(441));

var _polygon = _interopRequireDefault(__webpack_require__(442));

var _path = _interopRequireDefault(__webpack_require__(914));

var ArrowUtil = _interopRequireWildcard(__webpack_require__(190));

// 
function isInPolygons(polygons, x, y) {
  var isHit = false;

  for (var i = 0; i < polygons.length; i++) {
    var points = polygons[i];
    isHit = (0, _polygon.default)(points, x, y);

    if (isHit) {
      break;
    }
  }

  return isHit;
}

var Path =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Path, _super);

  function Path() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Path.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  Path.prototype.initAttrs = function (attrs) {
    this._setPathArr(attrs.path);

    this.setArrow();
  }; //  path


  Path.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (name === 'path') {
      this._setPathArr(value);
    } //  line  attrs attr attr 


    this.setArrow();
  }; //  path 


  Path.prototype._setPathArr = function (path) {
    //  path 
    this.attrs.path = (0, _pathUtil.path2Absolute)(path);

    var hasArc = _path.default.hasArc(path); //  path 
    // 


    this.set('hasArc', hasArc);
    this.set('paramsCache', {}); // 

    this.set('segments', null); //  path

    this.set('curve', null);
    this.set('tCache', null);
    this.set('totalLength', null);
  };

  Path.prototype.getSegments = function () {
    var segments = this.get('segements');

    if (!segments) {
      segments = (0, _pathUtil.path2Segments)(this.attr('path'));
      this.set('segments', segments);
    }

    return segments;
  };

  Path.prototype.setArrow = function () {
    var attrs = this.attr();
    var startArrow = attrs.startArrow,
        endArrow = attrs.endArrow;

    if (startArrow) {
      var tangent = this.getStartTangent();
      ArrowUtil.addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }

    if (endArrow) {
      var tangent = this.getEndTangent();
      ArrowUtil.addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };

  Path.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc = this.get('hasArc');
    var isHit = false;

    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = _path.default.isPointInStroke(segments, lineWidth, x, y, length_1);
    }

    if (!isHit && isFill) {
      if (hasArc) {
        //  canvas  api 
        isHit = (0, _pointInPath.default)(this, x, y);
      } else {
        var path = this.attr('path');

        var extractResutl = _path.default.extractPolygons(path); // 


        isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
      }
    }

    return isHit;
  };

  Path.prototype.createPath = function (context) {
    var attrs = this.attr();
    var paramsCache = this.get('paramsCache'); // 

    (0, _draw.drawPath)(this, context, attrs, paramsCache);
  };

  Path.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get total length of path
   * @return {number} length
   */


  Path.prototype.getTotalLength = function () {
    var totalLength = this.get('totalLength');

    if (!(0, _util.isNil)(totalLength)) {
      return totalLength;
    }

    this._calculateCurve();

    this._setTcache();

    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Path.prototype.getPoint = function (ratio) {
    var tCache = this.get('tCache');

    if (!tCache) {
      this._calculateCurve();

      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    var curve = this.get('curve');

    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }

      return null;
    }

    (0, _util.each)(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    var seg = curve[index];

    if ((0, _util.isNil)(seg) || (0, _util.isNil)(index)) {
      return null;
    }

    var l = seg.length;
    var nextSeg = curve[index + 1];
    return _gMath.Cubic.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };

  Path.prototype._calculateCurve = function () {
    var path = this.attr().path;
    this.set('curve', _path.default.pathToCurve(path));
  };

  Path.prototype._setTcache = function () {
    var totalLength = 0;
    var tempLength = 0; //  curve : [[0, 0.25], [0.25, 0.6]. [0.6, 0.9], [0.9, 1]]

    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l;
    var curve = this.get('curve');

    if (!curve) {
      return;
    }

    (0, _util.each)(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        totalLength += _gMath.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set('totalLength', totalLength);

    if (totalLength === 0) {
      this.set('tCache', []);
      return;
    }

    (0, _util.each)(curve, function (segment, i) {
      segmentN = curve[i + 1];
      l = segment.length;

      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = _gMath.Cubic.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]); //  path segmentL  0 

        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  Path.prototype.getStartTangent = function () {
    var segments = this.getSegments();
    var result;

    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];

      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }

    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  Path.prototype.getEndTangent = function () {
    var segments = this.getSegments();
    var length = segments.length;
    var result;

    if (length > 1) {
      var startPoint = segments[length - 2].currentPoint;
      var endPoint = segments[length - 1].currentPoint;
      var tangent = segments[length - 1].endTangent;
      result = [];

      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }

    return result;
  };

  return Path;
}(_base.default);

var _default = Path;
exports.default = _default;

/***/ }),
/* 914 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _gMath = __webpack_require__(35);

var _matrixUtil = __webpack_require__(33);

var vec3 = _interopRequireWildcard(__webpack_require__(176));

var _util = __webpack_require__(54);

var _line = _interopRequireDefault(__webpack_require__(191));

var _arc = _interopRequireDefault(__webpack_require__(443));

/**
 * @fileoverview path 
 * @author dxq613@gmail.com
 */
var transform = _matrixUtil.ext.transform;

function hasArc(path) {
  var hasArc = false;
  var count = path.length;

  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];

    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {
      hasArc = true;
      break;
    }
  }

  return hasArc;
}

function isPointInStroke(segments, lineWidth, x, y, length) {
  var isHit = false;
  var halfWidth = lineWidth / 2;

  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint,
        params = segment.params,
        prePoint = segment.prePoint,
        box = segment.box; // 

    if (box && !(0, _util.inBox)(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {
      continue;
    }

    switch (segment.command) {
      // L  Z  M 
      case 'L':
      case 'Z':
        isHit = (0, _line.default)(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;

      case 'Q':
        var qDistance = _gMath.Quad.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);

        isHit = qDistance <= lineWidth / 2;
        break;

      case 'C':
        var cDistance = _gMath.Cubic.pointDistance(prePoint[0], // ,  C 
        prePoint[1], params[1], // 'C' 12 34 56 
        params[2], params[3], params[4], params[5], params[6], x, y, length);

        isHit = cDistance <= lineWidth / 2;
        break;

      case 'A':
        // 
        var arcParams = segment.arcParams;
        var cx = arcParams.cx,
            cy = arcParams.cy,
            rx = arcParams.rx,
            ry = arcParams.ry,
            startAngle = arcParams.startAngle,
            endAngle = arcParams.endAngle,
            xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform(null, [['t', -cx, -cy], ['r', -xRotation], ['s', 1 / scaleX, 1 / scaleY]]);
        vec3.transformMat3(p, p, m);
        isHit = (0, _arc.default)(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;

      default:
        break;
    }

    if (isHit) {
      break;
    }
  }

  return isHit;
}
/**
 *  path 
 * @param {Array} path 
 * @returns {Array} 
 */


function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = []; //  'M'

  for (var i = 0; i < count; i++) {
    var params = path[i];
    var cmd = params[0];

    if (cmd === 'M') {
      //  'M' 
      if (points.length) {
        //  'Z'
        polylines.push(points);
        points = []; // 
      }

      points.push([params[1], params[2]]);
    } else if (cmd === 'Z') {
      if (points.length) {
        // 
        polygons.push(points);
        points = []; // 
      } //  'Z'

    } else {
      points.push([params[1], params[2]]);
    }
  } //  points  polygons  polyline
  //  M Z 


  if (points.length > 0) {
    polylines.push(points);
  }

  return {
    polygons: polygons,
    polylines: polylines
  };
}

var _default = (0, _tslib.__assign)({
  hasArc: hasArc,
  extractPolygons: extractPolygons,
  isPointInStroke: isPointInStroke
}, _gBase.PathUtil);

exports.default = _default;

/***/ }),
/* 915 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

var _polyline = _interopRequireDefault(__webpack_require__(444));

var _polygon = _interopRequireDefault(__webpack_require__(442));

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var Polygon =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Polygon, _super);

  function Polygon() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Polygon.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var points = this.attr().points;
    var isHit = false;

    if (isStroke) {
      isHit = (0, _polyline.default)(points, lineWidth, x, y, true);
    }

    if (!isHit && isFill) {
      isHit = (0, _polygon.default)(points, x, y); // isPointInPath(shape, x, y);
    }

    return isHit;
  };

  Polygon.prototype.createPath = function (context) {
    var attrs = this.attr();
    var points = attrs.points;

    if (points.length < 2) {
      return;
    }

    context.beginPath();

    for (var i = 0; i < points.length; i++) {
      var point = points[i];

      if (i === 0) {
        context.moveTo(point[0], point[1]);
      } else {
        context.lineTo(point[0], point[1]);
      }
    }

    context.closePath();
  };

  return Polygon;
}(_base.default);

var _default = Polygon;
exports.default = _default;

/***/ }),
/* 916 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gMath = __webpack_require__(35);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(71));

var _polyline = _interopRequireDefault(__webpack_require__(444));

var ArrowUtil = _interopRequireWildcard(__webpack_require__(190));

var PolyLine =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PolyLine, _super);

  function PolyLine() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  PolyLine.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  PolyLine.prototype.initAttrs = function (attrs) {
    this.setArrow();
  }; //  points


  PolyLine.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    this.setArrow();

    if (['points'].indexOf(name) !== -1) {
      this._resetCache();
    }
  };

  PolyLine.prototype._resetCache = function () {
    this.set('totalLength', null);
    this.set('tCache', null);
  };

  PolyLine.prototype.setArrow = function () {
    var attrs = this.attr();
    var _a = this.attrs,
        points = _a.points,
        startArrow = _a.startArrow,
        endArrow = _a.endArrow;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1];

    if (startArrow) {
      ArrowUtil.addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
    }

    if (endArrow) {
      ArrowUtil.addEndArrow(this, attrs, points[length - 2][0], points[length - 2][1], x2, y2);
    }
  }; //  fill


  PolyLine.prototype.isFill = function () {
    return false;
  };

  PolyLine.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    //  stroke , 
    if (!isStroke || !lineWidth) {
      return false;
    }

    var points = this.attr().points;
    return (0, _polyline.default)(points, lineWidth, x, y, false);
  }; // 


  PolyLine.prototype.isStroke = function () {
    return true;
  };

  PolyLine.prototype.createPath = function (context) {
    var _a = this.attr(),
        points = _a.points,
        startArrow = _a.startArrow,
        endArrow = _a.endArrow;

    var length = points.length;

    if (points.length < 2) {
      return;
    }

    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1]; // 

    if (startArrow && startArrow.d) {
      var distance = ArrowUtil.getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
      x1 += distance.dx;
      y1 += distance.dy;
    }

    if (endArrow && endArrow.d) {
      var distance = ArrowUtil.getShortenOffset(points[length - 2][0], points[length - 2][1], x2, y2, endArrow.d);
      x2 -= distance.dx;
      y2 -= distance.dy;
    }

    context.beginPath();
    context.moveTo(x1, y1);

    for (var i = 0; i < length - 1; i++) {
      var point = points[i];
      context.lineTo(point[0], point[1]);
    }

    context.lineTo(x2, y2);
  };

  PolyLine.prototype.afterDrawPath = function (context) {
    var startArrowShape = this.get('startArrowShape');
    var endArrowShape = this.get('endArrowShape');

    if (startArrowShape) {
      startArrowShape.draw(context);
    }

    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  /**
   * Get length of polyline
   * @return {number} length
   */


  PolyLine.prototype.getTotalLength = function () {
    var points = this.attr().points; // get totalLength from cache

    var totalLength = this.get('totalLength');

    if (!(0, _util.isNil)(totalLength)) {
      return totalLength;
    }

    this.set('totalLength', _gMath.Polyline.length(points));
    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  PolyLine.prototype.getPoint = function (ratio) {
    var points = this.attr().points; // get tCache from cache

    var tCache = this.get('tCache');

    if (!tCache) {
      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    (0, _util.each)(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return _gMath.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };

  PolyLine.prototype._setTcache = function () {
    var points = this.attr().points;

    if (!points || points.length === 0) {
      return;
    }

    var totalLength = this.getTotalLength();

    if (totalLength <= 0) {
      return;
    }

    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    (0, _util.each)(points, function (p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = _gMath.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  PolyLine.prototype.getStartTangent = function () {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  PolyLine.prototype.getEndTangent = function () {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };

  return PolyLine;
}(_base.default);

var _default = PolyLine;
exports.default = _default;

/***/ }),
/* 917 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

var _parse = __webpack_require__(439);

var _util = __webpack_require__(54);

var _rect = _interopRequireDefault(__webpack_require__(918));

var _rectRadius = _interopRequireDefault(__webpack_require__(919));

var _pointInPath = _interopRequireDefault(__webpack_require__(441));

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var Rect =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Rect, _super);

  function Rect() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Rect.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0
    });
  };

  Rect.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius; // 

    if (!radius) {
      var halfWidth = lineWidth / 2; // 

      if (isFill && isStroke) {
        return (0, _util.inBox)(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
      } // 


      if (isFill) {
        return (0, _util.inBox)(minX, minY, width, height, x, y);
      }

      if (isStroke) {
        return (0, _rect.default)(minX, minY, width, height, lineWidth, x, y);
      }
    } else {
      var isHit = false;

      if (isStroke) {
        isHit = (0, _rectRadius.default)(minX, minY, width, height, radius, lineWidth, x, y);
      } // 
      // 


      if (!isHit && isFill) {
        isHit = (0, _pointInPath.default)(this, x, y);
      }

      return isHit;
    }
  };

  Rect.prototype.createPath = function (context) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context.beginPath();

    if (radius === 0) {
      // rect
      context.rect(x, y, width, height);
    } else {
      var _a = (0, _parse.parseRadius)(radius),
          r1 = _a[0],
          r2 = _a[1],
          r3 = _a[2],
          r4 = _a[3];

      context.moveTo(x + r1, y);
      context.lineTo(x + width - r2, y);
      r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      context.lineTo(x + width, y + height - r3);
      r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      context.lineTo(x + r4, y + height);
      r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      context.lineTo(x, y + r1);
      r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  };

  return Rect;
}(_base.default);

var _default = Rect;
exports.default = _default;

/***/ }),
/* 918 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inRect;

var _util = __webpack_require__(54);

function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2; // 

  return (0, _util.inBox)(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 
  (0, _util.inBox)(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 
  (0, _util.inBox)(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 
  (0, _util.inBox)(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y); // 
}

/***/ }),
/* 919 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = rectWithRadius;

var _line = _interopRequireDefault(__webpack_require__(191));

var _arc = _interopRequireDefault(__webpack_require__(443));

function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return (0, _line.default)(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || (0, _line.default)(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || (0, _line.default)(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || (0, _line.default)(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || (0, _arc.default)(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || (0, _arc.default)(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || (0, _arc.default)(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || (0, _arc.default)(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}

/***/ }),
/* 920 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _base = _interopRequireDefault(__webpack_require__(71));

var _util = __webpack_require__(54);

var _gBase = __webpack_require__(27);

/**
 * @fileoverview 
 * @author dxq613@gmail.com
 */
var Text =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Text, _super);

  function Text() {
    return _super !== null && _super.apply(this, arguments) || this;
  } // 


  Text.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      text: null,
      fontSize: 12,
      fontFamily: 'sans-serif',
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontVariant: 'normal',
      textAlign: 'start',
      textBaseline: 'bottom'
    });
  }; // 


  Text.prototype.isOnlyHitBox = function () {
    return true;
  }; //  font text 


  Text.prototype.initAttrs = function (attrs) {
    this._assembleFont();

    if (attrs.text) {
      this._setText(attrs.text);
    }
  }; // 


  Text.prototype._assembleFont = function () {
    var attrs = this.attrs;
    attrs.font = (0, _gBase.assembleFont)(attrs);
  }; // 


  Text.prototype._setText = function (text) {
    var textArr = null;

    if ((0, _util.isString)(text) && text.indexOf('\n') !== -1) {
      textArr = text.split('\n');
    }

    this.set('textArr', textArr);
  }; //  fonttext


  Text.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (name.startsWith('font')) {
      this._assembleFont();
    }

    if (name === 'text') {
      this._setText(value);
    }
  }; //  text 
  // createPath(context) {
  // }
  // 


  Text.prototype._getSpaceingY = function () {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  }; // 


  Text.prototype._drawTextArr = function (context, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x = attrs.x;
    var y = attrs.y;
    var fontSize = attrs.fontSize * 1;

    var spaceingY = this._getSpaceingY();

    var height = (0, _gBase.getTextHeight)(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    (0, _util.each)(textArr, function (subText, index) {
      subY = y + index * (spaceingY + fontSize) - height + fontSize; // bottom;

      if (textBaseline === 'middle') subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === 'top') subY += height - fontSize;

      if (isFill) {
        context.fillText(subText, x, subY);
      } else {
        context.strokeText(subText, x, subY);
      }
    });
  }; // 


  Text.prototype._drawText = function (context, isFill) {
    var attrs = this.attr();
    var x = attrs.x;
    var y = attrs.y;
    var textArr = this.get('textArr');

    if (textArr) {
      this._drawTextArr(context, textArr, isFill);
    } else {
      var text = attrs.text;

      if (isFill) {
        context.fillText(text, x, y);
      } else {
        context.strokeText(text, x, y);
      }
    }
  }; // 


  Text.prototype.strokeAndFill = function (context) {
    var _a = this.attrs,
        lineWidth = _a.lineWidth,
        opacity = _a.opacity,
        strokeOpacity = _a.strokeOpacity,
        fillOpacity = _a.fillOpacity;

    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!(0, _util.isNil)(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = opacity;
        }

        this.stroke(context);
      }
    }

    if (this.isFill()) {
      if (!(0, _util.isNil)(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }

    this.afterDrawPath(context);
  }; // 


  Text.prototype.fill = function (context) {
    this._drawText(context, true);
  }; // 


  Text.prototype.stroke = function (context) {
    this._drawText(context, false);
  };

  return Text;
}(_base.default);

var _default = Text;
exports.default = _default;

/***/ }),
/* 921 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _hit = __webpack_require__(922);

var Shape = _interopRequireWildcard(__webpack_require__(148));

var _group = _interopRequireDefault(__webpack_require__(273));

var _util = __webpack_require__(54);

var _draw = __webpack_require__(149);

var Canvas =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Canvas, _super);

  function Canvas() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Canvas.prototype.getDefaultCfg = function () {
    var cfg = _super.prototype.getDefaultCfg.call(this); //  canvas


    cfg['renderer'] = 'canvas'; //  draw 

    cfg['autoDraw'] = true; // 

    cfg['localRefresh'] = true;
    cfg['refreshElements'] = []; // 

    cfg['clipView'] = true; //  false

    cfg['quickHit'] = false;
    return cfg;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Canvas.prototype.onCanvasChange = function (changeType) {
    /**
     *  changeType
     * 1. attr: 
     * 2. sort: 
     * 3. changeSize: 
     */
    if (changeType === 'attr' || changeType === 'sort' || changeType === 'changeSize') {
      this.set('refreshElements', [this]);
      this.draw();
    }
  };

  Canvas.prototype.getShapeBase = function () {
    return Shape;
  };

  Canvas.prototype.getGroupBase = function () {
    return _group.default;
  };
  /**
   * 
   */


  Canvas.prototype.getPixelRatio = function () {
    var pixelRatio = this.get('pixelRatio') || (0, _util.getPixelRatio)(); //  1  1 1 

    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };

  Canvas.prototype.getViewRange = function () {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  }; // 


  Canvas.prototype.createDom = function () {
    var element = document.createElement('canvas');
    var context = element.getContext('2d'); //  context 

    this.set('context', context);
    return element;
  };

  Canvas.prototype.setDOMSize = function (width, height) {
    _super.prototype.setDOMSize.call(this, width, height);

    var context = this.get('context');
    var el = this.get('el');
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height; //  canvas  context.scale 

    if (pixelRatio > 1) {
      context.scale(pixelRatio, pixelRatio);
    }
  }; // 


  Canvas.prototype.clear = function () {
    _super.prototype.clear.call(this);

    this._clearFrame(); // 


    var context = this.get('context');
    var element = this.get('el');
    context.clearRect(0, 0, element.width, element.height);
  };

  Canvas.prototype.getShape = function (x, y) {
    var shape;

    if (this.get('quickHit')) {
      shape = (0, _hit.getShape)(this, x, y);
    } else {
      shape = _super.prototype.getShape.call(this, x, y, null);
    }

    return shape;
  }; // 


  Canvas.prototype._getRefreshRegion = function () {
    var elements = this.get('refreshElements');
    var viewRegion = this.getViewRange();
    var region; // 

    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = (0, _draw.getMergedRegion)(elements);

      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1; // 

        var clipView = this.get('clipView'); //  view 

        if (clipView) {
          region = (0, _draw.mergeView)(region, viewRegion);
        }
      }
    }

    return region;
  };
  /**
   * 
   * @param {IElement} element 
   */


  Canvas.prototype.refreshElement = function (element) {
    var refreshElements = this.get('refreshElements');
    refreshElements.push(element); // if (this.get('autoDraw')) {
    //   this._startDraw();
    // }
  }; // 


  Canvas.prototype._clearFrame = function () {
    var drawFrame = this.get('drawFrame');

    if (drawFrame) {
      // 
      (0, _util.clearAnimationFrame)(drawFrame);
      this.set('drawFrame', null);
      this.set('refreshElements', []);
    }
  }; // 


  Canvas.prototype.draw = function () {
    var drawFrame = this.get('drawFrame');

    if (this.get('autoDraw') && drawFrame) {
      return;
    }

    this._startDraw();
  }; // 


  Canvas.prototype._drawAll = function () {
    var context = this.get('context');
    var element = this.get('el');
    var children = this.getChildren();
    context.clearRect(0, 0, element.width, element.height);
    (0, _draw.applyAttrsToContext)(context, this);
    (0, _draw.drawChildren)(context, children); //  https://github.com/antvis/g/issues/422 

    this.set('refreshElements', []);
  }; // 


  Canvas.prototype._drawRegion = function () {
    var context = this.get('context');
    var refreshElements = this.get('refreshElements');
    var children = this.getChildren();

    var region = this._getRefreshRegion(); //  region 
    //  localRefresh , draw


    if (region) {
      // 
      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY); //  clip

      context.save();
      context.beginPath();
      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.clip();
      (0, _draw.applyAttrsToContext)(context, this); //  10 10W  group  90ms  5-6 ms

      (0, _draw.checkRefresh)(this, children, region); // 

      (0, _draw.drawChildren)(context, children, region);
      context.restore();
    } else if (refreshElements.length) {
      //  elements  region 
      // 1.  group
      // 2.  elements 
      // 3. group  elements 
      //  hasChanged 
      (0, _draw.clearChanged)(refreshElements);
    }

    (0, _util.each)(refreshElements, function (element) {
      if (element.get('hasChanged')) {
        //  Group  draw()  hasChanged 
        //  hasChanged  Group 
        element.set('hasChanged', false);
      }
    });
    this.set('refreshElements', []);
  }; // 


  Canvas.prototype._startDraw = function () {
    var _this = this;

    var drawFrame = this.get('drawFrame');

    if (!drawFrame) {
      drawFrame = (0, _util.requestAnimationFrame)(function () {
        if (_this.get('localRefresh')) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }

        _this.set('drawFrame', null);
      });
      this.set('drawFrame', drawFrame);
    }
  };

  Canvas.prototype.skipDraw = function () {};

  return Canvas;
}(_gBase.AbstractCanvas);

var _default = Canvas;
exports.default = _default;

/***/ }),
/* 922 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getShape = getShape;

var _gBase = __webpack_require__(27);

function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = (0, _gBase.invert)(matrix);
    return (0, _gBase.multiplyVec2)(invertMatrix, v);
  }

  return v;
}

function getRefXY(element, x, y) {
  // @ts-ignore
  var totalMatrix = element.getTotalMatrix();

  if (totalMatrix) {
    var _a = invertFromMatrix([x, y, 1], totalMatrix),
        refX = _a[0],
        refY = _a[1];

    return [refX, refY];
  }

  return [x, y];
} // 


function preTest(element, x, y) {
  // @ts-ignore
  if (element.isCanvas && element.isCanvas()) {
    return true;
  } //  null
  // @ts-ignore


  if (!(0, _gBase.isAllowCapture)(element) || element.cfg.isInView === false) {
    return false;
  }

  if (element.cfg.clipShape) {
    //  clip
    var _a = getRefXY(element, x, y),
        refX = _a[0],
        refY = _a[1];

    if (element.isClipped(refX, refY)) {
      return false;
    }
  } // @ts-ignore 


  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox(); //  bbox
  //  const bbox = element.cfg.cacheCanvasBBox;
  // / isInView 
  //  element.getCanvasBBox(); 
  // if (!bbox) {
  //   return false;
  // }

  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }

  return true;
} //  g-base  getShape


function getShape(container, x, y) {
  //  null
  if (!preTest(container, x, y)) {
    return null;
  }

  var shape = null;
  var children = container.getChildren();
  var count = children.length;

  for (var i = count - 1; i >= 0; i--) {
    var child = children[i];

    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;

      var _a = getRefXY(child, x, y),
          refX = _a[0],
          refY = _a[1]; // @ts-ignore


      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }

    if (shape) {
      break;
    }
  }

  return shape;
}

/***/ }),
/* 923 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview circle
 * @author dengfuping_develop@163.com
 */
var Circle =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Circle, _super);

  function Circle() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'circle';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Circle.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      r: 0
    });
  };

  Circle.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      //  x, y cx, cy
      if (attr === 'x' || attr === 'y') {
        el.setAttribute("c" + attr, value);
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Circle;
}(_base.default);

var _default = Circle;
exports.default = _default;

/***/ }),
/* 924 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview dom
 * @author dengfuping_develop@163.com
 */
var Dom =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Dom, _super);

  function Dom() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'dom';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  Dom.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });

    if (typeof attrs['html'] === 'function') {
      var element = attrs['html'].call(this, attrs);

      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;

        for (var i = children.length - 1; i >= 0; i--) {
          el.removeChild(children[i]);
        }

        el.appendChild(element); // append to el if it's an element
      } else {
        el.innerHTML = element; // set innerHTML
      }
    } else {
      el.innerHTML = attrs['html']; // set innerHTML
    }
  };

  return Dom;
}(_base.default);

var _default = Dom;
exports.default = _default;

/***/ }),
/* 925 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview ellipse
 * @author dengfuping_develop@163.com
 */
var Ellipse =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Ellipse, _super);

  function Ellipse() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'ellipse';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Ellipse.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      rx: 0,
      ry: 0
    });
  };

  Ellipse.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      //  x, y cx, cy
      if (attr === 'x' || attr === 'y') {
        el.setAttribute("c" + attr, value);
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Ellipse;
}(_base.default);

var _default = Ellipse;
exports.default = _default;

/***/ }),
/* 926 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview image
 * @author dengfuping_develop@163.com
 */
var Image =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Image, _super);

  function Image() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'image';
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }

  Image.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    });
  };

  Image.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'img') {
        _this._setImage(attrs.img);
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Image.prototype.setAttr = function (name, value) {
    this.attrs[name] = value;

    if (name === 'img') {
      this._setImage(value);
    }
  };

  Image.prototype._setImage = function (img) {
    var attrs = this.attr();
    var el = this.get('el');

    if ((0, _util.isString)(img)) {
      el.setAttribute('href', img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute('width', img.width);
        this.attr('width', img.width);
      }

      if (!attrs.height) {
        el.setAttribute('height', img.height);
        this.attr('height', img.height);
      }

      el.setAttribute('href', img.src);
    } else if (img instanceof HTMLElement && (0, _util.isString)(img.nodeName) && img.nodeName.toUpperCase() === 'CANVAS') {
      // @ts-ignore
      el.setAttribute('href', img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement('canvas');
      canvas.setAttribute('width', "" + img.width);
      canvas.setAttribute('height', "" + img.height);
      canvas.getContext('2d').putImageData(img, 0, 0);

      if (!attrs.width) {
        el.setAttribute('width', "" + img.width);
        this.attr('width', img.width);
      }

      if (!attrs.height) {
        el.setAttribute('height', "" + img.height);
        this.attr('height', img.height);
      }

      el.setAttribute('href', canvas.toDataURL());
    }
  };

  return Image;
}(_base.default);

var _default = Image;
exports.default = _default;

/***/ }),
/* 927 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gMath = __webpack_require__(35);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview line
 * @author dengfuping_develop@163.com
 */
var Line =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Line, _super);

  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'line';
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }

  Line.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      startArrow: false,
      endArrow: false
    });
  };

  Line.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'startArrow' || attr === 'endArrow') {
        if (value) {
          var id = (0, _util.isObject)(value) ? context.addArrow(attrs, _constant.SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, _constant.SVG_ATTR_MAP[attr]);
          el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(_constant.SVG_ATTR_MAP[attr]);
        }
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };
  /**
   * Use math calculation to get length of line
   * @return {number} length
   */


  Line.prototype.getTotalLength = function () {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return _gMath.Line.length(x1, y1, x2, y2);
  };
  /**
   * Use math calculation to get point according to ratio as same sa Canvas version
   * @param {number} ratio
   * @return {Point} point
   */


  Line.prototype.getPoint = function (ratio) {
    var _a = this.attr(),
        x1 = _a.x1,
        y1 = _a.y1,
        x2 = _a.x2,
        y2 = _a.y2;

    return _gMath.Line.pointAt(x1, y1, x2, y2, ratio);
  };

  return Line;
}(_base.default);

var _default = Line;
exports.default = _default;

/***/ }),
/* 928 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(64));

var _symbols = _interopRequireDefault(__webpack_require__(929));

/**
 * @fileoverview marker
 * @author dengfuping_develop@163.com
 */
var Marker =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Marker, _super);

  function Marker() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'marker';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Marker.prototype.createPath = function (context) {
    var el = this.get('el');
    el.setAttribute('d', this._assembleMarker());
  };

  Marker.prototype._assembleMarker = function () {
    var d = this._getPath();

    if ((0, _util.isArray)(d)) {
      return d.map(function (path) {
        return path.join(' ');
      }).join('');
    }

    return d;
  };

  Marker.prototype._getPath = function () {
    var attrs = this.attr();
    var x = attrs.x,
        y = attrs.y; //  r  radius  r

    var r = attrs.r || attrs.radius;
    var symbol = attrs.symbol || 'circle';
    var method;

    if ((0, _util.isFunction)(symbol)) {
      method = symbol;
    } else {
      method = _symbols.default.get(symbol);
    }

    if (!method) {
      console.warn(method + " symbol is not exist.");
      return null;
    }

    return method(x, y, r);
  }; // 


  Marker.symbolsFactory = _symbols.default;
  return Marker;
}(_base.default);

var _default = Marker;
exports.default = _default;

/***/ }),
/* 929 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var Symbols = {
  // 
  circle: function circle(x, y, r) {
    return [['M', x, y], ['m', -r, 0], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0]];
  },
  // 
  square: function square(x, y, r) {
    return [['M', x - r, y - r], ['L', x + r, y - r], ['L', x + r, y + r], ['L', x - r, y + r], ['Z']];
  },
  // 
  diamond: function diamond(x, y, r) {
    return [['M', x - r, y], ['L', x, y - r], ['L', x + r, y], ['L', x, y + r], ['Z']];
  },
  // 
  triangle: function triangle(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y + diffY], ['L', x, y - diffY], ['L', x + r, y + diffY], ['z']];
  },
  // 
  triangleDown: function triangleDown(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [['M', x - r, y - diffY], ['L', x + r, y - diffY], ['L', x, y + diffY], ['Z']];
  }
};
var _default = {
  get: function get(type) {
    return Symbols[type];
  },
  register: function register(type, func) {
    Symbols[type] = func;
  },
  remove: function remove(type) {
    delete Symbols[type];
  },
  getAll: function getAll() {
    return Symbols;
  }
};
exports.default = _default;

/***/ }),
/* 930 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

var Path =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Path, _super);

  function Path() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'path';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Path.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  };

  Path.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'path' && (0, _util.isArray)(value)) {
        el.setAttribute('d', _this._formatPath(value));
      } else if (attr === 'startArrow' || attr === 'endArrow') {
        if (value) {
          var id = (0, _util.isObject)(value) ? context.addArrow(attrs, _constant.SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, _constant.SVG_ATTR_MAP[attr]);
          el.setAttribute(_constant.SVG_ATTR_MAP[attr], "url(#" + id + ")");
        } else {
          el.removeAttribute(_constant.SVG_ATTR_MAP[attr]);
        }
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Path.prototype._formatPath = function (value) {
    var newValue = value.map(function (path) {
      return path.join(' ');
    }).join('');

    if (~newValue.indexOf('NaN')) {
      return '';
    }

    return newValue;
  };
  /**
   * Get total length of path
   *  SVGPathElement.getTotalLength()  path 
   *  Canvas 
   * @return {number} length
   */


  Path.prototype.getTotalLength = function () {
    var el = this.get('el');
    return el ? el.getTotalLength() : null;
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Path.prototype.getPoint = function (ratio) {
    var el = this.get('el');
    var totalLength = this.getTotalLength(); // @see https://github.com/antvis/g/issues/634

    if (totalLength === 0) {
      return null;
    }

    var point = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point ? {
      x: point.x,
      y: point.y
    } : null;
  };

  return Path;
}(_base.default);

var _default = Path;
exports.default = _default;

/***/ }),
/* 931 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview polygon
 * @author dengfuping_develop@163.com
 */
var Polygon =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Polygon, _super);

  function Polygon() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'polygon';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Polygon.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'points' && (0, _util.isArray)(value) && value.length >= 2) {
        el.setAttribute('points', value.map(function (point) {
          return point[0] + "," + point[1];
        }).join(' '));
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  return Polygon;
}(_base.default);

var _default = Polygon;
exports.default = _default;

/***/ }),
/* 932 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gMath = __webpack_require__(35);

var _util = __webpack_require__(0);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

var Polyline =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Polyline, _super);

  function Polyline() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'polyline';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Polyline.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      startArrow: false,
      endArrow: false
    });
  }; //  points


  Polyline.prototype.onAttrChange = function (name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);

    if (['points'].indexOf(name) !== -1) {
      this._resetCache();
    }
  };

  Polyline.prototype._resetCache = function () {
    this.set('totalLength', null);
    this.set('tCache', null);
  };

  Polyline.prototype.createPath = function (context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get('el');
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'points' && (0, _util.isArray)(value) && value.length >= 2) {
        el.setAttribute('points', value.map(function (point) {
          return point[0] + "," + point[1];
        }).join(' '));
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };
  /**
   * Get length of polyline
   * @return {number} length
   */


  Polyline.prototype.getTotalLength = function () {
    var points = this.attr().points; // get totalLength from cache

    var totalLength = this.get('totalLength');

    if (!(0, _util.isNil)(totalLength)) {
      return totalLength;
    }

    this.set('totalLength', _gMath.Polyline.length(points));
    return this.get('totalLength');
  };
  /**
   * Get point according to ratio
   * @param {number} ratio
   * @return {Point} point
   */


  Polyline.prototype.getPoint = function (ratio) {
    var points = this.attr().points; // get tCache from cache

    var tCache = this.get('tCache');

    if (!tCache) {
      this._setTcache();

      tCache = this.get('tCache');
    }

    var subt;
    var index;
    (0, _util.each)(tCache, function (v, i) {
      if (ratio >= v[0] && ratio <= v[1]) {
        subt = (ratio - v[0]) / (v[1] - v[0]);
        index = i;
      }
    });
    return _gMath.Line.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };

  Polyline.prototype._setTcache = function () {
    var points = this.attr().points;

    if (!points || points.length === 0) {
      return;
    }

    var totalLength = this.getTotalLength();

    if (totalLength <= 0) {
      return;
    }

    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    (0, _util.each)(points, function (p, i) {
      if (points[i + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = _gMath.Line.length(p[0], p[1], points[i + 1][0], points[i + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set('tCache', tCache);
  };
  /**
   * Get start tangent vector
   * @return {Array}
   */


  Polyline.prototype.getStartTangent = function () {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  /**
   * Get end tangent vector
   * @return {Array}
   */


  Polyline.prototype.getEndTangent = function () {
    var points = this.attr().points;
    var l = points.length - 1;
    var result = [];
    result.push([points[l - 1][0], points[l - 1][1]]);
    result.push([points[l][0], points[l][1]]);
    return result;
  };

  return Polyline;
}(_base.default);

var _default = Polyline;
exports.default = _default;

/***/ }),
/* 933 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = _interopRequireDefault(__webpack_require__(64));

var _constant = __webpack_require__(55);

var _format = __webpack_require__(934);

/**
 * @fileoverview rect
 * @author dengfuping_develop@163.com
 */
var Rect =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Rect, _super);

  function Rect() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'rect';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Rect.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      radius: 0
    });
  };

  Rect.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el'); //  path 

    var completed = false; //  path 

    var pathRelatedAttrs = ['x', 'y', 'width', 'height', 'radius'];
    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute('d', _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && _constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
  };

  Rect.prototype._assembleRect = function (attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    var radius = attrs.radius;

    if (!radius) {
      return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
    }

    var r = (0, _format.parseRadius)(radius);

    if ((0, _util.isArray)(radius)) {
      if (radius.length === 1) {
        r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
      } else if (radius.length === 2) {
        r.r1 = r.r3 = radius[0];
        r.r2 = r.r4 = radius[1];
      } else if (radius.length === 3) {
        r.r1 = radius[0];
        r.r2 = r.r4 = radius[1];
        r.r3 = radius[2];
      } else {
        r.r1 = radius[0];
        r.r2 = radius[1];
        r.r3 = radius[2];
        r.r4 = radius[3];
      }
    } else {
      r.r1 = r.r2 = r.r3 = r.r4 = radius;
    }

    var d = [["M " + (x + r.r1) + "," + y], ["l " + (w - r.r1 - r.r2) + ",0"], ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2], ["l 0," + (h - r.r2 - r.r3)], ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3], ["l " + (r.r3 + r.r4 - w) + ",0"], ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4], ["l 0," + (r.r4 + r.r1 - h)], ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1], ['z']];
    return d.join(' ');
  };

  return Rect;
}(_base.default);

var _default = Rect;
exports.default = _default;

/***/ }),
/* 934 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseRadius = parseRadius;
exports.parsePath = parsePath;

var _util = __webpack_require__(0);

var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/gi;
var regexDot = /[^\s,]+/gi;

function parseRadius(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;

  if ((0, _util.isArray)(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }

  return {
    r1: r1,
    r2: r2,
    r3: r3,
    r4: r4
  };
}

function parsePath(path) {
  path = path || [];

  if ((0, _util.isArray)(path)) {
    return path;
  }

  if ((0, _util.isString)(path)) {
    path = path.match(regexTags);
    (0, _util.each)(path, function (item, index) {
      item = item.match(regexDot);

      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }

      (0, _util.each)(item, function (sub, i) {
        if (!isNaN(sub)) {
          item[i] = +sub;
        }
      });
      path[index] = item;
    });
    return path;
  }
}

/***/ }),
/* 935 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _detectBrowser = __webpack_require__(239);

var _svg = __webpack_require__(150);

var _constant = __webpack_require__(55);

var _base = _interopRequireDefault(__webpack_require__(64));

/**
 * @fileoverview text
 * @author dengfuping_develop@163.com
 */
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: 'before-edge',
  middle: 'central',
  bottom: 'after-edge',
  alphabetic: 'baseline',
  hanging: 'hanging'
}; // for FireFox

var BASELINE_MAP_FOR_FIREFOX = {
  top: 'text-before-edge',
  middle: 'central',
  bottom: 'text-after-edge',
  alphabetic: 'alphabetic',
  hanging: 'hanging'
};
var ANCHOR_MAP = {
  left: 'left',
  start: 'left',
  center: 'middle',
  right: 'end',
  end: 'end'
};

var Text =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Text, _super);

  function Text() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.type = 'text';
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }

  Text.prototype.getDefaultAttrs = function () {
    var attrs = _super.prototype.getDefaultAttrs.call(this);

    return (0, _tslib.__assign)((0, _tslib.__assign)({}, attrs), {
      x: 0,
      y: 0,
      text: null,
      fontSize: 12,
      fontFamily: 'sans-serif',
      fontStyle: 'normal',
      fontWeight: 'normal',
      fontVariant: 'normal',
      textAlign: 'start',
      textBaseline: 'bottom'
    });
  };

  Text.prototype.createPath = function (context, targetAttrs) {
    var _this = this;

    var attrs = this.attr();
    var el = this.get('el');

    this._setFont();

    (0, _util.each)(targetAttrs || attrs, function (value, attr) {
      if (attr === 'text') {
        _this._setText("" + value);
      } else if (attr === 'matrix' && value) {
        (0, _svg.setTransform)(_this);
      } else if (_constant.SVG_ATTR_MAP[attr]) {
        el.setAttribute(_constant.SVG_ATTR_MAP[attr], value);
      }
    });
    el.setAttribute('paint-order', 'stroke');
    el.setAttribute('style', 'stroke-linecap:butt; stroke-linejoin:miter;');
  };

  Text.prototype._setFont = function () {
    var el = this.get('el');

    var _a = this.attr(),
        textBaseline = _a.textBaseline,
        textAlign = _a.textAlign;

    var browser = (0, _detectBrowser.detect)();

    if (browser && browser.name === 'firefox') {
      // compatible with FireFox browser, ref: https://github.com/antvis/g/issues/119
      el.setAttribute('dominant-baseline', BASELINE_MAP_FOR_FIREFOX[textBaseline] || 'alphabetic');
    } else {
      el.setAttribute('alignment-baseline', BASELINE_MAP[textBaseline] || 'baseline');
    }

    el.setAttribute('text-anchor', ANCHOR_MAP[textAlign] || 'left');
  };

  Text.prototype._setText = function (text) {
    var el = this.get('el');

    var _a = this.attr(),
        x = _a.x,
        _b = _a.textBaseline,
        baseline = _b === void 0 ? 'bottom' : _b;

    if (!text) {
      el.innerHTML = '';
    } else if (~text.indexOf('\n')) {
      var textArr = text.split('\n');
      var textLen_1 = textArr.length - 1;
      var arr_1 = '';
      (0, _util.each)(textArr, function (segment, i) {
        if (i === 0) {
          if (baseline === 'alphabetic') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -textLen_1 + "em\">" + segment + "</tspan>";
          } else if (baseline === 'top') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"0.9em\">" + segment + "</tspan>";
          } else if (baseline === 'middle') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + -(textLen_1 - 1) / 2 + "em\">" + segment + "</tspan>";
          } else if (baseline === 'bottom') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"-" + (textLen_1 + LETTER_SPACING) + "em\">" + segment + "</tspan>";
          } else if (baseline === 'hanging') {
            arr_1 += "<tspan x=\"" + x + "\" dy=\"" + (-(textLen_1 - 1) - LETTER_SPACING) + "em\">" + segment + "</tspan>";
          }
        } else {
          arr_1 += "<tspan x=\"" + x + "\" dy=\"1em\">" + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text;
    }
  };

  return Text;
}(_base.default);

var _default = Text;
exports.default = _default;

/***/ }),
/* 936 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = __webpack_require__(1);

var _gBase = __webpack_require__(27);

var _constant = __webpack_require__(55);

var _draw = __webpack_require__(274);

var _svg = __webpack_require__(150);

var _dom = __webpack_require__(72);

var Shape = _interopRequireWildcard(__webpack_require__(192));

var _group = _interopRequireDefault(__webpack_require__(275));

var _defs = _interopRequireDefault(__webpack_require__(937));

var Canvas =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Canvas, _super);

  function Canvas(cfg) {
    return _super.call(this, (0, _tslib.__assign)((0, _tslib.__assign)({}, cfg), {
      autoDraw: true,
      //  canvas
      renderer: 'svg'
    })) || this;
  }

  Canvas.prototype.getShapeBase = function () {
    return Shape;
  };

  Canvas.prototype.getGroupBase = function () {
    return _group.default;
  }; //  Container  shape  SVG  dom 


  Canvas.prototype.getShape = function (x, y, ev) {
    var target = ev.target || ev.srcElement;

    if (!_constant.SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;

      while (parent_1 && !_constant.SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }

      target = parent_1;
    }

    return this.find(function (child) {
      return child.get('el') === target;
    });
  }; // 


  Canvas.prototype.createDom = function () {
    var element = (0, _dom.createSVGElement)('svg');
    var context = new _defs.default(element);
    element.setAttribute('width', "" + this.get('width'));
    element.setAttribute('height', "" + this.get('height')); //  context 

    this.set('context', context);
    return element;
  };
  /**
   * 
   * @param {ChangeType} changeType 
   */


  Canvas.prototype.onCanvasChange = function (changeType) {
    var context = this.get('context');
    var el = this.get('el');

    if (changeType === 'sort') {
      var children_1 = this.get('children');

      if (children_1 && children_1.length) {
        (0, _dom.sortDom)(this, function (a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === 'clear') {
      // el maybe null for canvas
      if (el) {
        //  SVG 
        el.innerHTML = '';
        var defsEl = context.el; //  defs 

        defsEl.innerHTML = ''; //  defs  el 

        el.appendChild(defsEl);
      }
    } else if (changeType === 'matrix') {
      (0, _svg.setTransform)(this);
    } else if (changeType === 'clip') {
      (0, _svg.setClip)(this, context);
    } else if (changeType === 'changeSize') {
      el.setAttribute('width', "" + this.get('width'));
      el.setAttribute('height', "" + this.get('height'));
    }
  }; //  draw 


  Canvas.prototype.draw = function () {
    var context = this.get('context');
    var children = this.getChildren();
    (0, _svg.setClip)(this, context);

    if (children.length) {
      (0, _draw.drawChildren)(context, children);
    }
  };

  return Canvas;
}(_gBase.AbstractCanvas);

var _default = Canvas;
exports.default = _default;

/***/ }),
/* 937 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _gradient = _interopRequireDefault(__webpack_require__(938));

var _shadow = _interopRequireDefault(__webpack_require__(939));

var _arrow = _interopRequireDefault(__webpack_require__(940));

var _clip = _interopRequireDefault(__webpack_require__(941));

var _pattern = _interopRequireDefault(__webpack_require__(942));

var _dom = __webpack_require__(72);

/**
 * @fileoverview defs
 * @author dengfuping_develop@163.com
 */
var Defs =
/** @class */
function () {
  function Defs(canvas) {
    var el = (0, _dom.createSVGElement)('defs');
    var id = (0, _util.uniqueId)('defs_');
    el.id = id;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }

  Defs.prototype.find = function (type, attr) {
    var children = this.children;
    var result = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].match(type, attr)) {
        result = children[i].id;
        break;
      }
    }

    return result;
  };

  Defs.prototype.findById = function (id) {
    var children = this.children;
    var flag = null;

    for (var i = 0; i < children.length; i++) {
      if (children[i].id === id) {
        flag = children[i];
        break;
      }
    }

    return flag;
  };

  Defs.prototype.add = function (item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };

  Defs.prototype.getDefaultArrow = function (attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;

    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }

    var arrow = new _arrow.default(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };

  Defs.prototype.addGradient = function (cfg) {
    var gradient = new _gradient.default(cfg);
    this.el.appendChild(gradient.el);
    this.add(gradient);
    return gradient.id;
  };

  Defs.prototype.addArrow = function (attrs, name) {
    var arrow = new _arrow.default(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };

  Defs.prototype.addShadow = function (cfg) {
    var shadow = new _shadow.default(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };

  Defs.prototype.addPattern = function (cfg) {
    var pattern = new _pattern.default(cfg);
    this.el.appendChild(pattern.el);
    this.add(pattern);
    return pattern.id;
  };

  Defs.prototype.addClip = function (cfg) {
    var clip = new _clip.default(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };

  return Defs;
}();

var _default = Defs;
exports.default = _default;

/***/ }),
/* 938 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _dom = __webpack_require__(72);

/**
 * @fileoverview gradient
 * @author dengfuping_develop@163.com
 */
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;

function addStop(steps) {
  var arr = steps.match(regexColorStop);

  if (!arr) {
    return '';
  }

  var stops = '';
  arr.sort(function (a, b) {
    a = a.split(':');
    b = b.split(':');
    return Number(a[0]) - Number(b[0]);
  });
  (0, _util.each)(arr, function (item) {
    item = item.split(':');
    stops += "<stop offset=\"" + item[0] + "\" stop-color=\"" + item[1] + "\"></stop>";
  });
  return stops;
}

function parseLineGradient(color, el) {
  var arr = regexLG.exec(color);
  var angle = (0, _util.mod)((0, _util.toRadian)(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;

  if (angle >= 0 && angle < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }

  var tanTheta = Math.tan(angle);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute('x1', start.x);
  el.setAttribute('y1', start.y);
  el.setAttribute('x2', x);
  el.setAttribute('y2', y);
  el.innerHTML = addStop(steps);
}

function parseRadialGradient(color, self) {
  var arr = regexRG.exec(color);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self.setAttribute('cx', cx);
  self.setAttribute('cy', cy);
  self.setAttribute('r', r);
  self.innerHTML = addStop(steps);
}

var Gradient =
/** @class */
function () {
  function Gradient(cfg) {
    this.cfg = {};
    var el = null;
    var id = (0, _util.uniqueId)('gradient_');

    if (cfg.toLowerCase()[0] === 'l') {
      el = (0, _dom.createSVGElement)('linearGradient');
      parseLineGradient(cfg, el);
    } else {
      el = (0, _dom.createSVGElement)('radialGradient');
      parseRadialGradient(cfg, el);
    }

    el.setAttribute('id', id);
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    return this;
  }

  Gradient.prototype.match = function (type, attr) {
    return this.cfg === attr;
  };

  return Gradient;
}();

var _default = Gradient;
exports.default = _default;

/***/ }),
/* 939 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _dom = __webpack_require__(72);

/**
 * @fileoverview shadow
 * @author dengfuping_develop@163.com
 */
var ATTR_MAP = {
  shadowColor: 'color',
  shadowOpacity: 'opacity',
  shadowBlur: 'blur',
  shadowOffsetX: 'dx',
  shadowOffsetY: 'dy'
};
var SHADOW_DIMENSION = {
  x: '-40%',
  y: '-40%',
  width: '200%',
  height: '200%'
};

var Shadow =
/** @class */
function () {
  function Shadow(cfg) {
    this.type = 'filter';
    this.cfg = {};
    this.type = 'filter';
    var el = (0, _dom.createSVGElement)('filter'); // expand the filter region to fill in shadows

    (0, _util.each)(SHADOW_DIMENSION, function (v, k) {
      el.setAttribute(k, v);
    });
    this.el = el;
    this.id = (0, _util.uniqueId)('filter_');
    this.el.id = this.id;
    this.cfg = cfg;

    this._parseShadow(cfg, el);

    return this;
  }

  Shadow.prototype.match = function (type, cfg) {
    if (this.type !== type) {
      return false;
    }

    var flag = true;
    var config = this.cfg;
    (0, _util.each)(Object.keys(config), function (attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };

  Shadow.prototype.update = function (name, value) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value;

    this._parseShadow(config, this.el);

    return this;
  };

  Shadow.prototype._parseShadow = function (config, el) {
    var child = "<feDropShadow\n      dx=\"" + (config.dx || 0) + "\"\n      dy=\"" + (config.dy || 0) + "\"\n      stdDeviation=\"" + (config.blur ? config.blur / 10 : 0) + "\"\n      flood-color=\"" + (config.color ? config.color : '#000') + "\"\n      flood-opacity=\"" + (config.opacity ? config.opacity : 1) + "\"\n      />";
    el.innerHTML = child;
  };

  return Shadow;
}();

var _default = Shadow;
exports.default = _default;

/***/ }),
/* 940 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _dom = __webpack_require__(72);

/**
 * @fileoverview arrow
 * @author dengfuping_develop@163.com
 */
var Arrow =
/** @class */
function () {
  function Arrow(attrs, type) {
    this.cfg = {};
    var el = (0, _dom.createSVGElement)('marker');
    var id = (0, _util.uniqueId)('marker_');
    el.setAttribute('id', id);
    var shape = (0, _dom.createSVGElement)('path');
    shape.setAttribute('stroke', attrs.stroke || 'none');
    shape.setAttribute('fill', attrs.fill || 'none');
    el.appendChild(shape);
    el.setAttribute('overflow', 'visible');
    el.setAttribute('orient', 'auto-start-reverse');
    this.el = el;
    this.child = shape;
    this.id = id;
    var cfg = attrs[type === 'marker-start' ? 'startArrow' : 'endArrow'];
    this.stroke = attrs.stroke || '#000';

    if (cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this.cfg = cfg; // when arrow config exists

      this._setMarker(attrs.lineWidth, shape);
    }

    return this;
  }

  Arrow.prototype.match = function () {
    return false;
  };

  Arrow.prototype._setDefaultPath = function (type, el) {
    var parent = this.el; //  10 60 

    el.setAttribute('d', "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute('refX', "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute('refY', "" + 5);
  };

  Arrow.prototype._setMarker = function (r, el) {
    var parent = this.el;
    var path = this.cfg.path;
    var d = this.cfg.d;

    if ((0, _util.isArray)(path)) {
      path = path.map(function (segment) {
        return segment.join(' ');
      }).join('');
    }

    el.setAttribute('d', path);
    parent.appendChild(el);

    if (d) {
      parent.setAttribute('refX', "" + d / r);
    }
  };

  Arrow.prototype.update = function (fill) {
    var child = this.child;

    if (child.attr) {
      child.attr('fill', fill);
    } else {
      child.setAttribute('fill', fill);
    }
  };

  return Arrow;
}();

var _default = Arrow;
exports.default = _default;

/***/ }),
/* 941 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _dom = __webpack_require__(72);

/**
 * @fileoverview clip
 * @author dengfuping_develop@163.com
 */
var Clip =
/** @class */
function () {
  function Clip(cfg) {
    this.type = 'clip';
    this.cfg = {};
    var el = (0, _dom.createSVGElement)('clipPath');
    this.el = el;
    this.id = (0, _util.uniqueId)('clip_');
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }

  Clip.prototype.match = function () {
    return false;
  };

  Clip.prototype.remove = function () {
    var el = this.el;
    el.parentNode.removeChild(el);
  };

  return Clip;
}();

var _default = Clip;
exports.default = _default;

/***/ }),
/* 942 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _util = __webpack_require__(0);

var _dom = __webpack_require__(72);

/**
 * @fileoverview pattern
 * @author dengfuping_develop@163.com
 */
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;

var Pattern =
/** @class */
function () {
  function Pattern(cfg) {
    this.cfg = {};
    var el = (0, _dom.createSVGElement)('pattern');
    el.setAttribute('patternUnits', 'userSpaceOnUse');
    var child = (0, _dom.createSVGElement)('image');
    el.appendChild(child);
    var id = (0, _util.uniqueId)('pattern_');
    el.id = id;
    this.el = el;
    this.id = id;
    this.cfg = cfg;
    var arr = regexPR.exec(cfg);
    var source = arr[2];
    child.setAttribute('href', source);
    var img = new Image();

    if (!source.match(/^data:/i)) {
      img.crossOrigin = 'Anonymous';
    }

    img.src = source;

    function onload() {
      el.setAttribute('width', "" + img.width);
      el.setAttribute('height', "" + img.height);
    }

    if (img.complete) {
      onload();
    } else {
      img.onload = onload; // Fix onload() bug in IE9

      img.src = img.src;
    }

    return this;
  }

  Pattern.prototype.match = function (type, attr) {
    return this.cfg === attr;
  };

  return Pattern;
}();

var _default = Pattern;
exports.default = _default;

/***/ }),
/* 943 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var constant_1 = __webpack_require__(270);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(151);
/** Interval  shape  */


var IntervalShapeFactory = base_1.registerShapeFactory('interval', {
  defaultShapeType: 'rect',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return util_1.getRectPoints(pointInfo);
  }
});
/** Inerval  shape */

base_1.registerShape('interval', 'rect', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, false, true);
    var group = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;

    if (backgroundCfg) {
      group = container.addGroup();
      var backgroundStyle = get_style_1.getBackgroundRectStyle(cfg);
      var backgroundPath = util_1.getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group.addShape('path', {
        attrs: tslib_1.__assign(tslib_1.__assign({}, backgroundStyle), {
          path: backgroundPath
        }),
        zIndex: -1,
        name: constant_1.BACKGROUND_SHAPE
      });
    }

    var path;

    if (style.radius && this.coordinate.isRect) {
      path = util_1.getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
    } else {
      path = this.parsePath(util_1.getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
    }

    var shape = group.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      }),
      name: 'interval'
    });
    return backgroundCfg ? group : shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color,
        isInPolar = markerCfg.isInPolar;

    if (isInPolar) {
      return {
        symbol: 'circle',
        style: {
          r: 4.5,
          fill: color
        }
      };
    }

    return {
      symbol: 'square',
      style: {
        r: 4,
        fill: color
      }
    };
  }
});
exports.default = IntervalShapeFactory;

/***/ }),
/* 944 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var util_1 = __webpack_require__(0);

var marker_1 = __webpack_require__(147);

var base_1 = __webpack_require__(29);

var split_points_1 = __webpack_require__(278);

var util_2 = __webpack_require__(280);

var PointShapeFactory = base_1.registerShapeFactory('point', {
  defaultShapeType: 'hollow-circle',
  getDefaultPoints: function getDefaultPoints(pointInfo) {
    return split_points_1.splitPoints(pointInfo);
  }
});
util_1.each(util_2.SHAPES, function (shapeName) {
  //  shape  hollow-shape
  base_1.registerShape('point', "hollow-" + shapeName, {
    draw: function draw(cfg, container) {
      return util_2.drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function getMarker(markerCfg) {
      var color = markerCfg.color;
      return {
        symbol: marker_1.MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color,
          fill: null
        }
      };
    }
  });
});
exports.default = PointShapeFactory;

/***/ }),
/* 945 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(29);

var util_1 = __webpack_require__(100);
/**
 * 
 */


base_1.registerShape('area', 'line', {
  draw: function draw(cfg, container) {
    var attrs = util_1.getShapeAttrs(cfg, true, false, this);
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }

        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
      },
      style: {
        r: 5,
        stroke: color,
        fill: null
      }
    };
  }
});

/***/ }),
/* 946 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(29);

var util_1 = __webpack_require__(100);
/**
 * 
 */


base_1.registerShape('area', 'smooth', {
  draw: function draw(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = util_1.getShapeAttrs(cfg, false, true, this, util_1.getConstraint(coordinate));
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }

        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
      },
      style: {
        r: 5,
        fill: color
      }
    };
  }
});

/***/ }),
/* 947 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var base_1 = __webpack_require__(29);

var util_1 = __webpack_require__(100);
/**  */


base_1.registerShape('area', 'smooth-line', {
  draw: function draw(cfg, container) {
    var coordinate = this.coordinate;
    var attrs = util_1.getShapeAttrs(cfg, true, true, this, util_1.getConstraint(coordinate));
    var shape = container.addShape({
      type: 'path',
      attrs: attrs,
      name: 'area'
    });
    return shape;
  },
  getMarker: function getMarker(markerCfg) {
    var color = markerCfg.color;
    return {
      symbol: function symbol(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }

        return [['M', x - r, y - 4], ['L', x + r, y - 4], ['L', x + r, y + 4], ['L', x - r, y + 4], ['Z']];
      },
      style: {
        r: 5,
        stroke: color,
        fill: null
      }
    };
  }
});

/***/ }),
/* 948 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var graphics_1 = __webpack_require__(45);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(451);

function getArcShapePath(from, to, center) {
  var sub = util_1.getQPath(to, center);
  var path = [['M', from.x, from.y]];
  path.push(sub);
  return path;
}

function getArcShapeWeightPath(points, center) {
  var arc1 = util_1.getQPath(points[1], center);
  var arc2 = util_1.getQPath(points[3], center);
  var path = [['M', points[0].x, points[0].y]];
  path.push(arc2);
  path.push(['L', points[3].x, points[3].y]);
  path.push(['L', points[2].x, points[2].y]);
  path.push(arc1);
  path.push(['L', points[1].x, points[1].y]);
  path.push(['L', points[0].x, points[0].y]);
  path.push(['Z']);
  return path;
} // 


base_1.registerShape('edge', 'arc', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false, 'lineWidth');
    var points = cfg.points;
    var type = points.length > 2 ? 'weight' : 'normal';
    var path;

    if (cfg.isInCircle) {
      var center = {
        x: 0,
        y: 1
      };

      if (type === 'normal') {
        path = getArcShapePath(points[0], points[1], center);
      } else {
        style.fill = style.stroke;
        path = getArcShapeWeightPath(points, center);
      }

      path = this.parsePath(path);
      return container.addShape('path', {
        attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
          path: path
        })
      });
    } else {
      if (type === 'normal') {
        points = this.parsePoints(points);
        path = graphics_1.getArcPath((points[1].x + points[0].x) / 2, points[0].y, Math.abs(points[1].x - points[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape('path', {
          attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
            path: path
          })
        });
      } else {
        var c1 = util_1.getCPath(points[1], points[3]);
        var c2 = util_1.getCPath(points[2], points[0]);
        path = [['M', points[0].x, points[0].y], ['L', points[1].x, points[1].y], c1, ['L', points[3].x, points[3].y], ['L', points[2].x, points[2].y], c2, ['Z']];
        path = this.parsePath(path);
        style.fill = style.stroke;
        return container.addShape('path', {
          attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
            path: path
          })
        });
      }
    }
  },
  getMarker: function getMarker(markerCfg) {
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

/***/ }),
/* 949 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var util_1 = __webpack_require__(451);

function getSmoothPath(from, to) {
  var sub = util_1.getCPath(from, to);
  var path = [['M', from.x, from.y]];
  path.push(sub);
  return path;
}

base_1.registerShape('edge', 'smooth', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false, 'lineWidth');
    var points = cfg.points;
    var path = this.parsePath(getSmoothPath(points[0], points[1]));
    return container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      })
    });
  },
  getMarker: function getMarker(markerCfg) {
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

/***/ }),
/* 950 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = __webpack_require__(29);

var get_style_1 = __webpack_require__(40);

var CORNER_PERCENT = 1 / 3;

function getVHVPath(from, to) {
  var points = [];
  points.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points.push(to);
  var path = [['M', from.x, from.y]];
  util_1.each(points, function (point) {
    path.push(['L', point.x, point.y]);
  });
  return path;
}

base_1.registerShape('edge', 'vhv', {
  draw: function draw(cfg, container) {
    var style = get_style_1.getStyle(cfg, true, false, 'lineWidth');
    var points = cfg.points;
    var path = this.parsePath(getVHVPath(points[0], points[1]));
    return container.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, style), {
        path: path
      })
    });
  },
  getMarker: function getMarker(markerCfg) {
    return {
      symbol: 'circle',
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});

/***/ }),
/* 951 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pieOuterLabelLayout = void 0;

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);

var util_2 = __webpack_require__(463);
/** label textline 4px */


var MARGIN = 4;
/**
 *  labelline
 * @param item PolarLabelItem
 */

function drawLabelline(item
/** PolarLabelItem */
, coordinate) {
  /**  */
  var center = coordinate.getCenter();
  /**  */

  var radius = coordinate.getRadius();

  if (item && item.labelLine) {
    var angle = item.angle,
        labelOffset = item.offset; // 

    var startPoint = graphics_1.polarToCartesian(center.x, center.y, radius, angle);
    var itemX = item.x + util_1.get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);
    var itemY = item.y + util_1.get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle) * MARGIN,
      y: itemY - Math.sin(angle) * MARGIN
    };
    var smoothConnector = item.labelLine.smooth;
    var path = [];
    var dx = endPoint.x - center.x;
    var dy = endPoint.y - center.y;
    var endAngle = Math.atan(dy / dx); //  & 

    if (dx < 0) {
      endAngle += Math.PI;
    } //  smooth, undefined  smooth


    if (smoothConnector === false) {
      if (!util_1.isObject(item.labelLine)) {
        // labelLine: true
        item.labelLine = {};
      } // 0 , 1 


      var sweepFlag = 0; // 

      if (angle < 0 && angle > -Math.PI / 2 || angle > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      } // 


      if (angle >= 0 && angle < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      } // 


      if (angle >= Math.PI / 2 && angle < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      } // 


      if (angle < -Math.PI / 2 || angle >= Math.PI && angle < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }

      var distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = graphics_1.polarToCartesian(center.x, center.y, radius + distance, angle); // 

      var breakPoint3 = graphics_1.polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);
      /**
       * @example
       * M 100 100 L100 90 A 50 50 0 0 0 150 50
       *  (100, 100),  (100, 90),  (50, 50)  (150, 50);
       * A  4  large-arc-flag,  180 : 0 1 
       *  5 : 
       */
      // 

      var largeArcFlag = 0; // step1: 

      path.push("M " + startPoint.x + " " + startPoint.y); // step2: 

      path.push("L " + breakPoint.x + " " + breakPoint.y); // step3:   

      path.push("A " + center.x + " " + center.y + " 0 " + largeArcFlag + " " + sweepFlag + " " + breakPoint3.x + " " + breakPoint3.y); // step4: 

      path.push("L " + endPoint.x + " " + endPoint.y);
    } else {
      var breakPoint = graphics_1.polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle); // G2 
      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);

      var xSign = startPoint.x < center.x ? 1 : -1; // step1: 

      path.push("M " + endPoint.x + " " + endPoint.y);
      var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);
      var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);

      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        // step2:  curve line ( & , , )
        path.push.apply(path, ['C', endPoint.x + xSign * 4, endPoint.y, 2 * breakPoint.x - startPoint.x, 2 * breakPoint.y - startPoint.y, startPoint.x, startPoint.y]);
      } // step3: 


      path.push("L " + startPoint.x + " " + startPoint.y);
    }

    item.labelLine.path = path.join(' ');
  }
}
/**
 *  outer-label ,  type = pie  label offset > 0 
 */


function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var items = util_1.filter(originalItems, function (item) {
    return !util_1.isNil(item);
  });
  /**  */

  var coordinate = labels[0] && labels[0].get('coordinate');

  if (!coordinate) {
    return;
  }
  /**  */


  var center = coordinate.getCenter();
  /**  */

  var radius = coordinate.getRadius();
  /** label shapes */

  var labelsMap = {};

  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
    var labelShape = labels_1[_i];
    labelsMap[labelShape.get('id')] = labelShape;
  } // note labelHeight  label 


  var labelHeight = util_1.get(items[0], 'labelHeight', 14);
  var labelOffset = util_1.get(items[0], 'offset', 0);

  if (labelOffset <= 0) {
    return;
  }

  var LEFT_HALF_KEY = 'left';
  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels

  var separateLabels = util_1.groupBy(items, function (item) {
    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate.start,
      end = coordinate.end; // step2: calculate totalHeight

  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());
  var totalR = totalHeight / 2;
  /** labels () */

  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center.y - totalR,
    maxY: center.y + totalR
  }; // step 3: antiCollision

  util_1.each(separateLabels, function (half, key) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);

    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function (a, b) {
        // sort by percentage DESC
        return b.percent - a.percent;
      });
      util_1.each(half, function (labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set('visible', false);
          labelItem.invisible = true;
        }
      });
    }

    util_2.antiCollision(half, labelHeight, labelsContainerRange);
  });
  util_1.each(separateLabels, function (half, key) {
    util_1.each(half, function (item) {
      var isRight = key === RIGHT_HALF_KEY;
      var labelShape = labelsMap[item.id]; // because group could not effect content-shape, should set content-shape position manually

      var content = labelShape.getChildByIndex(0); // textShape 

      if (content) {
        var r = radius + labelOffset; // (x - cx)^2 + (y - cy)^2 = totalR^2

        var dy = item.y - center.y;
        var rPow2 = Math.pow(r, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r);

        if (!isRight) {
          // left
          item.x = center.x - Math.max(dx, dx_offset);
        } else {
          // right
          item.x = center.x + Math.max(dx, dx_offset);
        }
      } // adjust labelShape


      if (content) {
        content.attr('y', item.y);
        content.attr('x', item.x);
      }

      drawLabelline(item, coordinate);
    });
  });
}

exports.pieOuterLabelLayout = pieOuterLabelLayout;

/***/ }),
/* 952 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pieSpiderLabelLayout = void 0;

var util_1 = __webpack_require__(0);

var graphics_1 = __webpack_require__(45);

var util_2 = __webpack_require__(463);

var transform_1 = __webpack_require__(115);
/** ,  */


var INFLECTION_OFFSET = 4;
/** , distance between label and edge: offsetX */

var LABEL_OFFSET_X = 4;
/**  */

var LABEL_TEXT_LINE_OFFSET = 4;

function drawLabelline(item, coordinate, inRight) {
  /**  */
  var center = coordinate.getCenter();
  /**  */

  var radius = coordinate.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = graphics_1.polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = {
    x: startPoint.x,
    y: startPoint.y
  };
  var p2 = {
    x: inflectionPoint.x,
    y: inflectionPoint.y
  };
  var endPoint = graphics_1.polarToCartesian(center.x, center.y, radius, item.angle);
  var path = ''; // 

  if (startPoint.y !== inflectionPoint.y) {
    var offset = inRight ? 4 : -4;
    p1.y = startPoint.y;
    /**  */

    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);

      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    /**   */


    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);

      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    /**   */


    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);

      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
    /**   */


    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);

      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
  }

  path = ["M " + startPoint.x + "," + startPoint.y, "L " + p1.x + "," + p1.y, "L " + p2.x + "," + p2.y, "L " + inflectionPoint.x + "," + inflectionPoint.y, "L " + endPoint.x + "," + endPoint.y].join(' ');
  item.labelLine = util_1.deepMix({}, item.labelLine, {
    path: path
  });
}
/**
 *  spider ,  pie-spider 
 * region  labelsRenderer ()
 */


function pieSpiderLabelLayout(items, labels, shapes, region) {
  /**  */
  var coordinate = labels[0] && labels[0].get('coordinate');

  if (!coordinate) {
    return;
  }
  /**  */


  var center = coordinate.getCenter();
  /**  */

  var radius = coordinate.getRadius();
  /** label shapes */

  var labelsMap = {};

  for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
    var labelShape = labels_1[_i];
    labelsMap[labelShape.get('id')] = labelShape;
  }

  var labelHeight = util_1.get(items[0], 'labelHeight', 14);
  var labelOffset = Math.max(util_1.get(items[0], 'offset', 0), INFLECTION_OFFSET); // step 1: adjust items to spider

  util_1.each(items, function (item) {
    var label = util_1.get(labelsMap, item.id);

    if (!label) {
      return;
    }

    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;
    var offsetX = !util_1.isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = graphics_1.polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate.start,
      end = coordinate.end;
  var LEFT_HALF_KEY = 'left';
  var RIGHT_HALF_KEY = 'right'; // step 1: separate labels

  var seperateLabels = util_1.groupBy(items, function (item) {
    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  }); // step2: calculate totalHeight

  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  util_1.each(seperateLabels, function (half) {
    var halfHeight = half.length * labelHeight;

    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  /** labels () */

  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center.y - totalHeight / 2,
    maxY: center.y + totalHeight / 2
  }; // step 3: antiCollision

  util_1.each(seperateLabels, function (half, key) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;

    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function (a, b) {
        // sort by percentage DESC
        return b.percent - a.percent;
      });
      util_1.each(half, function (labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set('visible', false);
          labelItem.invisible = true;
        }
      });
    }

    util_2.antiCollision(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY; // step4: applyTo labels and adjust labelLines

  util_1.each(seperateLabels, function (half, key) {
    var inRight = key === RIGHT_HALF_KEY;
    util_1.each(half, function (item) {
      var label = util_1.get(labelsMap, item && item.id);

      if (!label) {
        return;
      } // out of range, hidden


      if (item.y < startY || item.y > endY) {
        label.set('visible', false);
        return;
      }

      var labelContent = label.getChildByIndex(0);
      var box = labelContent.getCanvasBBox();
      var originalPos = {
        x: inRight ? box.x : box.maxX,
        y: box.y + box.height / 2
        /** vertical-align: middle */

      };
      transform_1.translate(labelContent, item.x - originalPos.x
      /**  pos.x  item.x */
      , item.y - originalPos.y); // adjust labelLines

      if (item.labelLine) {
        drawLabelline(item, coordinate, inRight);
      }
    });
  });
}

exports.pieSpiderLabelLayout = pieSpiderLabelLayout;

/***/ }),
/* 953 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hideOverlap = void 0;

var util_1 = __webpack_require__(0);

var collision_detect_1 = __webpack_require__(954);

var util_2 = __webpack_require__(114);
/**
 * label  label  label 
 *  'overlap'  label 
 * @param labels  label 
 */


function hideOverlap(items, labels, shapes, region) {
  // todo  labelrank
  // each label will hide the next one because the next one always has lower rank.
  // Detect overlapping labels
  for (var i = 0; i < labels.length; i++) {
    var label1 = labels[i];

    if (labels[i].get('visible')) {
      for (var j = i + 1; j < labels.length; j++) {
        var label2 = labels[j];

        if (label1 && label2 && label1 !== label2 && label2.get('visible')) {
          var box1 = util_2.getlLabelBackgroundInfo(label1, items[i], util_1.get(items[i], 'background.padding'));
          var box2 = util_2.getlLabelBackgroundInfo(label2, items[j], util_1.get(items[j], 'background.padding'));

          if (collision_detect_1.isIntersect(box1, box2)) {
            labels[j].set('visible', false);
          }
        }
      }
    }
  }
}

exports.hideOverlap = hideOverlap;

/***/ }),
/* 954 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIntersect = exports.isIntersectRect = void 0;

var tslib_1 = __webpack_require__(1);

var matrix_util_1 = __webpack_require__(33);

var dot = matrix_util_1.vec2.dot;
/**
 * @private
 * 1. 
 */

function getAxes(points
/**  */
) {
  //   , 
  if (points.length > 4) {
    return [];
  } // 


  var vector = function vector(start, end) {
    return [end.x - start.x, end.y - start.y];
  }; //   2 : A -> B, B -> C


  var AB = vector(points[0], points[1]);
  var BC = vector(points[1], points[2]);
  return [AB, BC];
}
/**
 * @private
 * 
 * 
 */


function rotateAtPoint(point, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }

  if (origin === void 0) {
    origin = {
      x: 0,
      y: 0
    };
  }

  var x = point.x,
      y = point.y;
  return {
    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
  };
}
/**
 * @private
 * 
 *
 * @param {Object} box
 */


function getRectPoints(box) {
  var points = [{
    x: box.x,
    y: box.y
  }, {
    x: box.x + box.width,
    y: box.y
  }, {
    x: box.x + box.width,
    y: box.y + box.height
  }, {
    x: box.x,
    y: box.y + box.height
  }];
  var rotation = box.rotation;

  if (rotation) {
    return [rotateAtPoint(points[0], rotation, points[0]), rotateAtPoint(points[1], rotation, points[0]), rotateAtPoint(points[2], rotation, points[0]), rotateAtPoint(points[3], rotation, points[0])];
  }

  return points;
}
/**
 * @private
 * 2. 
 *
 * 
 * 1 x1 * x2 + y1 * y2
 */


function getProjection(points
/**  */
, axis) {
  // 
  if (points.length > 4) {
    return {
      min: 0,
      max: 0
    };
  }

  var scalars = [];
  points.forEach(function (point) {
    scalars.push(dot([point.x, point.y], axis));
  });
  return {
    min: Math.min.apply(Math, scalars),
    max: Math.max.apply(Math, scalars)
  };
}

function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
/**
 * 
 */


function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}

exports.isIntersectRect = isIntersectRect;
/**
 * detect whether two shape is intersected, useful when shape is been rotated
 * , 
 *
 * - : 
 */

function isIntersect(box1, box2) {
  // 
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2);
  } //  4 


  var rect1Points = getRectPoints(box1);
  var rect2Points = getRectPoints(box2); // 

  var axes = tslib_1.__spreadArrays(getAxes(rect1Points), getAxes(rect2Points));

  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    var projection1 = getProjection(rect1Points, axis);
    var projection2 = getProjection(rect2Points, axis); // 

    if (!isProjectionOverlap(projection1, projection2)) return false;
  }

  return true;
}

exports.isIntersect = isIntersect;

/***/ }),
/* 955 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adjustColor = void 0;

var bbox_1 = __webpack_require__(77);

var color_1 = __webpack_require__(956);

function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }

  var element = shapes[0].get('element');
  var theme = element.geometry.theme;

  var _a = theme.labels || {},
      fillColorLight = _a.fillColorLight,
      fillColorDark = _a.fillColorDark;

  shapes.forEach(function (shape, index) {
    var label = labels[index];
    var textShape = label.find(function (el) {
      return el.get('type') === 'text';
    });
    var shapeBBox = bbox_1.BBox.fromObject(shape.getBBox());
    var textBBox = bbox_1.BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr('fill');
    var fillWhite = color_1.isContrastColorWhite(bgColor);

    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr('fill', fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr('fill', fillColorDark);
        }
      }
    } else {
      //  overflowLabel 
      textShape.attr(theme.overflowLabels.style);
    }
  });
}

exports.adjustColor = adjustColor;

/***/ }),
/* 956 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isContrastColorWhite = void 0;

var tslib_1 = __webpack_require__(1);

var color_util_1 = tslib_1.__importDefault(__webpack_require__(179)); // 


var preset = {
  '#5B8FF9': true
}; // YIQ
// http://24ways.org/2010/calculating-color-contrast
// http://www.w3.org/TR/AERT#color-contrast

exports.isContrastColorWhite = function (color) {
  var rgb = color_util_1.default.toRGB(color).toUpperCase();

  if (preset[rgb]) {
    return preset[rgb];
  }

  var _a = color_util_1.default.rgb2arr(rgb),
      r = _a[0],
      g = _a[1],
      b = _a[2];

  var isDark = (r * 299 + g * 587 + b * 114) / 1000 < 128;
  return isDark;
};

/***/ }),
/* 957 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intervalAdjustPosition = void 0;

var bbox_1 = __webpack_require__(77);

var util_1 = __webpack_require__(114);

function shouldInShapeSingle(geometry, label, shape) {
  var coordinate = geometry.coordinate;
  var textShape = util_1.findLabelTextShape(label);
  var textBBox = bbox_1.BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = bbox_1.BBox.fromObject(shape.getBBox());
  return coordinate.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}

function shouldInShape(geometry, labels, shapes) {
  var isStack = !!geometry.getAdjust('stack');
  return isStack || labels.every(function (label, index) {
    var shape = shapes[index];
    return shouldInShapeSingle(geometry, label, shape);
  });
}

function moveInShape(geometry, label, shape) {
  var coordinate = geometry.coordinate;
  var shapeBBox = bbox_1.BBox.fromObject(shape.getBBox());
  var textShape = util_1.findLabelTextShape(label);

  if (coordinate.isTransposed) {
    // 
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: 'center'
    });
  } else {
    // 
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: 'middle'
    });
  }
}
/**
 *  interval geometry 
 * @param items
 * @param labels
 * @param shapes
 */


function intervalAdjustPosition(items, labels, shapes) {
  var _a;

  if (shapes.length === 0) {
    return;
  }

  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;

  if (!geometry || geometry.type !== 'interval') {
    return;
  }

  var inShape = shouldInShape(geometry, labels, shapes);

  if (inShape) {
    shapes.forEach(function (shape, index) {
      var label = labels[index];
      moveInShape(geometry, label, shape);
    });
  }
}

exports.intervalAdjustPosition = intervalAdjustPosition;

/***/ }),
/* 958 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.intervalHideOverlap = void 0;

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(114);

function filterLabel(labels) {
  var MAX_CNT = 500; //  500 

  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  util_1.each(labels, function (label, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label);
    } else {
      label.set('visible', false);
    }
  });
  return filteredLabels;
}
/**
 *  interval geometry 
 * @param items
 * @param labels
 * @param shapes
 */


function intervalHideOverlap(items, labels, shapes) {
  var _a;

  if (shapes.length === 0) {
    return;
  }

  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;

  if (!geometry || geometry.type !== 'interval') {
    return;
  }

  var filteredLabels = filterLabel(labels);
  var xField = geometry.getXYFields()[0];
  var dones = [];
  var todo = [];
  var groupedLabels = util_1.groupBy(filteredLabels, function (label) {
    return label.get('data')[xField];
  });
  var xValues = util_1.uniq(util_1.map(filteredLabels, function (label) {
    return label.get('data')[xField];
  }));
  var xValue;
  filteredLabels.forEach(function (label) {
    label.set('visible', true);
  });

  var addCurrentGroup = function addCurrentGroup(curItems) {
    if (curItems) {
      if (curItems.length) {
        // 
        todo.push(curItems.pop());
      }

      todo.push.apply(todo, curItems);
    }
  };

  if (util_1.size(xValues) > 0) {
    // 
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }

  if (util_1.size(xValues) > 0) {
    // 
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }

  util_1.each(xValues.reverse(), function (val) {
    // 
    addCurrentGroup(groupedLabels[val]);
  });

  while (todo.length > 0) {
    var cur = todo.shift();

    if (cur.get('visible')) {
      if (util_2.checkShapeOverlap(cur, dones)) {
        cur.set('visible', false);
      } else {
        dones.push(cur);
      }
    }
  }
}

exports.intervalHideOverlap = intervalHideOverlap;

/***/ }),
/* 959 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pointAdjustPosition = void 0;

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(114);
/**
 * ( xField ) Label ...
 * @param geometry
 * @param labels
 */


function sortLabels(geometry, labels) {
  var yField = geometry.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function (left, right) {
    return left.get('data')[yField] - left.get('data')[yField];
  });

  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }

  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }

  result.push.apply(result, sortedLabels);
  return result;
}

function hasSome(dones, current, compare) {
  return dones.some(function (done) {
    return compare(done, current);
  });
}
/**
 * 
 */


function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
/**
 *  Label 
 * @param dones
 * @param current
 */


function checkShapeOverlap(dones, current) {
  return hasSome(dones, current, function (left, right) {
    var leftText = util_2.findLabelTextShape(left);
    var rightText = util_2.findLabelTextShape(right);
    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
/**
 *  point geometry 
 * @param items
 * @param labels
 * @param shapes
 * @param region
 * @param cfg
 */


function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a, _b;

  if (shapes.length === 0) {
    return;
  }

  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;

  if (!geometry || geometry.type !== 'point') {
    return;
  }

  var _c = geometry.getXYFields(),
      xField = _c[0],
      yField = _c[1];

  var groupedLabels = util_1.groupBy(labels, function (label) {
    return label.get('data')[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  util_1.map(util_1.keys(groupedLabels).reverse(), function (xValue) {
    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);

    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = util_2.findLabelTextShape(current);

      if (hasSome(dones, current, function (left, right) {
        return left.get('data')[xField] === right.get('data')[xField] && left.get('data')[yField] === right.get('data')[yField];
      })) {
        // 
        textShape.set('visible', false);
        continue;
      }

      var upFail = checkShapeOverlap(dones, current);
      var downFail = false;

      if (upFail) {
        textShape.attr('y', textShape.attr('y') + 2 * offset);
        downFail = checkShapeOverlap(dones, current);
      }

      if (downFail) {
        textShape.set('visible', false);
        continue;
      }

      dones.push(current);
    }
  });
}

exports.pointAdjustPosition = pointAdjustPosition;

/***/ }),
/* 960 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathAdjustPosition = void 0;

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(114);
/**
 * ( xField ) Label ...
 * @param geometry
 * @param labels
 */


function sortLabels(geometry, labels) {
  var yField = geometry.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function (left, right) {
    return left.get('data')[yField] - left.get('data')[yField];
  });

  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }

  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }

  result.push.apply(result, sortedLabels);
  return result;
}

function hasSome(dones, current, compare) {
  return dones.some(function (done) {
    return compare(done, current);
  });
}
/**
 * 
 */


function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }

  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
/**
 *  Label 
 * @param dones
 * @param current
 */


function checkShapeOverlap(dones, current) {
  return hasSome(dones, current, function (left, right) {
    var leftText = util_2.findLabelTextShape(left);
    var rightText = util_2.findLabelTextShape(right);
    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
/**
 *  point geometry 
 * @param items
 * @param labels
 * @param shapes
 * @param region
 * @param cfg
 */


function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a, _b;

  if (shapes.length === 0) {
    return;
  }

  var element = (_a = shapes[0]) === null || _a === void 0 ? void 0 : _a.get('element');
  var geometry = element === null || element === void 0 ? void 0 : element.geometry;

  if (!geometry || ['path', 'line', 'area'].indexOf(geometry.type) < 0) {
    return;
  }

  var _c = geometry.getXYFields(),
      xField = _c[0],
      yField = _c[1];

  var groupedLabels = util_1.groupBy(labels, function (label) {
    return label.get('data')[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  util_1.map(util_1.keys(groupedLabels).reverse(), function (xValue) {
    var sortedCollections = sortLabels(geometry, groupedLabels[xValue]);

    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = util_2.findLabelTextShape(current);

      if (hasSome(dones, current, function (left, right) {
        return left.get('data')[xField] === right.get('data')[xField] && left.get('data')[yField] === right.get('data')[yField];
      })) {
        // 
        textShape.set('visible', false);
        continue;
      }

      var upFail = checkShapeOverlap(dones, current);
      var downFail = false;

      if (upFail) {
        textShape.attr('y', textShape.attr('y') + 2 * offset);
        downFail = checkShapeOverlap(dones, current);
      }

      if (downFail) {
        textShape.set('visible', false);
        continue;
      }

      dones.push(current);
    }
  });
}

exports.pathAdjustPosition = pathAdjustPosition;

/***/ }),
/* 961 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.limitInPlot = void 0;

var util_1 = __webpack_require__(0);

var coordinate_1 = __webpack_require__(51);

var text_1 = __webpack_require__(962);

var transform_1 = __webpack_require__(115);
/**
 * @ignore
 *  label  Plot  Plot  label 
 * @param labels
 * @param cfg
 */


function limitInPlot(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }

  var direction = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ['top', 'right', 'bottom', 'left'];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || 'translate';
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate = labels[0].get('coordinate');

  if (!coordinate) {
    return;
  }

  var _a = coordinate_1.getCoordinateBBox(coordinate, margin),
      regionMinX = _a.minX,
      regionMinY = _a.minY,
      regionMaxX = _a.maxX,
      regionMaxY = _a.maxY;

  util_1.each(labels, function (label) {
    var _a = label.getCanvasBBox(),
        minX = _a.minX,
        minY = _a.minY,
        maxX = _a.maxX,
        maxY = _a.maxY,
        x = _a.x,
        y = _a.y,
        width = _a.width,
        height = _a.height;

    var finalX = x;
    var finalY = y;

    if (direction.indexOf('left') >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      // 
      finalX = regionMinX;
    }

    if (direction.indexOf('top') >= 0 && (minY < regionMinY || maxY < regionMinY)) {
      // 
      finalY = regionMinY;
    }

    if (direction.indexOf('right') >= 0) {
      if (minX > regionMaxX) {
        // 
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        // 
        finalX = finalX - (maxX - regionMaxX);
      }
    }

    if (direction.indexOf('bottom') >= 0) {
      if (minY > regionMaxY) {
        // 
        finalY = regionMaxY - height;
      } else if (maxY > regionMaxY) {
        // 
        finalY = finalY - (maxY - regionMaxY);
      }
    }

    if (finalX !== x || finalY !== y) {
      var translateX_1 = finalX - x;

      if (action === 'translate') {
        transform_1.translate(label, translateX_1, finalY - y);
      } else if (action === 'ellipsis') {
        var textShapes = label.findAll(function (shape) {
          return shape.get('type') === 'text';
        });
        textShapes.forEach(function (textShape) {
          var style = util_1.pick(textShape.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);
          var textBox = textShape.getCanvasBBox();
          var text = text_1.getEllipsisText(textShape.attr('text'), textBox.width - Math.abs(translateX_1), style);
          textShape.attr('text', text);
        });
      } else {
        label.hide();
      }
    }
  });
}

exports.limitInPlot = limitInPlot;

/***/ }),
/* 962 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEllipsisText = exports.measureTextWidth = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var context_1 = __webpack_require__(963);
/**
 * 
 */


exports.measureTextWidth = util_1.memoize(function (text, font) {
  if (font === void 0) {
    font = {};
  }

  var fontSize = font.fontSize,
      fontFamily = font.fontFamily,
      fontWeight = font.fontWeight,
      fontStyle = font.fontStyle,
      fontVariant = font.fontVariant;
  var ctx = context_1.getCanvasContext();
  ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(' ');
  return ctx.measureText(util_1.isString(text) ? text : '').width;
}, function (text, font) {
  if (font === void 0) {
    font = {};
  }

  return tslib_1.__spreadArrays([text], util_1.values(font)).join('');
});
/**
 *  ... 
 *  measureText measureText 
 * 1.  STEP  maxWidth 
 * 2. 
 * @param text ,  string,number
 * @param maxWidth
 * @param font
 */

exports.getEllipsisText = function (text, maxWidth, font) {
  var STEP = 16; //  16

  var DOT_WIDTH = exports.measureTextWidth('...', font);
  var leftText;

  if (!util_1.isString(text)) {
    leftText = util_1.toString(text);
  } else {
    leftText = text;
  }

  var leftWidth = maxWidth;
  var r = []; // 

  var currentText;
  var currentWidth;

  if (exports.measureTextWidth(text, font) <= maxWidth) {
    return text;
  } //  step 


  while (true) {
    // 
    currentText = leftText.substr(0, STEP); // 

    currentWidth = exports.measureTextWidth(currentText, font); // 

    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }

    r.push(currentText); // 

    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP); // 

    if (!leftText) {
      return r.join('');
    }
  } //  STEP 1 


  while (true) {
    // 
    currentText = leftText.substr(0, 1); // 

    currentWidth = exports.measureTextWidth(currentText, font); // 

    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }

    r.push(currentText); // 

    leftWidth -= currentWidth;
    leftText = leftText.substr(1);

    if (!leftText) {
      return r.join('');
    }
  }

  return r.join('') + "...";
};

/***/ }),
/* 963 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCanvasContext = void 0;
var ctx;
/**
 *  canvas context
 */

function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement('canvas').getContext('2d');
  }

  return ctx;
}

exports.getCanvasContext = getCanvasContext;

/***/ }),
/* 964 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showGrid = exports.getCircleGridItems = exports.getLineGridItems = exports.getGridThemeCfg = void 0;

var util_1 = __webpack_require__(0);
/**
 * @ignore
 * get the grid theme by type
 * @param theme
 * @param direction
 * @returns theme object
 */


function getGridThemeCfg(theme, direction) {
  return util_1.get(theme, ['components', 'axis', direction, 'grid'], {});
}

exports.getGridThemeCfg = getGridThemeCfg;
/**
 * @ignore
 * get axis grid items
 * @param coordinate
 * @param scale
 * @param dim
 * @return items
 */

function getLineGridItems(coordinate, scale, dim, alignTick) {
  var items = [];
  var ticks = scale.getTicks();

  if (coordinate.isPolar) {
    //  ticks
    ticks.push({
      value: 1,
      text: '',
      tickValue: ''
    });
  }

  ticks.reduce(function (preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;

    if (alignTick) {
      items.push({
        points: [coordinate.convert(dim === 'y' ? {
          x: 0,
          y: currentValue
        } : {
          x: currentValue,
          y: 0
        }), coordinate.convert(dim === 'y' ? {
          x: 1,
          y: currentValue
        } : {
          x: currentValue,
          y: 1
        })]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [coordinate.convert(dim === 'y' ? {
            x: 0,
            y: middleValue
          } : {
            x: middleValue,
            y: 0
          }), coordinate.convert(dim === 'y' ? {
            x: 1,
            y: middleValue
          } : {
            x: middleValue,
            y: 1
          })]
        });
      }
    }

    return currentTick;
  }, ticks[0]);
  return items;
}

exports.getLineGridItems = getLineGridItems;
/**
 * @ignore
 * get
 * @param coordinate
 * @param xScale
 * @param yScale
 * @param dim
 * @returns items
 */

function getCircleGridItems(coordinate, xScale, yScale, alignTick, dim) {
  var count = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function (preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value; // 

    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;

    if (dim === 'x') {
      //  x 
      items.push({
        points: [coordinate.convert({
          x: alignTick ? currentValue : middleValue,
          y: 0
        }), coordinate.convert({
          x: alignTick ? currentValue : middleValue,
          y: 1
        })]
      });
    } else {
      items.push({
        points: util_1.map(Array(count + 1), function (__, idx) {
          return coordinate.convert({
            x: idx / count,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }

    return currentTick;
  }, ticks[0]);
  return items;
}

exports.getCircleGridItems = getCircleGridItems;
/**
 * @ignore
 * show grid or not
 * @param axisTheme
 * @param axisOption
 */

function showGrid(axisTheme, axisOption) {
  var userGrid = util_1.get(axisOption, 'grid');

  if (userGrid === null) {
    return false;
  }

  var themeGrid = util_1.get(axisTheme, 'grid');
  return !(userGrid === undefined && themeGrid === null);
}

exports.showGrid = showGrid;

/***/ }),
/* 965 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = __webpack_require__(104);

var dependents_1 = __webpack_require__(68);

var bbox_1 = __webpack_require__(77);

var direction_1 = __webpack_require__(282);

var constant_1 = __webpack_require__(20);

var util_1 = __webpack_require__(0);

var helper_1 = __webpack_require__(76);

var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;

var Scrollbar =
/** @class */
function (_super) {
  tslib_1.__extends(Scrollbar, _super);

  function Scrollbar(view) {
    var _this = _super.call(this, view) || this;

    _this.onChangeFn = util_1.noop;

    _this.resetMeasure = function () {
      _this.clear();
    };

    _this.onValueChange = function (_a) {
      var ratio = _a.ratio;

      var animate = _this.getValidScrollbarCfg().animate;

      _this.ratio = util_1.clamp(ratio, 0, 1);

      var originalAnimate = _this.view.getOptions().animate;

      if (!animate) {
        _this.view.animate(false);
      }

      _this.changeViewData(_this.getScrollRange(), true);

      _this.view.animate(originalAnimate);
    };

    _this.container = _this.view.getLayer(constant_1.LAYER.FORE).addGroup();
    _this.onChangeFn = util_1.throttle(_this.onValueChange, 20, {
      leading: true
    });
    _this.trackLen = 0;
    _this.thumbLen = 0;
    _this.ratio = 0;

    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);

    _this.view.on(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);

    return _this;
  }

  Object.defineProperty(Scrollbar.prototype, "name", {
    get: function get() {
      return 'scrollbar';
    },
    enumerable: false,
    configurable: true
  });

  Scrollbar.prototype.destroy = function () {
    _super.prototype.destroy.call(this);

    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
    this.view.off(constant_1.VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
  };

  Scrollbar.prototype.init = function () {};
  /**
   * 
   */


  Scrollbar.prototype.render = function () {
    this.option = this.view.getOptions().scrollbar;

    if (this.option) {
      if (this.scrollbar) {
        // exist, update
        this.scrollbar = this.updateScrollbar();
      } else {
        // not exist, create
        this.scrollbar = this.createScrollbar();
        this.scrollbar.component.on('scrollchange', this.onChangeFn);
      }
    } else {
      if (this.scrollbar) {
        // exist, destroy
        this.scrollbar.component.destroy();
        this.scrollbar = undefined;
      }
    }
  };
  /**
   * 
   */


  Scrollbar.prototype.layout = function () {
    var _this = this;

    if (this.option && !this.trackLen) {
      this.measureScrollbar();
      setTimeout(function () {
        if (!_this.view.destroyed) {
          _this.changeViewData(_this.getScrollRange(), true);
        }
      });
    }

    if (this.scrollbar) {
      var width = this.view.coordinateBBox.width;
      var padding = this.scrollbar.component.get('padding');
      var bboxObject = this.scrollbar.component.getLayoutBBox();
      var bbox = new bbox_1.BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding);
      var cfg = this.getScrollbarComponentCfg();
      var x = void 0;
      var y = void 0;

      if (cfg.isHorizontal) {
        var _a = direction_1.directionToPosition(this.view.viewBBox, bbox, constant_1.DIRECTION.BOTTOM),
            x1 = _a[0],
            y1 = _a[1];

        var _b = direction_1.directionToPosition(this.view.coordinateBBox, bbox, constant_1.DIRECTION.BOTTOM),
            x2 = _b[0],
            y2 = _b[1];

        x = x2;
        y = y1;
      } else {
        var _c = direction_1.directionToPosition(this.view.viewBBox, bbox, constant_1.DIRECTION.RIGHT),
            x1 = _c[0],
            y1 = _c[1];

        var _d = direction_1.directionToPosition(this.view.viewBBox, bbox, constant_1.DIRECTION.RIGHT),
            x2 = _d[0],
            y2 = _d[1];

        x = x2;
        y = y1;
      }

      x += padding[3];
      y += padding[0]; //  bottom

      if (this.trackLen) {
        this.scrollbar.component.update(tslib_1.__assign(tslib_1.__assign({}, cfg), {
          x: x,
          y: y,
          trackLen: this.trackLen,
          thumbLen: this.thumbLen,
          thumbOffset: (this.trackLen - this.thumbLen) * this.ratio
        }));
      } else {
        this.scrollbar.component.update(tslib_1.__assign(tslib_1.__assign({}, cfg), {
          x: x,
          y: y
        }));
      }

      this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? constant_1.DIRECTION.BOTTOM : constant_1.DIRECTION.RIGHT);
    }
  };
  /**
   * 
   */


  Scrollbar.prototype.update = function () {
    //  render 
    this.render();
  };

  Scrollbar.prototype.getComponents = function () {
    return this.scrollbar ? [this.scrollbar] : [];
  };

  Scrollbar.prototype.clear = function () {
    if (this.scrollbar) {
      this.scrollbar.component.destroy();
      this.scrollbar = undefined;
    }

    this.trackLen = 0;
    this.thumbLen = 0;
    this.ratio = 0;
    this.cnt = 0;
    this.step = 0;
    this.data = undefined;
    this.xScaleCfg = undefined;
    this.yScalesCfg = [];
  };
  /**
   *  scrollbar 
   */


  Scrollbar.prototype.getThemeOptions = function () {
    var theme = this.view.getTheme();
    return util_1.get(theme, ['components', 'slider', 'common'], {});
  };

  Scrollbar.prototype.measureScrollbar = function () {
    var xScale = this.view.getXScale();
    var yScales = this.view.getYScales().slice();
    this.data = this.view.getOptions().data;
    this.step = this.getStep();
    this.cnt = this.getCnt();

    var _a = this.getScrollbarComponentCfg(),
        trackLen = _a.trackLen,
        thumbLen = _a.thumbLen;

    this.trackLen = trackLen;
    this.thumbLen = thumbLen;
    this.xScaleCfg = {
      field: xScale.field,
      values: xScale.values || []
    };
    this.yScalesCfg = yScales;
  };

  Scrollbar.prototype.getScrollRange = function () {
    var startIdx = Math.floor((this.cnt - this.step) * util_1.clamp(this.ratio, 0, 1));
    var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
    return [startIdx, endIdx];
  };

  Scrollbar.prototype.changeViewData = function (_a, render) {
    var _this = this;

    var startIdx = _a[0],
        endIdx = _a[1];
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal = type !== 'vertical';
    var values = util_1.valuesOfKey(this.data, this.xScaleCfg.field);
    var xValues = isHorizontal ? values : values.reverse();
    this.yScalesCfg.forEach(function (cfg) {
      _this.view.scale(cfg.field, {
        formatter: cfg.formatter,
        type: cfg.type,
        min: cfg.min,
        max: cfg.max
      });
    });
    this.view.filter(this.xScaleCfg.field, function (val) {
      var idx = xValues.indexOf(val);
      return idx > -1 ? helper_1.isBetween(idx, startIdx, endIdx) : true;
    });
    this.view.render(true);
  };

  Scrollbar.prototype.createScrollbar = function () {
    var type = this.getValidScrollbarCfg().type;
    var isHorizontal = type !== 'vertical';
    var component = new dependents_1.Scrollbar(tslib_1.__assign(tslib_1.__assign({
      container: this.container
    }, this.getScrollbarComponentCfg()), {
      x: 0,
      y: 0
    }));
    component.init();
    return {
      component: component,
      layer: constant_1.LAYER.FORE,
      direction: isHorizontal ? constant_1.DIRECTION.BOTTOM : constant_1.DIRECTION.RIGHT,
      type: constant_1.COMPONENT_TYPE.SCROLLBAR
    };
  };

  Scrollbar.prototype.updateScrollbar = function () {
    var config = this.getScrollbarComponentCfg();
    var realConfig = this.trackLen ? tslib_1.__assign(tslib_1.__assign({}, config), {
      trackLen: this.trackLen,
      thumbLen: this.thumbLen,
      thumbOffset: (this.trackLen - this.thumbLen) * this.ratio
    }) : tslib_1.__assign({}, config);
    this.scrollbar.component.update(realConfig);
    return this.scrollbar;
  };

  Scrollbar.prototype.getStep = function () {
    if (this.step) {
      return this.step;
    }

    var coordinateBBox = this.view.coordinateBBox;

    var _a = this.getValidScrollbarCfg(),
        type = _a.type,
        categorySize = _a.categorySize;

    var isHorizontal = type !== 'vertical';
    return Math.floor((isHorizontal ? coordinateBBox.width : coordinateBBox.height) / categorySize);
  };

  Scrollbar.prototype.getCnt = function () {
    if (this.cnt) {
      return this.cnt;
    }

    var xScale = this.view.getXScale();
    var data = this.view.getOptions().data;
    var values = util_1.valuesOfKey(data, xScale.field);
    return util_1.size(values);
  };

  Scrollbar.prototype.getScrollbarComponentCfg = function () {
    var _a = this.view,
        coordinateBBox = _a.coordinateBBox,
        viewBBox = _a.viewBBox;
    var xScale = this.view.getXScale();

    var _b = this.getValidScrollbarCfg(),
        type = _b.type,
        padding = _b.padding,
        width = _b.width,
        height = _b.height;

    var isHorizontal = type !== 'vertical';
    var paddingTop = padding[0],
        paddingRight = padding[1],
        paddingBottom = padding[2],
        paddingLeft = padding[3];
    var position = isHorizontal ? {
      x: coordinateBBox.minX + paddingLeft,
      y: viewBBox.maxY - height - paddingBottom
    } : {
      x: viewBBox.maxX - width - paddingRight,
      y: coordinateBBox.minY + paddingTop
    };
    var step = this.getStep();
    var cnt = this.getCnt();
    var trackLen = isHorizontal ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
    var thumbLen = Math.max(trackLen * util_1.clamp(step / cnt, 0, 1), MIN_THUMB_LENGTH);
    return tslib_1.__assign(tslib_1.__assign({}, this.getThemeOptions()), {
      x: position.x,
      y: position.y,
      size: isHorizontal ? height : width,
      isHorizontal: isHorizontal,
      trackLen: trackLen,
      thumbLen: thumbLen,
      thumbOffset: 0
    });
  };
  /**
   * 
   */


  Scrollbar.prototype.getValidScrollbarCfg = function () {
    var cfg = {
      type: 'horizontal',
      categorySize: DEFAULT_CATEGORY_SIZE,
      width: DEFAULT_SIZE,
      height: DEFAULT_SIZE,
      padding: [0, 0, 0, 0],
      animate: true
    };

    if (util_1.isObject(this.option)) {
      cfg = tslib_1.__assign(tslib_1.__assign({}, cfg), this.option);
    }

    if (!util_1.isObject(this.option) || !this.option.padding) {
      cfg.padding = cfg.type === 'horizontal' ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
    }

    return cfg;
  };

  return Scrollbar;
}(base_1.Controller);

exports.default = Scrollbar;

/***/ }),
/* 966 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearList = void 0;

var util_1 = __webpack_require__(0);

var STATUS_UNACTIVE = 'inactive';
var STATUS_ACTIVE = 'active';
/**
 *  Highlight 
 * @param list 
 * @ignore
 */

function clearList(list) {
  var items = list.getItems();
  util_1.each(items, function (item) {
    if (list.hasState(item, STATUS_ACTIVE)) {
      list.setItemState(item, STATUS_ACTIVE, false);
    }

    if (list.hasState(item, STATUS_UNACTIVE)) {
      list.setItemState(item, STATUS_UNACTIVE, false);
    }
  });
}

exports.clearList = clearList;

/***/ }),
/* 967 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(30);

var base_1 = tslib_1.__importDefault(__webpack_require__(288));
/**
 * @ignore
 *  Action
 */


var CircleMask =
/** @class */
function (_super) {
  tslib_1.__extends(CircleMask, _super);

  function CircleMask() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.shapeType = 'circle';
    return _this;
  }

  CircleMask.prototype.getMaskAttrs = function () {
    var points = this.points;
    var currentPoint = util_1.last(this.points);
    var r = 0;
    var x = 0;
    var y = 0;

    if (points.length) {
      var first = points[0];
      r = util_2.distance(first, currentPoint) / 2;
      x = (currentPoint.x + first.x) / 2;
      y = (currentPoint.y + first.y) / 2;
    }

    return {
      x: x,
      y: y,
      r: r
    };
  };

  return CircleMask;
}(base_1.default);

exports.default = CircleMask;

/***/ }),
/* 968 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var rect_1 = tslib_1.__importDefault(__webpack_require__(464));

function clampPoint(point) {
  point.x = util_1.clamp(point.x, 0, 1);
  point.y = util_1.clamp(point.y, 0, 1);
}
/**
 * @ignore
 */


var DimRect =
/** @class */
function (_super) {
  tslib_1.__extends(DimRect, _super);

  function DimRect() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.dim = 'x';
    _this.inPlot = true;
    return _this;
  }

  DimRect.prototype.getRegion = function () {
    var start = null;
    var end = null;
    var points = this.points;
    var dim = this.dim;
    var coord = this.context.view.getCoordinate();
    var normalStart = coord.invert(util_1.head(points));
    var normalEnd = coord.invert(util_1.last(points));

    if (this.inPlot) {
      //  0 - 1 
      clampPoint(normalStart);
      clampPoint(normalEnd);
    }

    if (dim === 'x') {
      // x , y 
      start = coord.convert({
        x: normalStart.x,
        y: 0
      });
      end = coord.convert({
        x: normalEnd.x,
        y: 1
      });
    } else {
      // y , x 
      start = coord.convert({
        x: 0,
        y: normalStart.y
      });
      end = coord.convert({
        x: 1,
        y: normalEnd.y
      });
    }

    return {
      start: start,
      end: end
    };
  };

  return DimRect;
}(rect_1.default);

exports.default = DimRect;

/***/ }),
/* 969 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(30);

var path_1 = tslib_1.__importDefault(__webpack_require__(465));
/**
 * Smooth path mask
 * @ignore
 */


var SmoothPathMask =
/** @class */
function (_super) {
  tslib_1.__extends(SmoothPathMask, _super);

  function SmoothPathMask() {
    return _super !== null && _super.apply(this, arguments) || this;
  } //  mask 


  SmoothPathMask.prototype.getMaskPath = function () {
    var points = this.points;
    return util_1.getSpline(points, true);
  };

  return SmoothPathMask;
}(path_1.default);

exports.default = SmoothPathMask;

/***/ }),
/* 970 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var range_filter_1 = tslib_1.__importDefault(__webpack_require__(466));

var util_2 = __webpack_require__(30);
/**
 *  view  view  views 
 * @ignore
 */


var SiblingFilter =
/** @class */
function (_super) {
  tslib_1.__extends(SiblingFilter, _super);

  function SiblingFilter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   *  view 
   * @param view
   * @param field
   * @param filter
   */


  SiblingFilter.prototype.filterView = function (view, field, filter) {
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      sibling.filter(field, filter);
    });
  };
  /**
   * 
   * @param view
   */


  SiblingFilter.prototype.reRender = function (view) {
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      sibling.render(true);
    });
  };

  return SiblingFilter;
}(range_filter_1.default);

exports.default = SiblingFilter;

/***/ }),
/* 971 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_2 = __webpack_require__(30);
/**
 *  Action
 * @ignore
 */


var ElementFilter =
/** @class */
function (_super) {
  tslib_1.__extends(ElementFilter, _super);

  function ElementFilter() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   */


  ElementFilter.prototype.filter = function () {
    var delegateObject = util_2.getDelegationObject(this.context);
    var view = this.context.view;
    var elements = util_2.getElements(view);

    if (util_2.isMask(this.context)) {
      var maskElements_1 = util_2.getMaskedElements(this.context, 10);

      if (maskElements_1) {
        util_1.each(elements, function (el) {
          if (maskElements_1.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    } else if (delegateObject) {
      var component = delegateObject.component;
      var field_1 = component.get('field'); // 

      if (util_2.isList(delegateObject)) {
        if (field_1) {
          var unCheckedItems = component.getItemsByState('unchecked');
          var scale_1 = util_2.getScaleByField(view, field_1);
          var names_1 = unCheckedItems.map(function (item) {
            return item.name;
          }); // 

          util_1.each(elements, function (el) {
            var value = util_2.getElementValue(el, field_1);
            var text = scale_1.getText(value);

            if (names_1.indexOf(text) >= 0) {
              el.hide();
            } else {
              el.show();
            }
          });
        }
      } else if (util_2.isSlider(delegateObject)) {
        var range = component.getValue();
        var min_1 = range[0],
            max_1 = range[1];
        util_1.each(elements, function (el) {
          var value = util_2.getElementValue(el, field_1);

          if (value >= min_1 && value <= max_1) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    }
  };
  /**
   * 
   */


  ElementFilter.prototype.clear = function () {
    var elements = util_2.getElements(this.context.view);
    util_1.each(elements, function (el) {
      el.show();
    });
  };
  /**
   *  data-filter 
   */


  ElementFilter.prototype.reset = function () {
    this.clear();
  };

  return ElementFilter;
}(base_1.default);

exports.default = ElementFilter;

/***/ }),
/* 972 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_2 = __webpack_require__(30);
/**
 * Sibling filter
 * @ignore
 */


var SiblingFilter =
/** @class */
function (_super) {
  tslib_1.__extends(SiblingFilter, _super);

  function SiblingFilter() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.byRecord = false;
    return _this;
  }
  /**
   * 
   */


  SiblingFilter.prototype.filter = function () {
    //  mask 
    if (util_2.isMask(this.context)) {
      if (this.byRecord) {
        this.filterByRecord();
      } else {
        this.filterByBBox();
      }
    }
  }; // 


  SiblingFilter.prototype.filterByRecord = function () {
    var view = this.context.view;
    var maskElements = util_2.getMaskedElements(this.context, 10);

    if (!maskElements) {
      return;
    }

    var xFiled = view.getXScale().field;
    var yField = view.getYScales()[0].field;
    var records = maskElements.map(function (el) {
      return el.getModel().data;
    });
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      var elements = util_2.getElements(sibling);
      util_1.each(elements, function (el) {
        var record = el.getModel().data; // records.includes(record) 

        if (util_2.isInRecords(records, record, xFiled, yField)) {
          el.show();
        } else {
          el.hide();
        }
      });
    });
  }; // 


  SiblingFilter.prototype.filterByBBox = function () {
    var _this = this;

    var view = this.context.view;
    var siblings = util_2.getSilbings(view);
    util_1.each(siblings, function (sibling) {
      var maskElements = util_2.getSiblingMaskElements(_this.context, sibling, 10);
      var elements = util_2.getElements(sibling);

      if (maskElements) {
        // mask  null
        util_1.each(elements, function (el) {
          if (maskElements.includes(el)) {
            el.show();
          } else {
            el.hide();
          }
        });
      }
    });
  };
  /**
   * 
   */


  SiblingFilter.prototype.reset = function () {
    var siblings = util_2.getSilbings(this.context.view);
    util_1.each(siblings, function (sibling) {
      var elements = util_2.getElements(sibling);
      util_1.each(elements, function (el) {
        el.show();
      });
    });
  };

  return SiblingFilter;
}(base_1.default);

exports.default = SiblingFilter;

/***/ }),
/* 973 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var matrix_util_1 = __webpack_require__(33);

var util_1 = __webpack_require__(0);

var padding_1 = __webpack_require__(267);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var PADDING_RIGHT = 10;
var PADDING_TOP = 5;
/**
 * Button action
 * @ignore
 */

var ButtonAction =
/** @class */
function (_super) {
  tslib_1.__extends(ButtonAction, _super);

  function ButtonAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.buttonGroup = null;
    _this.buttonCfg = {
      name: 'button',
      text: 'button',
      textStyle: {
        x: 0,
        y: 0,
        fontSize: 12,
        fill: '#333333',
        cursor: 'pointer'
      },
      padding: [8, 10],
      style: {
        fill: '#f7f7f7',
        stroke: '#cccccc',
        cursor: 'pointer'
      },
      activeStyle: {
        fill: '#e6e6e6'
      }
    };
    return _this;
  } // mix 


  ButtonAction.prototype.getButtonCfg = function () {
    return util_1.deepMix(this.buttonCfg, this.cfg);
  }; //  Button  


  ButtonAction.prototype.drawButton = function () {
    var config = this.getButtonCfg();
    var group = this.context.view.foregroundGroup.addGroup({
      name: config.name
    }); // 

    var textShape = group.addShape({
      type: 'text',
      name: 'button-text',
      attrs: tslib_1.__assign({
        text: config.text
      }, config.textStyle)
    });
    var textBBox = textShape.getBBox();
    var padding = padding_1.parsePadding(config.padding); // 

    var buttonShape = group.addShape({
      type: 'rect',
      name: 'button-rect',
      attrs: tslib_1.__assign({
        x: textBBox.x - padding[3],
        y: textBBox.y - padding[0],
        width: textBBox.width + padding[1] + padding[3],
        height: textBBox.height + padding[0] + padding[2]
      }, config.style)
    });
    buttonShape.toBack(); // 
    // active 

    group.on('mouseenter', function () {
      buttonShape.attr(config.activeStyle);
    });
    group.on('mouseleave', function () {
      buttonShape.attr(config.style);
    });
    this.buttonGroup = group;
  }; // 


  ButtonAction.prototype.resetPosition = function () {
    var view = this.context.view;
    var coord = view.getCoordinate();
    var point = coord.convert({
      x: 1,
      y: 1
    }); // 

    var buttonGroup = this.buttonGroup;
    var bbox = buttonGroup.getBBox();
    var matrix = matrix_util_1.ext.transform(null, [['t', point.x - bbox.width - PADDING_RIGHT, point.y + bbox.height + PADDING_TOP]]);
    buttonGroup.setMatrix(matrix);
  };
  /**
   * 
   */


  ButtonAction.prototype.show = function () {
    if (!this.buttonGroup) {
      this.drawButton();
    }

    this.resetPosition();
    this.buttonGroup.show();
  };
  /**
   * 
   */


  ButtonAction.prototype.hide = function () {
    if (this.buttonGroup) {
      this.buttonGroup.hide();
    }
  };
  /**
   * 
   */


  ButtonAction.prototype.destroy = function () {
    var buttonGroup = this.buttonGroup;

    if (buttonGroup) {
      buttonGroup.remove();
    }

    _super.prototype.destroy.call(this);
  };

  return ButtonAction;
}(base_1.default);

exports.default = ButtonAction;

/***/ }),
/* 974 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var base_1 = tslib_1.__importDefault(__webpack_require__(47));

var util_1 = __webpack_require__(30);

var DISTANCE = 4; // 

/**
 * @ignore
 * View  Drag  Action
 */

var Drag =
/** @class */
function (_super) {
  tslib_1.__extends(Drag, _super);

  function Drag() {
    var _this = _super !== null && _super.apply(this, arguments) || this; // Action  


    _this.starting = false; // 

    _this.dragStart = false;
    return _this;
  }
  /**
   * 
   */


  Drag.prototype.start = function () {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint();
  };
  /**
   * 
   */


  Drag.prototype.drag = function () {
    if (!this.startPoint) {
      return;
    }

    var current = this.context.getCurrentPoint();
    var view = this.context.view;
    var event = this.context.event;

    if (!this.dragStart) {
      if (util_1.distance(current, this.startPoint) > DISTANCE) {
        view.emit('dragstart', {
          target: event.target,
          x: event.x,
          y: event.y
        });
        this.dragStart = true;
      }
    } else {
      view.emit('drag', {
        target: event.target,
        x: event.x,
        y: event.y
      });
    }
  };
  /**
   * 
   */


  Drag.prototype.end = function () {
    if (this.dragStart) {
      var view = this.context.view;
      var event_1 = this.context.event;
      view.emit('dragend', {
        target: event_1.target,
        x: event_1.x,
        y: event_1.y
      });
    }

    this.starting = false;
    this.dragStart = false;
  };

  return Drag;
}(base_1.default);

exports.default = Drag;

/***/ }),
/* 975 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var matrix_util_1 = __webpack_require__(33);

var __1 = __webpack_require__(265);

var util_1 = __webpack_require__(30);

var MIN_DISTANCE = 5;
/**
 * @ignore
 * View  Action
 */

var Move =
/** @class */
function (_super) {
  tslib_1.__extends(Move, _super);

  function Move() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.starting = false;
    _this.isMoving = false; // private cacheRange = null;

    _this.startPoint = null;
    _this.startMatrix = null;
    return _this;
  }
  /**
   * 
   */


  Move.prototype.start = function () {
    this.starting = true;
    this.startPoint = this.context.getCurrentPoint(); // 

    this.startMatrix = this.context.view.middleGroup.getMatrix();
  };
  /**
   * 
   */


  Move.prototype.move = function () {
    if (!this.starting) {
      return;
    }

    var startPoint = this.startPoint;
    var currentPoint = this.context.getCurrentPoint();
    var d = util_1.distance(startPoint, currentPoint);

    if (d > MIN_DISTANCE && !this.isMoving) {
      this.isMoving = true;
    }

    if (this.isMoving) {
      var view = this.context.view;
      var matrix = matrix_util_1.ext.transform(this.startMatrix, [['t', currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]]);
      view.backgroundGroup.setMatrix(matrix);
      view.foregroundGroup.setMatrix(matrix);
      view.middleGroup.setMatrix(matrix);
    }
  };
  /**
   * 
   */


  Move.prototype.end = function () {
    if (this.isMoving) {
      this.isMoving = false;
    }

    this.startMatrix = null;
    this.starting = false;
    this.startPoint = null;
  };
  /**
   * 
   */


  Move.prototype.reset = function () {
    this.starting = false;
    this.startPoint = null;
    this.isMoving = false;
    var view = this.context.view;
    view.backgroundGroup.resetMatrix();
    view.foregroundGroup.resetMatrix();
    view.middleGroup.resetMatrix();
    this.isMoving = false;
  };

  return Move;
}(__1.Action);

exports.default = Move;

/***/ }),
/* 976 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var scale_transform_1 = tslib_1.__importDefault(__webpack_require__(467));
/**
 *  Scale  Action
 * @ignore
 */


var ScaleTranslate =
/** @class */
function (_super) {
  tslib_1.__extends(ScaleTranslate, _super);

  function ScaleTranslate() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.startPoint = null;
    _this.starting = false;
    _this.startCache = {};
    return _this;
  }
  /**
   * 
   */


  ScaleTranslate.prototype.start = function () {
    var _this = this;

    this.startPoint = this.context.getCurrentPoint();
    this.starting = true;
    var dims = this.dims;
    util_1.each(dims, function (dim) {
      var scale = _this.getScale(dim);

      var min = scale.min,
          max = scale.max,
          values = scale.values;
      _this.startCache[dim] = {
        min: min,
        max: max,
        values: values
      };
    });
  }; // 
  // private translateCategory(dim, scale, normalPoint) {
  // }

  /**
   * 
   */


  ScaleTranslate.prototype.end = function () {
    this.startPoint = null;
    this.starting = false;
    this.startCache = {};
  };
  /**
   * 
   */


  ScaleTranslate.prototype.translate = function () {
    var _this = this;

    if (!this.starting) {
      return;
    }

    var startPoint = this.startPoint;
    var coord = this.context.view.getCoordinate();
    var currentPoint = this.context.getCurrentPoint();
    var normalStart = coord.invert(startPoint);
    var noramlCurrent = coord.invert(currentPoint);
    var dx = noramlCurrent.x - normalStart.x;
    var dy = noramlCurrent.y - normalStart.y;
    var view = this.context.view;
    var dims = this.dims;
    util_1.each(dims, function (dim) {
      _this.translateDim(dim, {
        x: dx * -1,
        y: dy * -1
      });
    });
    view.render(true);
  }; // 


  ScaleTranslate.prototype.translateDim = function (dim, normalPoint) {
    if (this.hasDim(dim)) {
      var scale = this.getScale(dim);

      if (scale.isLinear) {
        this.translateLinear(dim, scale, normalPoint);
      } //  else { // 
      // this.translateCategory(dim, scale, normalPoint);
      // }

    }
  }; // linear 


  ScaleTranslate.prototype.translateLinear = function (dim, scale, normalPoint) {
    var view = this.context.view;
    var _a = this.startCache[dim],
        min = _a.min,
        max = _a.max;
    var range = max - min;
    var d = normalPoint[dim] * range; // 

    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        // @ts-ignore
        nice: scale.nice,
        min: min,
        max: max
      };
    }

    view.scale(scale.field, {
      // @ts-ignore
      nice: false,
      min: min + d,
      max: max + d
    });
  }; // 
  // private translateCategory(dim, scale, normalPoint) {
  // }

  /**
   * 
   */


  ScaleTranslate.prototype.reset = function () {
    _super.prototype.reset.call(this);

    this.startPoint = null;
    this.starting = false;
  };

  return ScaleTranslate;
}(scale_transform_1.default);

exports.default = ScaleTranslate;

/***/ }),
/* 977 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var scale_transform_1 = tslib_1.__importDefault(__webpack_require__(467));
/**
 *  Scale  Action
 * @ignore
 */


var ScaleTranslate =
/** @class */
function (_super) {
  tslib_1.__extends(ScaleTranslate, _super);

  function ScaleTranslate() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.zoomRatio = 0.05;
    return _this; // 
    // private translateCategory(dim, scale, normalPoint) {
    // }
  }
  /**
   * 
   */


  ScaleTranslate.prototype.zoomIn = function () {
    this.zoom(this.zoomRatio);
  };

  ScaleTranslate.prototype.zoom = function (scale) {
    var _this = this;

    var dims = this.dims;
    util_1.each(dims, function (dim) {
      _this.zoomDim(dim, scale);
    });
    this.context.view.render(true);
  };
  /**
   * 
   */


  ScaleTranslate.prototype.zoomOut = function () {
    this.zoom(-1 * this.zoomRatio);
  }; // 


  ScaleTranslate.prototype.zoomDim = function (dim, dRatio) {
    if (this.hasDim(dim)) {
      var scale = this.getScale(dim);

      if (scale.isLinear) {
        this.zoomLinear(dim, scale, dRatio);
      } //  else { // 
      // this.zoomCategory(dim, scale, normalPoint);
      // }

    }
  }; // linear 


  ScaleTranslate.prototype.zoomLinear = function (dim, scale, dRatio) {
    var view = this.context.view; // 

    if (!this.cacheScaleDefs[dim]) {
      this.cacheScaleDefs[dim] = {
        // @ts-ignore
        nice: scale.nice,
        min: scale.min,
        max: scale.max
      };
    } // 


    var scaleDef = this.cacheScaleDefs[dim];
    var range = scaleDef.max - scaleDef.min;
    var min = scale.min,
        max = scale.max;
    var d = dRatio * range;
    var toMin = min - d;
    var toMax = max + d;
    var curRange = toMax - toMin;
    var scaled = curRange / range;

    if (toMax > toMin && scaled < 100 && scaled > 0.01) {
      view.scale(scale.field, {
        // @ts-ignore
        nice: false,
        min: min - d,
        max: max + d
      });
    }
  };

  return ScaleTranslate;
}(scale_transform_1.default);

exports.default = ScaleTranslate;

/***/ }),
/* 978 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

/** @license React v0.25.1
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
module.exports = function $$$reconciler($$$hostConfig) {
  'use strict';

  var aa = __webpack_require__(979),
      ba = __webpack_require__(3),
      m = __webpack_require__(980);

  function n(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
      b += "&args[]=" + encodeURIComponent(arguments[c]);
    }

    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }

  var p = ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  p.hasOwnProperty("ReactCurrentDispatcher") || (p.ReactCurrentDispatcher = {
    current: null
  });
  p.hasOwnProperty("ReactCurrentBatchConfig") || (p.ReactCurrentBatchConfig = {
    suspense: null
  });
  var u = "function" === typeof Symbol && Symbol.for,
      ca = u ? Symbol.for("react.element") : 60103,
      da = u ? Symbol.for("react.portal") : 60106,
      ea = u ? Symbol.for("react.fragment") : 60107,
      fa = u ? Symbol.for("react.strict_mode") : 60108,
      ha = u ? Symbol.for("react.profiler") : 60114,
      ia = u ? Symbol.for("react.provider") : 60109,
      ja = u ? Symbol.for("react.context") : 60110,
      ka = u ? Symbol.for("react.concurrent_mode") : 60111,
      la = u ? Symbol.for("react.forward_ref") : 60112,
      ma = u ? Symbol.for("react.suspense") : 60113,
      na = u ? Symbol.for("react.suspense_list") : 60120,
      oa = u ? Symbol.for("react.memo") : 60115,
      pa = u ? Symbol.for("react.lazy") : 60116,
      qa = u ? Symbol.for("react.block") : 60121,
      ra = "function" === typeof Symbol && Symbol.iterator;

  function sa(a) {
    if (null === a || "object" !== (0, _typeof2.default)(a)) return null;
    a = ra && a[ra] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }

  function ta(a) {
    if (-1 === a._status) {
      a._status = 0;
      var b = a._ctor;
      b = b();
      a._result = b;
      b.then(function (b) {
        0 === a._status && (b = b.default, a._status = 1, a._result = b);
      }, function (b) {
        0 === a._status && (a._status = 2, a._result = b);
      });
    }
  }

  function ua(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;

    switch (a) {
      case ea:
        return "Fragment";

      case da:
        return "Portal";

      case ha:
        return "Profiler";

      case fa:
        return "StrictMode";

      case ma:
        return "Suspense";

      case na:
        return "SuspenseList";
    }

    if ("object" === (0, _typeof2.default)(a)) switch (a.$$typeof) {
      case ja:
        return "Context.Consumer";

      case ia:
        return "Context.Provider";

      case la:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");

      case oa:
        return ua(a.type);

      case qa:
        return ua(a.render);

      case pa:
        if (a = 1 === a._status ? a._result : null) return ua(a);
    }
    return null;
  }

  function va(a) {
    var b = a,
        c = a;
    if (a.alternate) for (; b.return;) {
      b = b.return;
    } else {
      a = b;

      do {
        b = a, 0 !== (b.effectTag & 1026) && (c = b.return), a = b.return;
      } while (a);
    }
    return 3 === b.tag ? c : null;
  }

  function wa(a) {
    if (va(a) !== a) throw Error(n(188));
  }

  function xa(a) {
    var b = a.alternate;

    if (!b) {
      b = va(a);
      if (null === b) throw Error(n(188));
      return b !== a ? null : a;
    }

    for (var c = a, d = b;;) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;

      if (null === f) {
        d = e.return;

        if (null !== d) {
          c = d;
          continue;
        }

        break;
      }

      if (e.child === f.child) {
        for (f = e.child; f;) {
          if (f === c) return wa(e), a;
          if (f === d) return wa(e), b;
          f = f.sibling;
        }

        throw Error(n(188));
      }

      if (c.return !== d.return) c = e, d = f;else {
        for (var g = !1, h = e.child; h;) {
          if (h === c) {
            g = !0;
            c = e;
            d = f;
            break;
          }

          if (h === d) {
            g = !0;
            d = e;
            c = f;
            break;
          }

          h = h.sibling;
        }

        if (!g) {
          for (h = f.child; h;) {
            if (h === c) {
              g = !0;
              c = f;
              d = e;
              break;
            }

            if (h === d) {
              g = !0;
              d = f;
              c = e;
              break;
            }

            h = h.sibling;
          }

          if (!g) throw Error(n(189));
        }
      }
      if (c.alternate !== d) throw Error(n(190));
    }

    if (3 !== c.tag) throw Error(n(188));
    return c.stateNode.current === c ? a : b;
  }

  function ya(a) {
    a = xa(a);
    if (!a) return null;

    for (var b = a;;) {
      if (5 === b.tag || 6 === b.tag) return b;
      if (b.child) b.child.return = b, b = b.child;else {
        if (b === a) break;

        for (; !b.sibling;) {
          if (!b.return || b.return === a) return null;
          b = b.return;
        }

        b.sibling.return = b.return;
        b = b.sibling;
      }
    }

    return null;
  }

  function za(a) {
    a = xa(a);
    if (!a) return null;

    for (var b = a;;) {
      if (5 === b.tag || 6 === b.tag) return b;
      if (b.child && 4 !== b.tag) b.child.return = b, b = b.child;else {
        if (b === a) break;

        for (; !b.sibling;) {
          if (!b.return || b.return === a) return null;
          b = b.return;
        }

        b.sibling.return = b.return;
        b = b.sibling;
      }
    }

    return null;
  }

  var Aa = $$$hostConfig.getPublicInstance,
      Ba = $$$hostConfig.getRootHostContext,
      Ca = $$$hostConfig.getChildHostContext,
      Da = $$$hostConfig.prepareForCommit,
      Ea = $$$hostConfig.resetAfterCommit,
      Fa = $$$hostConfig.createInstance,
      Ga = $$$hostConfig.appendInitialChild,
      Ha = $$$hostConfig.finalizeInitialChildren,
      Ia = $$$hostConfig.prepareUpdate,
      Ja = $$$hostConfig.shouldSetTextContent,
      Ka = $$$hostConfig.shouldDeprioritizeSubtree,
      La = $$$hostConfig.createTextInstance,
      Ma = $$$hostConfig.setTimeout,
      Na = $$$hostConfig.clearTimeout,
      Oa = $$$hostConfig.noTimeout,
      Pa = $$$hostConfig.isPrimaryRenderer,
      Qa = $$$hostConfig.supportsMutation,
      Ra = $$$hostConfig.supportsPersistence,
      Sa = $$$hostConfig.supportsHydration,
      Ta = $$$hostConfig.appendChild,
      Ua = $$$hostConfig.appendChildToContainer,
      Va = $$$hostConfig.commitTextUpdate,
      Wa = $$$hostConfig.commitMount,
      Xa = $$$hostConfig.commitUpdate,
      Ya = $$$hostConfig.insertBefore,
      Za = $$$hostConfig.insertInContainerBefore,
      $a = $$$hostConfig.removeChild,
      ab = $$$hostConfig.removeChildFromContainer,
      bb = $$$hostConfig.resetTextContent,
      cb = $$$hostConfig.hideInstance,
      db = $$$hostConfig.hideTextInstance,
      eb = $$$hostConfig.unhideInstance,
      fb = $$$hostConfig.unhideTextInstance,
      gb = $$$hostConfig.cloneInstance,
      hb = $$$hostConfig.createContainerChildSet,
      ib = $$$hostConfig.appendChildToContainerChildSet,
      jb = $$$hostConfig.finalizeContainerChildren,
      kb = $$$hostConfig.replaceContainerChildren,
      lb = $$$hostConfig.cloneHiddenInstance,
      mb = $$$hostConfig.cloneHiddenTextInstance,
      nb = $$$hostConfig.canHydrateInstance,
      ob = $$$hostConfig.canHydrateTextInstance,
      pb = $$$hostConfig.isSuspenseInstancePending,
      qb = $$$hostConfig.isSuspenseInstanceFallback,
      rb = $$$hostConfig.getNextHydratableSibling,
      sb = $$$hostConfig.getFirstHydratableChild,
      tb = $$$hostConfig.hydrateInstance,
      ub = $$$hostConfig.hydrateTextInstance,
      vb = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,
      wb = $$$hostConfig.commitHydratedContainer,
      xb = $$$hostConfig.commitHydratedSuspenseInstance,
      yb = /^(.*)[\\\/]/;

  function zb(a) {
    var b = "";

    do {
      a: switch (a.tag) {
        case 3:
        case 4:
        case 6:
        case 7:
        case 10:
        case 9:
          var c = "";
          break a;

        default:
          var d = a._debugOwner,
              e = a._debugSource,
              f = ua(a.type);
          c = null;
          d && (c = ua(d.type));
          d = f;
          f = "";
          e ? f = " (at " + e.fileName.replace(yb, "") + ":" + e.lineNumber + ")" : c && (f = " (created by " + c + ")");
          c = "\n    in " + (d || "Unknown") + f;
      }

      b += c;
      a = a.return;
    } while (a);

    return b;
  }

  var Ab = [],
      Bb = -1;

  function B(a) {
    0 > Bb || (a.current = Ab[Bb], Ab[Bb] = null, Bb--);
  }

  function C(a, b) {
    Bb++;
    Ab[Bb] = a.current;
    a.current = b;
  }

  var Cb = {},
      D = {
    current: Cb
  },
      E = {
    current: !1
  },
      Db = Cb;

  function Eb(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Cb;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {},
        f;

    for (f in c) {
      e[f] = b[f];
    }

    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }

  function F(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }

  function Fb() {
    B(E);
    B(D);
  }

  function Gb(a, b, c) {
    if (D.current !== Cb) throw Error(n(168));
    C(D, b);
    C(E, c);
  }

  function Hb(a, b, c) {
    var d = a.stateNode;
    a = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();

    for (var e in d) {
      if (!(e in a)) throw Error(n(108, ua(b) || "Unknown", e));
    }

    return aa({}, c, {}, d);
  }

  function Ib(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cb;
    Db = D.current;
    C(D, a);
    C(E, E.current);
    return !0;
  }

  function Jb(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(n(169));
    c ? (a = Hb(a, b, Db), d.__reactInternalMemoizedMergedChildContext = a, B(E), B(D), C(D, a)) : B(E);
    C(E, c);
  }

  var Kb = m.unstable_runWithPriority,
      Lb = m.unstable_scheduleCallback,
      Mb = m.unstable_cancelCallback,
      Nb = m.unstable_requestPaint,
      Ob = m.unstable_now,
      Pb = m.unstable_getCurrentPriorityLevel,
      Qb = m.unstable_ImmediatePriority,
      Rb = m.unstable_UserBlockingPriority,
      Sb = m.unstable_NormalPriority,
      Tb = m.unstable_LowPriority,
      Ub = m.unstable_IdlePriority,
      Vb = {},
      Wb = m.unstable_shouldYield,
      Xb = void 0 !== Nb ? Nb : function () {},
      Yb = null,
      Zb = null,
      $b = !1,
      ac = Ob(),
      G = 1E4 > ac ? Ob : function () {
    return Ob() - ac;
  };

  function bc() {
    switch (Pb()) {
      case Qb:
        return 99;

      case Rb:
        return 98;

      case Sb:
        return 97;

      case Tb:
        return 96;

      case Ub:
        return 95;

      default:
        throw Error(n(332));
    }
  }

  function cc(a) {
    switch (a) {
      case 99:
        return Qb;

      case 98:
        return Rb;

      case 97:
        return Sb;

      case 96:
        return Tb;

      case 95:
        return Ub;

      default:
        throw Error(n(332));
    }
  }

  function dc(a, b) {
    a = cc(a);
    return Kb(a, b);
  }

  function ec(a, b, c) {
    a = cc(a);
    return Lb(a, b, c);
  }

  function fc(a) {
    null === Yb ? (Yb = [a], Zb = Lb(Qb, gc)) : Yb.push(a);
    return Vb;
  }

  function H() {
    if (null !== Zb) {
      var a = Zb;
      Zb = null;
      Mb(a);
    }

    gc();
  }

  function gc() {
    if (!$b && null !== Yb) {
      $b = !0;
      var a = 0;

      try {
        var b = Yb;
        dc(99, function () {
          for (; a < b.length; a++) {
            var c = b[a];

            do {
              c = c(!0);
            } while (null !== c);
          }
        });
        Yb = null;
      } catch (c) {
        throw null !== Yb && (Yb = Yb.slice(a + 1)), Lb(Qb, H), c;
      } finally {
        $b = !1;
      }
    }
  }

  function hc(a, b, c) {
    c /= 10;
    return 1073741821 - (((1073741821 - a + b / 10) / c | 0) + 1) * c;
  }

  function ic(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }

  var jc = "function" === typeof Object.is ? Object.is : ic,
      kc = Object.prototype.hasOwnProperty;

  function lc(a, b) {
    if (jc(a, b)) return !0;
    if ("object" !== (0, _typeof2.default)(a) || null === a || "object" !== (0, _typeof2.default)(b) || null === b) return !1;
    var c = Object.keys(a),
        d = Object.keys(b);
    if (c.length !== d.length) return !1;

    for (d = 0; d < c.length; d++) {
      if (!kc.call(b, c[d]) || !jc(a[c[d]], b[c[d]])) return !1;
    }

    return !0;
  }

  function mc(a, b) {
    if (a && a.defaultProps) {
      b = aa({}, b);
      a = a.defaultProps;

      for (var c in a) {
        void 0 === b[c] && (b[c] = a[c]);
      }
    }

    return b;
  }

  var nc = {
    current: null
  },
      oc = null,
      pc = null,
      qc = null;

  function rc() {
    qc = pc = oc = null;
  }

  function sc(a, b) {
    a = a.type._context;
    Pa ? (C(nc, a._currentValue), a._currentValue = b) : (C(nc, a._currentValue2), a._currentValue2 = b);
  }

  function tc(a) {
    var b = nc.current;
    B(nc);
    a = a.type._context;
    Pa ? a._currentValue = b : a._currentValue2 = b;
  }

  function uc(a, b) {
    for (; null !== a;) {
      var c = a.alternate;
      if (a.childExpirationTime < b) a.childExpirationTime = b, null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);else if (null !== c && c.childExpirationTime < b) c.childExpirationTime = b;else break;
      a = a.return;
    }
  }

  function vc(a, b) {
    oc = a;
    qc = pc = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (a.expirationTime >= b && (wc = !0), a.firstContext = null);
  }

  function I(a, b) {
    if (qc !== a && !1 !== b && 0 !== b) {
      if ("number" !== typeof b || 1073741823 === b) qc = a, b = 1073741823;
      b = {
        context: a,
        observedBits: b,
        next: null
      };

      if (null === pc) {
        if (null === oc) throw Error(n(308));
        pc = b;
        oc.dependencies = {
          expirationTime: 0,
          firstContext: b,
          responders: null
        };
      } else pc = pc.next = b;
    }

    return Pa ? a._currentValue : a._currentValue2;
  }

  var xc = !1;

  function yc(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      baseQueue: null,
      shared: {
        pending: null
      },
      effects: null
    };
  }

  function zc(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = {
      baseState: a.baseState,
      baseQueue: a.baseQueue,
      shared: a.shared,
      effects: a.effects
    });
  }

  function Ac(a, b) {
    a = {
      expirationTime: a,
      suspenseConfig: b,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
    return a.next = a;
  }

  function Bc(a, b) {
    a = a.updateQueue;

    if (null !== a) {
      a = a.shared;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
  }

  function Cc(a, b) {
    var c = a.alternate;
    null !== c && zc(c, a);
    a = a.updateQueue;
    c = a.baseQueue;
    null === c ? (a.baseQueue = b.next = b, b.next = b) : (b.next = c.next, c.next = b);
  }

  function Dc(a, b, c, d) {
    var e = a.updateQueue;
    xc = !1;
    var f = e.baseQueue,
        g = e.shared.pending;

    if (null !== g) {
      if (null !== f) {
        var h = f.next;
        f.next = g.next;
        g.next = h;
      }

      f = g;
      e.shared.pending = null;
      h = a.alternate;
      null !== h && (h = h.updateQueue, null !== h && (h.baseQueue = g));
    }

    if (null !== f) {
      h = f.next;
      var k = e.baseState,
          l = 0,
          q = null,
          r = null,
          w = null;

      if (null !== h) {
        var z = h;

        do {
          g = z.expirationTime;

          if (g < d) {
            var Q = {
              expirationTime: z.expirationTime,
              suspenseConfig: z.suspenseConfig,
              tag: z.tag,
              payload: z.payload,
              callback: z.callback,
              next: null
            };
            null === w ? (r = w = Q, q = k) : w = w.next = Q;
            g > l && (l = g);
          } else {
            null !== w && (w = w.next = {
              expirationTime: 1073741823,
              suspenseConfig: z.suspenseConfig,
              tag: z.tag,
              payload: z.payload,
              callback: z.callback,
              next: null
            });
            Ec(g, z.suspenseConfig);

            a: {
              var A = a,
                  v = z;
              g = b;
              Q = c;

              switch (v.tag) {
                case 1:
                  A = v.payload;

                  if ("function" === typeof A) {
                    k = A.call(Q, k, g);
                    break a;
                  }

                  k = A;
                  break a;

                case 3:
                  A.effectTag = A.effectTag & -4097 | 64;

                case 0:
                  A = v.payload;
                  g = "function" === typeof A ? A.call(Q, k, g) : A;
                  if (null === g || void 0 === g) break a;
                  k = aa({}, k, g);
                  break a;

                case 2:
                  xc = !0;
              }
            }

            null !== z.callback && (a.effectTag |= 32, g = e.effects, null === g ? e.effects = [z] : g.push(z));
          }

          z = z.next;
          if (null === z || z === h) if (g = e.shared.pending, null === g) break;else z = f.next = g.next, g.next = h, e.baseQueue = f = g, e.shared.pending = null;
        } while (1);
      }

      null === w ? q = k : w.next = r;
      e.baseState = q;
      e.baseQueue = w;
      Gc(l);
      a.expirationTime = l;
      a.memoizedState = k;
    }
  }

  function Hc(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b],
          e = d.callback;

      if (null !== e) {
        d.callback = null;
        d = e;
        e = c;
        if ("function" !== typeof d) throw Error(n(191, d));
        d.call(e);
      }
    }
  }

  var Ic = p.ReactCurrentBatchConfig,
      Jc = new ba.Component().refs;

  function Kc(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : aa({}, b, c);
    a.memoizedState = c;
    0 === a.expirationTime && (a.updateQueue.baseState = c);
  }

  var Oc = {
    isMounted: function isMounted(a) {
      return (a = a._reactInternalFiber) ? va(a) === a : !1;
    },
    enqueueSetState: function enqueueSetState(a, b, c) {
      a = a._reactInternalFiber;
      var d = Lc(),
          e = Ic.suspense;
      d = Mc(d, a, e);
      e = Ac(d, e);
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      Bc(a, e);
      Nc(a, d);
    },
    enqueueReplaceState: function enqueueReplaceState(a, b, c) {
      a = a._reactInternalFiber;
      var d = Lc(),
          e = Ic.suspense;
      d = Mc(d, a, e);
      e = Ac(d, e);
      e.tag = 1;
      e.payload = b;
      void 0 !== c && null !== c && (e.callback = c);
      Bc(a, e);
      Nc(a, d);
    },
    enqueueForceUpdate: function enqueueForceUpdate(a, b) {
      a = a._reactInternalFiber;
      var c = Lc(),
          d = Ic.suspense;
      c = Mc(c, a, d);
      d = Ac(c, d);
      d.tag = 2;
      void 0 !== b && null !== b && (d.callback = b);
      Bc(a, d);
      Nc(a, c);
    }
  };

  function Pc(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !lc(c, d) || !lc(e, f) : !0;
  }

  function Qc(a, b, c) {
    var d = !1,
        e = Cb;
    var f = b.contextType;
    "object" === (0, _typeof2.default)(f) && null !== f ? f = I(f) : (e = F(b) ? Db : D.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Eb(a, e) : Cb);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Oc;
    a.stateNode = b;
    b._reactInternalFiber = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }

  function Rc(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Oc.enqueueReplaceState(b, b.state, null);
  }

  function Sc(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = Jc;
    yc(a);
    var f = b.contextType;
    "object" === (0, _typeof2.default)(f) && null !== f ? e.context = I(f) : (f = F(b) ? Db : D.current, e.context = Eb(a, f));
    Dc(a, c, e, d);
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Kc(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Oc.enqueueReplaceState(e, e.state, null), Dc(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.effectTag |= 4);
  }

  var Tc = Array.isArray;

  function Uc(a, b, c) {
    a = c.ref;

    if (null !== a && "function" !== typeof a && "object" !== (0, _typeof2.default)(a)) {
      if (c._owner) {
        c = c._owner;

        if (c) {
          if (1 !== c.tag) throw Error(n(309));
          var d = c.stateNode;
        }

        if (!d) throw Error(n(147, a));
        var e = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;

        b = function b(a) {
          var b = d.refs;
          b === Jc && (b = d.refs = {});
          null === a ? delete b[e] : b[e] = a;
        };

        b._stringRef = e;
        return b;
      }

      if ("string" !== typeof a) throw Error(n(284));
      if (!c._owner) throw Error(n(290, a));
    }

    return a;
  }

  function Vc(a, b) {
    if ("textarea" !== a.type) throw Error(n(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, ""));
  }

  function Wc(a) {
    function b(b, c) {
      if (a) {
        var d = b.lastEffect;
        null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
        c.nextEffect = null;
        c.effectTag = 8;
      }
    }

    function c(c, d) {
      if (!a) return null;

      for (; null !== d;) {
        b(c, d), d = d.sibling;
      }

      return null;
    }

    function d(b, a) {
      for (b = new Map(); null !== a;) {
        null !== a.key ? b.set(a.key, a) : b.set(a.index, a), a = a.sibling;
      }

      return b;
    }

    function e(a, b) {
      a = Xc(a, b);
      a.index = 0;
      a.sibling = null;
      return a;
    }

    function f(b, c, d) {
      b.index = d;
      if (!a) return c;
      d = b.alternate;
      if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;
      b.effectTag = 2;
      return c;
    }

    function g(b) {
      a && null === b.alternate && (b.effectTag = 2);
      return b;
    }

    function h(b, a, c, d) {
      if (null === a || 6 !== a.tag) return a = Yc(c, b.mode, d), a.return = b, a;
      a = e(a, c);
      a.return = b;
      return a;
    }

    function k(a, b, c, d) {
      if (null !== b && b.elementType === c.type) return d = e(b, c.props), d.ref = Uc(a, b, c), d.return = a, d;
      d = Zc(c.type, c.key, c.props, null, a.mode, d);
      d.ref = Uc(a, b, c);
      d.return = a;
      return d;
    }

    function l(a, b, c, d) {
      if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = $c(c, a.mode, d), b.return = a, b;
      b = e(b, c.children || []);
      b.return = a;
      return b;
    }

    function q(b, a, c, d, f) {
      if (null === a || 7 !== a.tag) return a = ad(c, b.mode, d, f), a.return = b, a;
      a = e(a, c);
      a.return = b;
      return a;
    }

    function r(a, b, c) {
      if ("string" === typeof b || "number" === typeof b) return b = Yc("" + b, a.mode, c), b.return = a, b;

      if ("object" === (0, _typeof2.default)(b) && null !== b) {
        switch (b.$$typeof) {
          case ca:
            return c = Zc(b.type, b.key, b.props, null, a.mode, c), c.ref = Uc(a, null, b), c.return = a, c;

          case da:
            return b = $c(b, a.mode, c), b.return = a, b;
        }

        if (Tc(b) || sa(b)) return b = ad(b, a.mode, c, null), b.return = a, b;
        Vc(a, b);
      }

      return null;
    }

    function w(b, a, c, d) {
      var e = null !== a ? a.key : null;
      if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(b, a, "" + c, d);

      if ("object" === (0, _typeof2.default)(c) && null !== c) {
        switch (c.$$typeof) {
          case ca:
            return c.key === e ? c.type === ea ? q(b, a, c.props.children, d, e) : k(b, a, c, d) : null;

          case da:
            return c.key === e ? l(b, a, c, d) : null;
        }

        if (Tc(c) || sa(c)) return null !== e ? null : q(b, a, c, d, null);
        Vc(b, c);
      }

      return null;
    }

    function z(b, a, c, d, e) {
      if ("string" === typeof d || "number" === typeof d) return b = b.get(c) || null, h(a, b, "" + d, e);

      if ("object" === (0, _typeof2.default)(d) && null !== d) {
        switch (d.$$typeof) {
          case ca:
            return b = b.get(null === d.key ? c : d.key) || null, d.type === ea ? q(a, b, d.props.children, e, d.key) : k(a, b, d, e);

          case da:
            return b = b.get(null === d.key ? c : d.key) || null, l(a, b, d, e);
        }

        if (Tc(d) || sa(d)) return b = b.get(c) || null, q(a, b, d, e, null);
        Vc(a, d);
      }

      return null;
    }

    function Q(e, g, h, k) {
      for (var l = null, v = null, t = g, x = g = 0, q = null; null !== t && x < h.length; x++) {
        t.index > x ? (q = t, t = null) : q = t.sibling;
        var y = w(e, t, h[x], k);

        if (null === y) {
          null === t && (t = q);
          break;
        }

        a && t && null === y.alternate && b(e, t);
        g = f(y, g, x);
        null === v ? l = y : v.sibling = y;
        v = y;
        t = q;
      }

      if (x === h.length) return c(e, t), l;

      if (null === t) {
        for (; x < h.length; x++) {
          t = r(e, h[x], k), null !== t && (g = f(t, g, x), null === v ? l = t : v.sibling = t, v = t);
        }

        return l;
      }

      for (t = d(e, t); x < h.length; x++) {
        q = z(t, e, x, h[x], k), null !== q && (a && null !== q.alternate && t.delete(null === q.key ? x : q.key), g = f(q, g, x), null === v ? l = q : v.sibling = q, v = q);
      }

      a && t.forEach(function (a) {
        return b(e, a);
      });
      return l;
    }

    function A(e, g, h, k) {
      var t = sa(h);
      if ("function" !== typeof t) throw Error(n(150));
      h = t.call(h);
      if (null == h) throw Error(n(151));

      for (var l = t = null, v = g, x = g = 0, q = null, y = h.next(); null !== v && !y.done; x++, y = h.next()) {
        v.index > x ? (q = v, v = null) : q = v.sibling;
        var A = w(e, v, y.value, k);

        if (null === A) {
          null === v && (v = q);
          break;
        }

        a && v && null === A.alternate && b(e, v);
        g = f(A, g, x);
        null === l ? t = A : l.sibling = A;
        l = A;
        v = q;
      }

      if (y.done) return c(e, v), t;

      if (null === v) {
        for (; !y.done; x++, y = h.next()) {
          y = r(e, y.value, k), null !== y && (g = f(y, g, x), null === l ? t = y : l.sibling = y, l = y);
        }

        return t;
      }

      for (v = d(e, v); !y.done; x++, y = h.next()) {
        y = z(v, e, x, y.value, k), null !== y && (a && null !== y.alternate && v.delete(null === y.key ? x : y.key), g = f(y, g, x), null === l ? t = y : l.sibling = y, l = y);
      }

      a && v.forEach(function (a) {
        return b(e, a);
      });
      return t;
    }

    return function (a, d, f, h) {
      var k = "object" === (0, _typeof2.default)(f) && null !== f && f.type === ea && null === f.key;
      k && (f = f.props.children);
      var l = "object" === (0, _typeof2.default)(f) && null !== f;
      if (l) switch (f.$$typeof) {
        case ca:
          a: {
            l = f.key;

            for (k = d; null !== k;) {
              if (k.key === l) {
                switch (k.tag) {
                  case 7:
                    if (f.type === ea) {
                      c(a, k.sibling);
                      d = e(k, f.props.children);
                      d.return = a;
                      a = d;
                      break a;
                    }

                    break;

                  default:
                    if (k.elementType === f.type) {
                      c(a, k.sibling);
                      d = e(k, f.props);
                      d.ref = Uc(a, k, f);
                      d.return = a;
                      a = d;
                      break a;
                    }

                }

                c(a, k);
                break;
              } else b(a, k);

              k = k.sibling;
            }

            f.type === ea ? (d = ad(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Zc(f.type, f.key, f.props, null, a.mode, h), h.ref = Uc(a, d, f), h.return = a, a = h);
          }

          return g(a);

        case da:
          a: {
            for (k = f.key; null !== d;) {
              if (d.key === k) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }

            d = $c(f, a.mode, h);
            d.return = a;
            a = d;
          }

          return g(a);
      }
      if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Yc(f, a.mode, h), d.return = a, a = d), g(a);
      if (Tc(f)) return Q(a, d, f, h);
      if (sa(f)) return A(a, d, f, h);
      l && Vc(a, f);
      if ("undefined" === typeof f && !k) switch (a.tag) {
        case 1:
        case 0:
          throw a = a.type, Error(n(152, a.displayName || a.name || "Component"));
      }
      return c(a, d);
    };
  }

  var bd = Wc(!0),
      cd = Wc(!1),
      dd = {},
      J = {
    current: dd
  },
      ed = {
    current: dd
  },
      fd = {
    current: dd
  };

  function gd(a) {
    if (a === dd) throw Error(n(174));
    return a;
  }

  function hd(a, b) {
    C(fd, b);
    C(ed, a);
    C(J, dd);
    a = Ba(b);
    B(J);
    C(J, a);
  }

  function id() {
    B(J);
    B(ed);
    B(fd);
  }

  function jd(a) {
    var b = gd(fd.current),
        c = gd(J.current);
    b = Ca(c, a.type, b);
    c !== b && (C(ed, a), C(J, b));
  }

  function kd(a) {
    ed.current === a && (B(J), B(ed));
  }

  var K = {
    current: 0
  };

  function ld(a) {
    for (var b = a; null !== b;) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || pb(c) || qb(c))) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.effectTag & 64)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }

      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }

    return null;
  }

  function md(a, b) {
    return {
      responder: a,
      props: b
    };
  }

  var nd = p.ReactCurrentDispatcher,
      L = p.ReactCurrentBatchConfig,
      od = 0,
      M = null,
      N = null,
      O = null,
      pd = !1;

  function P() {
    throw Error(n(321));
  }

  function qd(a, b) {
    if (null === b) return !1;

    for (var c = 0; c < b.length && c < a.length; c++) {
      if (!jc(a[c], b[c])) return !1;
    }

    return !0;
  }

  function rd(a, b, c, d, e, f) {
    od = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.expirationTime = 0;
    nd.current = null === a || null === a.memoizedState ? sd : td;
    a = c(d, e);

    if (b.expirationTime === od) {
      f = 0;

      do {
        b.expirationTime = 0;
        if (!(25 > f)) throw Error(n(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        nd.current = ud;
        a = c(d, e);
      } while (b.expirationTime === od);
    }

    nd.current = vd;
    b = null !== N && null !== N.next;
    od = 0;
    O = N = M = null;
    pd = !1;
    if (b) throw Error(n(300));
    return a;
  }

  function wd() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }

  function xd() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;

    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;else {
      if (null === a) throw Error(n(310));
      N = a;
      a = {
        memoizedState: N.memoizedState,
        baseState: N.baseState,
        baseQueue: N.baseQueue,
        queue: N.queue,
        next: null
      };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }

  function yd(a, b) {
    return "function" === typeof b ? b(a) : b;
  }

  function zd(a) {
    var b = xd(),
        c = b.queue;
    if (null === c) throw Error(n(311));
    c.lastRenderedReducer = a;
    var d = N,
        e = d.baseQueue,
        f = c.pending;

    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }

      d.baseQueue = e = f;
      c.pending = null;
    }

    if (null !== e) {
      e = e.next;
      d = d.baseState;
      var h = g = f = null,
          k = e;

      do {
        var l = k.expirationTime;

        if (l < od) {
          var q = {
            expirationTime: k.expirationTime,
            suspenseConfig: k.suspenseConfig,
            action: k.action,
            eagerReducer: k.eagerReducer,
            eagerState: k.eagerState,
            next: null
          };
          null === h ? (g = h = q, f = d) : h = h.next = q;
          l > M.expirationTime && (M.expirationTime = l, Gc(l));
        } else null !== h && (h = h.next = {
          expirationTime: 1073741823,
          suspenseConfig: k.suspenseConfig,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        }), Ec(l, k.suspenseConfig), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);

        k = k.next;
      } while (null !== k && k !== e);

      null === h ? f = d : h.next = g;
      jc(d, b.memoizedState) || (wc = !0);
      b.memoizedState = d;
      b.baseState = f;
      b.baseQueue = h;
      c.lastRenderedState = d;
    }

    return [b.memoizedState, c.dispatch];
  }

  function Ad(a) {
    var b = xd(),
        c = b.queue;
    if (null === c) throw Error(n(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch,
        e = c.pending,
        f = b.memoizedState;

    if (null !== e) {
      c.pending = null;
      var g = e = e.next;

      do {
        f = a(f, g.action), g = g.next;
      } while (g !== e);

      jc(f, b.memoizedState) || (wc = !0);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }

    return [f, d];
  }

  function Bd(a) {
    var b = wd();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = b.queue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: yd,
      lastRenderedState: a
    };
    a = a.dispatch = Cd.bind(null, M, a);
    return [b.memoizedState, a];
  }

  function Dd(a, b, c, d) {
    a = {
      tag: a,
      create: b,
      destroy: c,
      deps: d,
      next: null
    };
    b = M.updateQueue;
    null === b ? (b = {
      lastEffect: null
    }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }

  function Ed() {
    return xd().memoizedState;
  }

  function Fd(a, b, c, d) {
    var e = wd();
    M.effectTag |= a;
    e.memoizedState = Dd(1 | b, c, void 0, void 0 === d ? null : d);
  }

  function Gd(a, b, c, d) {
    var e = xd();
    d = void 0 === d ? null : d;
    var f = void 0;

    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;

      if (null !== d && qd(d, g.deps)) {
        Dd(b, c, f, d);
        return;
      }
    }

    M.effectTag |= a;
    e.memoizedState = Dd(1 | b, c, f, d);
  }

  function Hd(a, b) {
    return Fd(516, 4, a, b);
  }

  function Id(a, b) {
    return Gd(516, 4, a, b);
  }

  function Jd(a, b) {
    return Gd(4, 2, a, b);
  }

  function Kd(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function () {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
      b.current = null;
    };
  }

  function Ld(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return Gd(4, 2, Kd.bind(null, b, a), c);
  }

  function Md() {}

  function Nd(a, b) {
    wd().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }

  function Od(a, b) {
    var c = xd();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && qd(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }

  function Pd(a, b) {
    var c = xd();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && qd(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }

  function Qd(a, b, c) {
    var d = bc();
    dc(98 > d ? 98 : d, function () {
      a(!0);
    });
    dc(97 < d ? 97 : d, function () {
      var d = L.suspense;
      L.suspense = void 0 === b ? null : b;

      try {
        a(!1), c();
      } finally {
        L.suspense = d;
      }
    });
  }

  function Cd(a, b, c) {
    var d = Lc(),
        e = Ic.suspense;
    d = Mc(d, a, e);
    e = {
      expirationTime: d,
      suspenseConfig: e,
      action: c,
      eagerReducer: null,
      eagerState: null,
      next: null
    };
    var f = b.pending;
    null === f ? e.next = e : (e.next = f.next, f.next = e);
    b.pending = e;
    f = a.alternate;
    if (a === M || null !== f && f === M) pd = !0, e.expirationTime = od, M.expirationTime = od;else {
      if (0 === a.expirationTime && (null === f || 0 === f.expirationTime) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState,
            h = f(g, c);
        e.eagerReducer = f;
        e.eagerState = h;
        if (jc(h, g)) return;
      } catch (k) {} finally {}
      Nc(a, d);
    }
  }

  var vd = {
    readContext: I,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useResponder: P,
    useDeferredValue: P,
    useTransition: P
  },
      sd = {
    readContext: I,
    useCallback: Nd,
    useContext: I,
    useEffect: Hd,
    useImperativeHandle: function useImperativeHandle(a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Fd(4, 2, Kd.bind(null, b, a), c);
    },
    useLayoutEffect: function useLayoutEffect(a, b) {
      return Fd(4, 2, a, b);
    },
    useMemo: function useMemo(a, b) {
      var c = wd();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: function useReducer(a, b, c) {
      var d = wd();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = d.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      a = a.dispatch = Cd.bind(null, M, a);
      return [d.memoizedState, a];
    },
    useRef: function useRef(a) {
      var b = wd();
      a = {
        current: a
      };
      return b.memoizedState = a;
    },
    useState: Bd,
    useDebugValue: Md,
    useResponder: md,
    useDeferredValue: function useDeferredValue(a, b) {
      var c = Bd(a),
          d = c[0],
          e = c[1];
      Hd(function () {
        var c = L.suspense;
        L.suspense = void 0 === b ? null : b;

        try {
          e(a);
        } finally {
          L.suspense = c;
        }
      }, [a, b]);
      return d;
    },
    useTransition: function useTransition(a) {
      var b = Bd(!1),
          c = b[0];
      b = b[1];
      return [Nd(Qd.bind(null, b, a), [b, a]), c];
    }
  },
      td = {
    readContext: I,
    useCallback: Od,
    useContext: I,
    useEffect: Id,
    useImperativeHandle: Ld,
    useLayoutEffect: Jd,
    useMemo: Pd,
    useReducer: zd,
    useRef: Ed,
    useState: function useState() {
      return zd(yd);
    },
    useDebugValue: Md,
    useResponder: md,
    useDeferredValue: function useDeferredValue(a, b) {
      var c = zd(yd),
          d = c[0],
          e = c[1];
      Id(function () {
        var c = L.suspense;
        L.suspense = void 0 === b ? null : b;

        try {
          e(a);
        } finally {
          L.suspense = c;
        }
      }, [a, b]);
      return d;
    },
    useTransition: function useTransition(a) {
      var b = zd(yd),
          c = b[0];
      b = b[1];
      return [Od(Qd.bind(null, b, a), [b, a]), c];
    }
  },
      ud = {
    readContext: I,
    useCallback: Od,
    useContext: I,
    useEffect: Id,
    useImperativeHandle: Ld,
    useLayoutEffect: Jd,
    useMemo: Pd,
    useReducer: Ad,
    useRef: Ed,
    useState: function useState() {
      return Ad(yd);
    },
    useDebugValue: Md,
    useResponder: md,
    useDeferredValue: function useDeferredValue(a, b) {
      var c = Ad(yd),
          d = c[0],
          e = c[1];
      Id(function () {
        var c = L.suspense;
        L.suspense = void 0 === b ? null : b;

        try {
          e(a);
        } finally {
          L.suspense = c;
        }
      }, [a, b]);
      return d;
    },
    useTransition: function useTransition(a) {
      var b = Ad(yd),
          c = b[0];
      b = b[1];
      return [Od(Qd.bind(null, b, a), [b, a]), c];
    }
  },
      Rd = null,
      Sd = null,
      Td = !1;

  function Ud(a, b) {
    var c = Vd(5, null, null, 0);
    c.elementType = "DELETED";
    c.type = "DELETED";
    c.stateNode = b;
    c.return = a;
    c.effectTag = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }

  function Wd(a, b) {
    switch (a.tag) {
      case 5:
        return b = nb(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 6:
        return b = ob(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 13:
        return !1;

      default:
        return !1;
    }
  }

  function Xd(a) {
    if (Td) {
      var b = Sd;

      if (b) {
        var c = b;

        if (!Wd(a, b)) {
          b = rb(c);

          if (!b || !Wd(a, b)) {
            a.effectTag = a.effectTag & -1025 | 2;
            Td = !1;
            Rd = a;
            return;
          }

          Ud(Rd, c);
        }

        Rd = a;
        Sd = sb(b);
      } else a.effectTag = a.effectTag & -1025 | 2, Td = !1, Rd = a;
    }
  }

  function Yd(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) {
      a = a.return;
    }

    Rd = a;
  }

  function Zd(a) {
    if (!Sa || a !== Rd) return !1;
    if (!Td) return Yd(a), Td = !0, !1;
    var b = a.type;
    if (5 !== a.tag || "head" !== b && "body" !== b && !Ja(b, a.memoizedProps)) for (b = Sd; b;) {
      Ud(a, b), b = rb(b);
    }
    Yd(a);

    if (13 === a.tag) {
      if (!Sa) throw Error(n(316));
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(n(317));
      Sd = vb(a);
    } else Sd = Rd ? rb(a.stateNode) : null;

    return !0;
  }

  function $d() {
    Sa && (Sd = Rd = null, Td = !1);
  }

  var ae = p.ReactCurrentOwner,
      wc = !1;

  function R(a, b, c, d) {
    b.child = null === a ? cd(b, null, c, d) : bd(b, a.child, c, d);
  }

  function be(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    vc(b, e);
    d = rd(a, b, c, d, f, e);
    if (null !== a && !wc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), ce(a, b, e);
    b.effectTag |= 1;
    R(a, b, d, e);
    return b.child;
  }

  function de(a, b, c, d, e, f) {
    if (null === a) {
      var g = c.type;
      if ("function" === typeof g && !ee(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, fe(a, b, g, d, e, f);
      a = Zc(c.type, null, d, null, b.mode, f);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }

    g = a.child;
    if (e < f && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : lc, c(e, d) && a.ref === b.ref)) return ce(a, b, f);
    b.effectTag |= 1;
    a = Xc(g, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }

  function fe(a, b, c, d, e, f) {
    return null !== a && lc(a.memoizedProps, d) && a.ref === b.ref && (wc = !1, e < f) ? (b.expirationTime = a.expirationTime, ce(a, b, f)) : ge(a, b, c, d, f);
  }

  function he(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.effectTag |= 128;
  }

  function ge(a, b, c, d, e) {
    var f = F(c) ? Db : D.current;
    f = Eb(b, f);
    vc(b, e);
    c = rd(a, b, c, d, f, e);
    if (null !== a && !wc) return b.updateQueue = a.updateQueue, b.effectTag &= -517, a.expirationTime <= e && (a.expirationTime = 0), ce(a, b, e);
    b.effectTag |= 1;
    R(a, b, c, e);
    return b.child;
  }

  function ie(a, b, c, d, e) {
    if (F(c)) {
      var f = !0;
      Ib(b);
    } else f = !1;

    vc(b, e);
    if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), Qc(b, c, d), Sc(b, c, d, e), d = !0;else if (null === a) {
      var g = b.stateNode,
          h = b.memoizedProps;
      g.props = h;
      var k = g.context,
          l = c.contextType;
      "object" === (0, _typeof2.default)(l) && null !== l ? l = I(l) : (l = F(c) ? Db : D.current, l = Eb(b, l));
      var q = c.getDerivedStateFromProps,
          r = "function" === typeof q || "function" === typeof g.getSnapshotBeforeUpdate;
      r || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Rc(b, g, d, l);
      xc = !1;
      var w = b.memoizedState;
      g.state = w;
      Dc(b, d, g, e);
      k = b.memoizedState;
      h !== d || w !== k || E.current || xc ? ("function" === typeof q && (Kc(b, c, q, d), k = b.memoizedState), (h = xc || Pc(b, c, h, d, w, k, l)) ? (r || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.effectTag |= 4)) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.effectTag |= 4), d = !1);
    } else g = b.stateNode, zc(a, b), h = b.memoizedProps, g.props = b.type === b.elementType ? h : mc(b.type, h), k = g.context, l = c.contextType, "object" === (0, _typeof2.default)(l) && null !== l ? l = I(l) : (l = F(c) ? Db : D.current, l = Eb(b, l)), q = c.getDerivedStateFromProps, (r = "function" === typeof q || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Rc(b, g, d, l), xc = !1, k = b.memoizedState, g.state = k, Dc(b, d, g, e), w = b.memoizedState, h !== d || k !== w || E.current || xc ? ("function" === typeof q && (Kc(b, c, q, d), w = b.memoizedState), (q = xc || Pc(b, c, h, d, k, w, l)) ? (r || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, w, l), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, w, l)), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.effectTag |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 256), b.memoizedProps = d, b.memoizedState = w), g.props = d, g.state = w, g.context = l, d = q) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && k === a.memoizedState || (b.effectTag |= 256), d = !1);
    return je(a, b, c, d, f, e);
  }

  function je(a, b, c, d, e, f) {
    he(a, b);
    var g = 0 !== (b.effectTag & 64);
    if (!d && !g) return e && Jb(b, c, !1), ce(a, b, f);
    d = b.stateNode;
    ae.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.effectTag |= 1;
    null !== a && g ? (b.child = bd(b, a.child, null, f), b.child = bd(b, null, h, f)) : R(a, b, h, f);
    b.memoizedState = d.state;
    e && Jb(b, c, !0);
    return b.child;
  }

  function le(a) {
    var b = a.stateNode;
    b.pendingContext ? Gb(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Gb(a, b.context, !1);
    hd(a, b.containerInfo);
  }

  var me = {
    dehydrated: null,
    retryTime: 0
  };

  function ne(a, b, c) {
    var d = b.mode,
        e = b.pendingProps,
        f = K.current,
        g = !1,
        h;
    (h = 0 !== (b.effectTag & 64)) || (h = 0 !== (f & 2) && (null === a || null !== a.memoizedState));
    h ? (g = !0, b.effectTag &= -65) : null !== a && null === a.memoizedState || void 0 === e.fallback || !0 === e.unstable_avoidThisFallback || (f |= 1);
    C(K, f & 1);

    if (null === a) {
      void 0 !== e.fallback && Xd(b);

      if (g) {
        g = e.fallback;
        e = ad(null, d, 0, null);
        e.return = b;
        if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) {
          a.return = e, a = a.sibling;
        }
        c = ad(g, d, c, null);
        c.return = b;
        e.sibling = c;
        b.memoizedState = me;
        b.child = e;
        return c;
      }

      d = e.children;
      b.memoizedState = null;
      return b.child = cd(b, null, d, c);
    }

    if (null !== a.memoizedState) {
      a = a.child;
      d = a.sibling;

      if (g) {
        e = e.fallback;
        c = Xc(a, a.pendingProps);
        c.return = b;
        if (0 === (b.mode & 2) && (g = null !== b.memoizedState ? b.child.child : b.child, g !== a.child)) for (c.child = g; null !== g;) {
          g.return = c, g = g.sibling;
        }
        d = Xc(d, e);
        d.return = b;
        c.sibling = d;
        c.childExpirationTime = 0;
        b.memoizedState = me;
        b.child = c;
        return d;
      }

      c = bd(b, a.child, e.children, c);
      b.memoizedState = null;
      return b.child = c;
    }

    a = a.child;

    if (g) {
      g = e.fallback;
      e = ad(null, d, 0, null);
      e.return = b;
      e.child = a;
      null !== a && (a.return = e);
      if (0 === (b.mode & 2)) for (a = null !== b.memoizedState ? b.child.child : b.child, e.child = a; null !== a;) {
        a.return = e, a = a.sibling;
      }
      c = ad(g, d, c, null);
      c.return = b;
      e.sibling = c;
      c.effectTag |= 2;
      e.childExpirationTime = 0;
      b.memoizedState = me;
      b.child = e;
      return c;
    }

    b.memoizedState = null;
    return b.child = bd(b, a, e.children, c);
  }

  function oe(a, b) {
    a.expirationTime < b && (a.expirationTime = b);
    var c = a.alternate;
    null !== c && c.expirationTime < b && (c.expirationTime = b);
    uc(a.return, b);
  }

  function pe(a, b, c, d, e, f) {
    var g = a.memoizedState;
    null === g ? a.memoizedState = {
      isBackwards: b,
      rendering: null,
      renderingStartTime: 0,
      last: d,
      tail: c,
      tailExpiration: 0,
      tailMode: e,
      lastEffect: f
    } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailExpiration = 0, g.tailMode = e, g.lastEffect = f);
  }

  function qe(a, b, c) {
    var d = b.pendingProps,
        e = d.revealOrder,
        f = d.tail;
    R(a, b, d.children, c);
    d = K.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.effectTag |= 64;else {
      if (null !== a && 0 !== (a.effectTag & 64)) a: for (a = b.child; null !== a;) {
        if (13 === a.tag) null !== a.memoizedState && oe(a, c);else if (19 === a.tag) oe(a, c);else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;

        for (; null === a.sibling;) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }

        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    C(K, d);
    if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {
      case "forwards":
        c = b.child;

        for (e = null; null !== c;) {
          a = c.alternate, null !== a && null === ld(a) && (e = c), c = c.sibling;
        }

        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        pe(b, !1, e, c, f, b.lastEffect);
        break;

      case "backwards":
        c = null;
        e = b.child;

        for (b.child = null; null !== e;) {
          a = e.alternate;

          if (null !== a && null === ld(a)) {
            b.child = e;
            break;
          }

          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }

        pe(b, !0, c, null, f, b.lastEffect);
        break;

      case "together":
        pe(b, !1, null, null, void 0, b.lastEffect);
        break;

      default:
        b.memoizedState = null;
    }
    return b.child;
  }

  function ce(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    var d = b.expirationTime;
    0 !== d && Gc(d);
    if (b.childExpirationTime < c) return null;
    if (null !== a && b.child !== a.child) throw Error(n(153));

    if (null !== b.child) {
      a = b.child;
      c = Xc(a, a.pendingProps);
      b.child = c;

      for (c.return = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = Xc(a, a.pendingProps), c.return = b;
      }

      c.sibling = null;
    }

    return b.child;
  }

  function re(a) {
    a.effectTag |= 4;
  }

  var _se, te, ue, ve;

  if (Qa) _se = function se(a, b) {
    for (var c = b.child; null !== c;) {
      if (5 === c.tag || 6 === c.tag) Ga(a, c.stateNode);else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;

      for (; null === c.sibling;) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }

      c.sibling.return = c.return;
      c = c.sibling;
    }
  }, te = function te() {}, ue = function ue(a, b, c, d, e) {
    a = a.memoizedProps;

    if (a !== d) {
      var f = b.stateNode,
          g = gd(J.current);
      c = Ia(f, c, a, d, e, g);
      (b.updateQueue = c) && re(b);
    }
  }, ve = function ve(a, b, c, d) {
    c !== d && re(b);
  };else if (Ra) {
    _se = function se(a, b, c, d) {
      for (var e = b.child; null !== e;) {
        if (5 === e.tag) {
          var f = e.stateNode;
          c && d && (f = lb(f, e.type, e.memoizedProps, e));
          Ga(a, f);
        } else if (6 === e.tag) f = e.stateNode, c && d && (f = mb(f, e.memoizedProps, e)), Ga(a, f);else if (4 !== e.tag) {
          if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
            var g = e.child;

            if (null !== g && (null !== g.child && (g.child.return = g, _se(a, g, !0, f)), f = g.sibling, null !== f)) {
              f.return = e;
              e = f;
              continue;
            }
          }

          if (null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
        }

        if (e === b) break;

        for (; null === e.sibling;) {
          if (null === e.return || e.return === b) return;
          e = e.return;
        }

        e.sibling.return = e.return;
        e = e.sibling;
      }
    };

    var we = function we(a, b, c, d) {
      for (var e = b.child; null !== e;) {
        if (5 === e.tag) {
          var f = e.stateNode;
          c && d && (f = lb(f, e.type, e.memoizedProps, e));
          ib(a, f);
        } else if (6 === e.tag) f = e.stateNode, c && d && (f = mb(f, e.memoizedProps, e)), ib(a, f);else if (4 !== e.tag) {
          if (13 === e.tag && 0 !== (e.effectTag & 4) && (f = null !== e.memoizedState)) {
            var g = e.child;

            if (null !== g && (null !== g.child && (g.child.return = g, we(a, g, !0, f)), f = g.sibling, null !== f)) {
              f.return = e;
              e = f;
              continue;
            }
          }

          if (null !== e.child) {
            e.child.return = e;
            e = e.child;
            continue;
          }
        }

        if (e === b) break;

        for (; null === e.sibling;) {
          if (null === e.return || e.return === b) return;
          e = e.return;
        }

        e.sibling.return = e.return;
        e = e.sibling;
      }
    };

    te = function te(a) {
      var b = a.stateNode;

      if (null !== a.firstEffect) {
        var c = b.containerInfo,
            d = hb(c);
        we(d, a, !1, !1);
        b.pendingChildren = d;
        re(a);
        jb(c, d);
      }
    };

    ue = function ue(a, b, c, d, e) {
      var f = a.stateNode,
          g = a.memoizedProps;
      if ((a = null === b.firstEffect) && g === d) b.stateNode = f;else {
        var h = b.stateNode,
            k = gd(J.current),
            l = null;
        g !== d && (l = Ia(h, c, g, d, e, k));
        a && null === l ? b.stateNode = f : (f = gb(f, l, c, g, d, b, a, h), Ha(f, c, d, e, k) && re(b), b.stateNode = f, a ? re(b) : _se(f, b, !1, !1));
      }
    };

    ve = function ve(a, b, c, d) {
      c !== d ? (a = gd(fd.current), c = gd(J.current), b.stateNode = La(d, a, c, b), re(b)) : b.stateNode = a.stateNode;
    };
  } else te = function te() {}, ue = function ue() {}, ve = function ve() {};

  function xe(a, b) {
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;

        for (var c = null; null !== b;) {
          null !== b.alternate && (c = b), b = b.sibling;
        }

        null === c ? a.tail = null : c.sibling = null;
        break;

      case "collapsed":
        c = a.tail;

        for (var d = null; null !== c;) {
          null !== c.alternate && (d = c), c = c.sibling;
        }

        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }

  function ye(a, b, c) {
    var d = b.pendingProps;

    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null;

      case 1:
        return F(b.type) && Fb(), null;

      case 3:
        return id(), B(E), B(D), d = b.stateNode, d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (null === a || null === a.child) && Zd(b) && re(b), te(b), null;

      case 5:
        kd(b);
        var e = gd(fd.current);
        c = b.type;
        if (null !== a && null != b.stateNode) ue(a, b, c, d, e), a.ref !== b.ref && (b.effectTag |= 128);else {
          if (!d) {
            if (null === b.stateNode) throw Error(n(166));
            return null;
          }

          a = gd(J.current);

          if (Zd(b)) {
            if (!Sa) throw Error(n(175));
            a = tb(b.stateNode, b.type, b.memoizedProps, e, a, b);
            b.updateQueue = a;
            null !== a && re(b);
          } else {
            var f = Fa(c, d, e, a, b);

            _se(f, b, !1, !1);

            b.stateNode = f;
            Ha(f, c, d, e, a) && re(b);
          }

          null !== b.ref && (b.effectTag |= 128);
        }
        return null;

      case 6:
        if (a && null != b.stateNode) ve(a, b, a.memoizedProps, d);else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(n(166));
          a = gd(fd.current);
          e = gd(J.current);

          if (Zd(b)) {
            if (!Sa) throw Error(n(176));
            ub(b.stateNode, b.memoizedProps, b) && re(b);
          } else b.stateNode = La(d, a, e, b);
        }
        return null;

      case 13:
        B(K);
        d = b.memoizedState;
        if (0 !== (b.effectTag & 64)) return b.expirationTime = c, b;
        d = null !== d;
        e = !1;
        null === a ? void 0 !== b.memoizedProps.fallback && Zd(b) : (c = a.memoizedState, e = null !== c, d || null === c || (c = a.child.sibling, null !== c && (f = b.firstEffect, null !== f ? (b.firstEffect = c, c.nextEffect = f) : (b.firstEffect = b.lastEffect = c, c.nextEffect = null), c.effectTag = 8)));
        if (d && !e && 0 !== (b.mode & 2)) if (null === a && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (K.current & 1)) S === ze && (S = Ae);else {
          if (S === ze || S === Ae) S = Be;
          0 !== Ce && null !== T && (De(T, U), Ee(T, Ce));
        }
        Ra && d && (b.effectTag |= 4);
        Qa && (d || e) && (b.effectTag |= 4);
        return null;

      case 4:
        return id(), te(b), null;

      case 10:
        return tc(b), null;

      case 17:
        return F(b.type) && Fb(), null;

      case 19:
        B(K);
        d = b.memoizedState;
        if (null === d) return null;
        e = 0 !== (b.effectTag & 64);
        f = d.rendering;
        if (null === f) {
          if (e) xe(d, !1);else {
            if (S !== ze || null !== a && 0 !== (a.effectTag & 64)) for (a = b.child; null !== a;) {
              f = ld(a);

              if (null !== f) {
                b.effectTag |= 64;
                xe(d, !1);
                a = f.updateQueue;
                null !== a && (b.updateQueue = a, b.effectTag |= 4);
                null === d.lastEffect && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                a = c;

                for (d = b.child; null !== d;) {
                  e = d, c = a, e.effectTag &= 2, e.nextEffect = null, e.firstEffect = null, e.lastEffect = null, f = e.alternate, null === f ? (e.childExpirationTime = 0, e.expirationTime = c, e.child = null, e.memoizedProps = null, e.memoizedState = null, e.updateQueue = null, e.dependencies = null) : (e.childExpirationTime = f.childExpirationTime, e.expirationTime = f.expirationTime, e.child = f.child, e.memoizedProps = f.memoizedProps, e.memoizedState = f.memoizedState, e.updateQueue = f.updateQueue, c = f.dependencies, e.dependencies = null === c ? null : {
                    expirationTime: c.expirationTime,
                    firstContext: c.firstContext,
                    responders: c.responders
                  }), d = d.sibling;
                }

                C(K, K.current & 1 | 2);
                return b.child;
              }

              a = a.sibling;
            }
          }
        } else {
          if (!e) if (a = ld(f), null !== a) {
            if (b.effectTag |= 64, e = !0, a = a.updateQueue, null !== a && (b.updateQueue = a, b.effectTag |= 4), xe(d, !0), null === d.tail && "hidden" === d.tailMode && !f.alternate) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
          } else 2 * G() - d.renderingStartTime > d.tailExpiration && 1 < c && (b.effectTag |= 64, e = !0, xe(d, !1), b.expirationTime = b.childExpirationTime = c - 1);
          d.isBackwards ? (f.sibling = b.child, b.child = f) : (a = d.last, null !== a ? a.sibling = f : b.child = f, d.last = f);
        }
        return null !== d.tail ? (0 === d.tailExpiration && (d.tailExpiration = G() + 500), a = d.tail, d.rendering = a, d.tail = a.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = G(), a.sibling = null, b = K.current, C(K, e ? b & 1 | 2 : b & 1), a) : null;
    }

    throw Error(n(156, b.tag));
  }

  function Fe(a) {
    switch (a.tag) {
      case 1:
        F(a.type) && Fb();
        var b = a.effectTag;
        return b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;

      case 3:
        id();
        B(E);
        B(D);
        b = a.effectTag;
        if (0 !== (b & 64)) throw Error(n(285));
        a.effectTag = b & -4097 | 64;
        return a;

      case 5:
        return kd(a), null;

      case 13:
        return B(K), b = a.effectTag, b & 4096 ? (a.effectTag = b & -4097 | 64, a) : null;

      case 19:
        return B(K), null;

      case 4:
        return id(), null;

      case 10:
        return tc(a), null;

      default:
        return null;
    }
  }

  function Ge(a, b) {
    return {
      value: a,
      source: b,
      stack: zb(b)
    };
  }

  var He = "function" === typeof WeakSet ? WeakSet : Set;

  function Ie(a, b) {
    var c = b.source,
        d = b.stack;
    null === d && null !== c && (d = zb(c));
    null !== c && ua(c.type);
    b = b.value;
    null !== a && 1 === a.tag && ua(a.type);

    try {
      console.error(b);
    } catch (e) {
      setTimeout(function () {
        throw e;
      });
    }
  }

  function Je(a, b) {
    try {
      b.props = a.memoizedProps, b.state = a.memoizedState, b.componentWillUnmount();
    } catch (c) {
      Ke(a, c);
    }
  }

  function Le(a) {
    var b = a.ref;
    if (null !== b) if ("function" === typeof b) try {
      b(null);
    } catch (c) {
      Ke(a, c);
    } else b.current = null;
  }

  function Me(a, b) {
    switch (b.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return;

      case 1:
        if (b.effectTag & 256 && null !== a) {
          var c = a.memoizedProps,
              d = a.memoizedState;
          a = b.stateNode;
          b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : mc(b.type, c), d);
          a.__reactInternalSnapshotBeforeUpdate = b;
        }

        return;

      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        return;
    }

    throw Error(n(163));
  }

  function Ne(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;

    if (null !== b) {
      var c = b = b.next;

      do {
        if ((c.tag & a) === a) {
          var d = c.destroy;
          c.destroy = void 0;
          void 0 !== d && d();
        }

        c = c.next;
      } while (c !== b);
    }
  }

  function Oe(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;

    if (null !== b) {
      var c = b = b.next;

      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }

        c = c.next;
      } while (c !== b);
    }
  }

  function Pe(a, b, c) {
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        Oe(3, c);
        return;

      case 1:
        a = c.stateNode;
        if (c.effectTag & 4) if (null === b) a.componentDidMount();else {
          var d = c.elementType === c.type ? b.memoizedProps : mc(c.type, b.memoizedProps);
          a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate);
        }
        b = c.updateQueue;
        null !== b && Hc(c, b, a);
        return;

      case 3:
        b = c.updateQueue;

        if (null !== b) {
          a = null;
          if (null !== c.child) switch (c.child.tag) {
            case 5:
              a = Aa(c.child.stateNode);
              break;

            case 1:
              a = c.child.stateNode;
          }
          Hc(c, b, a);
        }

        return;

      case 5:
        a = c.stateNode;
        null === b && c.effectTag & 4 && Wa(a, c.type, c.memoizedProps, c);
        return;

      case 6:
        return;

      case 4:
        return;

      case 12:
        return;

      case 13:
        Sa && null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && xb(c))));
        return;

      case 19:
      case 17:
      case 20:
      case 21:
        return;
    }

    throw Error(n(163));
  }

  function Qe(a, b, c) {
    "function" === typeof Re && Re(b);

    switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        a = b.updateQueue;

        if (null !== a && (a = a.lastEffect, null !== a)) {
          var d = a.next;
          dc(97 < c ? 97 : c, function () {
            var a = d;

            do {
              var c = a.destroy;

              if (void 0 !== c) {
                var g = b;

                try {
                  c();
                } catch (h) {
                  Ke(g, h);
                }
              }

              a = a.next;
            } while (a !== d);
          });
        }

        break;

      case 1:
        Le(b);
        c = b.stateNode;
        "function" === typeof c.componentWillUnmount && Je(b, c);
        break;

      case 5:
        Le(b);
        break;

      case 4:
        Qa ? Se(a, b, c) : Ra && Te(b);
    }
  }

  function Ue(a, b, c) {
    for (var d = b;;) {
      if (Qe(a, d, c), null === d.child || Qa && 4 === d.tag) {
        if (d === b) break;

        for (; null === d.sibling;) {
          if (null === d.return || d.return === b) return;
          d = d.return;
        }

        d.sibling.return = d.return;
        d = d.sibling;
      } else d.child.return = d, d = d.child;
    }
  }

  function Ve(a) {
    var b = a.alternate;
    a.return = null;
    a.child = null;
    a.memoizedState = null;
    a.updateQueue = null;
    a.dependencies = null;
    a.alternate = null;
    a.firstEffect = null;
    a.lastEffect = null;
    a.pendingProps = null;
    a.memoizedProps = null;
    a.stateNode = null;
    null !== b && Ve(b);
  }

  function Te(a) {
    if (Ra) {
      a = a.stateNode.containerInfo;
      var b = hb(a);
      kb(a, b);
    }
  }

  function We(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }

  function Xe(a) {
    if (Qa) {
      a: {
        for (var b = a.return; null !== b;) {
          if (We(b)) {
            var c = b;
            break a;
          }

          b = b.return;
        }

        throw Error(n(160));
      }

      b = c.stateNode;

      switch (c.tag) {
        case 5:
          var d = !1;
          break;

        case 3:
          b = b.containerInfo;
          d = !0;
          break;

        case 4:
          b = b.containerInfo;
          d = !0;
          break;

        default:
          throw Error(n(161));
      }

      c.effectTag & 16 && (bb(b), c.effectTag &= -17);

      a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c.return || We(c.return)) {
            c = null;
            break a;
          }

          c = c.return;
        }

        c.sibling.return = c.return;

        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
          if (c.effectTag & 2) continue b;
          if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;
        }

        if (!(c.effectTag & 2)) {
          c = c.stateNode;
          break a;
        }
      }

      d ? Ye(a, c, b) : Ze(a, c, b);
    }
  }

  function Ye(a, b, c) {
    var d = a.tag,
        e = 5 === d || 6 === d;
    if (e) a = e ? a.stateNode : a.stateNode.instance, b ? Za(c, a, b) : Ua(c, a);else if (4 !== d && (a = a.child, null !== a)) for (Ye(a, b, c), a = a.sibling; null !== a;) {
      Ye(a, b, c), a = a.sibling;
    }
  }

  function Ze(a, b, c) {
    var d = a.tag,
        e = 5 === d || 6 === d;
    if (e) a = e ? a.stateNode : a.stateNode.instance, b ? Ya(c, a, b) : Ta(c, a);else if (4 !== d && (a = a.child, null !== a)) for (Ze(a, b, c), a = a.sibling; null !== a;) {
      Ze(a, b, c), a = a.sibling;
    }
  }

  function Se(a, b, c) {
    for (var d = b, e = !1, f, g;;) {
      if (!e) {
        e = d.return;

        a: for (;;) {
          if (null === e) throw Error(n(160));
          f = e.stateNode;

          switch (e.tag) {
            case 5:
              g = !1;
              break a;

            case 3:
              f = f.containerInfo;
              g = !0;
              break a;

            case 4:
              f = f.containerInfo;
              g = !0;
              break a;
          }

          e = e.return;
        }

        e = !0;
      }

      if (5 === d.tag || 6 === d.tag) Ue(a, d, c), g ? ab(f, d.stateNode) : $a(f, d.stateNode);else if (4 === d.tag) {
        if (null !== d.child) {
          f = d.stateNode.containerInfo;
          g = !0;
          d.child.return = d;
          d = d.child;
          continue;
        }
      } else if (Qe(a, d, c), null !== d.child) {
        d.child.return = d;
        d = d.child;
        continue;
      }
      if (d === b) break;

      for (; null === d.sibling;) {
        if (null === d.return || d.return === b) return;
        d = d.return;
        4 === d.tag && (e = !1);
      }

      d.sibling.return = d.return;
      d = d.sibling;
    }
  }

  function $e(a, b) {
    if (Qa) {
      switch (b.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
        case 22:
          Ne(3, b);
          return;

        case 1:
          return;

        case 5:
          var c = b.stateNode;

          if (null != c) {
            var d = b.memoizedProps;
            a = null !== a ? a.memoizedProps : d;
            var e = b.type,
                f = b.updateQueue;
            b.updateQueue = null;
            null !== f && Xa(c, f, e, a, d, b);
          }

          return;

        case 6:
          if (null === b.stateNode) throw Error(n(162));
          c = b.memoizedProps;
          Va(b.stateNode, null !== a ? a.memoizedProps : c, c);
          return;

        case 3:
          Sa && (b = b.stateNode, b.hydrate && (b.hydrate = !1, wb(b.containerInfo)));
          return;

        case 12:
          return;

        case 13:
          af(b);
          bf(b);
          return;

        case 19:
          bf(b);
          return;

        case 17:
          return;
      }

      throw Error(n(163));
    }

    switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        Ne(3, b);
        return;

      case 12:
        return;

      case 13:
        af(b);
        bf(b);
        return;

      case 19:
        bf(b);
        return;

      case 3:
        Sa && (c = b.stateNode, c.hydrate && (c.hydrate = !1, wb(c.containerInfo)));
    }

    a: if (Ra) {
      switch (b.tag) {
        case 1:
        case 5:
        case 6:
        case 20:
          break a;

        case 3:
        case 4:
          b = b.stateNode;
          kb(b.containerInfo, b.pendingChildren);
          break a;
      }

      throw Error(n(163));
    }
  }

  function af(a) {
    var b = a;
    if (null === a.memoizedState) var c = !1;else c = !0, b = a.child, cf = G();
    if (Qa && null !== b) a: if (a = b, Qa) for (b = a;;) {
      if (5 === b.tag) {
        var d = b.stateNode;
        c ? cb(d) : eb(b.stateNode, b.memoizedProps);
      } else if (6 === b.tag) d = b.stateNode, c ? db(d) : fb(d, b.memoizedProps);else if (13 === b.tag && null !== b.memoizedState && null === b.memoizedState.dehydrated) {
        d = b.child.sibling;
        d.return = b;
        b = d;
        continue;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }

      if (b === a) break a;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) break a;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }
  }

  function bf(a) {
    var b = a.updateQueue;

    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new He());
      b.forEach(function (b) {
        var d = df.bind(null, a, b);
        c.has(b) || (c.add(b), b.then(d, d));
      });
    }
  }

  var ef = "function" === typeof WeakMap ? WeakMap : Map;

  function ff(a, b, c) {
    c = Ac(c, null);
    c.tag = 3;
    c.payload = {
      element: null
    };
    var d = b.value;

    c.callback = function () {
      gf || (gf = !0, hf = d);
      Ie(a, b);
    };

    return c;
  }

  function jf(a, b, c) {
    c = Ac(c, null);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;

    if ("function" === typeof d) {
      var e = b.value;

      c.payload = function () {
        Ie(a, b);
        return d(e);
      };
    }

    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
      "function" !== typeof d && (null === kf ? kf = new Set([this]) : kf.add(this), Ie(a, b));
      var c = b.stack;
      this.componentDidCatch(b.value, {
        componentStack: null !== c ? c : ""
      });
    });
    return c;
  }

  var lf = Math.ceil,
      mf = p.ReactCurrentDispatcher,
      nf = p.ReactCurrentOwner,
      V = 0,
      of = 8,
      pf = 16,
      qf = 32,
      ze = 0,
      rf = 1,
      sf = 2,
      Ae = 3,
      Be = 4,
      tf = 5,
      W = V,
      T = null,
      X = null,
      U = 0,
      S = ze,
      uf = null,
      vf = 1073741823,
      wf = 1073741823,
      xf = null,
      Ce = 0,
      yf = !1,
      cf = 0,
      zf = 500,
      Y = null,
      gf = !1,
      hf = null,
      kf = null,
      Af = !1,
      Bf = null,
      Cf = 90,
      Df = null,
      Ef = 0,
      Ff = null,
      Gf = 0;

  function Lc() {
    return (W & (pf | qf)) !== V ? 1073741821 - (G() / 10 | 0) : 0 !== Gf ? Gf : Gf = 1073741821 - (G() / 10 | 0);
  }

  function Mc(a, b, c) {
    b = b.mode;
    if (0 === (b & 2)) return 1073741823;
    var d = bc();
    if (0 === (b & 4)) return 99 === d ? 1073741823 : 1073741822;
    if ((W & pf) !== V) return U;
    if (null !== c) a = hc(a, c.timeoutMs | 0 || 5E3, 250);else switch (d) {
      case 99:
        a = 1073741823;
        break;

      case 98:
        a = hc(a, 150, 100);
        break;

      case 97:
      case 96:
        a = hc(a, 5E3, 250);
        break;

      case 95:
        a = 2;
        break;

      default:
        throw Error(n(326));
    }
    null !== T && a === U && --a;
    return a;
  }

  function Nc(a, b) {
    if (50 < Ef) throw Ef = 0, Ff = null, Error(n(185));
    a = Hf(a, b);

    if (null !== a) {
      var c = bc();
      1073741823 === b ? (W & of) !== V && (W & (pf | qf)) === V ? If(a) : (Z(a), W === V && H()) : Z(a);
      (W & 4) === V || 98 !== c && 99 !== c || (null === Df ? Df = new Map([[a, b]]) : (c = Df.get(a), (void 0 === c || c > b) && Df.set(a, b)));
    }
  }

  function Hf(a, b) {
    a.expirationTime < b && (a.expirationTime = b);
    var c = a.alternate;
    null !== c && c.expirationTime < b && (c.expirationTime = b);
    var d = a.return,
        e = null;
    if (null === d && 3 === a.tag) e = a.stateNode;else for (; null !== d;) {
      c = d.alternate;
      d.childExpirationTime < b && (d.childExpirationTime = b);
      null !== c && c.childExpirationTime < b && (c.childExpirationTime = b);

      if (null === d.return && 3 === d.tag) {
        e = d.stateNode;
        break;
      }

      d = d.return;
    }
    null !== e && (T === e && (Gc(b), S === Be && De(e, U)), Ee(e, b));
    return e;
  }

  function Jf(a) {
    var b = a.lastExpiredTime;
    if (0 !== b) return b;
    b = a.firstPendingTime;
    if (!Kf(a, b)) return b;
    var c = a.lastPingedTime;
    a = a.nextKnownPendingLevel;
    a = c > a ? c : a;
    return 2 >= a && b !== a ? 0 : a;
  }

  function Z(a) {
    if (0 !== a.lastExpiredTime) a.callbackExpirationTime = 1073741823, a.callbackPriority = 99, a.callbackNode = fc(If.bind(null, a));else {
      var b = Jf(a),
          c = a.callbackNode;
      if (0 === b) null !== c && (a.callbackNode = null, a.callbackExpirationTime = 0, a.callbackPriority = 90);else {
        var d = Lc();
        1073741823 === b ? d = 99 : 1 === b || 2 === b ? d = 95 : (d = 10 * (1073741821 - b) - 10 * (1073741821 - d), d = 0 >= d ? 99 : 250 >= d ? 98 : 5250 >= d ? 97 : 95);

        if (null !== c) {
          var e = a.callbackPriority;
          if (a.callbackExpirationTime === b && e >= d) return;
          c !== Vb && Mb(c);
        }

        a.callbackExpirationTime = b;
        a.callbackPriority = d;
        b = 1073741823 === b ? fc(If.bind(null, a)) : ec(d, Lf.bind(null, a), {
          timeout: 10 * (1073741821 - b) - G()
        });
        a.callbackNode = b;
      }
    }
  }

  function Lf(a, b) {
    Gf = 0;
    if (b) return b = Lc(), Mf(a, b), Z(a), null;
    var c = Jf(a);

    if (0 !== c) {
      b = a.callbackNode;
      if ((W & (pf | qf)) !== V) throw Error(n(327));
      Nf();
      a === T && c === U || Of(a, c);

      if (null !== X) {
        var d = W;
        W |= pf;
        var e = Pf();

        do {
          try {
            Qf();
            break;
          } catch (h) {
            Rf(a, h);
          }
        } while (1);

        rc();
        W = d;
        mf.current = e;
        if (S === rf) throw b = uf, Of(a, c), De(a, c), Z(a), b;
        if (null === X) switch (e = a.finishedWork = a.current.alternate, a.finishedExpirationTime = c, d = S, T = null, d) {
          case ze:
          case rf:
            throw Error(n(345));

          case sf:
            Mf(a, 2 < c ? 2 : c);
            break;

          case Ae:
            De(a, c);
            d = a.lastSuspendedTime;
            c === d && (a.nextKnownPendingLevel = Sf(e));

            if (1073741823 === vf && (e = cf + zf - G(), 10 < e)) {
              if (yf) {
                var f = a.lastPingedTime;

                if (0 === f || f >= c) {
                  a.lastPingedTime = c;
                  Of(a, c);
                  break;
                }
              }

              f = Jf(a);
              if (0 !== f && f !== c) break;

              if (0 !== d && d !== c) {
                a.lastPingedTime = d;
                break;
              }

              a.timeoutHandle = Ma(Tf.bind(null, a), e);
              break;
            }

            Tf(a);
            break;

          case Be:
            De(a, c);
            d = a.lastSuspendedTime;
            c === d && (a.nextKnownPendingLevel = Sf(e));

            if (yf && (e = a.lastPingedTime, 0 === e || e >= c)) {
              a.lastPingedTime = c;
              Of(a, c);
              break;
            }

            e = Jf(a);
            if (0 !== e && e !== c) break;

            if (0 !== d && d !== c) {
              a.lastPingedTime = d;
              break;
            }

            1073741823 !== wf ? d = 10 * (1073741821 - wf) - G() : 1073741823 === vf ? d = 0 : (d = 10 * (1073741821 - vf) - 5E3, e = G(), c = 10 * (1073741821 - c) - e, d = e - d, 0 > d && (d = 0), d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3E3 > d ? 3E3 : 4320 > d ? 4320 : 1960 * lf(d / 1960)) - d, c < d && (d = c));

            if (10 < d) {
              a.timeoutHandle = Ma(Tf.bind(null, a), d);
              break;
            }

            Tf(a);
            break;

          case tf:
            if (1073741823 !== vf && null !== xf) {
              f = vf;
              var g = xf;
              d = g.busyMinDurationMs | 0;
              0 >= d ? d = 0 : (e = g.busyDelayMs | 0, f = G() - (10 * (1073741821 - f) - (g.timeoutMs | 0 || 5E3)), d = f <= e ? 0 : e + d - f);

              if (10 < d) {
                De(a, c);
                a.timeoutHandle = Ma(Tf.bind(null, a), d);
                break;
              }
            }

            Tf(a);
            break;

          default:
            throw Error(n(329));
        }
        Z(a);
        if (a.callbackNode === b) return Lf.bind(null, a);
      }
    }

    return null;
  }

  function If(a) {
    var b = a.lastExpiredTime;
    b = 0 !== b ? b : 1073741823;
    if ((W & (pf | qf)) !== V) throw Error(n(327));
    Nf();
    a === T && b === U || Of(a, b);

    if (null !== X) {
      var c = W;
      W |= pf;
      var d = Pf();

      do {
        try {
          Uf();
          break;
        } catch (e) {
          Rf(a, e);
        }
      } while (1);

      rc();
      W = c;
      mf.current = d;
      if (S === rf) throw c = uf, Of(a, b), De(a, b), Z(a), c;
      if (null !== X) throw Error(n(261));
      a.finishedWork = a.current.alternate;
      a.finishedExpirationTime = b;
      T = null;
      Tf(a);
      Z(a);
    }

    return null;
  }

  function Vf(a, b) {
    Mf(a, b);
    Z(a);
    (W & (pf | qf)) === V && H();
  }

  function Wf() {
    if (null !== Df) {
      var a = Df;
      Df = null;
      a.forEach(function (a, c) {
        Mf(c, a);
        Z(c);
      });
      H();
    }
  }

  function Xf(a, b) {
    var c = W;
    W |= 1;

    try {
      return a(b);
    } finally {
      W = c, W === V && H();
    }
  }

  function Yf(a, b) {
    if ((W & (pf | qf)) !== V) throw Error(n(187));
    var c = W;
    W |= 1;

    try {
      return dc(99, a.bind(null, b));
    } finally {
      W = c, H();
    }
  }

  function Of(a, b) {
    a.finishedWork = null;
    a.finishedExpirationTime = 0;
    var c = a.timeoutHandle;
    c !== Oa && (a.timeoutHandle = Oa, Na(c));
    if (null !== X) for (c = X.return; null !== c;) {
      var d = c;

      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && Fb();
          break;

        case 3:
          id();
          B(E);
          B(D);
          break;

        case 5:
          kd(d);
          break;

        case 4:
          id();
          break;

        case 13:
          B(K);
          break;

        case 19:
          B(K);
          break;

        case 10:
          tc(d);
      }

      c = c.return;
    }
    T = a;
    X = Xc(a.current, null);
    U = b;
    S = ze;
    uf = null;
    wf = vf = 1073741823;
    xf = null;
    Ce = 0;
    yf = !1;
  }

  function Rf(a, b) {
    do {
      try {
        rc();
        nd.current = vd;
        if (pd) for (var c = M.memoizedState; null !== c;) {
          var d = c.queue;
          null !== d && (d.pending = null);
          c = c.next;
        }
        od = 0;
        O = N = M = null;
        pd = !1;
        if (null === X || null === X.return) return S = rf, uf = b, X = null;

        a: {
          var e = a,
              f = X.return,
              g = X,
              h = b;
          b = U;
          g.effectTag |= 2048;
          g.firstEffect = g.lastEffect = null;

          if (null !== h && "object" === (0, _typeof2.default)(h) && "function" === typeof h.then) {
            var k = h;

            if (0 === (g.mode & 2)) {
              var l = g.alternate;
              l ? (g.updateQueue = l.updateQueue, g.memoizedState = l.memoizedState, g.expirationTime = l.expirationTime) : (g.updateQueue = null, g.memoizedState = null);
            }

            var q = 0 !== (K.current & 1),
                r = f;

            do {
              var w;

              if (w = 13 === r.tag) {
                var z = r.memoizedState;
                if (null !== z) w = null !== z.dehydrated ? !0 : !1;else {
                  var Q = r.memoizedProps;
                  w = void 0 === Q.fallback ? !1 : !0 !== Q.unstable_avoidThisFallback ? !0 : q ? !1 : !0;
                }
              }

              if (w) {
                var A = r.updateQueue;

                if (null === A) {
                  var v = new Set();
                  v.add(k);
                  r.updateQueue = v;
                } else A.add(k);

                if (0 === (r.mode & 2)) {
                  r.effectTag |= 64;
                  g.effectTag &= -2981;
                  if (1 === g.tag) if (null === g.alternate) g.tag = 17;else {
                    var t = Ac(1073741823, null);
                    t.tag = 2;
                    Bc(g, t);
                  }
                  g.expirationTime = 1073741823;
                  break a;
                }

                h = void 0;
                g = b;
                var x = e.pingCache;
                null === x ? (x = e.pingCache = new ef(), h = new Set(), x.set(k, h)) : (h = x.get(k), void 0 === h && (h = new Set(), x.set(k, h)));

                if (!h.has(g)) {
                  h.add(g);
                  var ke = cg.bind(null, e, k, g);
                  k.then(ke, ke);
                }

                r.effectTag |= 4096;
                r.expirationTime = b;
                break a;
              }

              r = r.return;
            } while (null !== r);

            h = Error((ua(g.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + zb(g));
          }

          S !== tf && (S = sf);
          h = Ge(h, g);
          r = f;

          do {
            switch (r.tag) {
              case 3:
                k = h;
                r.effectTag |= 4096;
                r.expirationTime = b;
                var Zf = ff(r, k, b);
                Cc(r, Zf);
                break a;

              case 1:
                k = h;
                var $f = r.type,
                    Fc = r.stateNode;

                if (0 === (r.effectTag & 64) && ("function" === typeof $f.getDerivedStateFromError || null !== Fc && "function" === typeof Fc.componentDidCatch && (null === kf || !kf.has(Fc)))) {
                  r.effectTag |= 4096;
                  r.expirationTime = b;
                  var ag = jf(r, k, b);
                  Cc(r, ag);
                  break a;
                }

            }

            r = r.return;
          } while (null !== r);
        }

        X = dg(X);
      } catch (bg) {
        b = bg;
        continue;
      }

      break;
    } while (1);
  }

  function Pf() {
    var a = mf.current;
    mf.current = vd;
    return null === a ? vd : a;
  }

  function Ec(a, b) {
    a < vf && 2 < a && (vf = a);
    null !== b && a < wf && 2 < a && (wf = a, xf = b);
  }

  function Gc(a) {
    a > Ce && (Ce = a);
  }

  function Uf() {
    for (; null !== X;) {
      X = eg(X);
    }
  }

  function Qf() {
    for (; null !== X && !Wb();) {
      X = eg(X);
    }
  }

  function eg(a) {
    var b = fg(a.alternate, a, U);
    a.memoizedProps = a.pendingProps;
    null === b && (b = dg(a));
    nf.current = null;
    return b;
  }

  function dg(a) {
    X = a;

    do {
      var b = X.alternate;
      a = X.return;

      if (0 === (X.effectTag & 2048)) {
        b = ye(b, X, U);

        if (1 === U || 1 !== X.childExpirationTime) {
          for (var c = 0, d = X.child; null !== d;) {
            var e = d.expirationTime,
                f = d.childExpirationTime;
            e > c && (c = e);
            f > c && (c = f);
            d = d.sibling;
          }

          X.childExpirationTime = c;
        }

        if (null !== b) return b;
        null !== a && 0 === (a.effectTag & 2048) && (null === a.firstEffect && (a.firstEffect = X.firstEffect), null !== X.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = X.firstEffect), a.lastEffect = X.lastEffect), 1 < X.effectTag && (null !== a.lastEffect ? a.lastEffect.nextEffect = X : a.firstEffect = X, a.lastEffect = X));
      } else {
        b = Fe(X);
        if (null !== b) return b.effectTag &= 2047, b;
        null !== a && (a.firstEffect = a.lastEffect = null, a.effectTag |= 2048);
      }

      b = X.sibling;
      if (null !== b) return b;
      X = a;
    } while (null !== X);

    S === ze && (S = tf);
    return null;
  }

  function Sf(a) {
    var b = a.expirationTime;
    a = a.childExpirationTime;
    return b > a ? b : a;
  }

  function Tf(a) {
    var b = bc();
    dc(99, gg.bind(null, a, b));
    return null;
  }

  function gg(a, b) {
    do {
      Nf();
    } while (null !== Bf);

    if ((W & (pf | qf)) !== V) throw Error(n(327));
    var c = a.finishedWork,
        d = a.finishedExpirationTime;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedExpirationTime = 0;
    if (c === a.current) throw Error(n(177));
    a.callbackNode = null;
    a.callbackExpirationTime = 0;
    a.callbackPriority = 90;
    a.nextKnownPendingLevel = 0;
    var e = Sf(c);
    a.firstPendingTime = e;
    d <= a.lastSuspendedTime ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : d <= a.firstSuspendedTime && (a.firstSuspendedTime = d - 1);
    d <= a.lastPingedTime && (a.lastPingedTime = 0);
    d <= a.lastExpiredTime && (a.lastExpiredTime = 0);
    a === T && (X = T = null, U = 0);
    1 < c.effectTag ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, e = c.firstEffect) : e = c : e = c.firstEffect;

    if (null !== e) {
      var f = W;
      W |= qf;
      nf.current = null;
      Da(a.containerInfo);
      Y = e;

      do {
        try {
          hg();
        } catch (t) {
          if (null === Y) throw Error(n(330));
          Ke(Y, t);
          Y = Y.nextEffect;
        }
      } while (null !== Y);

      Y = e;

      do {
        try {
          for (var g = a, h = b; null !== Y;) {
            var k = Y.effectTag;
            k & 16 && Qa && bb(Y.stateNode);

            if (k & 128) {
              var l = Y.alternate;

              if (null !== l) {
                var q = l.ref;
                null !== q && ("function" === typeof q ? q(null) : q.current = null);
              }
            }

            switch (k & 1038) {
              case 2:
                Xe(Y);
                Y.effectTag &= -3;
                break;

              case 6:
                Xe(Y);
                Y.effectTag &= -3;
                $e(Y.alternate, Y);
                break;

              case 1024:
                Y.effectTag &= -1025;
                break;

              case 1028:
                Y.effectTag &= -1025;
                $e(Y.alternate, Y);
                break;

              case 4:
                $e(Y.alternate, Y);
                break;

              case 8:
                var r = g,
                    w = Y,
                    z = h;
                Qa ? Se(r, w, z) : Ue(r, w, z);
                Ve(w);
            }

            Y = Y.nextEffect;
          }
        } catch (t) {
          if (null === Y) throw Error(n(330));
          Ke(Y, t);
          Y = Y.nextEffect;
        }
      } while (null !== Y);

      Ea(a.containerInfo);
      a.current = c;
      Y = e;

      do {
        try {
          for (k = a; null !== Y;) {
            var Q = Y.effectTag;
            Q & 36 && Pe(k, Y.alternate, Y);

            if (Q & 128) {
              l = void 0;
              var A = Y.ref;

              if (null !== A) {
                var v = Y.stateNode;

                switch (Y.tag) {
                  case 5:
                    l = Aa(v);
                    break;

                  default:
                    l = v;
                }

                "function" === typeof A ? A(l) : A.current = l;
              }
            }

            Y = Y.nextEffect;
          }
        } catch (t) {
          if (null === Y) throw Error(n(330));
          Ke(Y, t);
          Y = Y.nextEffect;
        }
      } while (null !== Y);

      Y = null;
      Xb();
      W = f;
    } else a.current = c;

    if (Af) Af = !1, Bf = a, Cf = b;else for (Y = e; null !== Y;) {
      b = Y.nextEffect, Y.nextEffect = null, Y = b;
    }
    b = a.firstPendingTime;
    0 === b && (kf = null);
    1073741823 === b ? a === Ff ? Ef++ : (Ef = 0, Ff = a) : Ef = 0;
    "function" === typeof ig && ig(c.stateNode, d);
    Z(a);
    if (gf) throw gf = !1, a = hf, hf = null, a;
    if ((W & of) !== V) return null;
    H();
    return null;
  }

  function hg() {
    for (; null !== Y;) {
      var a = Y.effectTag;
      0 !== (a & 256) && Me(Y.alternate, Y);
      0 === (a & 512) || Af || (Af = !0, ec(97, function () {
        Nf();
        return null;
      }));
      Y = Y.nextEffect;
    }
  }

  function Nf() {
    if (90 !== Cf) {
      var a = 97 < Cf ? 97 : Cf;
      Cf = 90;
      return dc(a, jg);
    }
  }

  function jg() {
    if (null === Bf) return !1;
    var a = Bf;
    Bf = null;
    if ((W & (pf | qf)) !== V) throw Error(n(331));
    var b = W;
    W |= qf;

    for (a = a.current.firstEffect; null !== a;) {
      try {
        var c = a;
        if (0 !== (c.effectTag & 512)) switch (c.tag) {
          case 0:
          case 11:
          case 15:
          case 22:
            Ne(5, c), Oe(5, c);
        }
      } catch (d) {
        if (null === a) throw Error(n(330));
        Ke(a, d);
      }

      c = a.nextEffect;
      a.nextEffect = null;
      a = c;
    }

    W = b;
    H();
    return !0;
  }

  function kg(a, b, c) {
    b = Ge(c, b);
    b = ff(a, b, 1073741823);
    Bc(a, b);
    a = Hf(a, 1073741823);
    null !== a && Z(a);
  }

  function Ke(a, b) {
    if (3 === a.tag) kg(a, a, b);else for (var c = a.return; null !== c;) {
      if (3 === c.tag) {
        kg(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;

        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === kf || !kf.has(d))) {
          a = Ge(b, a);
          a = jf(c, a, 1073741823);
          Bc(c, a);
          c = Hf(c, 1073741823);
          null !== c && Z(c);
          break;
        }
      }

      c = c.return;
    }
  }

  function cg(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    T === a && U === c ? S === Be || S === Ae && 1073741823 === vf && G() - cf < zf ? Of(a, U) : yf = !0 : Kf(a, c) && (b = a.lastPingedTime, 0 !== b && b < c || (a.lastPingedTime = c, Z(a)));
  }

  function df(a, b) {
    var c = a.stateNode;
    null !== c && c.delete(b);
    b = 0;
    0 === b && (b = Lc(), b = Mc(b, a, null));
    a = Hf(a, b);
    null !== a && Z(a);
  }

  var fg;

  fg = function fg(a, b, c) {
    var d = b.expirationTime;

    if (null !== a) {
      var e = b.pendingProps;
      if (a.memoizedProps !== e || E.current) wc = !0;else {
        if (d < c) {
          wc = !1;

          switch (b.tag) {
            case 3:
              le(b);
              $d();
              break;

            case 5:
              jd(b);
              if (b.mode & 4 && 1 !== c && Ka(b.type, e)) return b.expirationTime = b.childExpirationTime = 1, null;
              break;

            case 1:
              F(b.type) && Ib(b);
              break;

            case 4:
              hd(b, b.stateNode.containerInfo);
              break;

            case 10:
              sc(b, b.memoizedProps.value);
              break;

            case 13:
              if (null !== b.memoizedState) {
                d = b.child.childExpirationTime;
                if (0 !== d && d >= c) return ne(a, b, c);
                C(K, K.current & 1);
                b = ce(a, b, c);
                return null !== b ? b.sibling : null;
              }

              C(K, K.current & 1);
              break;

            case 19:
              d = b.childExpirationTime >= c;

              if (0 !== (a.effectTag & 64)) {
                if (d) return qe(a, b, c);
                b.effectTag |= 64;
              }

              e = b.memoizedState;
              null !== e && (e.rendering = null, e.tail = null);
              C(K, K.current);
              if (!d) return null;
          }

          return ce(a, b, c);
        }

        wc = !1;
      }
    } else wc = !1;

    b.expirationTime = 0;

    switch (b.tag) {
      case 2:
        d = b.type;
        null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
        a = b.pendingProps;
        e = Eb(b, D.current);
        vc(b, c);
        e = rd(null, b, d, a, e, c);
        b.effectTag |= 1;

        if ("object" === (0, _typeof2.default)(e) && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
          b.tag = 1;
          b.memoizedState = null;
          b.updateQueue = null;

          if (F(d)) {
            var f = !0;
            Ib(b);
          } else f = !1;

          b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
          yc(b);
          var g = d.getDerivedStateFromProps;
          "function" === typeof g && Kc(b, d, g, a);
          e.updater = Oc;
          b.stateNode = e;
          e._reactInternalFiber = b;
          Sc(b, d, a, c);
          b = je(null, b, d, !0, f, c);
        } else b.tag = 0, R(null, b, e, c), b = b.child;

        return b;

      case 16:
        a: {
          e = b.elementType;
          null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2);
          a = b.pendingProps;
          ta(e);
          if (1 !== e._status) throw e._result;
          e = e._result;
          b.type = e;
          f = b.tag = lg(e);
          a = mc(e, a);

          switch (f) {
            case 0:
              b = ge(null, b, e, a, c);
              break a;

            case 1:
              b = ie(null, b, e, a, c);
              break a;

            case 11:
              b = be(null, b, e, a, c);
              break a;

            case 14:
              b = de(null, b, e, mc(e.type, a), d, c);
              break a;
          }

          throw Error(n(306, e, ""));
        }

        return b;

      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : mc(d, e), ge(a, b, d, e, c);

      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : mc(d, e), ie(a, b, d, e, c);

      case 3:
        le(b);
        d = b.updateQueue;
        if (null === a || null === d) throw Error(n(282));
        d = b.pendingProps;
        e = b.memoizedState;
        e = null !== e ? e.element : null;
        zc(a, b);
        Dc(b, d, null, c);
        d = b.memoizedState.element;
        if (d === e) $d(), b = ce(a, b, c);else {
          if (e = b.stateNode.hydrate) Sa ? (Sd = sb(b.stateNode.containerInfo), Rd = b, e = Td = !0) : e = !1;
          if (e) for (c = cd(b, null, d, c), b.child = c; c;) {
            c.effectTag = c.effectTag & -3 | 1024, c = c.sibling;
          } else R(a, b, d, c), $d();
          b = b.child;
        }
        return b;

      case 5:
        return jd(b), null === a && Xd(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ja(d, e) ? g = null : null !== f && Ja(d, f) && (b.effectTag |= 16), he(a, b), b.mode & 4 && 1 !== c && Ka(d, e) ? (b.expirationTime = b.childExpirationTime = 1, b = null) : (R(a, b, g, c), b = b.child), b;

      case 6:
        return null === a && Xd(b), null;

      case 13:
        return ne(a, b, c);

      case 4:
        return hd(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = bd(b, null, d, c) : R(a, b, d, c), b.child;

      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : mc(d, e), be(a, b, d, e, c);

      case 7:
        return R(a, b, b.pendingProps, c), b.child;

      case 8:
        return R(a, b, b.pendingProps.children, c), b.child;

      case 12:
        return R(a, b, b.pendingProps.children, c), b.child;

      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          g = b.memoizedProps;
          f = e.value;
          sc(b, f);

          if (null !== g) {
            var h = g.value;
            f = jc(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0;

            if (0 === f) {
              if (g.children === e.children && !E.current) {
                b = ce(a, b, c);
                break a;
              }
            } else for (h = b.child, null !== h && (h.return = b); null !== h;) {
              var k = h.dependencies;

              if (null !== k) {
                g = h.child;

                for (var l = k.firstContext; null !== l;) {
                  if (l.context === d && 0 !== (l.observedBits & f)) {
                    1 === h.tag && (l = Ac(c, null), l.tag = 2, Bc(h, l));
                    h.expirationTime < c && (h.expirationTime = c);
                    l = h.alternate;
                    null !== l && l.expirationTime < c && (l.expirationTime = c);
                    uc(h.return, c);
                    k.expirationTime < c && (k.expirationTime = c);
                    break;
                  }

                  l = l.next;
                }
              } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;

              if (null !== g) g.return = h;else for (g = h; null !== g;) {
                if (g === b) {
                  g = null;
                  break;
                }

                h = g.sibling;

                if (null !== h) {
                  h.return = g.return;
                  g = h;
                  break;
                }

                g = g.return;
              }
              h = g;
            }
          }

          R(a, b, e.children, c);
          b = b.child;
        }

        return b;

      case 9:
        return e = b.type, f = b.pendingProps, d = f.children, vc(b, c), e = I(e, f.unstable_observedBits), d = d(e), b.effectTag |= 1, R(a, b, d, c), b.child;

      case 14:
        return e = b.type, f = mc(e, b.pendingProps), f = mc(e.type, f), de(a, b, e, f, d, c);

      case 15:
        return fe(a, b, b.type, b.pendingProps, d, c);

      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : mc(d, e), null !== a && (a.alternate = null, b.alternate = null, b.effectTag |= 2), b.tag = 1, F(d) ? (a = !0, Ib(b)) : a = !1, vc(b, c), Qc(b, d, e), Sc(b, d, e, c), je(null, b, d, !0, a, c);

      case 19:
        return qe(a, b, c);
    }

    throw Error(n(156, b.tag));
  };

  var mg = {
    current: !1
  },
      ig = null,
      Re = null;

  function ng(a) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (b.isDisabled || !b.supportsFiber) return !0;

    try {
      var c = b.inject(a);

      ig = function ig(a) {
        try {
          b.onCommitFiberRoot(c, a, void 0, 64 === (a.current.effectTag & 64));
        } catch (e) {}
      };

      Re = function Re(a) {
        try {
          b.onCommitFiberUnmount(c, a);
        } catch (e) {}
      };
    } catch (d) {}

    return !0;
  }

  function og(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.effectTag = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childExpirationTime = this.expirationTime = 0;
    this.alternate = null;
  }

  function Vd(a, b, c, d) {
    return new og(a, b, c, d);
  }

  function ee(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }

  function lg(a) {
    if ("function" === typeof a) return ee(a) ? 1 : 0;

    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === la) return 11;
      if (a === oa) return 14;
    }

    return 2;
  }

  function Xc(a, b) {
    var c = a.alternate;
    null === c ? (c = Vd(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.effectTag = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
    c.childExpirationTime = a.childExpirationTime;
    c.expirationTime = a.expirationTime;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : {
      expirationTime: b.expirationTime,
      firstContext: b.firstContext,
      responders: b.responders
    };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }

  function Zc(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) ee(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
      case ea:
        return ad(c.children, e, f, b);

      case ka:
        g = 8;
        e |= 7;
        break;

      case fa:
        g = 8;
        e |= 1;
        break;

      case ha:
        return a = Vd(12, c, b, e | 8), a.elementType = ha, a.type = ha, a.expirationTime = f, a;

      case ma:
        return a = Vd(13, c, b, e), a.type = ma, a.elementType = ma, a.expirationTime = f, a;

      case na:
        return a = Vd(19, c, b, e), a.elementType = na, a.expirationTime = f, a;

      default:
        if ("object" === (0, _typeof2.default)(a) && null !== a) switch (a.$$typeof) {
          case ia:
            g = 10;
            break a;

          case ja:
            g = 9;
            break a;

          case la:
            g = 11;
            break a;

          case oa:
            g = 14;
            break a;

          case pa:
            g = 16;
            d = null;
            break a;

          case qa:
            g = 22;
            break a;
        }
        throw Error(n(130, null == a ? a : (0, _typeof2.default)(a), ""));
    }
    b = Vd(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.expirationTime = f;
    return b;
  }

  function ad(a, b, c, d) {
    a = Vd(7, a, d, b);
    a.expirationTime = c;
    return a;
  }

  function Yc(a, b, c) {
    a = Vd(6, a, null, b);
    a.expirationTime = c;
    return a;
  }

  function $c(a, b, c) {
    b = Vd(4, null !== a.children ? a.children : [], a.key, b);
    b.expirationTime = c;
    b.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    };
    return b;
  }

  function pg(a, b, c) {
    this.tag = b;
    this.current = null;
    this.containerInfo = a;
    this.pingCache = this.pendingChildren = null;
    this.finishedExpirationTime = 0;
    this.finishedWork = null;
    this.timeoutHandle = Oa;
    this.pendingContext = this.context = null;
    this.hydrate = c;
    this.callbackNode = null;
    this.callbackPriority = 90;
    this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }

  function Kf(a, b) {
    var c = a.firstSuspendedTime;
    a = a.lastSuspendedTime;
    return 0 !== c && c >= b && a <= b;
  }

  function De(a, b) {
    var c = a.firstSuspendedTime,
        d = a.lastSuspendedTime;
    c < b && (a.firstSuspendedTime = b);
    if (d > b || 0 === c) a.lastSuspendedTime = b;
    b <= a.lastPingedTime && (a.lastPingedTime = 0);
    b <= a.lastExpiredTime && (a.lastExpiredTime = 0);
  }

  function Ee(a, b) {
    b > a.firstPendingTime && (a.firstPendingTime = b);
    var c = a.firstSuspendedTime;
    0 !== c && (b >= c ? a.firstSuspendedTime = a.lastSuspendedTime = a.nextKnownPendingLevel = 0 : b >= a.lastSuspendedTime && (a.lastSuspendedTime = b + 1), b > a.nextKnownPendingLevel && (a.nextKnownPendingLevel = b));
  }

  function Mf(a, b) {
    var c = a.lastExpiredTime;
    if (0 === c || c > b) a.lastExpiredTime = b;
  }

  var qg = null;

  function rg(a) {
    if (null === qg) try {
      var b = ("require" + Math.random()).slice(0, 7);
      qg = (module && module[b])("timers").setImmediate;
    } catch (c) {
      qg = function qg(a) {
        var b = new MessageChannel();
        b.port1.onmessage = a;
        b.port2.postMessage(void 0);
      };
    }
    return qg(a);
  }

  function sg(a) {
    var b = a._reactInternalFiber;

    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(n(188));
      throw Error(n(268, Object.keys(a)));
    }

    a = ya(b);
    return null === a ? null : a.stateNode;
  }

  function tg(a, b) {
    a = a.memoizedState;
    null !== a && null !== a.dehydrated && a.retryTime < b && (a.retryTime = b);
  }

  function ug(a, b) {
    tg(a, b);
    (a = a.alternate) && tg(a, b);
  }

  var vg = p.IsSomeRendererActing,
      wg = "function" === typeof m.unstable_flushAllWithoutAsserting,
      xg = m.unstable_flushAllWithoutAsserting || function () {
    for (var a = !1; Nf();) {
      a = !0;
    }

    return a;
  };

  function yg(a) {
    try {
      xg(), rg(function () {
        xg() ? yg(a) : a();
      });
    } catch (b) {
      a(b);
    }
  }

  var zg = 0,
      Ag = !1,
      Bg = {
    __proto__: null,
    createContainer: function createContainer(a, b, c) {
      a = new pg(a, b, c);
      b = Vd(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
      a.current = b;
      b.stateNode = a;
      yc(b);
      return a;
    },
    updateContainer: function updateContainer(a, b, c, d) {
      var e = b.current,
          f = Lc(),
          g = Ic.suspense;
      f = Mc(f, e, g);

      a: if (c) {
        c = c._reactInternalFiber;

        b: {
          if (va(c) !== c || 1 !== c.tag) throw Error(n(170));
          var h = c;

          do {
            switch (h.tag) {
              case 3:
                h = h.stateNode.context;
                break b;

              case 1:
                if (F(h.type)) {
                  h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                  break b;
                }

            }

            h = h.return;
          } while (null !== h);

          throw Error(n(171));
        }

        if (1 === c.tag) {
          var k = c.type;

          if (F(k)) {
            c = Hb(c, k, h);
            break a;
          }
        }

        c = h;
      } else c = Cb;

      null === b.context ? b.context = c : b.pendingContext = c;
      b = Ac(f, g);
      b.payload = {
        element: a
      };
      d = void 0 === d ? null : d;
      null !== d && (b.callback = d);
      Bc(e, b);
      Nc(e, f);
      return f;
    },
    batchedEventUpdates: function batchedEventUpdates(a, b) {
      var c = W;
      W |= 2;

      try {
        return a(b);
      } finally {
        W = c, W === V && H();
      }
    },
    batchedUpdates: Xf,
    unbatchedUpdates: function unbatchedUpdates(a, b) {
      var c = W;
      W &= -2;
      W |= of;

      try {
        return a(b);
      } finally {
        W = c, W === V && H();
      }
    },
    deferredUpdates: function deferredUpdates(a) {
      return dc(97, a);
    },
    syncUpdates: function syncUpdates(a, b, c, d) {
      return dc(99, a.bind(null, b, c, d));
    },
    discreteUpdates: function discreteUpdates(a, b, c, d, e) {
      var f = W;
      W |= 4;

      try {
        return dc(98, a.bind(null, b, c, d, e));
      } finally {
        W = f, W === V && H();
      }
    },
    flushDiscreteUpdates: function flushDiscreteUpdates() {
      (W & (1 | pf | qf)) === V && (Wf(), Nf());
    },
    flushControlled: function flushControlled(a) {
      var b = W;
      W |= 1;

      try {
        dc(99, a);
      } finally {
        W = b, W === V && H();
      }
    },
    flushSync: Yf,
    flushPassiveEffects: Nf,
    IsThisRendererActing: mg,
    getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;
      if (!a.child) return null;

      switch (a.child.tag) {
        case 5:
          return Aa(a.child.stateNode);

        default:
          return a.child.stateNode;
      }
    },
    attemptSynchronousHydration: function attemptSynchronousHydration(a) {
      switch (a.tag) {
        case 3:
          var b = a.stateNode;
          b.hydrate && Vf(b, b.firstPendingTime);
          break;

        case 13:
          Yf(function () {
            return Nc(a, 1073741823);
          }), b = hc(Lc(), 150, 100), ug(a, b);
      }
    },
    attemptUserBlockingHydration: function attemptUserBlockingHydration(a) {
      if (13 === a.tag) {
        var b = hc(Lc(), 150, 100);
        Nc(a, b);
        ug(a, b);
      }
    },
    attemptContinuousHydration: function attemptContinuousHydration(a) {
      13 === a.tag && (Nc(a, 3), ug(a, 3));
    },
    attemptHydrationAtCurrentPriority: function attemptHydrationAtCurrentPriority(a) {
      if (13 === a.tag) {
        var b = Lc();
        b = Mc(b, a, null);
        Nc(a, b);
        ug(a, b);
      }
    },
    findHostInstance: sg,
    findHostInstanceWithWarning: function findHostInstanceWithWarning(a) {
      return sg(a);
    },
    findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = za(a);
      return null === a ? null : 20 === a.tag ? a.stateNode.instance : a.stateNode;
    },
    shouldSuspend: function shouldSuspend() {
      return !1;
    },
    injectIntoDevTools: function injectIntoDevTools(a) {
      var b = a.findFiberByHostInstance;
      return ng(aa({}, a, {
        overrideHookState: null,
        overrideProps: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: p.ReactCurrentDispatcher,
        findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          a = ya(a);
          return null === a ? null : a.stateNode;
        },
        findFiberByHostInstance: function findFiberByHostInstance(a) {
          return b ? b(a) : null;
        },
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null
      }));
    },
    act: function act(a) {
      function b() {
        zg--;
        vg.current = c;
        mg.current = d;
      }

      !1 === Ag && (Ag = !0, console.error("act(...) is not supported in production builds of React, and might not behave as expected."));
      zg++;
      var c = vg.current;
      var d = mg.current;
      vg.current = !0;
      mg.current = !0;

      try {
        var e = Xf(a);
      } catch (f) {
        throw b(), f;
      }

      if (null !== e && "object" === (0, _typeof2.default)(e) && "function" === typeof e.then) return {
        then: function then(a, d) {
          e.then(function () {
            1 < zg || !0 === wg && !0 === c ? (b(), a()) : yg(function (c) {
              b();
              c ? d(c) : a();
            });
          }, function (a) {
            b();
            d(a);
          });
        }
      };

      try {
        1 !== zg || !1 !== wg && !1 !== c || xg(), b();
      } catch (f) {
        throw b(), f;
      }

      return {
        then: function then(a) {
          a();
        }
      };
    }
  },
      Cg = Bg && Bg["default"] || Bg;
  module.exports = Cg.default || Cg;
  var $$$renderer = module.exports;
  module.exports = $$$reconciler;
  return $$$renderer;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(468)(module)))

/***/ }),
/* 979 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),
/* 980 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(981);
} else {}

/***/ }),
/* 981 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.19.1
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _f, g, h, k, l;

if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
  var p = null,
      q = null,
      t = function t() {
    if (null !== p) try {
      var a = exports.unstable_now();
      p(!0, a);
      p = null;
    } catch (b) {
      throw setTimeout(t, 0), b;
    }
  },
      u = Date.now();

  exports.unstable_now = function () {
    return Date.now() - u;
  };

  _f = function f(a) {
    null !== p ? setTimeout(_f, 0, a) : (p = a, setTimeout(t, 0));
  };

  g = function g(a, b) {
    q = setTimeout(a, b);
  };

  h = function h() {
    clearTimeout(q);
  };

  k = function k() {
    return !1;
  };

  l = exports.unstable_forceFrameRate = function () {};
} else {
  var w = window.performance,
      x = window.Date,
      y = window.setTimeout,
      z = window.clearTimeout;

  if ("undefined" !== typeof console) {
    var A = window.cancelAnimationFrame;
    "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
    "function" !== typeof A && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
  }

  if ("object" === (0, _typeof2.default)(w) && "function" === typeof w.now) exports.unstable_now = function () {
    return w.now();
  };else {
    var B = x.now();

    exports.unstable_now = function () {
      return x.now() - B;
    };
  }
  var C = !1,
      D = null,
      E = -1,
      F = 5,
      G = 0;

  k = function k() {
    return exports.unstable_now() >= G;
  };

  l = function l() {};

  exports.unstable_forceFrameRate = function (a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported") : F = 0 < a ? Math.floor(1E3 / a) : 5;
  };

  var H = new MessageChannel(),
      I = H.port2;

  H.port1.onmessage = function () {
    if (null !== D) {
      var a = exports.unstable_now();
      G = a + F;

      try {
        D(!0, a) ? I.postMessage(null) : (C = !1, D = null);
      } catch (b) {
        throw I.postMessage(null), b;
      }
    } else C = !1;
  };

  _f = function _f(a) {
    D = a;
    C || (C = !0, I.postMessage(null));
  };

  g = function g(a, b) {
    E = y(function () {
      a(exports.unstable_now());
    }, b);
  };

  h = function h() {
    z(E);
    E = -1;
  };
}

function J(a, b) {
  var c = a.length;
  a.push(b);

  a: for (;;) {
    var d = c - 1 >>> 1,
        e = a[d];
    if (void 0 !== e && 0 < K(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}

function L(a) {
  a = a[0];
  return void 0 === a ? null : a;
}

function M(a) {
  var b = a[0];

  if (void 0 !== b) {
    var c = a.pop();

    if (c !== b) {
      a[0] = c;

      a: for (var d = 0, e = a.length; d < e;) {
        var m = 2 * (d + 1) - 1,
            n = a[m],
            v = m + 1,
            r = a[v];
        if (void 0 !== n && 0 > K(n, c)) void 0 !== r && 0 > K(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > K(r, c)) a[d] = r, a[v] = c, d = v;else break a;
      }
    }

    return b;
  }

  return null;
}

function K(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}

var N = [],
    O = [],
    P = 1,
    Q = null,
    R = 3,
    S = !1,
    T = !1,
    U = !1;

function V(a) {
  for (var b = L(O); null !== b;) {
    if (null === b.callback) M(O);else if (b.startTime <= a) M(O), b.sortIndex = b.expirationTime, J(N, b);else break;
    b = L(O);
  }
}

function W(a) {
  U = !1;
  V(a);
  if (!T) if (null !== L(N)) T = !0, _f(X);else {
    var b = L(O);
    null !== b && g(W, b.startTime - a);
  }
}

function X(a, b) {
  T = !1;
  U && (U = !1, h());
  S = !0;
  var c = R;

  try {
    V(b);

    for (Q = L(N); null !== Q && (!(Q.expirationTime > b) || a && !k());) {
      var d = Q.callback;

      if (null !== d) {
        Q.callback = null;
        R = Q.priorityLevel;
        var e = d(Q.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? Q.callback = e : Q === L(N) && M(N);
        V(b);
      } else M(N);

      Q = L(N);
    }

    if (null !== Q) var m = !0;else {
      var n = L(O);
      null !== n && g(W, n.startTime - b);
      m = !1;
    }
    return m;
  } finally {
    Q = null, R = c, S = !1;
  }
}

function Y(a) {
  switch (a) {
    case 1:
      return -1;

    case 2:
      return 250;

    case 5:
      return 1073741823;

    case 4:
      return 1E4;

    default:
      return 5E3;
  }
}

var Z = l;
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;

exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};

exports.unstable_continueExecution = function () {
  T || S || (T = !0, _f(X));
};

exports.unstable_getCurrentPriorityLevel = function () {
  return R;
};

exports.unstable_getFirstCallbackNode = function () {
  return L(N);
};

exports.unstable_next = function (a) {
  switch (R) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;

    default:
      b = R;
  }

  var c = R;
  R = b;

  try {
    return a();
  } finally {
    R = c;
  }
};

exports.unstable_pauseExecution = function () {};

exports.unstable_requestPaint = Z;

exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;

    default:
      a = 3;
  }

  var c = R;
  R = a;

  try {
    return b();
  } finally {
    R = c;
  }
};

exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();

  if ("object" === (0, _typeof2.default)(c) && null !== c) {
    var e = c.delay;
    e = "number" === typeof e && 0 < e ? d + e : d;
    c = "number" === typeof c.timeout ? c.timeout : Y(a);
  } else c = Y(a), e = d;

  c = e + c;
  a = {
    id: P++,
    callback: b,
    priorityLevel: a,
    startTime: e,
    expirationTime: c,
    sortIndex: -1
  };
  e > d ? (a.sortIndex = e, J(O, a), null === L(N) && a === L(O) && (U ? h() : U = !0, g(W, e - d))) : (a.sortIndex = c, J(N, a), T || S || (T = !0, _f(X)));
  return a;
};

exports.unstable_shouldYield = function () {
  var a = exports.unstable_now();
  V(a);
  var b = L(N);
  return b !== Q && null !== Q && null !== b && null !== b.callback && b.startTime <= a && b.expirationTime < Q.expirationTime || k();
};

exports.unstable_wrapCallback = function (a) {
  var b = R;
  return function () {
    var c = R;
    R = b;

    try {
      return a.apply(this, arguments);
    } finally {
      R = c;
    }
  };
};

/***/ }),
/* 982 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),
/* 983 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),
/* 984 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),
/* 985 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeToArray = __webpack_require__(470);

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 986 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 987 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 988 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var isArrayLike = function isArrayLike(value) {
  /**
   * isArrayLike([1, 2, 3]) => true
   * isArrayLike(document.body.children) => true
   * isArrayLike('abc') => true
   * isArrayLike(Function) => false
   */
  return value !== null && typeof value !== 'function' && isFinite(value.length);
};

exports.default = isArrayLike;

/***/ }),
/* 989 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var is_object_like_1 = __webpack_require__(471);

var is_type_1 = __webpack_require__(117);

var isPlainObject = function isPlainObject(value) {
  /**
   * isObjectLike(new Foo) => false
   * isObjectLike([1, 2, 3]) => false
   * isObjectLike({ x: 0, y: 0 }) => true
   * isObjectLike(Object.create(null)) => true
   */
  if (!is_object_like_1.default(value) || !is_type_1.default(value, 'Object')) {
    return false;
  }

  if (Object.getPrototypeOf(value) === null) {
    return true;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
};

exports.default = isPlainObject;

/***/ }),
/* 990 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 
 * @return {Boolean} 
 */

var is_type_1 = __webpack_require__(117);

var isNumber = function isNumber(value) {
  return is_type_1.default(value, 'Number');
};

exports.default = isNumber;

/***/ }),
/* 991 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeSensor = exports.getSensor = void 0;

var _id = _interopRequireDefault(__webpack_require__(992));

var _sensors = __webpack_require__(993);

var _constant = __webpack_require__(485);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

/**
 * all the sensor objects.
 * sensor pool
 */


var Sensors = {};
/**
 * get one sensor
 * @param element
 * @returns {*}
 */

var getSensor = function getSensor(element) {
  var sensorId = element.getAttribute(_constant.SizeSensorId); // 1. if the sensor exists, then use it

  if (sensorId && Sensors[sensorId]) {
    return Sensors[sensorId];
  } // 2. not exist, then create one


  var newId = (0, _id["default"])();
  element.setAttribute(_constant.SizeSensorId, newId);
  var sensor = (0, _sensors.createSensor)(element); // add sensor into pool

  Sensors[newId] = sensor;
  return sensor;
};
/**
 *  sensor
 * @param sensor
 */


exports.getSensor = getSensor;

var removeSensor = function removeSensor(sensor) {
  var sensorId = sensor.element.getAttribute(_constant.SizeSensorId); // remove attribute

  sensor.element.removeAttribute(_constant.SizeSensorId); // remove event, dom of the sensor used

  sensor.destroy(); // exist, then remove from pool

  if (sensorId && Sensors[sensorId]) {
    delete Sensors[sensorId];
  }
};

exports.removeSensor = removeSensor;

/***/ }),
/* 992 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */

var id = 1;
/**
 * generate unique id in application
 * @return {string}
 */

var _default = function _default() {
  return "".concat(id++);
};

exports["default"] = _default;

/***/ }),
/* 993 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSensor = void 0;

var _object = __webpack_require__(994);

var _resizeObserver = __webpack_require__(995);
/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */

/**
 * sensor strategies
 */
// export const createSensor = createObjectSensor;


var createSensor = typeof ResizeObserver !== 'undefined' ? _resizeObserver.createSensor : _object.createSensor;
exports.createSensor = createSensor;

/***/ }),
/* 994 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSensor = void 0;

var _debounce = _interopRequireDefault(__webpack_require__(484));

var _constant = __webpack_require__(485);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Created by hustcc on 18/6/9.
 * Contract: i@hust.cc
 */


var createSensor = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * create object DOM of sensor
   * @returns {HTMLObjectElement}
   */

  var newSensor = function newSensor() {
    // adjust style
    if (getComputedStyle(element).position === 'static') {
      element.style.position = 'relative';
    }

    var obj = document.createElement('object');

    obj.onload = function () {
      obj.contentDocument.defaultView.addEventListener('resize', resizeListener); //  resize

      resizeListener();
    };

    obj.style.display = 'block';
    obj.style.position = 'absolute';
    obj.style.top = '0';
    obj.style.left = '0';
    obj.style.height = '100%';
    obj.style.width = '100%';
    obj.style.overflow = 'hidden';
    obj.style.pointerEvents = 'none';
    obj.style.zIndex = '-1';
    obj.style.opacity = '0';
    obj.setAttribute('class', _constant.SensorClassName);
    obj.setAttribute('tabindex', _constant.SensorTabIndex);
    obj.type = 'text/html'; // append into dom

    element.appendChild(obj); // for ie, should set data attribute delay, or will be white screen

    obj.data = 'about:blank';
    return obj;
  };
  /**
   * trigger listeners
   */


  var resizeListener = (0, _debounce["default"])(function () {
    // trigger all listener
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * listen with one callback function
   * @param cb
   */

  var bind = function bind(cb) {
    // if not exist sensor, then create one
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy all
   */


  var destroy = function destroy() {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        // remote event
        sensor.contentDocument.defaultView.removeEventListener('resize', resizeListener);
      } // remove dom


      sensor.parentNode.removeChild(sensor); // initial variable

      sensor = undefined;
      listeners = [];
    }
  };
  /**
   * cancel listener bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

exports.createSensor = createSensor;

/***/ }),
/* 995 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createSensor = void 0;

var _debounce = _interopRequireDefault(__webpack_require__(484));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Created by hustcc on 18/7/5.
 * Contract: i@hust.cc
 */


var createSensor = function createSensor(element) {
  var sensor = undefined; // callback

  var listeners = [];
  /**
   * trigger listeners
   */

  var resizeListener = (0, _debounce["default"])(function () {
    // trigger all
    listeners.forEach(function (listener) {
      listener(element);
    });
  });
  /**
   * create ResizeObserver sensor
   * @returns
   */

  var newSensor = function newSensor() {
    var s = new ResizeObserver(resizeListener); // listen element

    s.observe(element); // trigger once

    resizeListener();
    return s;
  };
  /**
   * listen with callback
   * @param cb
   */


  var bind = function bind(cb) {
    if (!sensor) {
      sensor = newSensor();
    }

    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  /**
   * destroy
   */


  var destroy = function destroy() {
    sensor.disconnect();
    listeners = [];
    sensor = undefined;
  };
  /**
   * cancel bind
   * @param cb
   */


  var unbind = function unbind(cb) {
    var idx = listeners.indexOf(cb);

    if (idx !== -1) {
      listeners.splice(idx, 1);
    } // no listener, and sensor is exist
    // then destroy the sensor


    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };

  return {
    element: element,
    bind: bind,
    destroy: destroy,
    unbind: unbind
  };
};

exports.createSensor = createSensor;

/***/ }),
/* 996 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flow = void 0;
/**
 *  lodash.flow 
 * @param flows
 */

function flow() {
  var flows = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }

  return function (param) {
    return flows.reduce(function (result, f) {
      return f(result);
    }, param);
  };
}

exports.flow = flow;

/***/ }),
/* 997 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = void 0;
/**
 *  lodash.pick 
 * @param obj
 * @param keys
 */

function pick(obj, keys) {
  var r = {};

  if (obj !== null && (0, _typeof2.default)(obj) === 'object') {
    keys.forEach(function (key) {
      var v = obj[key];

      if (v !== undefined) {
        r[key] = v;
      }
    });
  }

  return r;
}

exports.pick = pick;

/***/ }),
/* 998 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.template = void 0;

var util_1 = __webpack_require__(0);
/**
 * 
 * template('hello, {name}', { name: 'AntV' }); // hello, AntV
 * @param string
 * @param options
 */


function template(source, data) {
  return util_1.reduce( // @ts-ignore
  data, function (r, v, k) {
    return r.replace(new RegExp("{\\s*" + k + "\\s*}", 'g'), v);
  }, source);
}

exports.template = template;

/***/ }),
/* 999 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Simplified from https://github.com/zertosh/invariant.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.log = exports.invariant = exports.LEVEL = void 0;

var tslib_1 = __webpack_require__(1);

var LEVEL;

(function (LEVEL) {
  LEVEL["ERROR"] = "error";
  LEVEL["WARN"] = "warn";
  LEVEL["INFO"] = "log";
})(LEVEL = exports.LEVEL || (exports.LEVEL = {}));

var BRAND = 'AntV/G2Plot';
/**
 * 
 * @param format
 * @param args
 */

function getMessage(format) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  var argIndex = 0;
  return BRAND + ": " + format.replace(/%s/g, function () {
    return "" + args[argIndex++];
  });
}
/**
 * invariant error
 * @param condition
 * @param format
 * @param args
 */


function invariant(condition, format) {
  var args = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }

  if (!condition) {
    var error = new Error(getMessage.apply(void 0, tslib_1.__spreadArrays([format], args)));
    error.name = BRAND; // error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
}

exports.invariant = invariant;
/**
 * 
 * @param level
 * @param condition
 * @param format
 * @param args
 */

function log(level, condition, format) {
  var args = [];

  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }

  if (!condition) {
    console[level](getMessage.apply(void 0, tslib_1.__spreadArrays([format], args)));
  }
}

exports.log = log;

/***/ }),
/* 1000 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContainerSize = void 0;
/**
 * get the element's bounding size
 * @param ele dom element
 * @returns the element width and height
 */

function getContainerSize(ele) {
  if (!ele) {
    return {
      width: 0,
      height: 0
    };
  }

  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}

exports.getContainerSize = getContainerSize;

/***/ }),
/* 1001 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllElements = exports.findGeometry = void 0;

var util_1 = __webpack_require__(0);
/**
 *  Chart  type  geometry
 * @param chart
 * @param type
 */


function findGeometry(chart, type) {
  return chart.geometries.find(function (g) {
    return g.type === type;
  });
}

exports.findGeometry = findGeometry;
/**
 *  Chart   elements
 */

function getAllElements(chart) {
  return util_1.reduce(chart.geometries, function (r, geometry) {
    return r.concat(geometry.elements);
  }, []);
}

exports.getAllElements = getAllElements;

/***/ }),
/* 1002 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findViewById = void 0;
/**
 *  Chart  id  View
 * @param chart
 * @param id
 */

function findViewById(chart, id) {
  return chart.views.find(function (view) {
    return view.id === id;
  });
}

exports.findViewById = findViewById;

/***/ }),
/* 1003 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformLabel = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);
/**
 *  v1 label formatter
 * @param labelOptions
 */


function transformLabel(labelOptions) {
  if (!util_1.isType(labelOptions, 'Object')) {
    return labelOptions;
  }

  var label = tslib_1.__assign({}, labelOptions);

  if (label.formatter && !label.content) {
    label.content = label.formatter;
  }

  return label;
}

exports.transformLabel = transformLabel;

/***/ }),
/* 1004 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSplinePath = exports.catmullRom2bezier = exports.smoothBezier = exports.points2Path = void 0;

var matrix_util_1 = __webpack_require__(33);

function points2Path(points, isInCircle) {
  var path = [];

  if (points.length) {
    path.push(['M', points[0].x, points[0].y]);

    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path.push(['L', item.x, item.y]);
    }

    if (isInCircle) {
      path.push(['Z']);
    }
  }

  return path;
}

exports.points2Path = points2Path;
/**
 * @ignore
 * 
 */

exports.smoothBezier = function (points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min;
  var max;

  if (hasConstraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min = matrix_util_1.vec2.min([0, 0], min, point);
      max = matrix_util_1.vec2.max([0, 0], max, point);
    }

    min = matrix_util_1.vec2.min([0, 0], min, constraint[0]);
    max = matrix_util_1.vec2.max([0, 0], max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(point);
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    var v = [0, 0];
    v = matrix_util_1.vec2.sub(v, nextPoint, prevPoint);
    v = matrix_util_1.vec2.scale(v, v, smooth);
    var d0 = matrix_util_1.vec2.distance(point, prevPoint);
    var d1 = matrix_util_1.vec2.distance(point, nextPoint);
    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    var v1 = matrix_util_1.vec2.scale([0, 0], v, -d0);
    var v2 = matrix_util_1.vec2.scale([0, 0], v, d1);
    var cp0 = matrix_util_1.vec2.add([0, 0], point, v1);
    var cp1 = matrix_util_1.vec2.add([0, 0], point, v2);

    if (hasConstraint) {
      cp0 = matrix_util_1.vec2.max([0, 0], cp0, min);
      cp0 = matrix_util_1.vec2.min([0, 0], cp0, max);
      cp1 = matrix_util_1.vec2.max([0, 0], cp1, min);
      cp1 = matrix_util_1.vec2.min([0, 0], cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
};
/**
 * @ignore
 * 
 */


function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];

  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }

  var controlPointList = exports.smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;

  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  return d1;
}

exports.catmullRom2bezier = catmullRom2bezier;
/**
 * @ignore
 * 
 */

function getSplinePath(points, isInCircle, constaint) {
  var data = [];
  var first = points[0];
  var prePoint = null;

  if (points.length <= 2) {
    // 
    return points2Path(points, isInCircle);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
      data.push(point.x);
      data.push(point.y);
      prePoint = point;
    }
  }

  var constraint = constaint || [// 
  [0, 0], [1, 1]];
  var splinePath = catmullRom2bezier(data, isInCircle, constraint);
  splinePath.unshift(['M', first.x, first.y]);
  return splinePath;
}

exports.getSplinePath = getSplinePath;

/***/ }),
/* 1005 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepAssign = void 0;
var MAX_MIX_LEVEL = 5; // 

var toString = {}.toString; // 

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};

var isArray = function isArray(value) {
  return isType(value, 'Array');
};

var isObjectLike = function isObjectLike(value) {
  /**
   * isObjectLike({}) => true
   * isObjectLike([1, 2, 3]) => true
   * isObjectLike(Function) => false
   */
  return (0, _typeof2.default)(value) === 'object' && value !== null;
};

var isPlainObject = function isPlainObject(value) {
  /**
   * isObjectLike(new Foo) => false
   * isObjectLike([1, 2, 3]) => false
   * isObjectLike({ x: 0, y: 0 }) => true
   */
  if (!isObjectLike(value) || !isType(value, 'Object')) {
    return false;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
};
/***
 * @param {any} dist
 * @param {any} src
 * @param {number} level 
 * @param {number} maxLevel 
 */


var deep = function deep(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;

  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value = src[key];

      if (!value) {
        // null  undefined 
        dist[key] = value;
      } else {
        if (isPlainObject(value)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }

          if (level < maxLevel) {
            deep(dist[key], value, level + 1, maxLevel);
          } else {
            // 
            dist[key] = src[key];
          }
        } else if (isArray(value)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value);
        } else {
          dist[key] = value;
        }
      }
    }
  }
};
/**
 * deepAssign  deepMix
 *  deepAssign  null undefined  source
 *  __tests__/unit/utils/deep-assign-spec.ts
 */


exports.deepAssign = function (rst) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }

  return rst;
};

/***/ }),
/* 1006 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kebabCase = void 0;
/**
 * @desc simple kebabCase like lodash
 *
 * kebabCase('fooBar'); => 'foo-bar'
 */

function kebabCase(word) {
  if (!word) {
    return word;
  }

  var result = word.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result.map(function (s) {
    return s.toLowerCase();
  }).join('-');
}

exports.kebabCase = kebabCase;

/***/ }),
/* 1007 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measureTextWidth = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var context_1 = __webpack_require__(1008);
/**
 * 
 * @param text 
 * @param font 
 */


exports.measureTextWidth = util_1.memoize(function (text, font) {
  if (font === void 0) {
    font = {};
  }

  var fontSize = font.fontSize,
      _a = font.fontFamily,
      fontFamily = _a === void 0 ? 'sans-serif' : _a,
      fontWeight = font.fontWeight,
      fontStyle = font.fontStyle,
      fontVariant = font.fontVariant;
  var ctx = context_1.getCanvasContext(); // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/font

  ctx.font = [fontStyle, fontWeight, fontVariant, fontSize + "px", fontFamily].join(' ');
  var metrics = ctx.measureText(util_1.isString(text) ? text : '');
  return metrics.width;
}, function (text, font) {
  if (font === void 0) {
    font = {};
  }

  return tslib_1.__spreadArrays([text], util_1.values(font)).join('');
});

/***/ }),
/* 1008 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCanvasContext = void 0;
var ctx;
/**
 *  canvas context
 */

function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement('canvas').getContext('2d');
  }

  return ctx;
}

exports.getCanvasContext = getCanvasContext;

/***/ }),
/* 1009 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.area = void 0;

var tslib_1 = __webpack_require__(1);

var tooltip_1 = __webpack_require__(88);

var utils_1 = __webpack_require__(16);

var base_1 = __webpack_require__(89);
/**
 * area geometry 
 * @param params
 */


function area(params) {
  var options = params.options;
  var area = options.area,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      smooth = options.smooth,
      tooltip = options.tooltip;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  return area ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'area',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        shape: smooth ? 'smooth' : 'area',
        tooltip: formatter
      }, area)
    }
  })) : params;
}

exports.area = area;

/***/ }),
/* 1010 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.line = void 0;

var util_1 = __webpack_require__(0);

var tooltip_1 = __webpack_require__(88);

var utils_1 = __webpack_require__(16);

var base_1 = __webpack_require__(89);
/**
 * line 
 * @param params
 */


function line(params) {
  var options = params.options;
  var line = options.line,
      stepType = options.stepType,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      smooth = options.smooth,
      connectNulls = options.connectNulls,
      tooltip = options.tooltip;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  return line ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'line',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: util_1.deepMix({
        shape: stepType || (smooth ? 'smooth' : 'line'),
        tooltip: formatter
      }, line),
      args: {
        connectNulls: connectNulls
      }
    }
  })) : params;
}

exports.line = line;

/***/ }),
/* 1011 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = void 0;

var tslib_1 = __webpack_require__(1);

var tooltip_1 = __webpack_require__(88);

var utils_1 = __webpack_require__(16);

var base_1 = __webpack_require__(89);
/**
 * point 
 * @param params
 */


function point(params) {
  var options = params.options;
  var point = options.point,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      sizeField = options.sizeField,
      shapeField = options.shapeField,
      tooltip = options.tooltip;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField, sizeField, shapeField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return point ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'point',
      colorField: seriesField,
      shapeField: shapeField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        tooltip: formatter
      }, point)
    }
  })) : params;
}

exports.point = point;

/***/ }),
/* 1012 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var tooltip_1 = __webpack_require__(88);

var base_1 = __webpack_require__(89);
/**
 *  adaptor
 * @param params
 */


function otherAdaptor(params) {
  var chart = params.chart,
      options = params.options,
      ext = params.ext;
  var seriesField = options.seriesField,
      isGroup = options.isGroup,
      isStack = options.isStack,
      marginRatio = options.marginRatio,
      widthRatio = options.widthRatio,
      groupField = options.groupField,
      theme = options.theme;
  /**
   * adjust
   */

  var adjust = [];

  if (seriesField) {
    // group
    if (isGroup) {
      adjust.push({
        type: 'dodge',
        dodgeBy: groupField || seriesField,
        marginRatio: marginRatio
      });
    } // stack


    if (isStack) {
      adjust.push({
        type: 'stack',
        marginRatio: marginRatio
      });
    }
  }

  if (adjust.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g.adjust(adjust);
  } // widthRatio


  if (!util_1.isNil(widthRatio)) {
    chart.theme(utils_1.deepAssign({}, util_1.isObject(theme) ? theme : g2_1.getTheme(theme), {
      // columWidthRatio  theme 
      columnWidthRatio: widthRatio
    }));
  }

  return params;
}

function interval(params) {
  var options = params.options;
  var xField = options.xField,
      yField = options.yField,
      interval = options.interval,
      seriesField = options.seriesField,
      tooltip = options.tooltip,
      minColumnWidth = options.minColumnWidth,
      maxColumnWidth = options.maxColumnWidth,
      columnBackground = options.columnBackground;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; //  interval 


  var ext = (interval ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'interval',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        tooltip: formatter
      }, interval),
      args: {
        minColumnWidth: minColumnWidth,
        maxColumnWidth: maxColumnWidth,
        background: columnBackground
      }
    }
  })) : params).ext;
  return otherAdaptor(tslib_1.__assign(tslib_1.__assign({}, params), {
    ext: ext
  }));
}

exports.interval = interval;

/***/ }),
/* 1013 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.edge = void 0;

var tslib_1 = __webpack_require__(1);

var tooltip_1 = __webpack_require__(88);

var utils_1 = __webpack_require__(16);

var base_1 = __webpack_require__(89);
/**
 * edge 
 * @param params
 */


function edge(params) {
  var options = params.options;
  var edge = options.edge,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return edge ? base_1.geometry(utils_1.deepAssign({}, params, {
    options: {
      type: 'edge',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: tslib_1.__assign({
        tooltip: formatter
      }, edge)
    }
  })) : params;
}

exports.edge = edge;

/***/ }),
/* 1014 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.statistic = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var common_1 = __webpack_require__(34);

var adaptor_1 = __webpack_require__(487);

var constant_1 = __webpack_require__(194);
/**
 * coordinate 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      radius = options.radius; // coordinate

  chart.coordinate('theta', {
    innerRadius: innerRadius,
    radius: radius
  });
  return params;
}
/**
 * statistic 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      statistic = options.statistic,
      percent = options.percent,
      meta = options.meta; // 

  chart.getController('annotation').clear(true);
  /**   */

  if (innerRadius && statistic) {
    var transformContent = statistic.content;

    if (transformContent && !transformContent.formatter) {
      // @ts-ignore
      transformContent.formatter = function (_a) {
        var percent = _a.percent;
        var metaFormatter = util_1.get(meta, [constant_1.PERCENT, 'formatter']);

        if (metaFormatter) {
          return metaFormatter(percent);
        }

        return percent;
      };
    }

    utils_1.renderStatistic(chart, {
      statistic: tslib_1.__assign(tslib_1.__assign({}, statistic), {
        content: transformContent
      }),
      plotType: 'ring-progress'
    }, {
      percent: percent
    });
  }

  if (updated) {
    chart.render(true);
  }

  return params;
}

exports.statistic = statistic;
/**
 * 
 * @param chart
 * @param options
 */

function adaptor(params) {
  return utils_1.flow(adaptor_1.geometry, common_1.scale({}), coordinate, statistic, common_1.animation, common_1.theme, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1015 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var constants_1 = __webpack_require__(152);

var utils_2 = __webpack_require__(118);

var data_1 = __webpack_require__(153);
/**
 * 
 * @param params
 */


function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      columnStyle = options.columnStyle,
      columnWidthRatio = options.columnWidthRatio;
  var seriesData = utils_2.getTinyData(data);
  chart.data(seriesData);
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: constants_1.X_FIELD,
      yField: constants_1.Y_FIELD,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color
      }
    }
  });
  geometries_1.interval(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction('element-active'); // scale

  common_1.scale((_a = {}, _a[constants_1.X_FIELD] = xAxis, _a[constants_1.Y_FIELD] = yAxis, _a), (_b = {}, _b[constants_1.X_FIELD] = {
    type: 'cat'
  }, _b[constants_1.Y_FIELD] = data_1.adjustYMetaByZero(seriesData, constants_1.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return utils_1.flow(geometry, common_1.tooltip, common_1.theme, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1016 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TOOLTIP_OPTIONS = void 0;

var util_1 = __webpack_require__(0);

exports.DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + util_1.get(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  }
};

/***/ }),
/* 1017 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var constants_1 = __webpack_require__(152);

var utils_2 = __webpack_require__(118);

var data_1 = __webpack_require__(153);
/**
 * 
 * @param params
 */


function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      areaStyle = options.areaStyle,
      pointOptions = options.point,
      lineOptions = options.line;
  var seriesData = utils_2.getTinyData(data);
  chart.data(seriesData);
  var primary = utils_1.deepAssign({}, params, {
    options: {
      xField: constants_1.X_FIELD,
      yField: constants_1.Y_FIELD,
      area: {
        color: color,
        style: areaStyle
      },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  }); // area geometry 

  geometries_1.area(primary);
  geometries_1.line(second);
  geometries_1.point(second);
  chart.axis(false);
  chart.legend(false); // scale

  common_1.scale((_a = {}, _a[constants_1.X_FIELD] = xAxis, _a[constants_1.Y_FIELD] = yAxis, _a), (_b = {}, _b[constants_1.X_FIELD] = {
    type: 'cat'
  }, _b[constants_1.Y_FIELD] = data_1.adjustYMetaByZero(seriesData, constants_1.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return utils_1.flow(geometry, common_1.tooltip, common_1.theme, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1018 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var utils_1 = __webpack_require__(16);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);

var data_1 = __webpack_require__(153);

var utils_2 = __webpack_require__(118);

var constants_1 = __webpack_require__(152);
/**
 * 
 * @param params
 */


function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      lineStyle = options.lineStyle,
      pointMapping = options.point;
  var seriesData = utils_2.getTinyData(data);
  chart.data(seriesData); // line geometry 

  var primary = utils_1.deepAssign({}, params, {
    options: {
      xField: constants_1.X_FIELD,
      yField: constants_1.Y_FIELD,
      line: {
        color: color,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  geometries_1.line(primary);
  geometries_1.point(second);
  chart.axis(false);
  chart.legend(false); // scale

  common_1.scale((_a = {}, _a[constants_1.X_FIELD] = xAxis, _a[constants_1.Y_FIELD] = yAxis, _a), (_b = {}, _b[constants_1.X_FIELD] = {
    type: 'cat'
  }, _b[constants_1.Y_FIELD] = data_1.adjustYMetaByZero(seriesData, constants_1.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return utils_1.flow(geometry, common_1.theme, common_1.tooltip, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1019 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

var marker_active_1 = __webpack_require__(1020);

g2_1.registerAction('marker-active', marker_active_1.MarkerActiveAction);
g2_1.registerInteraction('marker-active', {
  start: [{
    trigger: 'tooltip:show',
    action: 'marker-active:active'
  }]
});

/***/ }),
/* 1020 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerActiveAction = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var g2_1 = __webpack_require__(17);

var MarkerActiveAction =
/** @class */
function (_super) {
  tslib_1.__extends(MarkerActiveAction, _super);

  function MarkerActiveAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MarkerActiveAction.prototype.active = function () {
    var view = this.getView();
    var evt = this.context.event;

    if (evt.data) {
      // items:  tooltip 
      var items_1 = evt.data.items;
      var points = view.geometries.filter(function (geom) {
        return geom.type === 'point';
      });
      util_1.each(points, function (point) {
        util_1.each(point.elements, function (element) {
          var active = util_1.findIndex(items_1, function (item) {
            return item.data === element.data;
          }) !== -1; // @ts-ignore

          element.setState('active', active);
        });
      });
    }
  };

  MarkerActiveAction.prototype.getView = function () {
    return this.context.view;
  };

  return MarkerActiveAction;
}(g2_1.InteractionAction);

exports.MarkerActiveAction = MarkerActiveAction;

/***/ }),
/* 1021 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.interaction = void 0;

var polygon_1 = __webpack_require__(488);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var utils_2 = __webpack_require__(492);
/**
 *  option
 * @param params
 */


function defaultOptions(params) {
  var options = params.options;
  var colorField = options.colorField;
  return utils_1.deepAssign({
    options: {
      //  name 
      colorField: 'name',
      rectStyle: {
        lineWidth: 1,
        stroke: '#fff'
      },
      hierarchyConfig: {
        tile: 'treemapResquarify'
      },
      label: {
        fields: ['name'],
        layout: {
          type: 'limit-in-shape'
        }
      },
      tooltip: {
        showMarkers: false,
        showTitle: false,
        fields: ['name', 'value', colorField],
        formatter: function formatter(data) {
          return {
            name: data.name,
            value: data.value
          };
        }
      },
      interactions: [{
        type: 'view-zoom'
      }, {
        type: 'treemap-element-zoom'
      }]
    }
  }, params);
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var color = options.color,
      colorField = options.colorField,
      rectStyle = options.rectStyle;
  var data = utils_2.transformData({
    data: options.data,
    colorField: options.colorField,
    openDrillDown: utils_2.isDrillDown(options.interactions)
  });
  chart.data(data); // geometry

  polygon_1.polygon(utils_1.deepAssign({}, params, {
    options: {
      xField: 'x',
      yField: 'y',
      seriesField: colorField,
      rawFields: ['value'],
      polygon: {
        color: color,
        style: rectStyle
      }
    }
  }));
  return params;
}
/**
 * 
 * @param params
 */


function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * Interaction 
 * @param params
 */


function interaction(params) {
  var chart = params.chart,
      options = params.options;
  var interactions = options.interactions,
      hierarchyConfig = options.hierarchyConfig;
  common_1.interaction({
    chart: chart,
    options: {
      interactions: utils_2.getFommatInteractions(interactions, hierarchyConfig)
    }
  });
  return params;
}

exports.interaction = interaction;
/**
 * 
 * @param chart
 * @param options
 */

function adaptor(params) {
  return utils_1.flow(defaultOptions, geometry, axis, common_1.theme, common_1.legend, common_1.tooltip, interaction, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1022 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.treemap = void 0;

var tslib_1 = __webpack_require__(1);

var d3Hierarchy = tslib_1.__importStar(__webpack_require__(292));

var util_1 = __webpack_require__(0);

var util_2 = __webpack_require__(1046);

var DEFAULT_OPTIONS = {
  field: 'value',
  tile: 'treemapSquarify',
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ['x', 'y']
};

function treemap(data, options) {
  options = util_1.assign({}, DEFAULT_OPTIONS, options);
  var as = options.as;

  if (!util_1.isArray(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }

  var field;

  try {
    field = util_2.getField(options);
  } catch (e) {
    console.warn(e);
  }

  var partition = function partition(data) {
    return d3Hierarchy.treemap().tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
    /**
     * d3Hierarchy  sum  node  node  post-order traversal  value  node
     * for example:
     * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
     * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
     * ignoreParentValue  true()  0 + 5 + 5 = 10
     * ignoreParentValue  false   10 + 5 + 5 = 20
     * sum d  data, children 
     */
    d3Hierarchy.hierarchy(data).sum(function (d) {
      return options.ignoreParentValue && d.children ? 0 : d[field];
    }));
  };

  var root = partition(data);
  /*
   * points:
   *   3  2
   *   0  1
   */

  var x = as[0];
  var y = as[1];
  root.each(function (node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return util_2.getAllNodes(root);
}

exports.treemap = treemap;

/***/ }),
/* 1023 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;

  while (children = node.children) {
    node = children[0];
  }

  return node;
}

function leafRight(node) {
  var children;

  while (children = node.children) {
    node = children[children.length - 1];
  }

  return node;
}

function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0; // First walk, computing the initial x & y values.

    root.eachAfter(function (node) {
      var children = node.children;

      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2; // Second walk, normalizing x & y to the desired size.

    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };

  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };

  return cluster;
}

/***/ }),
/* 1024 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) {
    sum += children[i].value;
  }
  node.value = sum;
}

function _default() {
  return this.eachAfter(count);
}

/***/ }),
/* 1025 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _default(callback, that) {
  var index = -1;

  var _iterator = _createForOfIteratorHelper(this),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      callback.call(that, node, ++index, this);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return this;
}

/***/ }),
/* 1026 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback, that) {
  var node = this,
      nodes = [node],
      children,
      i,
      index = -1;

  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);

    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }

  return this;
}

/***/ }),
/* 1027 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback, that) {
  var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n,
      index = -1;

  while (node = nodes.pop()) {
    next.push(node);

    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }

  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }

  return this;
}

/***/ }),
/* 1028 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _default(callback, that) {
  var index = -1;

  var _iterator = _createForOfIteratorHelper(this),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;

      if (callback.call(that, node, ++index, this)) {
        return node;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

/***/ }),
/* 1029 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;

    while (--i >= 0) {
      sum += children[i].value;
    }

    node.value = sum;
  });
}

/***/ }),
/* 1030 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

/***/ }),
/* 1031 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];

  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }

  var k = nodes.length;

  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }

  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();

  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }

  return c;
}

/***/ }),
/* 1032 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var node = this,
      nodes = [node];

  while (node = node.parent) {
    nodes.push(node);
  }

  return nodes;
}

/***/ }),
/* 1033 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return Array.from(this);
}

/***/ }),
/* 1034 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

/***/ }),
/* 1035 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var root = this,
      links = [];
  root.each(function (node) {
    if (node !== root) {
      // Dont include the roots parent, if any.
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}

/***/ }),
/* 1036 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _callee;

var _regenerator = _interopRequireDefault(__webpack_require__(154));

var _marked = /*#__PURE__*/_regenerator.default.mark(_callee);

function _callee() {
  var node, current, next, children, i, n;
  return _regenerator.default.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          node = this, next = [node];

        case 1:
          current = next.reverse(), next = [];

        case 2:
          if (!(node = current.pop())) {
            _context.next = 8;
            break;
          }

          _context.next = 5;
          return node;

        case 5:
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }

          _context.next = 2;
          break;

        case 8:
          if (next.length) {
            _context.next = 1;
            break;
          }

        case 9:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

/***/ }),
/* 1037 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(2);

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && (0, _typeof2.default)(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
( false ? undefined : (0, _typeof2.default)(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(468)(module)))

/***/ }),
/* 1038 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _siblings = __webpack_require__(493);

var _accessors = __webpack_require__(294);

var _constant = _interopRequireWildcard(__webpack_require__(496));

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function _default() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;

    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(_constant.constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }

    return root;
  }

  pack.radius = function (x) {
    return arguments.length ? (radius = (0, _accessors.optional)(x), pack) : radius;
  };

  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0, _constant.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;
      if (r) for (i = 0; i < n; ++i) {
        children[i].r += r;
      }
      e = (0, _siblings.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) {
        children[i].r -= r;
      }
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;

    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

/***/ }),
/* 1039 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(__webpack_require__(497));

var _dice = _interopRequireDefault(__webpack_require__(155));

function _default() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        (0, _dice.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }

      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}

/***/ }),
/* 1040 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _accessors = __webpack_require__(294);

var _index = __webpack_require__(293);

var preroot = {
  depth: -1
},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function _default() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var nodes = Array.from(data),
        n = nodes.length,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map();

    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new _index.Node(d);

      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }

      if ((nodeId = parentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i];

      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function (node) {
      node.depth = node.parent.depth + 1;
      --n;
    }).eachBefore(_index.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }

  stratify.id = function (x) {
    return arguments.length ? (id = (0, _accessors.required)(x), stratify) : id;
  };

  stratify.parentId = function (x) {
    return arguments.length ? (parentId = (0, _accessors.required)(x), stratify) : parentId;
  };

  return stratify;
}

/***/ }),
/* 1041 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = __webpack_require__(293);

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
} // function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.


function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
} // This function works analogously to nextLeft.


function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
} // Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.


function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
} // All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).


function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;

  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
} // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.


function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor

  this.a = this; // ancestor

  this.z = 0; // prelim

  this.m = 0; // mod

  this.c = 0; // change

  this.s = 0; // shift

  this.t = null; // thread

  this.i = i; // number
}

TreeNode.prototype = Object.create(_index.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
} // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm


function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root); // Compute the layout using Buchheim et al.s algorithm.

    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.

    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function (node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function (node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
    return root;
  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.


  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;

    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;

      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }

    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  } // Computes all real x-coordinates by summing up the modifiers recursively.


  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  } // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).


  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;

      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);

        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }

        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }

      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }

      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }

    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };

  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };

  return tree;
}

/***/ }),
/* 1042 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(__webpack_require__(497));

var _squarify = _interopRequireDefault(__webpack_require__(295));

var _accessors = __webpack_require__(294);

var _constant = _interopRequireWildcard(__webpack_require__(496));

function _default() {
  var tile = _squarify.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant.constantZero,
      paddingTop = _constant.constantZero,
      paddingRight = _constant.constantZero,
      paddingBottom = _constant.constantZero,
      paddingLeft = _constant.constantZero;

  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;

    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function (x) {
    return arguments.length ? (tile = (0, _accessors.required)(x), treemap) : tile;
  };

  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}

/***/ }),
/* 1043 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i,
      n = nodes.length,
      sum,
      sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = value / 2 + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
    }

    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if (x1 - x0 > y1 - y0) {
      var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}

/***/ }),
/* 1044 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _dice = _interopRequireDefault(__webpack_require__(155));

var _slice = _interopRequireDefault(__webpack_require__(195));

function _default(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice.default : _dice.default)(parent, x0, y0, x1, y1);
}

/***/ }),
/* 1045 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dice = _interopRequireDefault(__webpack_require__(155));

var _slice = _interopRequireDefault(__webpack_require__(195));

var _squarify = __webpack_require__(295);

var _default = function custom(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;

        for (i = row.value = 0, n = nodes.length; i < n; ++i) {
          row.value += nodes[i].value;
        }

        if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0, _squarify.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}(_squarify.phi);

exports.default = _default;

/***/ }),
/* 1046 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllNodes = exports.getField = void 0;

var util_1 = __webpack_require__(0);

var INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';

function getField(options, defaultField) {
  var field = options.field,
      fields = options.fields;

  if (util_1.isString(field)) {
    return field;
  }

  if (util_1.isArray(field)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field[0];
  }

  console.warn(INVALID_FIELD_ERR_MSG + " will try to get fields instead.");

  if (util_1.isString(fields)) {
    return fields;
  }

  if (util_1.isArray(fields) && fields.length) {
    return fields[0];
  }

  if (defaultField) {
    return defaultField;
  }

  throw new TypeError(INVALID_FIELD_ERR_MSG);
}

exports.getField = getField;

function getAllNodes(root) {
  var nodes = [];

  if (root && root.each) {
    // d3-hierarchy
    root.each(function (node) {
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    // @antv/hierarchy
    root.eachNode(function (node) {
      nodes.push(node);
    });
  }

  return nodes;
}

exports.getAllNodes = getAllNodes;

/***/ }),
/* 1047 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

var treemap_drill_down_action_1 = __webpack_require__(1048);

var util_1 = __webpack_require__(1049);

g2_1.registerAction('treemap-drill-down-action', treemap_drill_down_action_1.TreemapDrillDownAction);
g2_1.registerInteraction('treemap-drill-down', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'element:click',
    isEnable: util_1.isTopParentNode,
    action: ['treemap-drill-down-action:click', 'reset-button:show']
  }],
  rollback: [{
    trigger: 'reset-button:click',
    action: ['treemap-drill-down-action:reset']
  }, {
    trigger: 'reset-button:click',
    action: ['reset-button:hide'],
    isEnable: function isEnable(context) {
      return !util_1.hasHistoryDrill(context);
    }
  }]
});

/***/ }),
/* 1048 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreemapDrillDownAction = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(492);

var TreemapDrillDownAction =
/** @class */
function (_super) {
  tslib_1.__extends(TreemapDrillDownAction, _super);

  function TreemapDrillDownAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this; //  scale


    _this.cacheDataStack = [];
    return _this;
  }

  TreemapDrillDownAction.prototype.drill = function (data) {
    console.log(this.context);
    var view = this.context.view;
    var currentData = view.getData();
    var groupScales = view.getGroupScales();
    var hierarchyConfig = util_1.get(view, ['interactions', 'treemap-drill-down', 'cfg', 'hierarchyConfig'], {}); //  update 

    var drillData = utils_1.transformData({
      data: data,
      colorField: util_1.get(groupScales, [0, 'field']),
      openDrillDown: true,
      hierarchyConfig: hierarchyConfig
    });
    view.changeData(drillData);
    this.cacheDataStack.push(currentData);
  };

  TreemapDrillDownAction.prototype.click = function () {
    var data = util_1.get(this.context, ['event', 'data', 'data']);
    if (!data) return false;
    this.drill(data);
  };

  TreemapDrillDownAction.prototype.reset = function () {
    var view = this.context.view;

    if (!util_1.isArray(this.cacheDataStack) || this.cacheDataStack.length <= 0) {
      return;
    }

    var cacheData = this.cacheDataStack.splice(this.cacheDataStack.length - 1, 1);
    view.changeData(cacheData[0]);
  };

  return TreemapDrillDownAction;
}(g2_1.Action);

exports.TreemapDrillDownAction = TreemapDrillDownAction;

/***/ }),
/* 1049 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasHistoryDrill = exports.isTopParentNode = void 0;

var util_1 = __webpack_require__(0);
/**
 * 
 */


function isTopParentNode(context) {
  var data = util_1.get(context, ['event', 'data', 'data'], {});
  return util_1.isArray(data.children) && data.children.length > 0 && data.depth === 1;
}

exports.isTopParentNode = isTopParentNode;
/**
 * 
 */

function hasHistoryDrill(context) {
  if (!context || !context.getAction) return false;
  var treemapElementDrillAction = context.getAction('treemap-drill-down-action');
  if (!treemapElementDrillAction) return false; // @ts-ignore

  var cacheDataStack = treemapElementDrillAction.cacheDataStack;
  return util_1.isArray(cacheDataStack) && cacheDataStack.length > 0;
}

exports.hasHistoryDrill = hasHistoryDrill;

/***/ }),
/* 1050 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var tslib_1 = __webpack_require__(1);

var adaptor_1 = __webpack_require__(499);
/**
 * 
 * @param params
 */


function adaptor(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      barStyle = options.barStyle,
      barWidthRatio = options.barWidthRatio,
      label = options.label,
      data = options.data,
      seriesField = options.seriesField,
      isStack = options.isStack,
      minBarWidth = options.minBarWidth,
      maxBarWidth = options.maxBarWidth; // label of bar charts default position is left, if plot has label

  if (label && !label.position) {
    label.position = 'left'; //  label layout  layout  position  layout

    if (!label.layout) {
      label.layout = [{
        type: 'interval-adjust-position'
      }, {
        type: 'interval-hide-overlap'
      }, {
        type: 'adjust-color'
      }, {
        type: 'limit-in-plot',
        cfg: {
          action: 'hide'
        }
      }];
    }
  } //  legend 


  var legend = options.legend;

  if (seriesField) {
    if (legend !== false) {
      legend = tslib_1.__assign({
        position: isStack ? 'top-left' : 'right-top',
        reversed: isStack ? false : true
      }, legend || {});
    }
  } else {
    legend = false;
  } // @ts-ignore 


  params.options.legend = legend; //  tooltip 

  var tooltip = options.tooltip;

  if (seriesField) {
    if (tooltip !== false) {
      tooltip = tslib_1.__assign({
        reversed: isStack ? false : true
      }, tooltip || {});
    }
  } // @ts-ignore 


  params.options.tooltip = tooltip; // transpose column to bar

  chart.coordinate().transpose();
  return adaptor_1.adaptor({
    chart: chart,
    options: tslib_1.__assign(tslib_1.__assign({}, options), {
      label: label,
      // switch xField and yField
      xField: yField,
      yField: xField,
      xAxis: yAxis,
      yAxis: xAxis,
      // rename attrs as column
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: options.barBackground,
      // bar 
      data: data ? data.slice().reverse() : data
    })
  }, true);
}

exports.adaptor = adaptor;

/***/ }),
/* 1051 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTag = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var g2_1 = __webpack_require__(17);

var utils_1 = __webpack_require__(16);

var conversion_1 = __webpack_require__(500);

function getConversionTagOptionsWithDefaults(options, horizontal) {
  return utils_1.deepAssign({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: 'rgba(0, 0, 0, 0.05)'
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: 'rgba(0, 0, 0, 0.85)',
        textAlign: 'center',
        textBaseline: 'middle'
      },
      formatter: conversion_1.conversionTagFormatter
    }
  }, options);
}

function parsePoints(coordinate, element) {
  // @ts-ignore
  return util_1.map(element.getModel().points, function (point) {
    return coordinate.convertPoint(point);
  });
}

function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view,
      geometry = config.geometry,
      group = config.group,
      options = config.options,
      horizontal = config.horizontal;
  var offset = options.offset,
      size = options.size,
      arrow = options.arrow;
  var coordinate = view.getCoordinate();
  var pointPrev = parsePoints(coordinate, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate, elemNext)[horizontal ? 0 : 3];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;

  if (typeof arrow === 'boolean') {
    return;
  }

  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points;

  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      // 
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points = [[pointPrev.x + spacing, pointPrev.y - offset], [pointPrev.x + spacing, pointPrev.y - offset - size], [pointNext.x - spacing, pointNext.y - offset - size / 2]];
    } else {
      // 
      points = [[pointPrev.x + spacing, pointPrev.y - offset], [pointPrev.x + spacing, pointPrev.y - offset - size], [pointNext.x - spacing - headSize, pointNext.y - offset - size], [pointNext.x - spacing, pointNext.y - offset - size / 2], [pointNext.x - spacing - headSize, pointNext.y - offset]];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      // 
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points = [[pointPrev.x + offset, pointPrev.y + spacing], [pointPrev.x + offset + size, pointPrev.y + spacing], [pointNext.x + offset + size / 2, pointNext.y - spacing]];
    } else {
      // 
      points = [[pointPrev.x + offset, pointPrev.y + spacing], [pointPrev.x + offset + size, pointPrev.y + spacing], [pointNext.x + offset + size, pointNext.y - spacing - headSize], [pointNext.x + offset + size / 2, pointNext.y - spacing], [pointNext.x + offset, pointNext.y - spacing - headSize]];
    }
  }

  group.addShape('polygon', {
    id: view.id + "-conversion-tag-arrow-" + geometry.getElementId(elemPrev.getModel().mappingData),
    name: 'conversion-tag-arrow',
    attrs: tslib_1.__assign(tslib_1.__assign({}, arrow.style || {}), {
      points: points
    })
  });
}

function renderTextTag(config, elemPrev, elemNext) {
  var _a, _b, _c;

  var view = config.view,
      geometry = config.geometry,
      group = config.group,
      options = config.options,
      field = config.field,
      horizontal = config.horizontal;
  var offset = options.offset,
      size = options.size;

  if (typeof options.text === 'boolean') {
    return;
  }

  var coordinate = view.getCoordinate();
  var text = ((_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field], elemNext.getData()[field]));
  var pointPrev = parsePoints(coordinate, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate, elemNext)[horizontal ? 0 : 3];
  var textShape = group.addShape('text', {
    id: view.id + "-conversion-tag-text-" + geometry.getElementId(elemPrev.getModel().mappingData),
    name: 'conversion-tag-text',
    attrs: tslib_1.__assign(tslib_1.__assign({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), {
      text: text,
      x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size / 2,
      y: horizontal ? pointPrev.y - offset - size / 2 : (pointPrev.y + pointNext.y) / 2
    })
  });

  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;

    if (textWidth > totalWidth) {
      var cWidth = textWidth / text.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = text.slice(0, cEnd) + "...";
      textShape.attr('text', textAdjusted);
    }
  }
}

function renderTag(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
/**
 *  adaptor/
 * @param field 
 * @param horizontal 
 * @param disabled 
 */


function conversionTag(field, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }

  if (disabled === void 0) {
    disabled = false;
  }

  return function (params) {
    var options = params.options,
        chart = params.chart;
    var conversionTag = options.conversionTag,
        theme = options.theme;

    if (conversionTag && !disabled) {
      //  1/3
      chart.theme(utils_1.deepAssign({}, util_1.isObject(theme) ? theme : g2_1.getTheme(theme), {
        columnWidthRatio: 1 / 3
      })); //   shape annotation 

      chart.annotation().shape({
        render: function render(container, view) {
          var group = container.addGroup({
            id: chart.id + "-conversion-tag-group",
            name: 'conversion-tag-group'
          });
          var interval = util_1.find(chart.geometries, function (geom) {
            return geom.type === 'interval';
          });
          var config = {
            view: view,
            geometry: interval,
            group: group,
            field: field,
            horizontal: horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag, horizontal)
          };
          var elements = horizontal ? interval.elements : interval.elements.slice().reverse();
          util_1.each(elements, function (elem, idx) {
            if (idx > 0) {
              renderTag(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }

    return params;
  };
}

exports.conversionTag = conversionTag;

/***/ }),
/* 1052 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectedArea = void 0;

var g2_1 = __webpack_require__(17);

var INTERACTION_MAP = {
  hover: '__interval-connected-area-hover__',
  click: '__interval-connected-area-click__'
};
/** hover  */

g2_1.registerInteraction(INTERACTION_MAP.hover, {
  start: [{
    trigger: "interval:mouseenter",
    action: ['element-highlight-by-color:highlight', 'element-link-by-color:link']
  }],
  end: [{
    trigger: 'interval:mouseleave',
    action: ['element-highlight-by-color:reset', 'element-link-by-color:unlink']
  }]
});
/** click  */

g2_1.registerInteraction(INTERACTION_MAP.click, {
  start: [{
    trigger: "interval:click",
    action: ['element-highlight-by-color:clear', 'element-highlight-by-color:highlight', 'element-link-by-color:clear', 'element-link-by-color:unlink', 'element-link-by-color:link']
  }],
  end: [{
    trigger: 'document:mousedown',
    action: ['element-highlight-by-color:clear', 'element-link-by-color:clear']
  }]
});
/**
 *  adaptor/
 * @param disable
 */

function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }

  return function (params) {
    var chart = params.chart,
        options = params.options;
    var connectedArea = options.connectedArea;

    var clear = function clear() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };

    if (!disable && connectedArea) {
      var trigger = connectedArea.trigger || 'hover';
      clear();
      chart.interaction(INTERACTION_MAP[trigger]);
    } else {
      clear();
    }

    return params;
  };
}

exports.connectedArea = connectedArea;

/***/ }),
/* 1053 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(16);

var percent_1 = __webpack_require__(156);

var adaptor_1 = __webpack_require__(491);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      areaStyle = options.areaStyle,
      color = options.color,
      pointMapping = options.point,
      lineMapping = options.line,
      isPercent = options.isPercent,
      xField = options.xField,
      yField = options.yField,
      tooltip = options.tooltip,
      seriesField = options.seriesField;
  var chartData = percent_1.getDataWhetherPecentage(data, yField, xField, yField, isPercent);
  chart.data(chartData); //  % , 

  var tooltipOptions = isPercent ? tslib_1.__assign({
    formatter: function formatter(datum) {
      return {
        name: datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var primary = utils_2.deepAssign({}, params, {
    options: {
      area: {
        color: color,
        style: areaStyle
      },
      //  tooltip 
      // 
      line: lineMapping && tslib_1.__assign({
        color: color
      }, lineMapping),
      point: pointMapping && tslib_1.__assign({
        color: color
      }, pointMapping),
      tooltip: tooltipOptions,
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  });
  var second = utils_2.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  }); // area geometry 

  geometries_1.area(primary);
  geometries_1.line(second);
  geometries_1.point(second);
  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var areaGeometry = utils_1.findGeometry(chart, 'area'); // label  false,   label

  if (!label) {
    areaGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    areaGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: tslib_1.__assign({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, utils_2.transformLabel(cfg))
    });
  }

  return params;
}
/**
 *  adjust
 * @param params
 */


function adjust(params) {
  var chart = params.chart,
      options = params.options;
  var isStack = options.isStack,
      isPercent = options.isPercent;

  if (isPercent || isStack) {
    util_1.each(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_2.flow(geometry, adaptor_1.meta, adjust, common_1.theme, adaptor_1.axis, adaptor_1.legend, common_1.tooltip, label, common_1.slider, common_1.annotation(), common_1.interaction, common_1.animation, common_1.limitInPlot)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1054 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.pieAnnotation = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);

var utils_1 = __webpack_require__(16);

var contants_1 = __webpack_require__(501);

var utils_2 = __webpack_require__(502);
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      angleField = options.angleField,
      colorField = options.colorField,
      color = options.color,
      pieStyle = options.pieStyle; // 

  var processData = utils_2.processIllegalData(data, angleField);

  if (utils_2.isAllZero(processData, angleField)) {
    //  0  position 
    var percentageField_1 = '$$percentage$$';
    processData = processData.map(function (d) {
      var _a;

      return tslib_1.__assign(tslib_1.__assign({}, d), (_a = {}, _a[percentageField_1] = 1 / processData.length, _a));
    });
    chart.data(processData);
    var p = utils_1.deepAssign({}, params, {
      options: {
        xField: '1',
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    geometries_1.interval(p); // all zero 

    chart.geometries[0].tooltip(colorField + "*" + angleField);
  } else {
    chart.data(processData);
    var p = utils_1.deepAssign({}, params, {
      options: {
        xField: '1',
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    geometries_1.interval(p);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var meta = options.meta,
      colorField = options.colorField; // meta  scale 

  var scales = utils_1.deepAssign({}, meta);
  chart.scale(scales, (_a = {}, _a[colorField] = {
    type: 'cat'
  }, _a));
  return params;
}
/**
 * coord 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius,
      innerRadius = options.innerRadius,
      startAngle = options.startAngle,
      endAngle = options.endAngle;
  chart.coordinate({
    type: 'theta',
    cfg: {
      radius: radius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    }
  });
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      colorField = options.colorField,
      angleField = options.angleField;
  var geometry = chart.geometries[0]; // label  false,   label

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    var labelCfg = utils_1.transformLabel(cfg); //   label content 

    if (labelCfg.content) {
      var content_1 = labelCfg.content;

      labelCfg.content = function (data, dataum, index) {
        var name = data[colorField];
        var value = data[angleField]; // dymatic get scale, scale is ready this time

        var angleScale = chart.getScaleByField(angleField);
        var percent = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value);
        return util_1.isFunction(content_1) ? // append pecent (number) to data, users can get origin data from `dataum._origin`
        content_1(tslib_1.__assign(tslib_1.__assign({}, data), {
          percent: percent
        }), dataum, index) : util_1.isString(content_1) ? utils_1.template(content_1, {
          value: value,
          name: name,
          // percentage (string), default keep 2
          percentage: util_1.isNumber(percent) && !util_1.isNil(value) ? (percent * 100).toFixed(2) + "%" : null
        }) : content_1;
      };
    }

    var LABEL_LAYOUT_TYPE_MAP = {
      inner: '',
      outer: 'pie-outer',
      spider: 'pie-spider'
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : 'pie-outer';
    var labelLayoutCfg = labelCfg.layout ? !util_1.isArray(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{
      type: labelLayoutType
    }] : []).concat(labelLayoutCfg);
    geometry.label({
      // fix: could not create scale, when field is undefinedattributes  fields  scale
      fields: colorField ? [angleField, colorField] : [angleField],
      callback: callback,
      cfg: tslib_1.__assign(tslib_1.__assign({}, labelCfg), {
        offset: utils_2.adaptOffset(labelCfg.type, labelCfg.offset),
        type: 'pie'
      })
    });
  }

  return params;
}
/**
 * statistic 
 * @param params
 */


function pieAnnotation(params) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      statistic = options.statistic,
      angleField = options.angleField,
      colorField = options.colorField,
      meta = options.meta; // 

  chart.getController('annotation').clear(true); //  annotations

  utils_1.flow(common_1.annotation())(params);
  /**   */

  if (innerRadius && statistic) {
    var _a = utils_1.deepAssign({}, contants_1.DEFAULT_OPTIONS.statistic, statistic),
        title = _a.title,
        content = _a.content;

    if (title !== false) {
      title = utils_1.deepAssign({}, {
        formatter: function formatter(datum) {
          return datum ? datum[colorField] : '';
        }
      }, title);
    }

    if (content !== false) {
      content = utils_1.deepAssign({}, {
        formatter: function formatter(datum, data) {
          var metaFormatter = util_1.get(meta, [angleField, 'formatter']);
          var dataValue = datum ? datum[angleField] : utils_2.getTotalValue(data, angleField);
          return metaFormatter ? metaFormatter(dataValue) : dataValue;
        }
      }, content);
    }

    utils_1.renderStatistic(chart, {
      statistic: {
        title: title,
        content: content
      },
      plotType: 'pie'
    });
  }

  return params;
}

exports.pieAnnotation = pieAnnotation;
/**
 *  tooltip  tooltip.shared  false
 * @param params
 */

function adaptorTooltipOptions(params) {
  return util_1.get(params, ['options', 'tooltip']) !== false ? utils_1.deepAssign({}, params, {
    options: {
      tooltip: {
        shared: false
      }
    }
  }) : params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_1.flow(geometry, meta, common_1.theme, coordinate, common_1.legend, function (args) {
    return common_1.tooltip(adaptorTooltipOptions(args));
  }, label, common_1.state,
  /**   */
  pieAnnotation, common_1.interaction, common_1.animation)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1055 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

var pie_legend_action_1 = __webpack_require__(1056);

var pie_statistic_action_1 = __webpack_require__(1057);

g2_1.registerAction('pie-statistic', pie_statistic_action_1.StatisticAction);
g2_1.registerInteraction('pie-statistic-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'pie-statistic:change'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'pie-statistic:reset'
  }]
});
g2_1.registerAction('pie-legend', pie_legend_action_1.PieLegendAction);
g2_1.registerInteraction('pie-legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: 'pie-legend:active'
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: 'pie-legend:reset'
  }]
});

/***/ }),
/* 1056 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PieLegendAction = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var matrix_1 = __webpack_require__(503);
/**
 *   action
 */


var PieLegendAction =
/** @class */
function (_super) {
  tslib_1.__extends(PieLegendAction, _super);

  function PieLegendAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   */


  PieLegendAction.prototype.getActiveElements = function () {
    var delegateObject = g2_1.Util.getDelegationObject(this.context);

    if (delegateObject) {
      var view = this.context.view;
      var component = delegateObject.component,
          item_1 = delegateObject.item;
      var field_1 = component.get('field');

      if (field_1) {
        var elements = view.geometries[0].elements;
        return elements.filter(function (ele) {
          return ele.getModel().data[field_1] === item_1.value;
        });
      }
    }

    return [];
  };
  /**
   * 
   */


  PieLegendAction.prototype.getActiveElementLabels = function () {
    var view = this.context.view;
    var elements = this.getActiveElements();
    var labels = view.geometries[0].labelsContainer.getChildren();
    return labels.filter(function (label) {
      return elements.find(function (ele) {
        return util_1.isEqual(ele.getData(), label.get('data'));
      });
    });
  };

  PieLegendAction.prototype.transfrom = function (offset) {
    if (offset === void 0) {
      offset = 7.5;
    }

    var elements = this.getActiveElements();
    var elementLabels = this.getActiveElementLabels();
    elements.forEach(function (element, idx) {
      var labelShape = elementLabels[idx];
      var coordinate = element.geometry.coordinate;

      if (coordinate.isPolar && coordinate.isTransposed) {
        var _a = g2_1.Util.getAngle(element.getModel(), coordinate),
            startAngle = _a.startAngle,
            endAngle = _a.endAngle;

        var middleAngle = (startAngle + endAngle) / 2;
        var r = offset;
        var x = r * Math.cos(middleAngle);
        var y = r * Math.sin(middleAngle);
        element.shape.setMatrix(matrix_1.transform([['t', x, y]]));
        labelShape.setMatrix(matrix_1.transform([['t', x, y]]));
      }
    });
  };

  PieLegendAction.prototype.active = function () {
    this.transfrom();
  };
  /**
   * 
   */


  PieLegendAction.prototype.reset = function () {
    this.transfrom(0);
  };

  return PieLegendAction;
}(g2_1.Action);

exports.PieLegendAction = PieLegendAction;

/***/ }),
/* 1057 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatisticAction = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var statistic_1 = __webpack_require__(486);
/**
 * Pie  Action
 */


var StatisticAction =
/** @class */
function (_super) {
  tslib_1.__extends(StatisticAction, _super);

  function StatisticAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  StatisticAction.prototype.getAnnotations = function (_view) {
    var view = _view || this.context.view; // @ts-ignore

    return view.getController('annotation').option;
  };

  StatisticAction.prototype.getInitialAnnotation = function () {
    return this.initialAnnotation;
  };

  StatisticAction.prototype.init = function () {
    var _this = this;

    var view = this.context.view;
    view.removeInteraction('tooltip');
    view.on('afterchangesize', function () {
      var annotations = _this.getAnnotations(view);

      _this.initialAnnotation = annotations;
    });
  };

  StatisticAction.prototype.change = function () {
    var _a = this.context,
        view = _a.view,
        event = _a.event;
    var annotations = this.getAnnotations();

    if (!this.initialAnnotation) {
      this.initialAnnotation = annotations;
    }

    var data = ((event === null || event === void 0 ? void 0 : event.data) || {}).data;

    if (event.type.match('legend-item')) {
      var delegateObject = g2_1.Util.getDelegationObject(this.context); // @ts-ignore

      var colorField_1 = view.getGroupedFields()[0];

      if (delegateObject && colorField_1) {
        var item_1 = delegateObject.item;
        data = view.getData().find(function (d) {
          return d[colorField_1] === item_1.value;
        });
      }
    }

    if (data) {
      var annotationController_1 = view.getController('annotation');
      annotationController_1.clear(true); // @ts-ignore

      var _b = view.getScaleFields(),
          angleField_1 = _b[1],
          colorField_2 = _b[2];

      var angleScale_1 = view.getScaleByField(angleField_1);
      var colorScale_1 = view.getScaleByField(colorField_2);
      var annotationOptions_1 = annotations.filter(function (a) {
        return !util_1.get(a, 'key', '').match('statistic');
      });
      var statisticOptions = annotations.filter(function (a) {
        return util_1.get(a, 'key', '').match('statistic');
      });
      var titleOpt_1 = statisticOptions.filter(function (opt) {
        return opt.key === 'top-statistic';
      });
      var contentOpt_1 = statisticOptions.filter(function (opt) {
        return opt.key === 'bottom-statistic';
      });
      util_1.each(statisticOptions, function (option) {
        var text;
        var transform;

        if (option.key === 'top-statistic') {
          text = colorScale_1 ? colorScale_1.getText(data[colorField_2]) : null;
          transform = contentOpt_1 ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
        } else {
          text = angleScale_1 ? angleScale_1.getText(data[angleField_1]) : data[angleField_1];
          transform = titleOpt_1 ? 'translate(-50%, 0)' : 'translate(-50%,-50%)';
        }

        annotationOptions_1.push(tslib_1.__assign(tslib_1.__assign({}, option), {
          html: function html(container, view) {
            var coordinate = view.getCoordinate();
            var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
            var style = util_1.isFunction(option.style) ? option.style() : option.style;
            statistic_1.setStatisticContainerStyle(container, tslib_1.__assign({
              width: containerWidth + "px",
              transform: transform
            }, statistic_1.adapteStyle(style)));
            var filteredData = view.getData();

            if (option.customHtml) {
              return option.customHtml(container, view, data, filteredData);
            }

            if (option.formatter) {
              text = option.formatter(data, filteredData);
            } // todo G2  & G2  number


            return text ? util_1.isString(text) ? text : "" + text : '<div></div>';
          }
        }));
        annotationOptions_1.forEach(function (opt) {
          // @ts-ignore
          annotationController_1.annotation(opt);
        });
        view.render(true);
      });
    }
  };

  StatisticAction.prototype.reset = function () {
    var view = this.context.view;
    var annotationController = view.getController('annotation');
    annotationController.clear(true);
    var initialStatistic = this.getInitialAnnotation();
    util_1.each(initialStatistic, function (a) {
      view.annotation()[a.type](a);
    });
    view.render(true);
  };

  return StatisticAction;
}(g2_1.Action);

exports.StatisticAction = StatisticAction;

/***/ }),
/* 1058 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var utils_2 = __webpack_require__(16);

var constant_1 = __webpack_require__(290);

var common_1 = __webpack_require__(34);
/**
 * 
 * @param params
 */


function field(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      type = options.type,
      reflect = options.reflect,
      xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      sizeField = options.sizeField,
      sizeRatio = options.sizeRatio,
      shape = options.shape,
      color = options.color;
  chart.data(data);
  var geometry;

  if (type === 'density') {
    geometry = chart.heatmap().position(xField + "*" + yField);
  } else {
    geometry = chart.polygon().position(xField + "*" + yField);
  }

  if (colorField) {
    geometry.color(colorField, color || constant_1.DEFAULT_COLORS.GRADIENT.CONTINUOUS);
  }

  if (reflect) {
    chart.coordinate().reflect(reflect);
  }
  /**
   * The ratio between the actual size and the max available size, must be in range `[0,1]`.
   *
   * If the `sizeRatio` attribute is undefined or it exceeds the range,
   * `checkedSizeRatio` would be set to 1 as default.
   */


  var checkedSizeRatio = 1;

  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn('sizeRatio is not in effect: Must define shape or sizeField first');
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn('sizeRatio is not in effect: It must be a number in [0,1]');
    } else {
      checkedSizeRatio = sizeRatio;
    }
  } // when it has to change shape from original rect


  if (shape) {
    // just to change shape in cell
    if (!sizeField) {
      geometry.shape('', function () {
        return [shape, 1, checkedSizeRatio];
      });
    } // specific shape in different size


    if (sizeField) {
      var field_1 = data.map(function (row) {
        return row[sizeField];
      });
      var min_1 = Math.min.apply(Math, field_1);
      var max_1 = Math.max.apply(Math, field_1);
      geometry.shape(sizeField, function (v) {
        return [shape, (v - min_1) / (max_1 - min_1), checkedSizeRatio];
      });
    }
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return utils_2.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField;

  if (legend) {
    chart.legend(colorField, legend);
  } else {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function style(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      sizeField = options.sizeField,
      heatmapStyle = options.heatmapStyle;
  var geometry = chart.geometries[0];

  if (heatmapStyle && geometry) {
    if (util_1.isFunction(heatmapStyle)) {
      geometry.style(xField + "*" + yField + "*" + colorField + "*" + sizeField, heatmapStyle);
    } else if (util_1.isObject(heatmapStyle)) {
      geometry.style(heatmapStyle);
    }
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      colorField = options.colorField,
      type = options.type;
  var geometry = utils_1.findGeometry(chart, type === 'density' ? 'heatmap' : 'polygon');

  if (!label) {
    geometry.label(false);
  } else if (colorField) {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    geometry.label({
      fields: [colorField],
      callback: callback,
      cfg: utils_2.transformLabel(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_2.flow(field, meta, common_1.theme, axis, legend, common_1.tooltip, style, label, common_1.annotation(), common_1.interaction, common_1.animation)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1059 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

g2_1.registerShape('polygon', 'circle', {
  draw: function draw(cfg, group) {
    var _a, _b;

    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value);
    var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon = group.addShape('circle', {
      attrs: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
        x: cx,
        y: cy,
        r: radius
      }, cfg.defaultStyle), cfg.style), {
        fill: fill
      })
    });
    return polygon;
  }
});

/***/ }),
/* 1060 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

g2_1.registerShape('polygon', 'square', {
  draw: function draw(cfg, group) {
    var _a, _b;

    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxSideLength = Math.min(width, height);
    var value = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value);
    var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon = group.addShape('rect', {
      attrs: tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({
        x: cx - sideLength / 2,
        y: cy - sideLength / 2,
        width: sideLength,
        height: sideLength
      }, cfg.defaultStyle), cfg.style), {
        fill: fill
      })
    });
    return polygon;
  }
});

/***/ }),
/* 1061 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(504);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var colorField = options.colorField,
      color = options.color;
  var data = utils_2.transform(params);
  chart.data(data);
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: 'x',
      yField: 'y',
      seriesField: colorField && 'color',
      point: {
        color: color,
        shape: 'word-cloud'
      }
    }
  });
  var ext = geometries_1.point(p).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect('y');
  chart.axis(false);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  return utils_1.flow(common_1.scale({
    x: {
      nice: false
    },
    y: {
      nice: false
    }
  }))(params);
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  utils_1.flow(geometry, meta, common_1.tooltip, common_1.legend, common_1.interaction, common_1.animation, common_1.theme, common_1.state)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1062 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.functor = exports.transform = exports.wordCloud = void 0;

var util_1 = __webpack_require__(0);

var DEFAULT_OPTIONS = {
  font: function font() {
    return 'serif';
  },
  padding: 1,
  size: [500, 500],
  spiral: 'archimedean',
  // timeInterval: Infinity // max execute time
  timeInterval: 3000
};
/**
 * 
 * 
 * 
 * @param words
 * @param options
 */

function wordCloud(words, options) {
  // 
  options = util_1.assign({}, DEFAULT_OPTIONS, options);
  return transform(words, options);
}

exports.wordCloud = wordCloud;
/**
 * 
 * @param words
 * @param options
 */

function transform(words, options) {
  // 
  var layout = tagCloud();
  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {
    if (!util_1.isNil(options[key])) {
      layout[key](options[key]);
    }
  });
  layout.words(words);

  if (options.imageMask) {
    layout.createMask(options.imageMask);
  }

  var result = layout.start();
  var tags = result._tags;
  tags.forEach(function (tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a = options.size,
      w = _a[0],
      h = _a[1]; // 
  // 
  // 
  // 

  tags.push({
    text: '',
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags.push({
    text: '',
    value: 0,
    x: w,
    y: h,
    opacity: 0
  });
  return tags;
}

exports.transform = transform;
var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;

function cloudText(d) {
  return d.text;
}

function cloudFont() {
  return 'serif';
}

function cloudFontNormal() {
  return 'normal';
}

function cloudFontSize(d) {
  return d.value;
}

function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}

function cloudPadding() {
  return 1;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.


function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0;
  var n = data.length;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    var w = c.measureText(d.text + 'm').width * ratio,
        h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);

    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }

    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    var w = d.width,
        w32 = w >> 5;
    var h = d.y1 - d.y0; // Zero the buffer

    for (var i = 0; i < h * w32; i++) {
      sprite[i] = 0;
    }

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0;
  var x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1];
  var x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [];
  var i = -1;

  while (++i < n) {
    a[i] = 0;
  }

  return a;
}

function cloudCanvas() {
  return document.createElement('canvas');
}

function functor(d) {
  return util_1.isFunction(d) ? d : function () {
    return d;
  };
}

exports.functor = functor;
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

function tagCloud() {
  var size = [256, 256],
      font = cloudFont,
      fontSize = cloudFontSize,
      fontWeight = cloudFontNormal,
      rotate = cloudRotate,
      padding = cloudPadding,
      spiral = archimedeanSpiral,
      random = Math.random,
      words = [],
      timeInterval = Infinity;
  var text = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};

  cloud.start = function () {
    var width = size[0],
        height = size[1];
    var contextAndRatio = getContext(canvas()),
        board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),
        n = words.length,
        tags = [],
        data = words.map(function (d, i, data) {
      d.text = text.call(this, d, i, data);
      d.font = font.call(this, d, i, data);
      d.style = fontStyle.call(this, d, i, data);
      d.weight = fontWeight.call(this, d, i, data);
      d.rotate = rotate.call(this, d, i, data);
      d.size = ~~fontSize.call(this, d, i, data);
      d.padding = padding.call(this, d, i, data);
      return d;
    }).sort(function (a, b) {
      return b.size - a.size;
    });
    var i = -1,
        bounds = !cloud.board ? null : [{
      x: 0,
      y: 0
    }, {
      x: width,
      y: height
    }];
    step();

    function step() {
      var start = Date.now();

      while (Date.now() - start < timeInterval && ++i < n) {
        var d = data[i];
        d.x = width * (random() + 0.5) >> 1;
        d.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data, i);

        if (d.hasText && place(board, d, bounds)) {
          tags.push(d);

          if (bounds) {
            if (!cloud.hasImage) {
              // update bounds if image mask not set
              cloudBounds(bounds, d);
            }
          } else {
            bounds = [{
              x: d.x + d.x0,
              y: d.y + d.y0
            }, {
              x: d.x + d.x1,
              y: d.y + d.y1
            }];
          } // Temporary hack


          d.x -= size[0] >> 1;
          d.y -= size[1] >> 1;
        }
      }

      cloud._tags = tags;
      cloud._bounds = bounds;
    }

    return cloud;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],
    var startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < 0.5 ? 1 : -1;
    var dxdy,
        t = -dt,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0;
          var last = void 0,
              x = (tag.y + tag.y0) * sw + (lx >> 5);

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          delete tag.sprite;
          return true;
        }
      }
    }

    return false;
  }

  cloud.createMask = function (img) {
    var can = document.createElement('canvas');
    var width = size[0],
        height = size[1]; //  width  height  0  cxt.getImageData 

    if (!width || !height) {
      return;
    }

    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext('2d');
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;

    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++) {
        var k = w32 * j + (i >> 5);
        var tmp = j * width + i << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m = flag ? 1 << 31 - i % 32 : 0;
        board[k] |= m;
      }
    }

    cloud.board = board;
    cloud.hasImage = true;
  };

  cloud.timeInterval = function (_) {
    timeInterval = _ == null ? Infinity : _;
  };

  cloud.words = function (_) {
    words = _;
  };

  cloud.size = function (_) {
    size = [+_[0], +_[1]];
  };

  cloud.font = function (_) {
    font = functor(_);
  };

  cloud.fontWeight = function (_) {
    fontWeight = functor(_);
  };

  cloud.rotate = function (_) {
    rotate = functor(_);
  };

  cloud.spiral = function (_) {
    spiral = spirals[_] || _;
  };

  cloud.fontSize = function (_) {
    fontSize = functor(_);
  };

  cloud.padding = function (_) {
    padding = functor(_);
  };

  cloud.random = function (_) {
    random = functor(_);
  };

  return cloud;
}

/***/ }),
/* 1063 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

g2_1.registerShape('point', 'word-cloud', {
  draw: function draw(cfg, group) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group.addShape('text', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, getTextAttrs(cfg)), {
        x: cx,
        y: cy
      })
    });
    var rotate = cfg.data.rotate;

    if (typeof rotate === 'number') {
      g2_1.Util.rotate(shape, rotate * Math.PI / 180);
    }

    return shape;
  }
});

function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: 'center',
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: 'alphabetic'
  };
}

/***/ }),
/* 1064 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.legend = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      sectorStyle = options.sectorStyle,
      color = options.color; // 

  chart.data(data);
  utils_1.flow(geometries_1.interval)(utils_1.deepAssign({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color
      }
    }
  }));
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      xField = options.xField;
  var geometry = utils_1.findGeometry(chart, 'interval'); // label  false  label

  if (label === false) {
    geometry.label(false);
  } else if (util_1.isObject(label)) {
    var callback = label.callback,
        fields = label.fields,
        cfg = tslib_1.__rest(label, ["callback", "fields"]);

    var offset = cfg.offset;
    var layout = cfg.layout; //  label  shape  'limit-in-shape' 
    //  label 

    if (offset === undefined || offset >= 0) {
      layout = layout ? util_1.isArray(layout) ? layout : [layout] : [];
      cfg.layout = util_1.filter(layout, function (v) {
        return v.type !== 'limit-in-shape';
      });
      cfg.layout.length || delete cfg.layout;
    }

    geometry.label({
      fields: fields || [xField],
      callback: callback,
      cfg: utils_1.transformLabel(cfg)
    });
  } else {
    utils_1.log(utils_1.LEVEL.WARN, label === null, 'the label option must be an Object.');
    geometry.label({
      fields: [xField]
    });
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend);
  }

  return params;
}

exports.legend = legend;
/**
 * coord 
 * @param params
 */

function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius,
      innerRadius = options.innerRadius;
  chart.coordinate({
    type: 'polar',
    cfg: {
      radius: radius,
      innerRadius: innerRadius
    }
  });
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  falsy 

  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  utils_1.flow(geometry, meta, label, coordinate, axis, legend, common_1.tooltip, common_1.interaction, common_1.animation, common_1.theme, common_1.annotation(), common_1.state)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1065 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.meta = void 0;

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var conversion_1 = __webpack_require__(500);

var basic_1 = __webpack_require__(505);

var compare_1 = __webpack_require__(1066);

var facet_1 = __webpack_require__(1067);

var dynamic_height_1 = __webpack_require__(1068);

var constant_1 = __webpack_require__(119);
/**
 *
 * geometry,
 * 1. interval.shape('funnel')
 * 2. 
 * 3. polypon
 * 4.  + list 
* /

/**
 * options 
 * @param params
 */


function defaultOptions(params) {
  var _a;

  var options = params.options;
  var compareField = options.compareField,
      xField = options.xField,
      yField = options.yField;
  var defaultOption = {
    minSize: 0,
    maxSize: 1,
    meta: (_a = {}, _a[constant_1.FUNNEL_MAPPING_VALUE] = {
      min: 0,
      max: 1,
      nice: false
    }, _a),
    label: compareField ? {
      fields: [xField, yField, compareField, constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION],
      style: {
        fill: '#fff',
        fontSize: 12
      },
      formatter: function formatter(datum) {
        return "" + datum[yField];
      }
    } : {
      fields: [xField, yField, constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION],
      offset: 0,
      position: 'middle',
      style: {
        fill: '#fff',
        fontSize: 12
      },
      formatter: function formatter(datum) {
        return datum[xField] + " " + datum[yField];
      }
    },
    tooltip: {
      showTitle: false,
      showMarkers: false,
      shared: false,
      title: xField,
      formatter: function formatter(datum) {
        return {
          name: datum[xField],
          value: datum[yField]
        };
      }
    },
    conversionTag: {
      offsetX: 10,
      offsetY: 0,
      style: {},
      // conversionTag 
      formatter: function formatter(datum) {
        return "\u8F6C\u5316\u7387: " + conversion_1.conversionTagFormatter.apply(void 0, datum[constant_1.FUNNEL_CONVERSATION]);
      }
    }
  };
  return utils_1.deepAssign({
    options: defaultOption
  }, params);
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var options = params.options;
  var compareField = options.compareField,
      dynamicHeight = options.dynamicHeight,
      seriesField = options.seriesField;

  if (seriesField) {
    return facet_1.facetFunnel(params);
  }

  if (compareField) {
    return compare_1.compareFunnel(params);
  }

  if (dynamicHeight) {
    return dynamic_height_1.dynamicHeightFunnel(params);
  }

  return basic_1.basicFunnel(params);
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}

exports.meta = meta;
/**
 * 
 * @param params
 */

function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend;

  if (legend === false) {
    chart.legend(false);
  } else {
    chart.legend(legend); // TODO FIX: legend-click 
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return utils_1.flow(defaultOptions, geometry, meta, axis, common_1.tooltip, common_1.interaction, legend, common_1.animation, common_1.theme, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1066 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareFunnel = void 0;

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var tooltip_1 = __webpack_require__(88);

var base_1 = __webpack_require__(89);

var constant_1 = __webpack_require__(119);

var common_1 = __webpack_require__(296);
/**
 * 
 * @param params
 */


function field(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var _b = options.data,
      data = _b === void 0 ? [] : _b,
      yField = options.yField; // 

  chart.data(data);
  chart.scale((_a = {}, _a[yField] = {
    sync: true
  }, _a));
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xField = options.xField,
      yField = options.yField,
      color = options.color,
      compareField = options.compareField,
      isTransposed = options.isTransposed,
      tooltip = options.tooltip,
      maxSize = options.maxSize,
      minSize = options.minSize,
      label = options.label;
  chart.facet('mirror', {
    fields: [compareField],
    // 
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    eachView: function eachView(view, facet) {
      var index = isTransposed ? facet.rowIndex : facet.columnIndex;

      if (!isTransposed) {
        view.coordinate({
          type: 'rect',
          actions: [['transpose'], ['scale', index === 0 ? -1 : 1, -1]]
        });
      }

      var formatterData = common_1.transformData(facet.data, data, {
        yField: yField,
        maxSize: maxSize,
        minSize: minSize
      });
      view.data(formatterData); // 

      var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField, compareField]),
          fields = _a.fields,
          formatter = _a.formatter;

      var defaultFacetLabel = isTransposed ? {
        offset: index === 0 ? 10 : -23,
        position: index === 0 ? 'bottom' : 'top'
      } : {
        offset: 10,
        position: 'left',
        style: {
          textAlign: index === 0 ? 'end' : 'start'
        }
      };
      base_1.geometry({
        chart: view,
        options: {
          type: 'interval',
          xField: xField,
          yField: constant_1.FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: util_1.isArray(fields) && fields.concat([constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION]),
          mapping: {
            shape: 'funnel',
            tooltip: formatter,
            color: color,
            style: {
              lineWidth: 1,
              stroke: '#fff'
            }
          },
          label: label === false ? false : utils_1.deepAssign({}, defaultFacetLabel, label)
        }
      });
    }
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var chart = params.chart,
      options = params.options;
  var conversionTag = options.conversionTag,
      isTransposed = options.isTransposed;
  chart.once('beforepaint', function () {
    chart.views.forEach(function (view, viewIndex) {
      var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
        var ratio = viewIndex === 0 ? -1 : 1;
        return utils_1.deepAssign({}, initLineOption, {
          start: [datumIndex - 0.5, datum[constant_1.FUNNEL_MAPPING_VALUE]],
          end: [datumIndex - 0.5, datum[constant_1.FUNNEL_MAPPING_VALUE] + 0.05],
          text: isTransposed ? {
            style: {
              textAlign: 'start'
            }
          } : {
            offsetX: conversionTag !== false ? ratio * conversionTag.offsetX : 0,
            style: {
              textAlign: viewIndex === 0 ? 'end' : 'start'
            }
          }
        });
      };

      common_1.conversionTagComponent(getLineCoordinate)(utils_1.deepAssign({}, {
        chart: view,
        options: options
      }));
    });
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function compareFunnel(params) {
  return utils_1.flow(field, geometry, conversionTag)(params);
}

exports.compareFunnel = compareFunnel;

/***/ }),
/* 1067 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.facetFunnel = void 0;

var utils_1 = __webpack_require__(16);

var basic_1 = __webpack_require__(505);
/**
 * 
 * @param params
 */


function field(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var _b = options.data,
      data = _b === void 0 ? [] : _b,
      yField = options.yField; // 

  chart.data(data);
  chart.scale((_a = {}, _a[yField] = {
    sync: true
  }, _a));
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var seriesField = options.seriesField,
      isTransposed = options.isTransposed;
  chart.facet('rect', {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    eachView: function eachView(view, facet) {
      basic_1.basicFunnel(utils_1.deepAssign({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function facetFunnel(params) {
  return utils_1.flow(field, geometry)(params);
}

exports.facetFunnel = facetFunnel;

/***/ }),
/* 1068 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dynamicHeightFunnel = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var constant_1 = __webpack_require__(119);

var base_1 = __webpack_require__(89);

var tooltip_1 = __webpack_require__(88);

var common_1 = __webpack_require__(296);
/**
 * 
 * @param params
 * :  yfield 2 2
 * :  g2 data ->  -> 
 *  -0.5 <= x <= 0.5, 0 <= y <= 1 
 * ,  x 
 *  data.length + 1  y = 4x - 1 [0.5, 1], [0.25, 0] data  y  y 
 */

/**
 * 
 * @param params
 */


function field(params) {
  var chart = params.chart,
      options = params.options;
  var _a = options.data,
      data = _a === void 0 ? [] : _a,
      yField = options.yField; // 

  var sum = util_1.reduce(data, function (total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max = util_1.maxBy(data, yField)[yField];
  var formatData = util_1.map(data, function (row, index) {
    //  xy  [, ]
    var x = [];
    var y = [];
    row[constant_1.FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum; // 

    if (index) {
      var preItemX = data[index - 1][constant_1.PLOYGON_X];
      var preItemY = data[index - 1][constant_1.PLOYGON_Y];
      x[0] = preItemX[3];
      y[0] = preItemY[3];
      x[1] = preItemX[2];
      y[1] = preItemY[2];
    } else {
      x[0] = -0.5;
      y[0] = 1;
      x[1] = 0.5;
      y[1] = 1;
    } // 


    y[2] = y[1] - row[constant_1.FUNNEL_TOTAL_PERCENT];
    x[2] = (y[2] + 1) / 4;
    y[3] = y[2];
    x[3] = -x[2]; // 

    row[constant_1.PLOYGON_X] = x;
    row[constant_1.PLOYGON_Y] = y;
    row[constant_1.FUNNEL_PERCENT] = (row[yField] || 0) / max;
    row[constant_1.FUNNEL_CONVERSATION] = [util_1.get(data, [index - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      color = options.color,
      tooltip = options.tooltip,
      label = options.label;

  var _a = tooltip_1.getTooltipMapping(tooltip, [xField, yField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  base_1.geometry({
    chart: chart,
    options: {
      type: 'polygon',
      xField: constant_1.PLOYGON_X,
      yField: constant_1.PLOYGON_Y,
      colorField: xField,
      tooltipFields: util_1.isArray(fields) && fields.concat([constant_1.FUNNEL_PERCENT, constant_1.FUNNEL_CONVERSATION]),
      label: label,
      mapping: {
        tooltip: formatter,
        color: color
      }
    }
  });
  return params;
}
/**
 * 
 * @param params
 */


function transpose(params) {
  var chart = params.chart,
      options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: 'rect',
    actions: isTransposed ? [['transpose'], ['reflect', 'x']] : []
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
    return tslib_1.__assign(tslib_1.__assign({}, initLineOption), {
      start: [datum[constant_1.PLOYGON_X][1], datum[constant_1.PLOYGON_Y][1]],
      end: [datum[constant_1.PLOYGON_X][1] + 0.05, datum[constant_1.PLOYGON_Y][1]]
    });
  };

  common_1.conversionTagComponent(getLineCoordinate)(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function dynamicHeightFunnel(params) {
  return utils_1.flow(field, geometry, transpose, conversionTag)(params);
}

exports.dynamicHeightFunnel = dynamicHeightFunnel;

/***/ }),
/* 1069 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var tslib_1 = __webpack_require__(1);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);

var utils_1 = __webpack_require__(16);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      lineStyle = options.lineStyle,
      color = options.color,
      pointOptions = options.point,
      areaOptions = options.area;
  chart.data(data); //   geometry

  var primary = utils_1.deepAssign({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color
      },
      point: pointOptions ? tslib_1.__assign({
        color: color
      }, pointOptions) : pointOptions,
      area: areaOptions ? tslib_1.__assign({
        color: color
      }, areaOptions) : areaOptions,
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  }); //  Geometry

  var second = utils_1.deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  geometries_1.line(primary);
  geometries_1.point(second);
  geometries_1.area(second);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * coord 
 * @param params
 */


function coord(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius;
  chart.coordinate('polar', {
    radius: radius
  });
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      xAxis = options.xAxis,
      yField = options.yField,
      yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var geometry = utils_1.findGeometry(chart, 'line');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: utils_1.transformLabel(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_1.flow(geometry, meta, common_1.theme, coord, axis, common_1.legend, common_1.tooltip, label, common_1.interaction, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1070 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

var radar_tooltip_action_1 = __webpack_require__(1071);

g2_1.registerAction('radar-tooltip', radar_tooltip_action_1.RadarTooltipAction);
g2_1.registerInteraction('radar-tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'radar-tooltip:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'radar-tooltip:hide'
  }]
});

/***/ }),
/* 1071 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RadarTooltipAction = exports.RadarTooltipController = void 0;

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var RadarTooltipController =
/** @class */
function (_super) {
  tslib_1.__extends(RadarTooltipController, _super);

  function RadarTooltipController() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Object.defineProperty(RadarTooltipController.prototype, "name", {
    get: function get() {
      return 'radar-tooltip';
    },
    enumerable: false,
    configurable: true
  });

  RadarTooltipController.prototype.getTooltipItems = function (point) {
    var _a = this.getTooltipCfg(),
        shared = _a.shared,
        cfgTitle = _a.title;

    var hintItems = _super.prototype.getTooltipItems.call(this, point);

    if (hintItems.length > 0) {
      var geometry_1 = this.view.geometries[0];
      var dataArray = geometry_1.dataArray;
      var title_1 = hintItems[0].name;
      var result_1 = [];
      dataArray.forEach(function (mappingData) {
        mappingData.forEach(function (d) {
          var items = g2_1.Util.getTooltipItems(d, geometry_1);
          var item = items[0];

          if (!shared && item && item.name === title_1) {
            var displayTitle = util_1.isNil(cfgTitle) ? title_1 : cfgTitle;
            result_1.push(tslib_1.__assign(tslib_1.__assign({}, item), {
              name: item.title,
              title: displayTitle
            }));
          } else if (shared && item) {
            var displayTitle = util_1.isNil(cfgTitle) ? item.name || title_1 : cfgTitle;
            result_1.push(tslib_1.__assign(tslib_1.__assign({}, item), {
              name: item.title,
              title: displayTitle
            }));
          }
        });
      });
      return result_1;
    }

    return [];
  };

  return RadarTooltipController;
}(g2_1.TooltipController);

exports.RadarTooltipController = RadarTooltipController;
g2_1.registerComponentController('radar-tooltip', RadarTooltipController);
/**
 *  tooltip  action
 */

var RadarTooltipAction =
/** @class */
function (_super) {
  tslib_1.__extends(RadarTooltipAction, _super);

  function RadarTooltipAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  RadarTooltipAction.prototype.init = function () {
    var view = this.context.view;
    view.removeInteraction('tooltip');
  };

  RadarTooltipAction.prototype.show = function () {
    var event = this.context.event;
    var controller = this.getTooltipController();
    controller.showTooltip({
      x: event.x,
      y: event.y
    });
  };

  RadarTooltipAction.prototype.hide = function () {
    var controller = this.getTooltipController();
    controller.hideTooltip();
  };

  RadarTooltipAction.prototype.getTooltipController = function () {
    var view = this.context.view;
    return view.getController('radar-tooltip');
  };

  return RadarTooltipAction;
}(g2_1.Action);

exports.RadarTooltipAction = RadarTooltipAction;

/***/ }),
/* 1072 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.statistic = void 0;

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(506);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      color = options.color,
      liquidStyle = options.liquidStyle,
      radius = options.radius,
      outline = options.outline,
      wave = options.wave;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data(utils_2.getLiquidData(percent));
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: 'type',
      yField: 'percent',
      // radius  columnWidthRatio 
      //   redius 
      widthRatio: radius,
      interval: {
        color: color,
        style: liquidStyle,
        shape: 'liquid-fill-gauge'
      }
    }
  });
  var ext = geometries_1.interval(p).ext;
  var geometry = ext.geometry; //  radius  shape 

  geometry.customInfo({
    radius: radius,
    outline: outline,
    wave: wave
  }); // 

  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
/**
 * 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var statistic = options.statistic,
      percent = options.percent,
      meta = options.meta; // 

  chart.getController('annotation').clear(true);

  if (statistic.content && !statistic.content.formatter) {
    var metaFormatter_1 = util_1.get(meta, ['percent', 'formatter']); // @ts-ignore

    statistic.content.formatter = function (_a) {
      var percent = _a.percent;
      return metaFormatter_1 ? metaFormatter_1(percent) : (percent * 100).toFixed(2) + "%";
    };
  }

  utils_1.renderStatistic(chart, {
    statistic: statistic,
    plotType: 'liquid'
  }, {
    percent: percent
  });

  if (updated) {
    chart.render(true);
  }

  return params;
}

exports.statistic = statistic;
/**
 * 
 * @param chart
 * @param options
 */

function adaptor(params) {
  // flow  G2 API
  return utils_1.flow(geometry, statistic, common_1.scale({}), common_1.animation, common_1.theme, common_1.interaction)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1073 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var matrix_1 = __webpack_require__(503);

var DURATION = 5000;
/**
 * 
 * @param min
 * @param max
 * @param factor
 */

function lerp(min, max, factor) {
  return min + (max - min) * factor;
}
/**
 *  attrs
 * @param cfg
 */


function getFillAttrs(cfg) {
  var attrs = tslib_1.__assign({
    opacity: 1
  }, cfg.style);

  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }

  return attrs;
}
/**
 *  attrs
 * @param cfg
 */


function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: '#fff',
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = util_1.mix({}, defaultAttrs, cfg.style);

  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }

  if (util_1.isNumber(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }

  return attrs;
}
/**
 * 
 * Using Bezier curves to fit sine wave.
 * There is 4 control points for each curve of wave,
 * which is at 1/4 wave length of the sine wave.
 *
 * The control points for a wave from (a) to (d) are a-b-c-d:
 *          c *----* d
 *     b *
 *       |
 * ... a * ..................
 *
 * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
 *
 * @param x          x position of the left-most point (a)
 * @param stage      0-3, stating which part of the wave it is
 * @param waveLength wave length of the sine wave
 * @param amplitude  wave amplitude
 * @return 
 */


function getWaterWavePositions(x, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];
  }

  if (stage === 1) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];
  }

  if (stage === 2) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];
  }

  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];
}
/**
 * 
 * @param radius          
 * @param waterLevel      
 * @param waveLength      
 * @param phase           
 * @param amplitude       
 * @param cx              x
 * @param cy              y
 * @return path            
 * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
 */


function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path = [];
  var _phase = phase; // map phase to [-Math.PI * 2, 0]

  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }

  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }

  _phase = _phase / Math.PI / 2 * waveLength;
  var left = cx - radius + _phase - radius * 2;
  /**
   * top-left corner as start point
   *
   * draws this point
   *  |
   * \|/
   *  ~~~~~~~~
   *  |      |
   *  +------+
   */

  path.push(['M', left, waterLevel]);
  /**
   * top wave
   *
   * ~~~~~~~~ <- draws this sine wave
   * |      |
   * +------+
   */

  var waveRight = 0;

  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);
    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);

    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  /**
   * top-right corner
   *
   *                       ~~~~~~~~
   * 3. draws this line -> |      | <- 1. draws this line
   *                       +------+
   *                          ^
   *                          |
   *                  2. draws this line
   */


  path.push(['L', waveRight + left, cy + radius]);
  path.push(['L', left, cy + radius]);
  path.push(['Z']); // path.push(['L', left, waterLevel]);

  return path;
}
/**
 * 
 * @param x           x
 * @param y           y
 * @param level        01
 * @param waveCount   
 * @param waveAttrs      
 * @param group       
 * @param clip        
 * @param radius      
 * @param waveLength  
 */


function addWaterWave(x, y, level, waveCount, waveAttrs, group, clip, radius, waveLength) {
  var fill = waveAttrs.fill,
      opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;

  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 0 : idx / (waveCount - 1);
    var wave = group.addShape('path', {
      name: "waterwave-path",
      attrs: {
        path: getWaterWavePath(radius, bbox.minY + height * level, waveLength, 0, width / 32, // 
        x, y),
        fill: fill,
        opacity: lerp(0.2, 0.9, factor) * opacity
      }
    });

    try {
      var matrix = matrix_1.transform([['t', waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({
        matrix: matrix
      }, {
        duration: lerp(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e) {
      // TODO off-screen canvas  canvas
      console.warn('off-screen group animate error!');
    }
  }
}

g2_1.registerShape('interval', 'liquid-fill-gauge', {
  draw: function draw(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var radio = customInfo.radius;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border,
        distance = outline.distance;
    var waveCount = wave.count,
        waveLength = wave.length; //  minX

    var minX = util_1.reduce(cfg.points, function (r, p) {
      return Math.min(r, p.x);
    }, Infinity);
    var center = this.parsePoint({
      x: cx,
      y: cy
    });
    var minXPoint = this.parsePoint({
      x: minX,
      y: cy
    });
    var halfWidth = center.x - minXPoint.x; //   radius 

    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs(cfg);
    var circleAttrs = getLineAttrs(cfg); // 1. 

    container.addShape('circle', {
      name: 'wrap',
      attrs: util_1.mix(circleAttrs, {
        x: center.x,
        y: center.y,
        r: radius,
        fill: 'transparent',
        lineWidth: border
      })
    }); // 2.  group

    var waves = container.addGroup({
      name: 'waves'
    }); // 3.  clip 

    var clipCircle = waves.setClip({
      type: 'circle',
      attrs: {
        x: center.x,
        y: center.y,
        r: radius - distance - border / 2
      }
    }); // 4. 

    addWaterWave(center.x, center.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipCircle, radius * 2, waveLength);
    return container;
  }
});

/***/ }),
/* 1074 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = void 0;

var tslib_1 = __webpack_require__(1);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var utils_2 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var histogram_1 = __webpack_require__(507);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      binField = options.binField,
      binNumber = options.binNumber,
      binWidth = options.binWidth,
      color = options.color,
      stackField = options.stackField,
      legend = options.legend,
      columnStyle = options.columnStyle; // 

  var plotData = histogram_1.binHistogram(data, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: 'range',
      yField: 'count',
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color,
        style: columnStyle
      }
    }
  });
  geometries_1.interval(p); // 

  if (legend && stackField) {
    chart.legend(stackField, legend);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis;
  return utils_2.flow(common_1.scale({
    range: xAxis,
    count: yAxis
  }))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis; //  false 

  if (xAxis === false) {
    chart.axis('range', false);
  } else {
    chart.axis('range', xAxis);
  }

  if (yAxis === false) {
    chart.axis('count', false);
  } else {
    chart.axis('count', yAxis);
  }

  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label;
  var geometry = utils_1.findGeometry(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    geometry.label({
      fields: ['count'],
      callback: callback,
      cfg: utils_2.transformLabel(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_2.flow(geometry, meta, axis, common_1.theme, label, common_1.tooltip, common_1.interaction, common_1.animation)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1075 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.tooltip = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var geometries_1 = __webpack_require__(48);

var utils_1 = __webpack_require__(16);

var constants_1 = __webpack_require__(508);

var utils_2 = __webpack_require__(509);

__webpack_require__(1076);
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xField = options.xField,
      yField = options.yField,
      total = options.total,
      leaderLine = options.leaderLine,
      columnWidthRatio = options.columnWidthRatio,
      waterfallStyle = options.waterfallStyle,
      risingFill = options.risingFill,
      fallingFill = options.fallingFill,
      color = options.color; // 

  chart.data(utils_2.transformData(data, xField, yField, total)); //  colorMapping

  var colorMapping = color || function (datum) {
    if (util_1.get(datum, [constants_1.IS_TOTAL])) {
      return util_1.get(total, ['style', 'fill'], '');
    }

    return util_1.get(datum, [constants_1.Y_FIELD, 1]) - util_1.get(datum, [constants_1.Y_FIELD, 0]) > 0 ? risingFill : fallingFill;
  };

  var p = utils_1.deepAssign({}, params, {
    options: {
      xField: xField,
      yField: constants_1.Y_FIELD,
      seriesField: xField,
      rawFields: [yField, constants_1.DIFF_FIELD, constants_1.IS_TOTAL, constants_1.Y_FIELD],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        shape: 'waterfall',
        color: colorMapping
      }
    }
  });
  var ext = geometries_1.interval(p).ext;
  var geometry = ext.geometry; //  waterfall leaderLineCfg  shape 

  geometry.customInfo({
    leaderLine: leaderLine
  });
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      meta = options.meta;
  var Y_FIELD_META = utils_1.deepAssign({}, {
    alias: yField
  }, util_1.get(meta, yField));
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a[constants_1.Y_FIELD] = yAxis, _a), utils_1.deepAssign({}, meta, (_b = {}, _b[constants_1.Y_FIELD] = Y_FIELD_META, _b[constants_1.DIFF_FIELD] = Y_FIELD_META, _b[constants_1.ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(constants_1.Y_FIELD, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(constants_1.Y_FIELD, yAxis);
  }

  return params;
}
/**
 * legend  todo  hover 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      total = options.total,
      risingFill = options.risingFill,
      fallingFill = options.fallingFill;

  if (legend === false) {
    chart.legend(false);
  } else {
    var items = [{
      name: '',
      value: 'increase',
      marker: {
        symbol: 'square',
        style: {
          r: 5,
          fill: risingFill
        }
      }
    }, {
      name: '',
      value: 'decrease',
      marker: {
        symbol: 'square',
        style: {
          r: 5,
          fill: fallingFill
        }
      }
    }];

    if (total) {
      items.push({
        name: total.label || '',
        value: 'total',
        marker: {
          symbol: 'square',
          style: utils_1.deepAssign({}, {
            r: 5
          }, util_1.get(total, 'style'))
        }
      });
    }

    chart.legend(utils_1.deepAssign({}, {
      custom: true,
      position: 'top',
      items: items
    }, legend));
    chart.removeInteraction('legend-filter');
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      labelMode = options.labelMode,
      xField = options.xField;
  var geometry = utils_1.findGeometry(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    geometry.label({
      fields: labelMode === 'absolute' ? [constants_1.ABSOLUTE_FIELD, xField] : [constants_1.DIFF_FIELD, xField],
      callback: callback,
      cfg: utils_1.transformLabel(cfg)
    });
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip,
      xField = options.xField,
      yField = options.yField;

  if (tooltip !== false) {
    chart.tooltip(tslib_1.__assign({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      // tooltip  y 
      fields: [yField]
    }, tooltip)); //  yField  tooltip 

    var geometry_1 = chart.geometries[0];
    (tooltip === null || tooltip === void 0 ? void 0 : tooltip.formatter) ? geometry_1.tooltip(xField + "*" + yField, tooltip.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }

  return params;
}

exports.tooltip = tooltip;
/**
 * 
 * @param params
 */

function adaptor(params) {
  return utils_1.flow(geometry, meta, axis, legend, tooltip, label, common_1.state, common_1.theme, common_1.interaction, common_1.animation, common_1.annotation())(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1076 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);
/**
 *  path
 * @param points
 */


function getRectPath(points) {
  var path = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];

    if (point) {
      var action = i === 0 ? 'M' : 'L';
      path.push([action, point.x, point.y]);
    }
  }

  var first = points[0];
  path.push(['L', first.x, first.y]);
  path.push(['z']);
  return path;
}
/**
 * 
 * @param cfg 
 */


function getFillAttrs(cfg) {
  return utils_1.deepAssign({}, cfg.defaultStyle, cfg.style, {
    fill: cfg.color
  });
}

g2_1.registerShape('interval', 'waterfall', {
  draw: function draw(cfg, container) {
    var customInfo = cfg.customInfo,
        points = cfg.points,
        nextPoints = cfg.nextPoints;
    var group = container.addGroup(); //  

    var rectPath = this.parsePath(getRectPath(points));
    var fillAttrs = getFillAttrs(cfg);
    group.addShape('path', {
      attrs: tslib_1.__assign(tslib_1.__assign({}, fillAttrs), {
        path: rectPath
      })
    }); //  

    var leaderLineCfg = util_1.get(customInfo, 'leaderLine');

    if (leaderLineCfg && nextPoints) {
      var linkPath = [['M', points[2].x, points[2].y], ['L', nextPoints[0].x, nextPoints[0].y]];

      if (points[2].y === nextPoints[1].y) {
        linkPath[1] = ['L', nextPoints[1].x, nextPoints[1].y];
      }

      linkPath = this.parsePath(linkPath);
      group.addShape('path', {
        attrs: tslib_1.__assign({
          path: linkPath
        }, leaderLineCfg.style || {})
      });
    }

    return group;
  }
});

/***/ }),
/* 1077 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.tooltip = exports.meta = exports.transformOptions = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var common_1 = __webpack_require__(34);

var utils_2 = __webpack_require__(16);

var util_2 = __webpack_require__(1078);
/**
 *  data.length === 1 
 * @param params
 * @returns params
 */


function transformOptions(options) {
  var _a = options.data,
      data = _a === void 0 ? [] : _a; //  data.length === 1 

  if (data.length === 1) {
    return utils_1.deepAssign({}, options, {
      meta: util_2.getMeta(options)
    });
  }

  return options;
}

exports.transformOptions = transformOptions;
/**
 * 
 * @param params
 */

function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      type = options.type,
      color = options.color,
      shape = options.shape,
      pointStyle = options.pointStyle,
      shapeField = options.shapeField,
      colorField = options.colorField,
      xField = options.xField,
      yField = options.yField,
      sizeField = options.sizeField;
  var size = options.size;
  var tooltip = options.tooltip;

  if (sizeField) {
    if (!size) {
      size = [2, 8];
    }

    if (util_1.isNumber(size)) {
      size = [size, size];
    }
  }

  if (tooltip && !tooltip.fields) {
    tooltip = tslib_1.__assign(tslib_1.__assign({}, tooltip), {
      fields: [xField, yField, colorField, sizeField, shapeField]
    });
  } // 


  chart.data(data); // geometry

  geometries_1.point(utils_1.deepAssign({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color,
        shape: shape,
        size: size,
        style: pointStyle
      },
      tooltip: tooltip
    }
  }));
  var geometry = utils_2.findGeometry(chart, 'point'); // 

  if (type) {
    geometry.adjust(type);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  var newOptions = options; //  data.length === 1 

  if (data.length === 1) {
    newOptions = transformOptions(utils_1.deepAssign({}, options, {
      meta: util_2.getMeta(options)
    }));
  }

  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(utils_1.deepAssign({}, params, {
    options: newOptions
  }));
}

exports.meta = meta;
/**
 * axis 
 * @param params
 */

function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField,
      shapeField = options.shapeField,
      sizeField = options.sizeField; // legend  shapeField  colorField 

  var showLegend = util_1.isBoolean(legend) ? legend : legend || !!(shapeField || colorField);

  if (showLegend) {
    chart.legend(colorField || shapeField, legend); // 

    if (sizeField) {
      chart.legend(sizeField, false);
    }
  } else {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var scatterGeometry = utils_2.findGeometry(chart, 'point'); // label  false,   label

  if (!label) {
    scatterGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = tslib_1.__rest(label, ["callback"]);

    scatterGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: utils_2.transformLabel(cfg)
    });
  }

  return params;
}
/**
 * annotation 
 * -  annotation: quadrant()
 * @param params
 */


function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];

  if (quadrant) {
    var _a = quadrant.xBaseline,
        xBaseline = _a === void 0 ? 0 : _a,
        _b = quadrant.yBaseline,
        yBaseline = _b === void 0 ? 0 : _b,
        labels_1 = quadrant.labels,
        regionStyle_1 = quadrant.regionStyle,
        lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = util_2.getQuadrantDefaultConfig(xBaseline, yBaseline); // 

    var quadrants = new Array(4).join(',').split(',');
    quadrants.forEach(function (_, index) {
      annotationOptions.push(tslib_1.__assign(tslib_1.__assign({
        type: 'region',
        top: false
      }, defaultConfig_1.regionStyle[index].position), {
        style: utils_1.deepAssign({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index])
      }), tslib_1.__assign({
        type: 'text',
        top: true
      }, utils_1.deepAssign({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
    }); // 

    annotationOptions.push({
      type: 'line',
      top: false,
      start: ['min', yBaseline],
      end: ['max', yBaseline],
      style: utils_1.deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: 'line',
      top: false,
      start: [xBaseline, 'min'],
      end: [xBaseline, 'max'],
      style: utils_1.deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }

  return utils_1.flow(common_1.annotation(annotationOptions))(params);
} // 


function regressionLine(params) {
  var options = params.options,
      chart = params.chart;
  var regressionLine = options.regressionLine;

  if (regressionLine) {
    var style_1 = regressionLine.style,
        _a = regressionLine.top,
        top_1 = _a === void 0 ? false : _a;
    var defaultStyle_1 = {
      stroke: '#9ba29a',
      lineWidth: 2,
      opacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function render(container, view) {
        var group = container.addGroup({
          id: chart.id + "-regression-line",
          name: 'regression-line-group'
        });
        var path = util_2.getPath({
          view: view,
          options: options
        });
        group.addShape('path', {
          name: 'regression-line',
          attrs: tslib_1.__assign(tslib_1.__assign({
            path: path
          }, defaultStyle_1), style_1)
        });
      }
    });
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;

  if (tooltip) {
    chart.tooltip(tooltip);
  } else if (tooltip === false) {
    chart.tooltip(false);
  }

  return params;
}

exports.tooltip = tooltip;
/**
 * 
 * @param chart
 * @param options
 */

function adaptor(params) {
  // flow  G2 API
  return utils_1.flow(geometry, meta, axis, legend, tooltip, label, common_1.interaction, scatterAnnotation, common_1.animation, common_1.theme, regressionLine)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1078 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMeta = exports.getPath = exports.getQuadrantDefaultConfig = void 0;

var tslib_1 = __webpack_require__(1);

var d3_regression_1 = __webpack_require__(510);

var util_1 = __webpack_require__(0);

var utils_1 = __webpack_require__(16);

var REGRESSION_MAP = {
  exp: d3_regression_1.regressionExp,
  linear: d3_regression_1.regressionLinear,
  loess: d3_regression_1.regressionLoess,
  log: d3_regression_1.regressionLog,
  poly: d3_regression_1.regressionPoly,
  pow: d3_regression_1.regressionPow,
  quad: d3_regression_1.regressionQuad
};
/**
 * 
 * @param {number} xBaseline
 * @param {number} yBaseline
 */

function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  // 
  var textOffset = 10; // 

  var defaultConfig = {
    regionStyle: [{
      position: {
        start: [xBaseline, 'max'],
        end: ['max', yBaseline]
      },
      style: {
        fill: '#d8d0c0',
        opacity: 0.4
      }
    }, {
      position: {
        start: ['min', 'max'],
        end: [xBaseline, yBaseline]
      },
      style: {
        fill: '#a3dda1',
        opacity: 0.4
      }
    }, {
      position: {
        start: ['min', yBaseline],
        end: [xBaseline, 'min']
      },
      style: {
        fill: '#d8d0c0',
        opacity: 0.4
      }
    }, {
      position: {
        start: [xBaseline, yBaseline],
        end: ['max', 'min']
      },
      style: {
        fill: '#a3dda1',
        opacity: 0.4
      }
    }],
    lineStyle: {
      stroke: '#9ba29a',
      lineWidth: 1
    },
    labelStyle: [{
      position: ['max', yBaseline],
      offsetX: -textOffset,
      offsetY: -textOffset,
      style: {
        textAlign: 'right',
        textBaseline: 'bottom',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['min', yBaseline],
      offsetX: textOffset,
      offsetY: -textOffset,
      style: {
        textAlign: 'left',
        textBaseline: 'bottom',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['min', yBaseline],
      offsetX: textOffset,
      offsetY: textOffset,
      style: {
        textAlign: 'left',
        textBaseline: 'top',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['max', yBaseline],
      offsetX: -textOffset,
      offsetY: textOffset,
      style: {
        textAlign: 'right',
        textBaseline: 'top',
        fontSize: 14,
        fill: '#ccc'
      }
    }]
  };
  return defaultConfig;
}

exports.getQuadrantDefaultConfig = getQuadrantDefaultConfig;

var splinePath = function splinePath(data, config) {
  var view = config.view,
      _a = config.options,
      xField = _a.xField,
      yField = _a.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data.map(function (d) {
    return view.getCoordinate().convert({
      x: xScaleView.scale(d[0]),
      y: yScaleView.scale(d[1])
    });
  });
  return utils_1.getSplinePath(pathData, false);
};

exports.getPath = function (config) {
  var options = config.options;
  var xField = options.xField,
      yField = options.yField,
      data = options.data,
      regressionLine = options.regressionLine;
  var _a = regressionLine.type,
      type = _a === void 0 ? 'linear' : _a,
      algorithm = regressionLine.algorithm;
  var pathData;

  if (algorithm) {
    pathData = util_1.isArray(algorithm) ? algorithm : algorithm(data);
  } else {
    var reg = REGRESSION_MAP[type]().x(function (d) {
      return d[xField];
    }).y(function (d) {
      return d[yField];
    });
    pathData = reg(data);
  }

  return splinePath(pathData, config);
}; // data.length === 1 meta: {min, max}


exports.getMeta = function (options) {
  var _a;

  var _b = options.meta,
      meta = _b === void 0 ? {} : _b,
      xField = options.xField,
      yField = options.yField,
      data = options.data;
  var xFieldValue = data[0][xField];
  var yFieldValue = data[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;

  var getValue = function getValue(field, type, axis) {
    var customValue = util_1.get(meta, [field, type]);

    if (util_1.isNumber(customValue)) {
      return customValue;
    }

    if (axis === 'x') {
      var rangeX = {
        min: xIsPositiveNumber ? 0 : xFieldValue * 2,
        max: xIsPositiveNumber ? xFieldValue * 2 : 0
      };
      return rangeX[type];
    }

    var rangeY = {
      min: yIsPositiveNumber ? 0 : yFieldValue * 2,
      max: yIsPositiveNumber ? yFieldValue * 2 : 0
    };
    return rangeY[type];
  };

  return tslib_1.__assign(tslib_1.__assign({}, meta), (_a = {}, _a[xField] = tslib_1.__assign(tslib_1.__assign({}, meta[xField]), {
    min: getValue(xField, 'min', 'x'),
    max: getValue(xField, 'max', 'x')
  }), _a[yField] = tslib_1.__assign(tslib_1.__assign({}, meta[yField]), {
    min: getValue(yField, 'min', 'y'),
    max: getValue(yField, 'max', 'y')
  }), _a));
};

/***/ }),
/* 1079 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _interpose = __webpack_require__(157);

var _ols3 = __webpack_require__(158);

var _points = __webpack_require__(98);

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      domain;

  function exponential(data) {
    var n = 0,
        Y = 0,
        YL = 0,
        XY = 0,
        XYL = 0,
        X2Y = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points.visitPoints)(data, x, y, function (dx, dy) {
      var ly = Math.log(dy),
          xy = dx * dy;
      ++n;
      Y += (dy - Y) / n;
      XY += (xy - XY) / n;
      X2Y += (dx * xy - X2Y) / n;
      YL += (dy * ly - YL) / n;
      XYL += (xy * ly - XYL) / n;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });

    var _ols = (0, _ols3.ols)(XY / Y, YL / Y, XYL / Y, X2Y / Y),
        _ols2 = (0, _slicedToArray2.default)(_ols, 2),
        a = _ols2[0],
        b = _ols2[1];

    a = Math.exp(a);

    var fn = function fn(x) {
      return a * Math.exp(b * x);
    },
        out = (0, _interpose.interpose)(xmin, xmax, fn);

    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, Y, fn);
    return out;
  }

  exponential.domain = function (arr) {
    return arguments.length ? (domain = arr, exponential) : domain;
  };

  exponential.x = function (fn) {
    return arguments.length ? (x = fn, exponential) : x;
  };

  exponential.y = function (fn) {
    return arguments.length ? (y = fn, exponential) : y;
  };

  return exponential;
}

/***/ }),
/* 1080 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.angle = angle;
exports.midpoint = midpoint;

// Returns the angle of a line in degrees.
function angle(line) {
  return Math.atan2(line[1][1] - line[0][1], line[1][0] - line[0][0]) * 180 / Math.PI;
} // Returns the midpoint of a line.


function midpoint(line) {
  return [(line[0][0] + line[1][0]) / 2, (line[0][1] + line[1][1]) / 2];
}

/***/ }),
/* 1081 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _median = __webpack_require__(1082);

var _ols3 = __webpack_require__(158);

var _points3 = __webpack_require__(98);

// Adapted from science.js by Jason Davies
// License: https://github.com/jasondavies/science.js/blob/master/LICENSE
// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js
// Adapted from vega-statistics by Jeffrey Heer
// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/loess.js
var maxiters = 2,
    epsilon = 1e-12;

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      bandwidth = .3;

  function loess(data) {
    var _points = (0, _points3.points)(data, x, y, true),
        _points2 = (0, _slicedToArray2.default)(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length,
        bw = Math.max(2, ~~(bandwidth * n)),
        yhat = new Float64Array(n),
        residuals = new Float64Array(n),
        robustWeights = new Float64Array(n).fill(1);

    for (var iter = -1; ++iter <= maxiters;) {
      var interval = [0, bw - 1];

      for (var i = 0; i < n; ++i) {
        var dx = xv[i],
            i0 = interval[0],
            i1 = interval[1],
            edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
        var W = 0,
            X = 0,
            Y = 0,
            XY = 0,
            X2 = 0,
            denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity

        for (var k = i0; k <= i1; ++k) {
          var xk = xv[k],
              yk = yv[k],
              w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
              xkw = xk * w;
          W += w;
          X += xkw;
          Y += yk * w;
          XY += yk * xkw;
          X2 += xk * xkw;
        } // Linear regression fit


        var _ols = (0, _ols3.ols)(X / W, Y / W, XY / W, X2 / W),
            _ols2 = (0, _slicedToArray2.default)(_ols, 2),
            a = _ols2[0],
            b = _ols2[1];

        yhat[i] = a + b * dx;
        residuals[i] = Math.abs(yv[i] - yhat[i]);
        updateInterval(xv, i + 1, interval);
      }

      if (iter === maxiters) {
        break;
      }

      var medianResidual = (0, _median.median)(residuals);
      if (Math.abs(medianResidual) < epsilon) break;

      for (var _i = 0, arg, _w; _i < n; ++_i) {
        arg = residuals[_i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations
        // Keeping weights tiny but non-zero prevents singularites

        robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
      }
    }

    return output(xv, yhat, ux, uy);
  }

  loess.bandwidth = function (bw) {
    return arguments.length ? (bandwidth = bw, loess) : bandwidth;
  };

  loess.x = function (fn) {
    return arguments.length ? (x = fn, loess) : x;
  };

  loess.y = function (fn) {
    return arguments.length ? (y = fn, loess) : y;
  };

  return loess;
} // Weighting kernel for local regression


function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
} // Advance sliding window interval of nearest neighbors


function updateInterval(xv, i, interval) {
  var val = xv[i],
      left = interval[0],
      right = interval[1] + 1;
  if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge
  // Step when distance is equal to ensure movement over duplicate x values

  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
} // Generate smoothed output points
// Average points with repeated x values


function output(xv, yhat, ux, uy) {
  var n = xv.length,
      out = [];
  var i = 0,
      cnt = 0,
      prev = [],
      v;

  for (; i < n; ++i) {
    v = xv[i] + ux;

    if (prev[0] === v) {
      // Average output values via online update
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      // Add new output point
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }

  prev[1] += uy;
  return out;
}

/***/ }),
/* 1082 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.median = median;

// Returns the medium value of an array of numbers.
function median(arr) {
  arr.sort(function (a, b) {
    return a - b;
  });
  var i = arr.length / 2;
  return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
}

/***/ }),
/* 1083 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _interpose = __webpack_require__(157);

var _ols3 = __webpack_require__(158);

var _points = __webpack_require__(98);

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      domain;

  function logarithmic(data) {
    var n = 0,
        X = 0,
        Y = 0,
        XY = 0,
        X2 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points.visitPoints)(data, x, y, function (dx, dy) {
      var lx = Math.log(dx);
      ++n;
      X += (lx - X) / n;
      Y += (dy - Y) / n;
      XY += (lx * dy - XY) / n;
      X2 += (lx * lx - X2) / n;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });

    var _ols = (0, _ols3.ols)(X, Y, XY, X2),
        _ols2 = (0, _slicedToArray2.default)(_ols, 2),
        intercept = _ols2[0],
        slope = _ols2[1],
        fn = function fn(x) {
      return slope * Math.log(x) + intercept;
    },
        out = (0, _interpose.interpose)(xmin, xmax, fn);

    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, Y, fn);
    return out;
  }

  logarithmic.domain = function (arr) {
    return arguments.length ? (domain = arr, logarithmic) : domain;
  };

  logarithmic.x = function (fn) {
    return arguments.length ? (x = fn, logarithmic) : x;
  };

  logarithmic.y = function (fn) {
    return arguments.length ? (y = fn, logarithmic) : y;
  };

  return logarithmic;
}

/***/ }),
/* 1084 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _interpose = __webpack_require__(157);

var _points3 = __webpack_require__(98);

var _linear = _interopRequireDefault(__webpack_require__(511));

var _quadratic = _interopRequireDefault(__webpack_require__(512));

// Adapted from regression-js by Tom Alexander
// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE
// ...with ideas from vega-statistics by Jeffrey Heer
// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/poly.js
// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE
function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      order = 3,
      domain;

  function polynomial(data) {
    // Use more efficient methods for lower orders
    if (order === 1) {
      var o = (0, _linear.default)().x(x).y(y).domain(domain)(data);
      o.coefficients = [o.b, o.a];
      delete o.a;
      delete o.b;
      return o;
    }

    if (order === 2) {
      var _o = (0, _quadratic.default)().x(x).y(y).domain(domain)(data);

      _o.coefficients = [_o.c, _o.b, _o.a];
      delete _o.a;
      delete _o.b;
      delete _o.c;
      return _o;
    }

    var _points = (0, _points3.points)(data, x, y),
        _points2 = (0, _slicedToArray2.default)(_points, 4),
        xv = _points2[0],
        yv = _points2[1],
        ux = _points2[2],
        uy = _points2[3],
        n = xv.length,
        lhs = [],
        rhs = [],
        k = order + 1;

    var Y = 0,
        n0 = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points3.visitPoints)(data, x, y, function (dx, dy) {
      ++n0;
      Y += (dy - Y) / n0;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });
    var i, j, l, v, c;

    for (i = 0; i < k; ++i) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i) * yv[l];
      }

      lhs.push(v);
      c = new Float64Array(k);

      for (j = 0; j < k; ++j) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i + j);
        }

        c[j] = v;
      }

      rhs.push(c);
    }

    rhs.push(lhs);

    var coef = gaussianElimination(rhs),
        fn = function fn(x) {
      x -= ux;
      var y = uy + coef[0] + coef[1] * x + coef[2] * x * x;

      for (i = 3; i < k; ++i) {
        y += coef[i] * Math.pow(x, i);
      }

      return y;
    },
        out = (0, _interpose.interpose)(xmin, xmax, fn);

    out.coefficients = uncenter(k, coef, -ux, uy);
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, Y, fn);
    return out;
  }

  polynomial.domain = function (arr) {
    return arguments.length ? (domain = arr, polynomial) : domain;
  };

  polynomial.x = function (fn) {
    return arguments.length ? (x = fn, polynomial) : x;
  };

  polynomial.y = function (fn) {
    return arguments.length ? (y = fn, polynomial) : y;
  };

  polynomial.order = function (n) {
    return arguments.length ? (order = n, polynomial) : order;
  };

  return polynomial;
}

function uncenter(k, a, x, y) {
  var z = Array(k);
  var i, j, v, c; // initialize to zero

  for (i = 0; i < k; ++i) {
    z[i] = 0;
  } // polynomial expansion


  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;

    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j; // binomial coefficent

      z[i - j] += v * Math.pow(x, j) * c;
    }
  } // bias term


  z[0] += y;
  return z;
} // Given an array for a two-dimensional matrix and the polynomial order,
// solve A * x = b using Gaussian elimination.


function gaussianElimination(matrix) {
  var n = matrix.length - 1,
      coef = [];
  var i, j, k, r, t;

  for (i = 0; i < n; ++i) {
    r = i; // max row

    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }

    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }

    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }

  for (j = n - 1; j >= 0; --j) {
    t = 0;

    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }

    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }

  return coef;
}

/***/ }),
/* 1085 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _determination = __webpack_require__(120);

var _interpose = __webpack_require__(157);

var _ols3 = __webpack_require__(158);

var _points = __webpack_require__(98);

function _default() {
  var x = function x(d) {
    return d[0];
  },
      y = function y(d) {
    return d[1];
  },
      domain;

  function power(data) {
    var n = 0,
        X = 0,
        Y = 0,
        XY = 0,
        X2 = 0,
        YS = 0,
        xmin = domain ? +domain[0] : Infinity,
        xmax = domain ? +domain[1] : -Infinity;
    (0, _points.visitPoints)(data, x, y, function (dx, dy) {
      var lx = Math.log(dx),
          ly = Math.log(dy);
      ++n;
      X += (lx - X) / n;
      Y += (ly - Y) / n;
      XY += (lx * ly - XY) / n;
      X2 += (lx * lx - X2) / n;
      YS += (dy - YS) / n;

      if (!domain) {
        if (dx < xmin) xmin = dx;
        if (dx > xmax) xmax = dx;
      }
    });

    var _ols = (0, _ols3.ols)(X, Y, XY, X2),
        _ols2 = (0, _slicedToArray2.default)(_ols, 2),
        a = _ols2[0],
        b = _ols2[1];

    a = Math.exp(a);

    var fn = function fn(x) {
      return a * Math.pow(x, b);
    },
        out = (0, _interpose.interpose)(xmin, xmax, fn);

    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = (0, _determination.determination)(data, x, y, YS, fn);
    return out;
  }

  power.domain = function (arr) {
    return arguments.length ? (domain = arr, power) : domain;
  };

  power.x = function (fn) {
    return arguments.length ? (x = fn, power) : x;
  };

  power.y = function (fn) {
    return arguments.length ? (y = fn, power) : y;
  };

  return power;
}

/***/ }),
/* 1086 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.meta = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var utils_1 = __webpack_require__(16);

var geometries_1 = __webpack_require__(48);

var utils_2 = __webpack_require__(513);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var bulletStyle = options.bulletStyle,
      targetField = options.targetField,
      rangeField = options.rangeField,
      measureField = options.measureField,
      xField = options.xField,
      color = options.color,
      layout = options.layout,
      size = options.size,
      label = options.label; // 

  var _a = utils_2.transformData(options),
      min = _a.min,
      max = _a.max,
      ds = _a.ds;

  chart.data(ds); // rangeGeometry

  var r = utils_1.deepAssign({}, params, {
    options: {
      xField: xField,
      yField: rangeField,
      seriesField: 'rKey',
      isStack: true,
      label: util_1.get(label, 'range'),
      interval: {
        color: util_1.get(color, 'range'),
        style: util_1.get(bulletStyle, 'range'),
        size: util_1.get(size, 'range')
      }
    }
  });
  geometries_1.interval(r); //  tooltip 

  chart.geometries[0].tooltip(false); // measureGeometry

  var m = utils_1.deepAssign({}, params, {
    options: {
      xField: xField,
      yField: measureField,
      seriesField: 'mKey',
      isStack: true,
      label: util_1.get(label, 'measure'),
      interval: {
        color: util_1.get(color, 'measure'),
        style: util_1.get(bulletStyle, 'measure'),
        size: util_1.get(size, 'measure')
      }
    }
  });
  geometries_1.interval(m); // targetGeometry

  var t = utils_1.deepAssign({}, params, {
    options: {
      xField: xField,
      yField: targetField,
      seriesField: 'tKey',
      label: util_1.get(label, 'target'),
      point: {
        color: util_1.get(color, 'target'),
        style: util_1.get(bulletStyle, 'target'),
        size: util_1.get(size, 'target') / 2,
        shape: layout === 'horizontal' ? 'line' : 'hyphen'
      }
    }
  });
  geometries_1.point(t); // 

  if (layout === 'horizontal') {
    chart.coordinate().transpose();
  }

  return tslib_1.__assign(tslib_1.__assign({}, params), {
    ext: {
      data: {
        min: min,
        max: max
      }
    }
  });
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options,
      ext = params.ext;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      targetField = options.targetField,
      rangeField = options.rangeField,
      measureField = options.measureField,
      xField = options.xField;
  var extData = ext.data;
  return utils_1.flow(common_1.scale((_a = {}, _a[xField] = xAxis, _a[measureField] = yAxis, _a), (_b = {}, _b[measureField] = {
    min: extData === null || extData === void 0 ? void 0 : extData.min,
    max: extData === null || extData === void 0 ? void 0 : extData.max
  }, _b[targetField] = {
    sync: "" + measureField
  }, _b[rangeField] = {
    sync: "" + measureField
  }, _b)))(params);
}

exports.meta = meta;
/**
 * axis 
 * @param params
 */

function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      measureField = options.measureField,
      rangeField = options.rangeField,
      targetField = options.targetField;
  chart.axis("" + rangeField, false);
  chart.axis("" + targetField, false); //  false 

  if (xAxis === false) {
    chart.axis("" + xField, false);
  } else {
    chart.axis("" + xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis("" + measureField, false);
  } else {
    chart.axis("" + measureField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend;
  chart.removeInteraction('legend-filter'); // @TODO  legend

  chart.legend(legend); //  color  legend, legend

  chart.legend('rKey', false);
  chart.legend('mKey', false);
  chart.legend('tKey', false);
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      measureField = options.measureField,
      targetField = options.targetField,
      rangeField = options.rangeField;
  var _a = chart.geometries,
      rangeGeometry = _a[0],
      measureGeometry = _a[1],
      targetGeometry = _a[2];

  if (util_1.get(label, 'range')) {
    rangeGeometry.label("" + rangeField, tslib_1.__assign({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, utils_1.transformLabel(label.range)));
  } else {
    rangeGeometry.label(false);
  }

  if (util_1.get(label, 'measure')) {
    measureGeometry.label("" + measureField, tslib_1.__assign({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, utils_1.transformLabel(label.measure)));
  } else {
    measureGeometry.label(false);
  }

  if (util_1.get(label, 'target')) {
    targetGeometry.label("" + targetField, tslib_1.__assign({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, utils_1.transformLabel(label.target)));
  } else {
    targetGeometry.label(false);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  utils_1.flow(geometry, meta, axis, legend, common_1.theme, label, common_1.tooltip, common_1.interaction, common_1.animation)(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1087 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flow = flow;

/**
 *  lodash.flow 
 * @param flows
 */
function flow() {
  var flows = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }

  return function (param) {
    return flows.reduce(function (result, f) {
      return f(result);
    }, param);
  };
}

/***/ }),
/* 1088 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pick = pick;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

/**
 *  lodash.pick 
 * @param obj
 * @param keys
 */
function pick(obj, keys) {
  var r = {};

  if (obj !== null && (0, _typeof2.default)(obj) === 'object') {
    keys.forEach(function (key) {
      var v = obj[key];

      if (v !== undefined) {
        r[key] = v;
      }
    });
  }

  return r;
}

/***/ }),
/* 1089 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.template = template;

var _util = __webpack_require__(0);

/**
 * 
 * template('hello, {name}', { name: 'AntV' }); // hello, AntV
 * @param string
 * @param options
 */
function template(source, data) {
  return (0, _util.reduce)( // @ts-ignore
  data, function (r, v, k) {
    return r.replace(new RegExp("{\\s*" + k + "\\s*}", 'g'), v);
  }, source);
}

/***/ }),
/* 1090 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invariant = invariant;
exports.log = log;
exports.LEVEL = void 0;

var _tslib = __webpack_require__(1);

/**
 * Simplified from https://github.com/zertosh/invariant.
 */
var LEVEL;
exports.LEVEL = LEVEL;

(function (LEVEL) {
  LEVEL["ERROR"] = "error";
  LEVEL["WARN"] = "warn";
  LEVEL["INFO"] = "log";
})(LEVEL || (exports.LEVEL = LEVEL = {}));

var BRAND = 'AntV/G2Plot';
/**
 * 
 * @param format
 * @param args
 */

function getMessage(format) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  var argIndex = 0;
  return BRAND + ": " + format.replace(/%s/g, function () {
    return "" + args[argIndex++];
  });
}
/**
 * invariant error
 * @param condition
 * @param format
 * @param args
 */


function invariant(condition, format) {
  var args = [];

  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }

  if (!condition) {
    var error = new Error(getMessage.apply(void 0, (0, _tslib.__spreadArrays)([format], args)));
    error.name = BRAND; // error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
}
/**
 * 
 * @param level
 * @param condition
 * @param format
 * @param args
 */


function log(level, condition, format) {
  var args = [];

  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }

  if (!condition) {
    console[level](getMessage.apply(void 0, (0, _tslib.__spreadArrays)([format], args)));
  }
}

/***/ }),
/* 1091 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getContainerSize = getContainerSize;

/**
 * get the element's bounding size
 * @param ele dom element
 * @returns the element width and height
 */
function getContainerSize(ele) {
  if (!ele) {
    return {
      width: 0,
      height: 0
    };
  }

  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}

/***/ }),
/* 1092 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findGeometry = findGeometry;
exports.getAllElements = getAllElements;

var _util = __webpack_require__(0);

/**
 *  Chart  type  geometry
 * @param chart
 * @param type
 */
function findGeometry(chart, type) {
  return chart.geometries.find(function (g) {
    return g.type === type;
  });
}
/**
 *  Chart   elements
 */


function getAllElements(chart) {
  return (0, _util.reduce)(chart.geometries, function (r, geometry) {
    return r.concat(geometry.elements);
  }, []);
}

/***/ }),
/* 1093 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformLabel = transformLabel;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

/**
 *  v1 label formatter
 * @param labelOptions
 */
function transformLabel(labelOptions) {
  if (!(0, _util.isType)(labelOptions, 'Object')) {
    return labelOptions;
  }

  var label = (0, _tslib.__assign)({}, labelOptions);

  if (label.formatter && !label.content) {
    label.content = label.formatter;
  }

  return label;
}

/***/ }),
/* 1094 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.points2Path = points2Path;
exports.catmullRom2bezier = catmullRom2bezier;
exports.getSplinePath = getSplinePath;
exports.smoothBezier = void 0;

var _matrixUtil = __webpack_require__(33);

function points2Path(points, isInCircle) {
  var path = [];

  if (points.length) {
    path.push(['M', points[0].x, points[0].y]);

    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {
      var item = points[i];
      path.push(['L', item.x, item.y]);
    }

    if (isInCircle) {
      path.push(['Z']);
    }
  }

  return path;
}
/**
 * @ignore
 * 
 */


var smoothBezier = function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min;
  var max;

  if (hasConstraint) {
    min = [Infinity, Infinity];
    max = [-Infinity, -Infinity];

    for (var i = 0, l = points.length; i < l; i++) {
      var point = points[i];
      min = _matrixUtil.vec2.min([0, 0], min, point);
      max = _matrixUtil.vec2.max([0, 0], max, point);
    }

    min = _matrixUtil.vec2.min([0, 0], min, constraint[0]);
    max = _matrixUtil.vec2.max([0, 0], max, constraint[1]);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (isLoop) {
      prevPoint = points[i ? i - 1 : len - 1];
      nextPoint = points[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(point);
        continue;
      } else {
        prevPoint = points[i - 1];
        nextPoint = points[i + 1];
      }
    }

    var v = [0, 0];
    v = _matrixUtil.vec2.sub(v, nextPoint, prevPoint);
    v = _matrixUtil.vec2.scale(v, v, smooth);

    var d0 = _matrixUtil.vec2.distance(point, prevPoint);

    var d1 = _matrixUtil.vec2.distance(point, nextPoint);

    var sum = d0 + d1;

    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }

    var v1 = _matrixUtil.vec2.scale([0, 0], v, -d0);

    var v2 = _matrixUtil.vec2.scale([0, 0], v, d1);

    var cp0 = _matrixUtil.vec2.add([0, 0], point, v1);

    var cp1 = _matrixUtil.vec2.add([0, 0], point, v2);

    if (hasConstraint) {
      cp0 = _matrixUtil.vec2.max([0, 0], cp0, min);
      cp0 = _matrixUtil.vec2.min([0, 0], cp0, max);
      cp1 = _matrixUtil.vec2.max([0, 0], cp1, min);
      cp1 = _matrixUtil.vec2.min([0, 0], cp1, max);
    }

    cps.push(cp0);
    cps.push(cp1);
  }

  if (isLoop) {
    cps.push(cps.shift());
  }

  return cps;
};
/**
 * @ignore
 * 
 */


exports.smoothBezier = smoothBezier;

function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];

  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }

  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;

  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }

  return d1;
}
/**
 * @ignore
 * 
 */


function getSplinePath(points, isInCircle, constaint) {
  var data = [];
  var first = points[0];
  var prePoint = null;

  if (points.length <= 2) {
    // 
    return points2Path(points, isInCircle);
  }

  for (var i = 0, len = points.length; i < len; i++) {
    var point = points[i];

    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {
      data.push(point.x);
      data.push(point.y);
      prePoint = point;
    }
  }

  var constraint = constaint || [// 
  [0, 0], [1, 1]];
  var splinePath = catmullRom2bezier(data, isInCircle, constraint);
  splinePath.unshift(['M', first.x, first.y]);
  return splinePath;
}

/***/ }),
/* 1095 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deepAssign = void 0;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var MAX_MIX_LEVEL = 5; // 

var toString = {}.toString; // 

var isType = function isType(value, type) {
  return toString.call(value) === '[object ' + type + ']';
};

var isArray = function isArray(value) {
  return isType(value, 'Array');
};

var isObjectLike = function isObjectLike(value) {
  /**
   * isObjectLike({}) => true
   * isObjectLike([1, 2, 3]) => true
   * isObjectLike(Function) => false
   */
  return (0, _typeof2.default)(value) === 'object' && value !== null;
};

var isPlainObject = function isPlainObject(value) {
  /**
   * isObjectLike(new Foo) => false
   * isObjectLike([1, 2, 3]) => false
   * isObjectLike({ x: 0, y: 0 }) => true
   */
  if (!isObjectLike(value) || !isType(value, 'Object')) {
    return false;
  }

  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
};
/***
 * @param {any} dist
 * @param {any} src
 * @param {number} level 
 * @param {number} maxLevel 
 */


var deep = function deep(dist, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;

  for (var key in src) {
    if (Object.prototype.hasOwnProperty.call(src, key)) {
      var value = src[key];

      if (!value) {
        // null  undefined 
        dist[key] = value;
      } else {
        if (isPlainObject(value)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }

          if (level < maxLevel) {
            deep(dist[key], value, level + 1, maxLevel);
          } else {
            // 
            dist[key] = src[key];
          }
        } else if (isArray(value)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value);
        } else {
          dist[key] = value;
        }
      }
    }
  }
};
/**
 * deepAssign  deepMix
 *  deepAssign  null undefined  source
 *  __tests__/unit/utils/deep-assign-spec.ts
 */


var deepAssign = function deepAssign(rst) {
  var args = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }

  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }

  return rst;
};

exports.deepAssign = deepAssign;

/***/ }),
/* 1096 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.kebabCase = kebabCase;

/**
 * @desc simple kebabCase like lodash
 *
 * kebabCase('fooBar'); => 'foo-bar'
 */
function kebabCase(word) {
  if (!word) {
    return word;
  }

  var result = word.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result.map(function (s) {
    return s.toLowerCase();
  }).join('-');
}

/***/ }),
/* 1097 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.measureTextWidth = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _context = __webpack_require__(1098);

/**
 * 
 * @param text 
 * @param font 
 */
var measureTextWidth = (0, _util.memoize)(function (text, font) {
  if (font === void 0) {
    font = {};
  }

  var fontSize = font.fontSize,
      _a = font.fontFamily,
      fontFamily = _a === void 0 ? 'sans-serif' : _a,
      fontWeight = font.fontWeight,
      fontStyle = font.fontStyle,
      fontVariant = font.fontVariant;
  var ctx = (0, _context.getCanvasContext)(); // @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/font

  ctx.font = [fontStyle, fontWeight, fontVariant, fontSize + "px", fontFamily].join(' ');
  var metrics = ctx.measureText((0, _util.isString)(text) ? text : '');
  return metrics.width;
}, function (text, font) {
  if (font === void 0) {
    font = {};
  }

  return (0, _tslib.__spreadArrays)([text], (0, _util.values)(font)).join('');
});
exports.measureTextWidth = measureTextWidth;

/***/ }),
/* 1098 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCanvasContext = getCanvasContext;
var ctx;
/**
 *  canvas context
 */

function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement('canvas').getContext('2d');
  }

  return ctx;
}

/***/ }),
/* 1099 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(1100);

Object.keys(_common).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _common[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _common[key];
    }
  });
});

var _tooltip = __webpack_require__(1101);

Object.keys(_tooltip).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _tooltip[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _tooltip[key];
    }
  });
});

var _state = __webpack_require__(1102);

Object.keys(_state).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _state[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _state[key];
    }
  });
});

var _attr = __webpack_require__(1103);

Object.keys(_attr).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _attr[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _attr[key];
    }
  });
});

var _statistic = __webpack_require__(1104);

Object.keys(_statistic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _statistic[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _statistic[key];
    }
  });
});

var _meta = __webpack_require__(1105);

Object.keys(_meta).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _meta[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _meta[key];
    }
  });
});

/***/ }),
/* 1100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 1106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Line = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(516);

__webpack_require__(1112);

var Line =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Line, _super);

  function Line() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'line';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Line.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *   
   */


  Line.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
          type: 'x'
        }
      },
      legend: {
        position: 'top-left'
      },
      isStack: false
    });
  };
  /**
   *   
   */


  Line.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Line;
}(_plot.Plot);

exports.Line = Line;

/***/ }),
/* 1107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.area = area;

var _tslib = __webpack_require__(1);

var _tooltip = __webpack_require__(90);

var _utils = __webpack_require__(12);

var _base = __webpack_require__(78);

/**
 * area geometry 
 * @param params
 */
function area(params) {
  var options = params.options;
  var area = options.area,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      smooth = options.smooth,
      tooltip = options.tooltip;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  return area ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'area',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        shape: smooth ? 'smooth' : 'area',
        tooltip: formatter
      }, area)
    }
  })) : params;
}

/***/ }),
/* 1108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.line = line;

var _util = __webpack_require__(0);

var _tooltip = __webpack_require__(90);

var _utils = __webpack_require__(12);

var _base = __webpack_require__(78);

/**
 * line 
 * @param params
 */
function line(params) {
  var options = params.options;
  var line = options.line,
      stepType = options.stepType,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      smooth = options.smooth,
      connectNulls = options.connectNulls,
      tooltip = options.tooltip;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  return line ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'line',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _util.deepMix)({
        shape: stepType || (smooth ? 'smooth' : 'line'),
        tooltip: formatter
      }, line),
      args: {
        connectNulls: connectNulls
      }
    }
  })) : params;
}

/***/ }),
/* 1109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = point;

var _tslib = __webpack_require__(1);

var _tooltip = __webpack_require__(90);

var _utils = __webpack_require__(12);

var _base = __webpack_require__(78);

/**
 * point 
 * @param params
 */
function point(params) {
  var options = params.options;
  var point = options.point,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      sizeField = options.sizeField,
      shapeField = options.shapeField,
      tooltip = options.tooltip;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField, sizeField, shapeField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return point ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'point',
      colorField: seriesField,
      shapeField: shapeField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, point)
    }
  })) : params;
}

/***/ }),
/* 1110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = interval;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _tooltip = __webpack_require__(90);

var _base = __webpack_require__(78);

/**
 *  adaptor
 * @param params
 */
function otherAdaptor(params) {
  var chart = params.chart,
      options = params.options,
      ext = params.ext;
  var seriesField = options.seriesField,
      isGroup = options.isGroup,
      isStack = options.isStack,
      marginRatio = options.marginRatio,
      widthRatio = options.widthRatio,
      groupField = options.groupField,
      theme = options.theme;
  /**
   * adjust
   */

  var adjust = [];

  if (seriesField) {
    // group
    if (isGroup) {
      adjust.push({
        type: 'dodge',
        dodgeBy: groupField || seriesField,
        marginRatio: marginRatio
      });
    } // stack


    if (isStack) {
      adjust.push({
        type: 'stack',
        marginRatio: marginRatio
      });
    }
  }

  if (adjust.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g.adjust(adjust);
  } // widthRatio


  if (!(0, _util.isNil)(widthRatio)) {
    chart.theme((0, _utils.deepAssign)({}, (0, _util.isObject)(theme) ? theme : (0, _g.getTheme)(theme), {
      // columWidthRatio  theme 
      columnWidthRatio: widthRatio
    }));
  }

  return params;
}

function interval(params) {
  var options = params.options;
  var xField = options.xField,
      yField = options.yField,
      interval = options.interval,
      seriesField = options.seriesField,
      tooltip = options.tooltip,
      minColumnWidth = options.minColumnWidth,
      maxColumnWidth = options.maxColumnWidth,
      columnBackground = options.columnBackground;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter; //  interval 


  var ext = (interval ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'interval',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, interval),
      args: {
        minColumnWidth: minColumnWidth,
        maxColumnWidth: maxColumnWidth,
        background: columnBackground
      }
    }
  })) : params).ext;
  return otherAdaptor((0, _tslib.__assign)((0, _tslib.__assign)({}, params), {
    ext: ext
  }));
}

/***/ }),
/* 1111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.edge = edge;

var _tslib = __webpack_require__(1);

var _tooltip = __webpack_require__(90);

var _utils = __webpack_require__(12);

var _base = __webpack_require__(78);

/**
 * edge 
 * @param params
 */
function edge(params) {
  var options = params.options;
  var edge = options.edge,
      xField = options.xField,
      yField = options.yField,
      seriesField = options.seriesField,
      tooltip = options.tooltip;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, seriesField]),
      fields = _a.fields,
      formatter = _a.formatter;

  return edge ? (0, _base.geometry)((0, _utils.deepAssign)({}, params, {
    options: {
      type: 'edge',
      colorField: seriesField,
      tooltipFields: fields,
      mapping: (0, _tslib.__assign)({
        tooltip: formatter
      }, edge)
    }
  })) : params;
}

/***/ }),
/* 1112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

var _markerActive = __webpack_require__(1113);

(0, _g.registerAction)('marker-active', _markerActive.MarkerActiveAction);
(0, _g.registerInteraction)('marker-active', {
  start: [{
    trigger: 'tooltip:show',
    action: 'marker-active:active'
  }]
});

/***/ }),
/* 1113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MarkerActiveAction = void 0;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _g = __webpack_require__(17);

var MarkerActiveAction =
/** @class */
function (_super) {
  (0, _tslib.__extends)(MarkerActiveAction, _super);

  function MarkerActiveAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MarkerActiveAction.prototype.active = function () {
    var view = this.getView();
    var evt = this.context.event;

    if (evt.data) {
      // items:  tooltip 
      var items_1 = evt.data.items;
      var points = view.geometries.filter(function (geom) {
        return geom.type === 'point';
      });
      (0, _util.each)(points, function (point) {
        (0, _util.each)(point.elements, function (element) {
          var active = (0, _util.findIndex)(items_1, function (item) {
            return item.data === element.data;
          }) !== -1; // @ts-ignore

          element.setState('active', active);
        });
      });
    }
  };

  MarkerActiveAction.prototype.getView = function () {
    return this.context.view;
  };

  return MarkerActiveAction;
}(_g.InteractionAction);

exports.MarkerActiveAction = MarkerActiveAction;

/***/ }),
/* 1114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Area = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _percent = __webpack_require__(122);

var _adaptor = __webpack_require__(1115);

var Area =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Area, _super);

  function Area() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'area';
    return _this;
  }
  /**
   *   
   */


  Area.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      tooltip: {
        shared: true,
        showMarkers: true,
        showCrosshairs: true,
        crosshairs: {
          type: 'x'
        }
      },
      isStack: true,
      // 
      line: {},
      legend: {
        position: 'top-left'
      }
    });
  };
  /**
   * @override
   * @param data
   */


  Area.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        isPercent = _a.isPercent,
        xField = _a.xField,
        yField = _a.yField;
    this.chart.changeData((0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent));
  };
  /**
   *   
   */


  Area.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Area;
}(_plot.Plot);

exports.Area = Area;

/***/ }),
/* 1115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _percent = __webpack_require__(122);

var _adaptor = __webpack_require__(516);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      areaStyle = options.areaStyle,
      color = options.color,
      pointMapping = options.point,
      lineMapping = options.line,
      isPercent = options.isPercent,
      xField = options.xField,
      yField = options.yField,
      tooltip = options.tooltip,
      seriesField = options.seriesField;
  var chartData = (0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent);
  chart.data(chartData); //  % , 

  var tooltipOptions = isPercent ? (0, _tslib.__assign)({
    formatter: function formatter(datum) {
      return {
        name: datum[seriesField] || datum[xField],
        value: (Number(datum[yField]) * 100).toFixed(2) + '%'
      };
    }
  }, tooltip) : tooltip;
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      area: {
        color: color,
        style: areaStyle
      },
      //  tooltip 
      // 
      line: lineMapping && (0, _tslib.__assign)({
        color: color
      }, lineMapping),
      point: pointMapping && (0, _tslib.__assign)({
        color: color
      }, pointMapping),
      tooltip: tooltipOptions,
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  }); // area geometry 

  (0, _geometries.area)(primary);
  (0, _geometries.line)(second);
  (0, _geometries.point)(second);
  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var areaGeometry = (0, _utils.findGeometry)(chart, 'area'); // label  false,   label

  if (!label) {
    areaGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _tslib.__assign)({
        layout: [{
          type: 'limit-in-plot'
        }, {
          type: 'path-adjust-position'
        }, {
          type: 'point-adjust-position'
        }, {
          type: 'limit-in-plot',
          cfg: {
            action: 'hide'
          }
        }]
      }, (0, _utils.transformLabel)(cfg))
    });
  }

  return params;
}
/**
 *  adjust
 * @param params
 */


function adjust(params) {
  var chart = params.chart,
      options = params.options;
  var isStack = options.isStack,
      isPercent = options.isPercent;

  if (isPercent || isStack) {
    (0, _util.each)(chart.geometries, function (g) {
      g.adjust('stack');
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, _adaptor.meta, adjust, _common.theme, _adaptor.axis, _adaptor.legend, _common.tooltip, label, _common.slider, (0, _common.annotation)(), _common.interaction, _common.animation, _common.limitInPlot)(params);
}

/***/ }),
/* 1116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Column = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _percent = __webpack_require__(122);

var _adaptor = __webpack_require__(519);

/**
 * 
 */
var Column =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Column, _super);

  function Column() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'column';
    return _this;
  }
  /**
   * @override
   */


  Column.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        yField = _a.yField,
        xField = _a.xField,
        isPercent = _a.isPercent;
    this.chart.changeData((0, _percent.getDataWhetherPecentage)(data, yField, xField, yField, isPercent));
  };
  /**
   *   
   */


  Column.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      columnWidthRatio: 0.6,
      marginRatio: 1 / 32,
      tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Column.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Column;
}(_plot.Plot);

exports.Column = Column;

/***/ }),
/* 1117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionTag = conversionTag;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _g = __webpack_require__(17);

var _utils = __webpack_require__(12);

var _conversion = __webpack_require__(520);

function getConversionTagOptionsWithDefaults(options, horizontal) {
  return (0, _utils.deepAssign)({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: 'rgba(0, 0, 0, 0.05)'
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: 'rgba(0, 0, 0, 0.85)',
        textAlign: 'center',
        textBaseline: 'middle'
      },
      formatter: _conversion.conversionTagFormatter
    }
  }, options);
}

function parsePoints(coordinate, element) {
  // @ts-ignore
  return (0, _util.map)(element.getModel().points, function (point) {
    return coordinate.convertPoint(point);
  });
}

function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view,
      geometry = config.geometry,
      group = config.group,
      options = config.options,
      horizontal = config.horizontal;
  var offset = options.offset,
      size = options.size,
      arrow = options.arrow;
  var coordinate = view.getCoordinate();
  var pointPrev = parsePoints(coordinate, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate, elemNext)[horizontal ? 0 : 3];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;

  if (typeof arrow === 'boolean') {
    return;
  }

  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points;

  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      // 
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points = [[pointPrev.x + spacing, pointPrev.y - offset], [pointPrev.x + spacing, pointPrev.y - offset - size], [pointNext.x - spacing, pointNext.y - offset - size / 2]];
    } else {
      // 
      points = [[pointPrev.x + spacing, pointPrev.y - offset], [pointPrev.x + spacing, pointPrev.y - offset - size], [pointNext.x - spacing - headSize, pointNext.y - offset - size], [pointNext.x - spacing, pointNext.y - offset - size / 2], [pointNext.x - spacing - headSize, pointNext.y - offset]];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      // 
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points = [[pointPrev.x + offset, pointPrev.y + spacing], [pointPrev.x + offset + size, pointPrev.y + spacing], [pointNext.x + offset + size / 2, pointNext.y - spacing]];
    } else {
      // 
      points = [[pointPrev.x + offset, pointPrev.y + spacing], [pointPrev.x + offset + size, pointPrev.y + spacing], [pointNext.x + offset + size, pointNext.y - spacing - headSize], [pointNext.x + offset + size / 2, pointNext.y - spacing], [pointNext.x + offset, pointNext.y - spacing - headSize]];
    }
  }

  group.addShape('polygon', {
    id: view.id + "-conversion-tag-arrow-" + geometry.getElementId(elemPrev.getModel().mappingData),
    name: 'conversion-tag-arrow',
    attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, arrow.style || {}), {
      points: points
    })
  });
}

function renderTextTag(config, elemPrev, elemNext) {
  var _a, _b, _c;

  var view = config.view,
      geometry = config.geometry,
      group = config.group,
      options = config.options,
      field = config.field,
      horizontal = config.horizontal;
  var offset = options.offset,
      size = options.size;

  if (typeof options.text === 'boolean') {
    return;
  }

  var coordinate = view.getCoordinate();
  var text = ((_a = options.text) === null || _a === void 0 ? void 0 : _a.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field], elemNext.getData()[field]));
  var pointPrev = parsePoints(coordinate, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate, elemNext)[horizontal ? 0 : 3];
  var textShape = group.addShape('text', {
    id: view.id + "-conversion-tag-text-" + geometry.getElementId(elemPrev.getModel().mappingData),
    name: 'conversion-tag-text',
    attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), {
      text: text,
      x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size / 2,
      y: horizontal ? pointPrev.y - offset - size / 2 : (pointPrev.y + pointNext.y) / 2
    })
  });

  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;

    if (textWidth > totalWidth) {
      var cWidth = textWidth / text.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = text.slice(0, cEnd) + "...";
      textShape.attr('text', textAdjusted);
    }
  }
}

function renderTag(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
/**
 *  adaptor/
 * @param field 
 * @param horizontal 
 * @param disabled 
 */


function conversionTag(field, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }

  if (disabled === void 0) {
    disabled = false;
  }

  return function (params) {
    var options = params.options,
        chart = params.chart;
    var conversionTag = options.conversionTag,
        theme = options.theme;

    if (conversionTag && !disabled) {
      //  1/3
      chart.theme((0, _utils.deepAssign)({}, (0, _util.isObject)(theme) ? theme : (0, _g.getTheme)(theme), {
        columnWidthRatio: 1 / 3
      })); //   shape annotation 

      chart.annotation().shape({
        render: function render(container, view) {
          var group = container.addGroup({
            id: chart.id + "-conversion-tag-group",
            name: 'conversion-tag-group'
          });
          var interval = (0, _util.find)(chart.geometries, function (geom) {
            return geom.type === 'interval';
          });
          var config = {
            view: view,
            geometry: interval,
            group: group,
            field: field,
            horizontal: horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag, horizontal)
          };
          var elements = horizontal ? interval.elements : interval.elements.slice().reverse();
          (0, _util.each)(elements, function (elem, idx) {
            if (idx > 0) {
              renderTag(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }

    return params;
  };
}

/***/ }),
/* 1118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.connectedArea = connectedArea;

var _g = __webpack_require__(17);

var INTERACTION_MAP = {
  hover: '__interval-connected-area-hover__',
  click: '__interval-connected-area-click__'
};
/** hover  */

(0, _g.registerInteraction)(INTERACTION_MAP.hover, {
  start: [{
    trigger: "interval:mouseenter",
    action: ['element-highlight-by-color:highlight', 'element-link-by-color:link']
  }],
  end: [{
    trigger: 'interval:mouseleave',
    action: ['element-highlight-by-color:reset', 'element-link-by-color:unlink']
  }]
});
/** click  */

(0, _g.registerInteraction)(INTERACTION_MAP.click, {
  start: [{
    trigger: "interval:click",
    action: ['element-highlight-by-color:clear', 'element-highlight-by-color:highlight', 'element-link-by-color:clear', 'element-link-by-color:unlink', 'element-link-by-color:link']
  }],
  end: [{
    trigger: 'document:mousedown',
    action: ['element-highlight-by-color:clear', 'element-link-by-color:clear']
  }]
});
/**
 *  adaptor/
 * @param disable
 */

function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }

  return function (params) {
    var chart = params.chart,
        options = params.options;
    var connectedArea = options.connectedArea;

    var clear = function clear() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };

    if (!disable && connectedArea) {
      var trigger = connectedArea.trigger || 'hover';
      clear();
      chart.interaction(INTERACTION_MAP[trigger]);
    } else {
      clear();
    }

    return params;
  };
}

/***/ }),
/* 1119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bar = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _percent = __webpack_require__(122);

var _adaptor = __webpack_require__(1120);

/**
 * 
 */
var Bar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Bar, _super);

  function Bar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'bar';
    return _this;
  }
  /**
   * @override
   */


  Bar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        xField = _a.xField,
        yField = _a.yField,
        isPercent = _a.isPercent;
    this.chart.changeData((0, _percent.getDataWhetherPecentage)(data, xField, yField, xField, isPercent));
  };
  /**
   *   
   */


  Bar.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      barWidthRatio: 0.6,
      marginRatio: 1 / 32,
      tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Bar.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Bar;
}(_plot.Plot);

exports.Bar = Bar;

/***/ }),
/* 1120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _adaptor = __webpack_require__(519);

/**
 * 
 * @param params
 */
function adaptor(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      barStyle = options.barStyle,
      barWidthRatio = options.barWidthRatio,
      label = options.label,
      data = options.data,
      seriesField = options.seriesField,
      isStack = options.isStack,
      minBarWidth = options.minBarWidth,
      maxBarWidth = options.maxBarWidth; // label of bar charts default position is left, if plot has label

  if (label && !label.position) {
    label.position = 'left'; //  label layout  layout  position  layout

    if (!label.layout) {
      label.layout = [{
        type: 'interval-adjust-position'
      }, {
        type: 'interval-hide-overlap'
      }, {
        type: 'adjust-color'
      }, {
        type: 'limit-in-plot',
        cfg: {
          action: 'hide'
        }
      }];
    }
  } //  legend 


  var legend = options.legend;

  if (seriesField) {
    if (legend !== false) {
      legend = (0, _tslib.__assign)({
        position: isStack ? 'top-left' : 'right-top',
        reversed: isStack ? false : true
      }, legend || {});
    }
  } else {
    legend = false;
  } // @ts-ignore 


  params.options.legend = legend; //  tooltip 

  var tooltip = options.tooltip;

  if (seriesField) {
    if (tooltip !== false) {
      tooltip = (0, _tslib.__assign)({
        reversed: isStack ? false : true
      }, tooltip || {});
    }
  } // @ts-ignore 


  params.options.tooltip = tooltip; // transpose column to bar

  chart.coordinate().transpose();
  return (0, _adaptor.adaptor)({
    chart: chart,
    options: (0, _tslib.__assign)((0, _tslib.__assign)({}, options), {
      label: label,
      // switch xField and yField
      xField: yField,
      yField: xField,
      xAxis: yAxis,
      yAxis: xAxis,
      // rename attrs as column
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: options.barBackground,
      // bar 
      data: data ? data.slice().reverse() : data
    })
  }, true);
}

/***/ }),
/* 1121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pie = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1122);

var _contants = __webpack_require__(521);

var _utils = __webpack_require__(522);

__webpack_require__(1123);

var Pie =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Pie, _super);

  function Pie() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'pie';
    return _this;
  }
  /**
   *   
   * @static 
   */


  Pie.getDefaultOptions = function () {
    return _contants.DEFAULT_OPTIONS;
  };
  /**
   * 
   * @param data
   */


  Pie.prototype.changeData = function (data) {
    var prevOptions = this.options;
    var angleField = this.options.angleField;
    var prevData = (0, _utils.processIllegalData)(prevOptions.data, angleField);
    var curData = (0, _utils.processIllegalData)(data, angleField); //  0

    if ((0, _utils.isAllZero)(prevData, angleField) || (0, _utils.isAllZero)(curData, angleField)) {
      this.update({
        data: data
      });
    } else {
      this.updateOption({
        data: data
      });
      this.chart.data(curData); // todo  G2  afterrender  annotations

      (0, _adaptor.pieAnnotation)({
        chart: this.chart,
        options: this.options
      });
      this.chart.render(true);
    }
  };
  /**
   *   ,  base 
   */


  Pie.prototype.getDefaultOptions = function () {
    return Pie.getDefaultOptions();
  };
  /**
   *   
   */


  Pie.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Pie;
}(_plot.Plot);

exports.Pie = Pie;

/***/ }),
/* 1122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pieAnnotation = pieAnnotation;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _utils = __webpack_require__(12);

var _contants = __webpack_require__(521);

var _utils2 = __webpack_require__(522);

/**
 * 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      angleField = options.angleField,
      colorField = options.colorField,
      color = options.color,
      pieStyle = options.pieStyle; // 

  var processData = (0, _utils2.processIllegalData)(data, angleField);

  if ((0, _utils2.isAllZero)(processData, angleField)) {
    //  0  position 
    var percentageField_1 = '$$percentage$$';
    processData = processData.map(function (d) {
      var _a;

      return (0, _tslib.__assign)((0, _tslib.__assign)({}, d), (_a = {}, _a[percentageField_1] = 1 / processData.length, _a));
    });
    chart.data(processData);
    var p = (0, _utils.deepAssign)({}, params, {
      options: {
        xField: '1',
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    (0, _geometries.interval)(p); // all zero 

    chart.geometries[0].tooltip(colorField + "*" + angleField);
  } else {
    chart.data(processData);
    var p = (0, _utils.deepAssign)({}, params, {
      options: {
        xField: '1',
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color,
          style: pieStyle
        },
        args: {
          zIndexReversed: true
        }
      }
    });
    (0, _geometries.interval)(p);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var meta = options.meta,
      colorField = options.colorField; // meta  scale 

  var scales = (0, _utils.deepAssign)({}, meta);
  chart.scale(scales, (_a = {}, _a[colorField] = {
    type: 'cat'
  }, _a));
  return params;
}
/**
 * coord 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius,
      innerRadius = options.innerRadius,
      startAngle = options.startAngle,
      endAngle = options.endAngle;
  chart.coordinate({
    type: 'theta',
    cfg: {
      radius: radius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    }
  });
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      colorField = options.colorField,
      angleField = options.angleField;
  var geometry = chart.geometries[0]; // label  false,   label

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    var labelCfg = (0, _utils.transformLabel)(cfg); //   label content 

    if (labelCfg.content) {
      var content_1 = labelCfg.content;

      labelCfg.content = function (data, dataum, index) {
        var name = data[colorField];
        var value = data[angleField]; // dymatic get scale, scale is ready this time

        var angleScale = chart.getScaleByField(angleField);
        var percent = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value);
        return (0, _util.isFunction)(content_1) ? // append pecent (number) to data, users can get origin data from `dataum._origin`
        content_1((0, _tslib.__assign)((0, _tslib.__assign)({}, data), {
          percent: percent
        }), dataum, index) : (0, _util.isString)(content_1) ? (0, _utils.template)(content_1, {
          value: value,
          name: name,
          // percentage (string), default keep 2
          percentage: (0, _util.isNumber)(percent) && !(0, _util.isNil)(value) ? (percent * 100).toFixed(2) + "%" : null
        }) : content_1;
      };
    }

    var LABEL_LAYOUT_TYPE_MAP = {
      inner: '',
      outer: 'pie-outer',
      spider: 'pie-spider'
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : 'pie-outer';
    var labelLayoutCfg = labelCfg.layout ? !(0, _util.isArray)(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{
      type: labelLayoutType
    }] : []).concat(labelLayoutCfg);
    geometry.label({
      // fix: could not create scale, when field is undefinedattributes  fields  scale
      fields: colorField ? [angleField, colorField] : [angleField],
      callback: callback,
      cfg: (0, _tslib.__assign)((0, _tslib.__assign)({}, labelCfg), {
        offset: (0, _utils2.adaptOffset)(labelCfg.type, labelCfg.offset),
        type: 'pie'
      })
    });
  }

  return params;
}
/**
 * statistic 
 * @param params
 */


function pieAnnotation(params) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      statistic = options.statistic,
      angleField = options.angleField,
      colorField = options.colorField,
      meta = options.meta; // 

  chart.getController('annotation').clear(true); //  annotations

  (0, _utils.flow)((0, _common.annotation)())(params);
  /**   */

  if (innerRadius && statistic) {
    var _a = (0, _utils.deepAssign)({}, _contants.DEFAULT_OPTIONS.statistic, statistic),
        title = _a.title,
        content = _a.content;

    if (title !== false) {
      title = (0, _utils.deepAssign)({}, {
        formatter: function formatter(datum) {
          return datum ? datum[colorField] : '';
        }
      }, title);
    }

    if (content !== false) {
      content = (0, _utils.deepAssign)({}, {
        formatter: function formatter(datum, data) {
          var metaFormatter = (0, _util.get)(meta, [angleField, 'formatter']);
          var dataValue = datum ? datum[angleField] : (0, _utils2.getTotalValue)(data, angleField);
          return metaFormatter ? metaFormatter(dataValue) : dataValue;
        }
      }, content);
    }

    (0, _utils.renderStatistic)(chart, {
      statistic: {
        title: title,
        content: content
      },
      plotType: 'pie'
    });
  }

  return params;
}
/**
 *  tooltip  tooltip.shared  false
 * @param params
 */


function adaptorTooltipOptions(params) {
  return (0, _util.get)(params, ['options', 'tooltip']) !== false ? (0, _utils.deepAssign)({}, params, {
    options: {
      tooltip: {
        shared: false
      }
    }
  }) : params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, _common.theme, coordinate, _common.legend, function (args) {
    return (0, _common.tooltip)(adaptorTooltipOptions(args));
  }, label, _common.state,
  /**   */
  pieAnnotation, _common.interaction, _common.animation)(params);
}

/***/ }),
/* 1123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

var _pieLegendAction = __webpack_require__(1124);

var _pieStatisticAction = __webpack_require__(1125);

(0, _g.registerAction)('pie-statistic', _pieStatisticAction.StatisticAction);
(0, _g.registerInteraction)('pie-statistic-active', {
  start: [{
    trigger: 'element:mouseenter',
    action: 'pie-statistic:change'
  }],
  end: [{
    trigger: 'element:mouseleave',
    action: 'pie-statistic:reset'
  }]
});
(0, _g.registerAction)('pie-legend', _pieLegendAction.PieLegendAction);
(0, _g.registerInteraction)('pie-legend-active', {
  start: [{
    trigger: 'legend-item:mouseenter',
    action: 'pie-legend:active'
  }],
  end: [{
    trigger: 'legend-item:mouseleave',
    action: 'pie-legend:reset'
  }]
});

/***/ }),
/* 1124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PieLegendAction = void 0;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _matrix = __webpack_require__(523);

/**
 *   action
 */
var PieLegendAction =
/** @class */
function (_super) {
  (0, _tslib.__extends)(PieLegendAction, _super);

  function PieLegendAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  /**
   * 
   */


  PieLegendAction.prototype.getActiveElements = function () {
    var delegateObject = _g.Util.getDelegationObject(this.context);

    if (delegateObject) {
      var view = this.context.view;
      var component = delegateObject.component,
          item_1 = delegateObject.item;
      var field_1 = component.get('field');

      if (field_1) {
        var elements = view.geometries[0].elements;
        return elements.filter(function (ele) {
          return ele.getModel().data[field_1] === item_1.value;
        });
      }
    }

    return [];
  };
  /**
   * 
   */


  PieLegendAction.prototype.getActiveElementLabels = function () {
    var view = this.context.view;
    var elements = this.getActiveElements();
    var labels = view.geometries[0].labelsContainer.getChildren();
    return labels.filter(function (label) {
      return elements.find(function (ele) {
        return (0, _util.isEqual)(ele.getData(), label.get('data'));
      });
    });
  };

  PieLegendAction.prototype.transfrom = function (offset) {
    if (offset === void 0) {
      offset = 7.5;
    }

    var elements = this.getActiveElements();
    var elementLabels = this.getActiveElementLabels();
    elements.forEach(function (element, idx) {
      var labelShape = elementLabels[idx];
      var coordinate = element.geometry.coordinate;

      if (coordinate.isPolar && coordinate.isTransposed) {
        var _a = _g.Util.getAngle(element.getModel(), coordinate),
            startAngle = _a.startAngle,
            endAngle = _a.endAngle;

        var middleAngle = (startAngle + endAngle) / 2;
        var r = offset;
        var x = r * Math.cos(middleAngle);
        var y = r * Math.sin(middleAngle);
        element.shape.setMatrix((0, _matrix.transform)([['t', x, y]]));
        labelShape.setMatrix((0, _matrix.transform)([['t', x, y]]));
      }
    });
  };

  PieLegendAction.prototype.active = function () {
    this.transfrom();
  };
  /**
   * 
   */


  PieLegendAction.prototype.reset = function () {
    this.transfrom(0);
  };

  return PieLegendAction;
}(_g.Action);

exports.PieLegendAction = PieLegendAction;

/***/ }),
/* 1125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StatisticAction = void 0;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _statistic = __webpack_require__(515);

/**
 * Pie  Action
 */
var StatisticAction =
/** @class */
function (_super) {
  (0, _tslib.__extends)(StatisticAction, _super);

  function StatisticAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  StatisticAction.prototype.getAnnotations = function (_view) {
    var view = _view || this.context.view; // @ts-ignore

    return view.getController('annotation').option;
  };

  StatisticAction.prototype.getInitialAnnotation = function () {
    return this.initialAnnotation;
  };

  StatisticAction.prototype.init = function () {
    var _this = this;

    var view = this.context.view;
    view.removeInteraction('tooltip');
    view.on('afterchangesize', function () {
      var annotations = _this.getAnnotations(view);

      _this.initialAnnotation = annotations;
    });
  };

  StatisticAction.prototype.change = function () {
    var _a = this.context,
        view = _a.view,
        event = _a.event;
    var annotations = this.getAnnotations();

    if (!this.initialAnnotation) {
      this.initialAnnotation = annotations;
    }

    var data = ((event === null || event === void 0 ? void 0 : event.data) || {}).data;

    if (event.type.match('legend-item')) {
      var delegateObject = _g.Util.getDelegationObject(this.context); // @ts-ignore


      var colorField_1 = view.getGroupedFields()[0];

      if (delegateObject && colorField_1) {
        var item_1 = delegateObject.item;
        data = view.getData().find(function (d) {
          return d[colorField_1] === item_1.value;
        });
      }
    }

    if (data) {
      var annotationController_1 = view.getController('annotation');
      annotationController_1.clear(true); // @ts-ignore

      var _b = view.getScaleFields(),
          angleField_1 = _b[1],
          colorField_2 = _b[2];

      var angleScale_1 = view.getScaleByField(angleField_1);
      var colorScale_1 = view.getScaleByField(colorField_2);
      var annotationOptions_1 = annotations.filter(function (a) {
        return !(0, _util.get)(a, 'key', '').match('statistic');
      });
      var statisticOptions = annotations.filter(function (a) {
        return (0, _util.get)(a, 'key', '').match('statistic');
      });
      var titleOpt_1 = statisticOptions.filter(function (opt) {
        return opt.key === 'top-statistic';
      });
      var contentOpt_1 = statisticOptions.filter(function (opt) {
        return opt.key === 'bottom-statistic';
      });
      (0, _util.each)(statisticOptions, function (option) {
        var text;
        var transform;

        if (option.key === 'top-statistic') {
          text = colorScale_1 ? colorScale_1.getText(data[colorField_2]) : null;
          transform = contentOpt_1 ? 'translate(-50%, -100%)' : 'translate(-50%, -50%)';
        } else {
          text = angleScale_1 ? angleScale_1.getText(data[angleField_1]) : data[angleField_1];
          transform = titleOpt_1 ? 'translate(-50%, 0)' : 'translate(-50%,-50%)';
        }

        annotationOptions_1.push((0, _tslib.__assign)((0, _tslib.__assign)({}, option), {
          html: function html(container, view) {
            var coordinate = view.getCoordinate();
            var containerWidth = coordinate.getRadius() * coordinate.innerRadius * 2;
            var style = (0, _util.isFunction)(option.style) ? option.style() : option.style;
            (0, _statistic.setStatisticContainerStyle)(container, (0, _tslib.__assign)({
              width: containerWidth + "px",
              transform: transform
            }, (0, _statistic.adapteStyle)(style)));
            var filteredData = view.getData();

            if (option.customHtml) {
              return option.customHtml(container, view, data, filteredData);
            }

            if (option.formatter) {
              text = option.formatter(data, filteredData);
            } // todo G2  & G2  number


            return text ? (0, _util.isString)(text) ? text : "" + text : '<div></div>';
          }
        }));
        annotationOptions_1.forEach(function (opt) {
          // @ts-ignore
          annotationController_1.annotation(opt);
        });
        view.render(true);
      });
    }
  };

  StatisticAction.prototype.reset = function () {
    var view = this.context.view;
    var annotationController = view.getController('annotation');
    annotationController.clear(true);
    var initialStatistic = this.getInitialAnnotation();
    (0, _util.each)(initialStatistic, function (a) {
      view.annotation()[a.type](a);
    });
    view.render(true);
  };

  return StatisticAction;
}(_g.Action);

exports.StatisticAction = StatisticAction;

/***/ }),
/* 1126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Rose = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1127);

var Rose =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Rose, _super);

  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'rose';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Rose.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *  options 
   */


  Rose.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: false,
      yAxis: false,
      legend: {
        position: 'right',
        offsetX: -10
      },
      sectorStyle: {
        stroke: '#fff',
        lineWidth: 1
      },
      label: {
        layout: {
          type: 'limit-in-shape'
        }
      },
      tooltip: {
        shared: true,
        showMarkers: false
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   *   
   */


  Rose.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Rose;
}(_plot.Plot);

exports.Rose = Rose;

/***/ }),
/* 1127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.legend = legend;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      sectorStyle = options.sectorStyle,
      color = options.color; // 

  chart.data(data);
  (0, _utils.flow)(_geometries.interval)((0, _utils.deepAssign)({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color
      }
    }
  }));
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      xField = options.xField;
  var geometry = (0, _utils.findGeometry)(chart, 'interval'); // label  false  label

  if (label === false) {
    geometry.label(false);
  } else if ((0, _util.isObject)(label)) {
    var callback = label.callback,
        fields = label.fields,
        cfg = (0, _tslib.__rest)(label, ["callback", "fields"]);
    var offset = cfg.offset;
    var layout = cfg.layout; //  label  shape  'limit-in-shape' 
    //  label 

    if (offset === undefined || offset >= 0) {
      layout = layout ? (0, _util.isArray)(layout) ? layout : [layout] : [];
      cfg.layout = (0, _util.filter)(layout, function (v) {
        return v.type !== 'limit-in-shape';
      });
      cfg.layout.length || delete cfg.layout;
    }

    geometry.label({
      fields: fields || [xField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  } else {
    (0, _utils.log)(_utils.LEVEL.WARN, label === null, 'the label option must be an Object.');
    geometry.label({
      fields: [xField]
    });
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      seriesField = options.seriesField;

  if (legend === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend);
  }

  return params;
}
/**
 * coord 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius,
      innerRadius = options.innerRadius;
  chart.coordinate({
    type: 'polar',
    cfg: {
      radius: radius,
      innerRadius: innerRadius
    }
  });
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  falsy 

  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  (0, _utils.flow)(geometry, meta, label, coordinate, axis, legend, _common.tooltip, _common.interaction, _common.animation, _common.theme, (0, _common.annotation)(), _common.state)(params);
}

/***/ }),
/* 1128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WordCloud = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1129);

var _utils2 = __webpack_require__(524);

__webpack_require__(1131);

// shape
var WordCloud =
/** @class */
function (_super) {
  (0, _tslib.__extends)(WordCloud, _super);

  function WordCloud() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'word-cloud';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  WordCloud.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });

    if (this.options.imageMask) {
      this.render();
    } else {
      this.chart.changeData((0, _utils2.transform)({
        chart: this.chart,
        options: this.options
      }));
    }
  };
  /**
   *  options 
   */


  WordCloud.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      timeInterval: 2000,
      legend: false,
      tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: false,
        fields: ['text', 'value', 'color'],
        formatter: function formatter(datum) {
          return {
            name: datum.text,
            value: datum.value
          };
        }
      },
      wordStyle: {
        fontFamily: 'Verdana',
        fontWeight: 'normal',
        padding: 1,
        fontSize: [12, 60],
        rotation: [0, 90],
        rotationSteps: 2,
        rotateRatio: 0.5
      }
    });
  };
  /**
   * 
   */


  WordCloud.prototype.render = function () {
    var _this = this;

    return new Promise(function (res) {
      var imageMask = _this.options.imageMask;

      if (!imageMask) {
        // 
        _super.prototype.render.call(_this);

        res();
        return;
      }

      var handler = function handler(img) {
        _this.options = (0, _tslib.__assign)((0, _tslib.__assign)({}, _this.options), {
          imageMask: img || null
        }); // 

        _super.prototype.render.call(_this);

        res();
      };

      (0, _utils2.processImageMask)(imageMask).then(handler).catch(handler);
    });
  };
  /**
   *   
   */


  WordCloud.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  /**
   *   
   */


  WordCloud.prototype.triggerResize = function () {
    var _this = this;

    if (!this.chart.destroyed) {
      // 
      //  adaptor
      // 
      this.execAdaptor(); // 
      // TODO: 

      window.setTimeout(function () {
        // 
        _super.prototype.triggerResize.call(_this);
      });
    }
  };

  return WordCloud;
}(_plot.Plot);

exports.WordCloud = WordCloud;

/***/ }),
/* 1129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _utils2 = __webpack_require__(524);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var colorField = options.colorField,
      color = options.color;
  var data = (0, _utils2.transform)(params);
  chart.data(data);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: 'x',
      yField: 'y',
      seriesField: colorField && 'color',
      point: {
        color: color,
        shape: 'word-cloud'
      }
    }
  });
  var ext = (0, _geometries.point)(p).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect('y');
  chart.axis(false);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  return (0, _utils.flow)((0, _common.scale)({
    x: {
      nice: false
    },
    y: {
      nice: false
    }
  }))(params);
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  (0, _utils.flow)(geometry, meta, _common.tooltip, _common.legend, _common.interaction, _common.animation, _common.theme, _common.state)(params);
}

/***/ }),
/* 1130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordCloud = wordCloud;
exports.transform = transform;
exports.functor = functor;

var _util = __webpack_require__(0);

var DEFAULT_OPTIONS = {
  font: function font() {
    return 'serif';
  },
  padding: 1,
  size: [500, 500],
  spiral: 'archimedean',
  // timeInterval: Infinity // max execute time
  timeInterval: 3000
};
/**
 * 
 * 
 * 
 * @param words
 * @param options
 */

function wordCloud(words, options) {
  // 
  options = (0, _util.assign)({}, DEFAULT_OPTIONS, options);
  return transform(words, options);
}
/**
 * 
 * @param words
 * @param options
 */


function transform(words, options) {
  // 
  var layout = tagCloud();
  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {
    if (!(0, _util.isNil)(options[key])) {
      layout[key](options[key]);
    }
  });
  layout.words(words);

  if (options.imageMask) {
    layout.createMask(options.imageMask);
  }

  var result = layout.start();
  var tags = result._tags;
  tags.forEach(function (tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a = options.size,
      w = _a[0],
      h = _a[1]; // 
  // 
  // 
  // 

  tags.push({
    text: '',
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags.push({
    text: '',
    value: 0,
    x: w,
    y: h,
    opacity: 0
  });
  return tags;
}

var cloudRadians = Math.PI / 180,
    cw = 1 << 11 >> 5,
    ch = 1 << 11;

function cloudText(d) {
  return d.text;
}

function cloudFont() {
  return 'serif';
}

function cloudFontNormal() {
  return 'normal';
}

function cloudFontSize(d) {
  return d.value;
}

function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}

function cloudPadding() {
  return 1;
} // Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.


function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
      ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
      y = 0,
      maxh = 0;
  var n = data.length;
  --di;

  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    var w = c.measureText(d.text + 'm').width * ratio,
        h = d.size << 1;

    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
          cr = Math.cos(d.rotate * cloudRadians),
          wcr = w * cr,
          wsr = w * sr,
          hcr = h * cr,
          hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }

    if (h > maxh) maxh = h;

    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }

    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);

    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }

    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }

  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
      sprite = [];

  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    var w = d.width,
        w32 = w >> 5;
    var h = d.y1 - d.y0; // Zero the buffer

    for (var i = 0; i < h * w32; i++) {
      sprite[i] = 0;
    }

    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
        seenRow = -1;

    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }

      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }

    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
} // Use mask-based collision detection.


function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
      w = tag.width >> 5,
      lx = tag.x - (w << 4),
      sx = lx & 0x7f,
      msx = 32 - sx,
      h = tag.y1 - tag.y0;
  var x = (tag.y + tag.y0) * sw + (lx >> 5),
      last;

  for (var j = 0; j < h; j++) {
    last = 0;

    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }

    x += sw;
  }

  return false;
}

function cloudBounds(bounds, d) {
  var b0 = bounds[0],
      b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}

function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}

function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}

function rectangularSpiral(size) {
  var dy = 4,
      dx = dy * size[0] / size[1];
  var x = 0,
      y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.

    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;

      case 1:
        y += dy;
        break;

      case 2:
        x -= dx;
        break;

      default:
        y -= dy;
        break;
    }

    return [x, y];
  };
} // TODO reuse arrays?


function zeroArray(n) {
  var a = [];
  var i = -1;

  while (++i < n) {
    a[i] = 0;
  }

  return a;
}

function cloudCanvas() {
  return document.createElement('canvas');
}

function functor(d) {
  return (0, _util.isFunction)(d) ? d : function () {
    return d;
  };
}

var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

function tagCloud() {
  var size = [256, 256],
      font = cloudFont,
      fontSize = cloudFontSize,
      fontWeight = cloudFontNormal,
      rotate = cloudRotate,
      padding = cloudPadding,
      spiral = archimedeanSpiral,
      random = Math.random,
      words = [],
      timeInterval = Infinity;
  var text = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};

  cloud.start = function () {
    var width = size[0],
        height = size[1];
    var contextAndRatio = getContext(canvas()),
        board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),
        n = words.length,
        tags = [],
        data = words.map(function (d, i, data) {
      d.text = text.call(this, d, i, data);
      d.font = font.call(this, d, i, data);
      d.style = fontStyle.call(this, d, i, data);
      d.weight = fontWeight.call(this, d, i, data);
      d.rotate = rotate.call(this, d, i, data);
      d.size = ~~fontSize.call(this, d, i, data);
      d.padding = padding.call(this, d, i, data);
      return d;
    }).sort(function (a, b) {
      return b.size - a.size;
    });
    var i = -1,
        bounds = !cloud.board ? null : [{
      x: 0,
      y: 0
    }, {
      x: width,
      y: height
    }];
    step();

    function step() {
      var start = Date.now();

      while (Date.now() - start < timeInterval && ++i < n) {
        var d = data[i];
        d.x = width * (random() + 0.5) >> 1;
        d.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data, i);

        if (d.hasText && place(board, d, bounds)) {
          tags.push(d);

          if (bounds) {
            if (!cloud.hasImage) {
              // update bounds if image mask not set
              cloudBounds(bounds, d);
            }
          } else {
            bounds = [{
              x: d.x + d.x0,
              y: d.y + d.y0
            }, {
              x: d.x + d.x1,
              y: d.y + d.y1
            }];
          } // Temporary hack


          d.x -= size[0] >> 1;
          d.y -= size[1] >> 1;
        }
      }

      cloud._tags = tags;
      cloud._bounds = bounds;
    }

    return cloud;
  };

  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }

  function place(board, tag, bounds) {
    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],
    var startX = tag.x,
        startY = tag.y,
        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),
        s = spiral(size),
        dt = random() < 0.5 ? 1 : -1;
    var dxdy,
        t = -dt,
        dx,
        dy;

    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.

      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
              w = tag.width >> 5,
              sw = size[0] >> 5,
              lx = tag.x - (w << 4),
              sx = lx & 0x7f,
              msx = 32 - sx,
              h = tag.y1 - tag.y0;
          var last = void 0,
              x = (tag.y + tag.y0) * sw + (lx >> 5);

          for (var j = 0; j < h; j++) {
            last = 0;

            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }

            x += sw;
          }

          delete tag.sprite;
          return true;
        }
      }
    }

    return false;
  }

  cloud.createMask = function (img) {
    var can = document.createElement('canvas');
    var width = size[0],
        height = size[1]; //  width  height  0  cxt.getImageData 

    if (!width || !height) {
      return;
    }

    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext('2d');
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;

    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++) {
        var k = w32 * j + (i >> 5);
        var tmp = j * width + i << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m = flag ? 1 << 31 - i % 32 : 0;
        board[k] |= m;
      }
    }

    cloud.board = board;
    cloud.hasImage = true;
  };

  cloud.timeInterval = function (_) {
    timeInterval = _ == null ? Infinity : _;
  };

  cloud.words = function (_) {
    words = _;
  };

  cloud.size = function (_) {
    size = [+_[0], +_[1]];
  };

  cloud.font = function (_) {
    font = functor(_);
  };

  cloud.fontWeight = function (_) {
    fontWeight = functor(_);
  };

  cloud.rotate = function (_) {
    rotate = functor(_);
  };

  cloud.spiral = function (_) {
    spiral = spirals[_] || _;
  };

  cloud.fontSize = function (_) {
    fontSize = functor(_);
  };

  cloud.padding = function (_) {
    padding = functor(_);
  };

  cloud.random = function (_) {
    random = functor(_);
  };

  return cloud;
}

/***/ }),
/* 1131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

(0, _g.registerShape)('point', 'word-cloud', {
  draw: function draw(cfg, group) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group.addShape('text', {
      attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, getTextAttrs(cfg)), {
        x: cx,
        y: cy
      })
    });
    var rotate = cfg.data.rotate;

    if (typeof rotate === 'number') {
      _g.Util.rotate(shape, rotate * Math.PI / 180);
    }

    return shape;
  }
});

function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: 'center',
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: 'alphabetic'
  };
}

/***/ }),
/* 1132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scatter = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1133);

__webpack_require__(525);

var Scatter =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Scatter, _super);

  function Scatter() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'point';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Scatter.prototype.changeData = function (data) {
    this.updateOption((0, _adaptor.transformOptions)((0, _utils.deepAssign)({}, this.options, {
      data: data
    })));

    var _a = this,
        options = _a.options,
        chart = _a.chart;

    (0, _adaptor.meta)({
      chart: chart,
      options: options
    });
    this.chart.changeData(data);
  };
  /**
   * 
   */


  Scatter.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  Scatter.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      size: 4,
      tooltip: {
        showTitle: false,
        showMarkers: false,
        showCrosshairs: true,
        crosshairs: {
          type: 'xy'
        }
      }
    });
  };

  return Scatter;
}(_plot.Plot);

exports.Scatter = Scatter;

/***/ }),
/* 1133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformOptions = transformOptions;
exports.meta = meta;
exports.tooltip = tooltip;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _common = __webpack_require__(25);

var _util2 = __webpack_require__(1134);

/**
 *  data.length === 1 
 * @param params
 * @returns params
 */
function transformOptions(options) {
  var _a = options.data,
      data = _a === void 0 ? [] : _a; //  data.length === 1 

  if (data.length === 1) {
    return (0, _utils.deepAssign)({}, options, {
      meta: (0, _util2.getMeta)(options)
    });
  }

  return options;
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      type = options.type,
      color = options.color,
      shape = options.shape,
      pointStyle = options.pointStyle,
      shapeField = options.shapeField,
      colorField = options.colorField,
      xField = options.xField,
      yField = options.yField,
      sizeField = options.sizeField;
  var size = options.size;
  var tooltip = options.tooltip;

  if (sizeField) {
    if (!size) {
      size = [2, 8];
    }

    if ((0, _util.isNumber)(size)) {
      size = [size, size];
    }
  }

  if (tooltip && !tooltip.fields) {
    tooltip = (0, _tslib.__assign)((0, _tslib.__assign)({}, tooltip), {
      fields: [xField, yField, colorField, sizeField, shapeField]
    });
  } // 


  chart.data(data); // geometry

  (0, _geometries.point)((0, _utils.deepAssign)({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color,
        shape: shape,
        size: size,
        style: pointStyle
      },
      tooltip: tooltip
    }
  }));
  var geometry = (0, _utils.findGeometry)(chart, 'point'); // 

  if (type) {
    geometry.adjust(type);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  var newOptions = options; //  data.length === 1 

  if (data.length === 1) {
    newOptions = transformOptions((0, _utils.deepAssign)({}, options, {
      meta: (0, _util2.getMeta)(options)
    }));
  }

  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))((0, _utils.deepAssign)({}, params, {
    options: newOptions
  }));
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField,
      shapeField = options.shapeField,
      sizeField = options.sizeField; // legend  shapeField  colorField 

  var showLegend = (0, _util.isBoolean)(legend) ? legend : legend || !!(shapeField || colorField);

  if (showLegend) {
    chart.legend(colorField || shapeField, legend); // 

    if (sizeField) {
      chart.legend(sizeField, false);
    }
  } else {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var scatterGeometry = (0, _utils.findGeometry)(chart, 'point'); // label  false,   label

  if (!label) {
    scatterGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * annotation 
 * -  annotation: quadrant()
 * @param params
 */


function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];

  if (quadrant) {
    var _a = quadrant.xBaseline,
        xBaseline = _a === void 0 ? 0 : _a,
        _b = quadrant.yBaseline,
        yBaseline = _b === void 0 ? 0 : _b,
        labels_1 = quadrant.labels,
        regionStyle_1 = quadrant.regionStyle,
        lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = (0, _util2.getQuadrantDefaultConfig)(xBaseline, yBaseline); // 

    var quadrants = new Array(4).join(',').split(',');
    quadrants.forEach(function (_, index) {
      annotationOptions.push((0, _tslib.__assign)((0, _tslib.__assign)({
        type: 'region',
        top: false
      }, defaultConfig_1.regionStyle[index].position), {
        style: (0, _utils.deepAssign)({}, defaultConfig_1.regionStyle[index].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index])
      }), (0, _tslib.__assign)({
        type: 'text',
        top: true
      }, (0, _utils.deepAssign)({}, defaultConfig_1.labelStyle[index], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index])));
    }); // 

    annotationOptions.push({
      type: 'line',
      top: false,
      start: ['min', yBaseline],
      end: ['max', yBaseline],
      style: (0, _utils.deepAssign)({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: 'line',
      top: false,
      start: [xBaseline, 'min'],
      end: [xBaseline, 'max'],
      style: (0, _utils.deepAssign)({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }

  return (0, _utils.flow)((0, _common.annotation)(annotationOptions))(params);
} // 


function regressionLine(params) {
  var options = params.options,
      chart = params.chart;
  var regressionLine = options.regressionLine;

  if (regressionLine) {
    var style_1 = regressionLine.style,
        _a = regressionLine.top,
        top_1 = _a === void 0 ? false : _a;
    var defaultStyle_1 = {
      stroke: '#9ba29a',
      lineWidth: 2,
      opacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function render(container, view) {
        var group = container.addGroup({
          id: chart.id + "-regression-line",
          name: 'regression-line-group'
        });
        var path = (0, _util2.getPath)({
          view: view,
          options: options
        });
        group.addShape('path', {
          name: 'regression-line',
          attrs: (0, _tslib.__assign)((0, _tslib.__assign)({
            path: path
          }, defaultStyle_1), style_1)
        });
      }
    });
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;

  if (tooltip) {
    chart.tooltip(tooltip);
  } else if (tooltip === false) {
    chart.tooltip(false);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, axis, legend, tooltip, label, _common.interaction, scatterAnnotation, _common.animation, _common.theme, regressionLine)(params);
}

/***/ }),
/* 1134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getQuadrantDefaultConfig = getQuadrantDefaultConfig;
exports.getMeta = exports.getPath = void 0;

var _tslib = __webpack_require__(1);

var _d3Regression = __webpack_require__(510);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var REGRESSION_MAP = {
  exp: _d3Regression.regressionExp,
  linear: _d3Regression.regressionLinear,
  loess: _d3Regression.regressionLoess,
  log: _d3Regression.regressionLog,
  poly: _d3Regression.regressionPoly,
  pow: _d3Regression.regressionPow,
  quad: _d3Regression.regressionQuad
};
/**
 * 
 * @param {number} xBaseline
 * @param {number} yBaseline
 */

function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  // 
  var textOffset = 10; // 

  var defaultConfig = {
    regionStyle: [{
      position: {
        start: [xBaseline, 'max'],
        end: ['max', yBaseline]
      },
      style: {
        fill: '#d8d0c0',
        opacity: 0.4
      }
    }, {
      position: {
        start: ['min', 'max'],
        end: [xBaseline, yBaseline]
      },
      style: {
        fill: '#a3dda1',
        opacity: 0.4
      }
    }, {
      position: {
        start: ['min', yBaseline],
        end: [xBaseline, 'min']
      },
      style: {
        fill: '#d8d0c0',
        opacity: 0.4
      }
    }, {
      position: {
        start: [xBaseline, yBaseline],
        end: ['max', 'min']
      },
      style: {
        fill: '#a3dda1',
        opacity: 0.4
      }
    }],
    lineStyle: {
      stroke: '#9ba29a',
      lineWidth: 1
    },
    labelStyle: [{
      position: ['max', yBaseline],
      offsetX: -textOffset,
      offsetY: -textOffset,
      style: {
        textAlign: 'right',
        textBaseline: 'bottom',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['min', yBaseline],
      offsetX: textOffset,
      offsetY: -textOffset,
      style: {
        textAlign: 'left',
        textBaseline: 'bottom',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['min', yBaseline],
      offsetX: textOffset,
      offsetY: textOffset,
      style: {
        textAlign: 'left',
        textBaseline: 'top',
        fontSize: 14,
        fill: '#ccc'
      }
    }, {
      position: ['max', yBaseline],
      offsetX: -textOffset,
      offsetY: textOffset,
      style: {
        textAlign: 'right',
        textBaseline: 'top',
        fontSize: 14,
        fill: '#ccc'
      }
    }]
  };
  return defaultConfig;
}

var splinePath = function splinePath(data, config) {
  var view = config.view,
      _a = config.options,
      xField = _a.xField,
      yField = _a.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data.map(function (d) {
    return view.getCoordinate().convert({
      x: xScaleView.scale(d[0]),
      y: yScaleView.scale(d[1])
    });
  });
  return (0, _utils.getSplinePath)(pathData, false);
};

var getPath = function getPath(config) {
  var options = config.options;
  var xField = options.xField,
      yField = options.yField,
      data = options.data,
      regressionLine = options.regressionLine;
  var _a = regressionLine.type,
      type = _a === void 0 ? 'linear' : _a,
      algorithm = regressionLine.algorithm;
  var pathData;

  if (algorithm) {
    pathData = (0, _util.isArray)(algorithm) ? algorithm : algorithm(data);
  } else {
    var reg = REGRESSION_MAP[type]().x(function (d) {
      return d[xField];
    }).y(function (d) {
      return d[yField];
    });
    pathData = reg(data);
  }

  return splinePath(pathData, config);
}; // data.length === 1 meta: {min, max}


exports.getPath = getPath;

var getMeta = function getMeta(options) {
  var _a;

  var _b = options.meta,
      meta = _b === void 0 ? {} : _b,
      xField = options.xField,
      yField = options.yField,
      data = options.data;
  var xFieldValue = data[0][xField];
  var yFieldValue = data[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;

  var getValue = function getValue(field, type, axis) {
    var customValue = (0, _util.get)(meta, [field, type]);

    if ((0, _util.isNumber)(customValue)) {
      return customValue;
    }

    if (axis === 'x') {
      var rangeX = {
        min: xIsPositiveNumber ? 0 : xFieldValue * 2,
        max: xIsPositiveNumber ? xFieldValue * 2 : 0
      };
      return rangeX[type];
    }

    var rangeY = {
      min: yIsPositiveNumber ? 0 : yFieldValue * 2,
      max: yIsPositiveNumber ? yFieldValue * 2 : 0
    };
    return rangeY[type];
  };

  return (0, _tslib.__assign)((0, _tslib.__assign)({}, meta), (_a = {}, _a[xField] = (0, _tslib.__assign)((0, _tslib.__assign)({}, meta[xField]), {
    min: getValue(xField, 'min', 'x'),
    max: getValue(xField, 'max', 'x')
  }), _a[yField] = (0, _tslib.__assign)((0, _tslib.__assign)({}, meta[yField]), {
    min: getValue(yField, 'min', 'y'),
    max: getValue(yField, 'max', 'y')
  }), _a));
};

exports.getMeta = getMeta;

/***/ }),
/* 1135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Radar = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1136);

__webpack_require__(1137);

var Radar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Radar, _super);

  function Radar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'radar';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Radar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData(data);
  };
  /**
   *   
   */


  Radar.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: {
        label: {
          offset: 15
        },
        grid: {
          line: {
            type: 'line'
          }
        }
      },
      yAxis: {
        grid: {
          line: {
            type: 'circle'
          }
        }
      },
      legend: {
        position: 'top'
      },
      tooltip: {
        shared: true,
        showCrosshairs: true,
        showMarkers: true,
        crosshairs: {
          type: 'xy',
          line: {
            style: {
              stroke: '#565656',
              lineDash: [4]
            }
          },
          follow: true
        }
      }
    });
  };
  /**
   *   
   */


  Radar.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Radar;
}(_plot.Plot);

exports.Radar = Radar;

/***/ }),
/* 1136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _utils = __webpack_require__(12);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      lineStyle = options.lineStyle,
      color = options.color,
      pointOptions = options.point,
      areaOptions = options.area;
  chart.data(data); //   geometry

  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color
      },
      point: pointOptions ? (0, _tslib.__assign)({
        color: color
      }, pointOptions) : pointOptions,
      area: areaOptions ? (0, _tslib.__assign)({
        color: color
      }, areaOptions) : areaOptions,
      // label  geometry adaptor label adaptor 
      label: undefined
    }
  }); //  Geometry

  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  });
  (0, _geometries.line)(primary);
  (0, _geometries.point)(second);
  (0, _geometries.area)(second);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * coord 
 * @param params
 */


function coord(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius;
  chart.coordinate('polar', {
    radius: radius
  });
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      xAxis = options.xAxis,
      yField = options.yField,
      yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var geometry = (0, _utils.findGeometry)(chart, 'line');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [yField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, _common.theme, coord, axis, _common.legend, _common.tooltip, label, _common.interaction, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

var _radarTooltipAction = __webpack_require__(1138);

(0, _g.registerAction)('radar-tooltip', _radarTooltipAction.RadarTooltipAction);
(0, _g.registerInteraction)('radar-tooltip', {
  start: [{
    trigger: 'plot:mousemove',
    action: 'radar-tooltip:show'
  }],
  end: [{
    trigger: 'plot:mouseleave',
    action: 'radar-tooltip:hide'
  }]
});

/***/ }),
/* 1138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RadarTooltipAction = exports.RadarTooltipController = void 0;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var RadarTooltipController =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RadarTooltipController, _super);

  function RadarTooltipController() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Object.defineProperty(RadarTooltipController.prototype, "name", {
    get: function get() {
      return 'radar-tooltip';
    },
    enumerable: false,
    configurable: true
  });

  RadarTooltipController.prototype.getTooltipItems = function (point) {
    var _a = this.getTooltipCfg(),
        shared = _a.shared,
        cfgTitle = _a.title;

    var hintItems = _super.prototype.getTooltipItems.call(this, point);

    if (hintItems.length > 0) {
      var geometry_1 = this.view.geometries[0];
      var dataArray = geometry_1.dataArray;
      var title_1 = hintItems[0].name;
      var result_1 = [];
      dataArray.forEach(function (mappingData) {
        mappingData.forEach(function (d) {
          var items = _g.Util.getTooltipItems(d, geometry_1);

          var item = items[0];

          if (!shared && item && item.name === title_1) {
            var displayTitle = (0, _util.isNil)(cfgTitle) ? title_1 : cfgTitle;
            result_1.push((0, _tslib.__assign)((0, _tslib.__assign)({}, item), {
              name: item.title,
              title: displayTitle
            }));
          } else if (shared && item) {
            var displayTitle = (0, _util.isNil)(cfgTitle) ? item.name || title_1 : cfgTitle;
            result_1.push((0, _tslib.__assign)((0, _tslib.__assign)({}, item), {
              name: item.title,
              title: displayTitle
            }));
          }
        });
      });
      return result_1;
    }

    return [];
  };

  return RadarTooltipController;
}(_g.TooltipController);

exports.RadarTooltipController = RadarTooltipController;
(0, _g.registerComponentController)('radar-tooltip', RadarTooltipController);
/**
 *  tooltip  action
 */

var RadarTooltipAction =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RadarTooltipAction, _super);

  function RadarTooltipAction() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  RadarTooltipAction.prototype.init = function () {
    var view = this.context.view;
    view.removeInteraction('tooltip');
  };

  RadarTooltipAction.prototype.show = function () {
    var event = this.context.event;
    var controller = this.getTooltipController();
    controller.showTooltip({
      x: event.x,
      y: event.y
    });
  };

  RadarTooltipAction.prototype.hide = function () {
    var controller = this.getTooltipController();
    controller.hideTooltip();
  };

  RadarTooltipAction.prototype.getTooltipController = function () {
    var view = this.context.view;
    return view.getController('radar-tooltip');
  };

  return RadarTooltipAction;
}(_g.Action);

exports.RadarTooltipAction = RadarTooltipAction;

/***/ }),
/* 1139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DualAxes = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1140);

var DualAxes =
/** @class */
function (_super) {
  (0, _tslib.__extends)(DualAxes, _super);

  function DualAxes() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /** :  */


    _this.type = 'dual-axes';
    return _this;
  }
  /**
   *   
   */


  DualAxes.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      yAxis: [],
      syncViewPadding: true
    });
  };
  /**
   * 
   */


  DualAxes.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return DualAxes;
}(_plot.Plot);

exports.DualAxes = DualAxes;

/***/ }),
/* 1140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformOptions = transformOptions;
exports.color = color;
exports.meta = meta;
exports.axis = axis;
exports.tooltip = tooltip;
exports.interaction = interaction;
exports.annotation = annotation;
exports.animation = animation;
exports.limitInPlot = limitInPlot;
exports.legend = legend;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _percent = __webpack_require__(122);

var _utils = __webpack_require__(12);

var _view = __webpack_require__(514);

var _option = __webpack_require__(297);

var _legend = __webpack_require__(1141);

var _geometry = __webpack_require__(1142);

var _types = __webpack_require__(526);

var _constant = __webpack_require__(527);

/**
 * transformOptions
 * 1. get index getOptions:  appendPaddingsyncView 
 * 2. get adpator transformOption: deepAssign 
 *    2.1 defaultoption tooltiplegend
 *    2.2  options
 *    2.3  options  options yaxisGeometryOption deepAssign  assign 
 *
 * @param params
 */
function transformOptions(params) {
  var _a;

  var options = params.options;
  var _b = options.geometryOptions,
      geometryOptions = _b === void 0 ? [] : _b,
      xField = options.xField,
      yField = options.yField;
  var allLine = (0, _util.every)(geometryOptions, function (_a) {
    var geometry = _a.geometry;
    return geometry === _types.DualAxesGeometry.Line || geometry === undefined;
  });
  return (0, _utils.deepAssign)({}, {
    options: {
      geometryOptions: [],
      meta: (_a = {}, _a[xField] = {
        //  cat 
        type: 'cat',
        // x  scale 
        sync: true,
        // 
        range: allLine ? [0, 1] : undefined
      }, _a),
      tooltip: {
        showMarkers: allLine,
        //  crosshairs
        showCrosshairs: allLine,
        shared: true,
        crosshairs: {
          type: 'x'
        }
      },
      interactions: !allLine ? [{
        type: 'legend-visible-filter'
      }, {
        type: 'active-region'
      }] : [{
        type: 'legend-visible-filter'
      }],
      legend: {
        position: 'top-left'
      }
    }
  }, params, {
    options: {
      // yAxis
      yAxis: (0, _option.transformObjectToArray)(yField, options.yAxis),
      // geometryOptions
      geometryOptions: [(0, _option.getGeometryOption)(xField, yField[0], geometryOptions[0]), (0, _option.getGeometryOption)(xField, yField[1], geometryOptions[1])],
      // annotations
      annotations: (0, _option.transformObjectToArray)(yField, options.annotations)
    }
  });
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      geometryOptions = options.geometryOptions,
      data = options.data,
      tooltip = options.tooltip;
  var SORT_MAP = {
    line: 0,
    column: 1
  }; // id

  var geometries = [(0, _tslib.__assign)((0, _tslib.__assign)({}, geometryOptions[0]), {
    id: _constant.LEFT_AXES_VIEW,
    data: data[0],
    yField: yField[0]
  }), (0, _tslib.__assign)((0, _tslib.__assign)({}, geometryOptions[1]), {
    id: _constant.RIGHT_AXES_VIEW,
    data: data[1],
    yField: yField[1]
  })]; //  view 

  geometries.sort(function (a, b) {
    return -SORT_MAP[a.geometry] + SORT_MAP[b.geometry];
  }).forEach(function (geometry) {
    var id = geometry.id,
        data = geometry.data,
        yField = geometry.yField; // 

    var isPercent = (0, _option.isColumn)(geometry) && geometry.isPercent;
    var formatData = isPercent ? (0, _percent.percent)(data, yField, xField, yField) : data;
    var view = chart.createView({
      id: id
    }).data(formatData);
    var tooltipOptions = isPercent ? (0, _tslib.__assign)({
      formatter: function formatter(datum) {
        return {
          name: datum[geometry.seriesField] || yField,
          value: (Number(datum[yField]) * 100).toFixed(2) + '%'
        };
      }
    }, tooltip) : tooltip; // 

    (0, _geometry.drawSingleGeometry)({
      chart: view,
      options: {
        xField: xField,
        yField: yField,
        tooltip: tooltipOptions,
        geometryOption: geometry
      }
    });
  });
  return params;
}

function color(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var geometryOptions = options.geometryOptions;
  var themeColor = ((_a = chart.getTheme()) === null || _a === void 0 ? void 0 : _a.colors10) || [];
  var start = 0;
  /*  geometry  color
   * 1.  geometryOptions  color drawGeometry 
   * 2.   color Geometry group scales theme color 10 
   * 3.  group  view  N   concat  themeColor
   * 4.  Geometry group scales color
   * 5.  view  g2
   */

  chart.once('beforepaint', function () {
    (0, _util.each)(geometryOptions, function (geometryOption, index) {
      var view = (0, _view.findViewById)(chart, index === 0 ? _constant.LEFT_AXES_VIEW : _constant.RIGHT_AXES_VIEW);
      if (geometryOption.color) return;
      var groupScale = view.getGroupScales();
      var count = (0, _util.get)(groupScale, [0, 'values', 'length'], 1);
      var color = themeColor.slice(start, start + count).concat(index === 0 ? [] : themeColor);
      view.geometries.forEach(function (geometry) {
        if (geometryOption.seriesField) {
          geometry.color(geometryOption.seriesField, color);
        } else {
          geometry.color(color[0]);
        }
      });
      start += count;
    });
    chart.render(true);
  });
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  (0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField[0]] = yAxis[0], _a))((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW)
  }));
  (0, _common.scale)((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW)
  }));
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var leftView = (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW);
  var rightView = (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW);
  var xField = options.xField,
      yField = options.yField,
      xAxis = options.xAxis,
      yAxis = options.yAxis;
  chart.axis(xField, false);
  chart.axis(yField[0], false);
  chart.axis(yField[1], false); //  View

  leftView.axis(xField, xAxis);
  leftView.axis(yField[0], (0, _option.getYAxisWithDefault)(yAxis[0], _types.AxisType.Left)); //  Y 

  rightView.axis(xField, false);
  rightView.axis(yField[1], (0, _option.getYAxisWithDefault)(yAxis[1], _types.AxisType.Right));
  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;
  var leftView = (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW);
  var rightView = (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW); // tooltip  getDefaultOption  undefined

  chart.tooltip(tooltip); //  view  tooltip shared  interaction active-region 
  // view  chart  shared

  leftView.tooltip({
    shared: true
  });
  rightView.tooltip({
    shared: true
  });
  return params;
}
/**
 * interaction 
 * @param params
 */


function interaction(params) {
  var chart = params.chart;
  (0, _common.interaction)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW)
  }));
  (0, _common.interaction)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW)
  }));
  return params;
}
/**
 * annotation 
 * @param params
 */


function annotation(params) {
  var chart = params.chart,
      options = params.options;
  var annotations = options.annotations;
  var a1 = (0, _util.get)(annotations, [0]);
  var a2 = (0, _util.get)(annotations, [1]);
  (0, _common.annotation)(a1)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW),
    options: {
      annotations: a1
    }
  }));
  (0, _common.annotation)(a2)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW),
    options: {
      annotations: a2
    }
  }));
  return params;
}

function animation(params) {
  var chart = params.chart;
  (0, _common.animation)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW)
  }));
  (0, _common.animation)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW)
  }));
  return params;
}
/**
 *  limitInPlot
 * @param params
 */


function limitInPlot(params) {
  var chart = params.chart,
      options = params.options;
  var yAxis = options.yAxis;
  (0, _common.limitInPlot)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW),
    options: {
      yAxis: yAxis[0]
    }
  }));
  (0, _common.limitInPlot)((0, _utils.deepAssign)({}, params, {
    chart: (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW),
    options: {
      yAxis: yAxis[1]
    }
  }));
  return params;
}
/**
 * legend 
 *  custom-
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      geometryOptions = options.geometryOptions,
      yField = options.yField,
      data = options.data;
  var leftView = (0, _view.findViewById)(chart, _constant.LEFT_AXES_VIEW);
  var rightView = (0, _view.findViewById)(chart, _constant.RIGHT_AXES_VIEW);

  if (legend === false) {
    chart.legend(false);
  } else if ((0, _util.isObject)(legend) && legend.custom === true) {
    chart.legend(legend);
  } else {
    // 
    chart.once('beforepaint', function () {
      var leftItems = data[0].length ? (0, _legend.getViewLegendItems)({
        view: leftView,
        geometryOption: geometryOptions[0],
        yField: yField[0],
        legend: legend
      }) : [];
      var rightItems = data[1].length ? (0, _legend.getViewLegendItems)({
        view: rightView,
        geometryOption: geometryOptions[1],
        yField: yField[1],
        legend: legend
      }) : [];
      chart.legend((0, _utils.deepAssign)({}, legend, {
        custom: true,
        // todo 
        // @ts-ignore
        items: leftItems.concat(rightItems)
      }));
    }); // 

    chart.on('legend-item:click', function (evt) {
      var delegateObject = (0, _util.get)(evt, 'gEvent.delegateObject', {});

      if (delegateObject && delegateObject.item) {
        var _a = delegateObject.item,
            field_1 = _a.value,
            isGeometry = _a.isGeometry,
            viewId = _a.viewId; // geometry  view.changeVisible

        if (isGeometry) {
          var idx = (0, _util.findIndex)(yField, function (yF) {
            return yF === field_1;
          });

          if (idx > -1) {
            var geometries = (0, _util.get)((0, _view.findViewById)(chart, viewId), 'geometries');
            (0, _util.each)(geometries, function (g) {
              g.changeVisible(!delegateObject.item.unchecked);
            });
          }
        } else {
          var legendItem_1 = (0, _util.get)(chart.getController('legend'), 'option.items', []); // 

          (0, _util.each)(chart.views, function (view) {
            // 
            var groupScale = view.getGroupScales();
            (0, _util.each)(groupScale, function (scale) {
              if (scale.values && scale.values.indexOf(field_1) > -1) {
                view.filter(scale.field, function (value) {
                  var curLegendItem = (0, _util.find)(legendItem_1, function (item) {
                    return item.value === value;
                  }); //  legend  unchecked 

                  return !curLegendItem.unchecked;
                });
              }
            });
            chart.render(true);
          });
        }
      }
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // transformOptions color legend  beforepaint
  return (0, _utils.flow)(transformOptions, geometry, meta, axis, limitInPlot, tooltip, interaction, annotation, _common.theme, animation, color, legend)(params);
}

/***/ }),
/* 1141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getViewLegendItems = getViewLegendItems;

var _util = __webpack_require__(0);

var _g = __webpack_require__(17);

var _utils = __webpack_require__(12);

var _option = __webpack_require__(297);

/**
 *  view  legendItem seriesField 
 * @param params
 */
function getViewLegendItems(params) {
  var view = params.view,
      geometryOption = params.geometryOption,
      yField = params.yField,
      legend = params.legend;
  var userMarker = (0, _util.get)(legend, 'marker');
  var geometry = (0, _utils.findGeometry)(view, (0, _option.isLine)(geometryOption) ? 'line' : 'interval');

  if (!geometryOption.seriesField) {
    //  g2 
    var colorAttribute = geometry.getAttribute('color');
    var color = colorAttribute.values[0];
    var marker = userMarker || ((0, _option.isLine)(geometryOption) ? {
      symbol: function symbol(x, y, r) {
        return [['M', x - r, y], ['L', x + r, y]];
      },
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color
      }
    } : {
      symbol: 'square',
      style: {
        fill: color
      }
    });
    return [{
      value: yField,
      name: (0, _util.get)(view, "options.scales." + yField + ".alias") || yField,
      marker: marker,
      isGeometry: true,
      viewId: view.id
    }];
  }

  var attributes = geometry.getGroupAttributes();
  return (0, _util.reduce)(attributes, function (items, attr) {
    var attrItems = _g.Util.getLegendItems(view, geometry, attr, view.getTheme(), userMarker);

    return items.concat(attrItems);
  }, []);
}

/***/ }),
/* 1142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drawSingleGeometry = drawSingleGeometry;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _geometries = __webpack_require__(32);

var _utils = __webpack_require__(12);

var _option = __webpack_require__(297);

/**
 * 
 * @param params
 */
function drawSingleGeometry(params) {
  var options = params.options,
      chart = params.chart;
  var geometryOption = options.geometryOption;
  var isStack = geometryOption.isStack,
      color = geometryOption.color,
      seriesField = geometryOption.seriesField,
      groupField = geometryOption.groupField,
      isGroup = geometryOption.isGroup;
  var FIELD_KEY = ['xField', 'yField'];

  if ((0, _option.isLine)(geometryOption)) {
    // 
    (0, _geometries.line)((0, _utils.deepAssign)({}, params, {
      options: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _utils.pick)(options, FIELD_KEY)), geometryOption), {
        line: {
          color: geometryOption.color,
          style: geometryOption.lineStyle
        }
      })
    })); // 

    (0, _geometries.point)((0, _utils.deepAssign)({}, params, {
      options: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _utils.pick)(options, FIELD_KEY)), geometryOption), {
        point: geometryOption.point && (0, _tslib.__assign)({
          color: color,
          shape: 'circle'
        }, geometryOption.point)
      })
    })); // adjust

    var adjust_1 = [];

    if (isGroup) {
      adjust_1.push({
        type: 'dodge',
        dodgeBy: groupField || seriesField,
        customOffset: 0
      });
    }

    if (isStack) {
      adjust_1.push({
        type: 'stack'
      });
    }

    if (adjust_1.length) {
      (0, _util.each)(chart.geometries, function (g) {
        g.adjust(adjust_1);
      });
    }
  }

  if ((0, _option.isColumn)(geometryOption)) {
    (0, _geometries.interval)((0, _utils.deepAssign)({}, params, {
      options: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _utils.pick)(options, FIELD_KEY)), geometryOption), {
        widthRatio: geometryOption.columnWidthRatio,
        interval: (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _utils.pick)(geometryOption, ['color'])), {
          style: geometryOption.columnStyle
        })
      })
    }));
  }

  return params;
}

/***/ }),
/* 1143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyLine = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1144);

var _constants = __webpack_require__(159);

var _utils = __webpack_require__(123);

var TinyLine =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyLine, _super);

  function TinyLine() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-line';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyLine.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData((0, _utils.getTinyData)(data));
  };

  TinyLine.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: (0, _tslib.__assign)({}, _constants.DEFAULT_TOOLTIP_OPTIONS),
      animation: true
    };
  };
  /**
   *   
   */


  TinyLine.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return TinyLine;
}(_plot.Plot);

exports.TinyLine = TinyLine;

/***/ }),
/* 1144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _utils = __webpack_require__(12);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _data = __webpack_require__(106);

var _utils2 = __webpack_require__(123);

var _constants = __webpack_require__(159);

/**
 * 
 * @param params
 */
function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      lineStyle = options.lineStyle,
      pointMapping = options.point;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData); // line geometry 

  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      line: {
        color: color,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  });
  (0, _geometries.line)(primary);
  (0, _geometries.point)(second);
  chart.axis(false);
  chart.legend(false); // scale

  (0, _common.scale)((_a = {}, _a[_constants.X_FIELD] = xAxis, _a[_constants.Y_FIELD] = yAxis, _a), (_b = {}, _b[_constants.X_FIELD] = {
    type: 'cat'
  }, _b[_constants.Y_FIELD] = (0, _data.adjustYMetaByZero)(seriesData, _constants.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(geometry, _common.theme, _common.tooltip, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyColumn = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(123);

var _adaptor = __webpack_require__(1146);

var _constants = __webpack_require__(1147);

var TinyColumn =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyColumn, _super);

  function TinyColumn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-column';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyColumn.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData((0, _utils.getTinyData)(data));
  };

  TinyColumn.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: (0, _tslib.__assign)({}, _constants.DEFAULT_TOOLTIP_OPTIONS),
      animation: true
    };
  };
  /**
   *   
   */


  TinyColumn.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return TinyColumn;
}(_plot.Plot);

exports.TinyColumn = TinyColumn;

/***/ }),
/* 1146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _constants = __webpack_require__(159);

var _utils2 = __webpack_require__(123);

var _data = __webpack_require__(106);

/**
 * 
 * @param params
 */
function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      columnStyle = options.columnStyle,
      columnWidthRatio = options.columnWidthRatio;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color
      }
    }
  });
  (0, _geometries.interval)(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction('element-active'); // scale

  (0, _common.scale)((_a = {}, _a[_constants.X_FIELD] = xAxis, _a[_constants.Y_FIELD] = yAxis, _a), (_b = {}, _b[_constants.X_FIELD] = {
    type: 'cat'
  }, _b[_constants.Y_FIELD] = (0, _data.adjustYMetaByZero)(seriesData, _constants.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(geometry, _common.tooltip, _common.theme, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_TOOLTIP_OPTIONS = void 0;

var _util = __webpack_require__(0);

var DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function customContent(x, data) {
    return "" + (0, _util.get)(data, [0, 'data', 'y'], 0);
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: '<span>{value}</span>',
  domStyles: {
    'g2-tooltip': {
      padding: '2px 4px',
      fontSize: '10px'
    }
  }
};
exports.DEFAULT_TOOLTIP_OPTIONS = DEFAULT_TOOLTIP_OPTIONS;

/***/ }),
/* 1148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TinyArea = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _constants = __webpack_require__(159);

var _utils = __webpack_require__(123);

var _adaptor = __webpack_require__(1149);

var TinyArea =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TinyArea, _super);

  function TinyArea() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'tiny-area';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  TinyArea.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    this.chart.changeData((0, _utils.getTinyData)(data));
  };

  TinyArea.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 2,
      tooltip: (0, _tslib.__assign)({}, _constants.DEFAULT_TOOLTIP_OPTIONS),
      // 
      color: 'l(90) 0:#E5EDFE 1:#ffffff',
      areaStyle: {
        fillOpacity: 0.6
      },
      line: {
        size: 1,
        color: '#5B8FF9'
      },
      animation: true
    };
  };
  /**
   *   
   */


  TinyArea.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return TinyArea;
}(_plot.Plot);

exports.TinyArea = TinyArea;

/***/ }),
/* 1149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _constants = __webpack_require__(159);

var _utils2 = __webpack_require__(123);

var _data = __webpack_require__(106);

/**
 * 
 * @param params
 */
function geometry(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      color = options.color,
      areaStyle = options.areaStyle,
      pointOptions = options.point,
      lineOptions = options.line;
  var seriesData = (0, _utils2.getTinyData)(data);
  chart.data(seriesData);
  var primary = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: _constants.X_FIELD,
      yField: _constants.Y_FIELD,
      area: {
        color: color,
        style: areaStyle
      },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = (0, _utils.deepAssign)({}, primary, {
    options: {
      tooltip: false
    }
  }); // area geometry 

  (0, _geometries.area)(primary);
  (0, _geometries.line)(second);
  (0, _geometries.point)(second);
  chart.axis(false);
  chart.legend(false); // scale

  (0, _common.scale)((_a = {}, _a[_constants.X_FIELD] = xAxis, _a[_constants.Y_FIELD] = yAxis, _a), (_b = {}, _b[_constants.X_FIELD] = {
    type: 'cat'
  }, _b[_constants.Y_FIELD] = (0, _data.adjustYMetaByZero)(seriesData, _constants.Y_FIELD), _b))(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(geometry, _common.tooltip, _common.theme, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Histogram = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _histogram = __webpack_require__(528);

var _adaptor = __webpack_require__(1151);

var Histogram =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Histogram, _super);

  function Histogram() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'histogram';
    return _this;
  }

  Histogram.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var _a = this.options,
        binField = _a.binField,
        binNumber = _a.binNumber,
        binWidth = _a.binWidth,
        stackField = _a.stackField;
    this.chart.changeData((0, _histogram.binHistogram)(data, binField, binWidth, binNumber, stackField));
  };

  Histogram.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      // @ts-ignore
      columnStyle: {
        stroke: '#FFFFFF'
      },
      tooltip: {
        shared: true,
        showMarkers: false
      },
      interactions: [{
        type: 'active-region'
      }]
    });
  };
  /**
   * 
   */


  Histogram.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Histogram;
}(_plot.Plot);

exports.Histogram = Histogram;

/***/ }),
/* 1151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _histogram = __webpack_require__(528);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      binField = options.binField,
      binNumber = options.binNumber,
      binWidth = options.binWidth,
      color = options.color,
      stackField = options.stackField,
      legend = options.legend,
      columnStyle = options.columnStyle; // 

  var plotData = (0, _histogram.binHistogram)(data, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: 'range',
      yField: 'count',
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color,
        style: columnStyle
      }
    }
  });
  (0, _geometries.interval)(p); // 

  if (legend && stackField) {
    chart.legend(stackField, legend);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis;
  return (0, _utils.flow)((0, _common.scale)({
    range: xAxis,
    count: yAxis
  }))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis; //  false 

  if (xAxis === false) {
    chart.axis('range', false);
  } else {
    chart.axis('range', xAxis);
  }

  if (yAxis === false) {
    chart.axis('count', false);
  } else {
    chart.axis('count', yAxis);
  }

  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label;
  var geometry = (0, _utils.findGeometry)(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: ['count'],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, axis, _common.theme, label, _common.tooltip, _common.interaction, _common.animation)(params);
}

/***/ }),
/* 1152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Progress = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(529);

var _constant = __webpack_require__(530);

var _utils = __webpack_require__(298);

var Progress =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Progress, _super);

  function Progress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'process';
    return _this;
  }

  Progress.prototype.getDefaultOptions = function () {
    return {
      percent: 0.2,
      color: _constant.DEFAULT_COLOR,
      animation: true
    };
  };
  /**
   * 
   * @param percent
   */


  Progress.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.changeData((0, _utils.getProgressData)(percent));
  };
  /**
   *   
   */


  Progress.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Progress;
}(_plot.Plot);

exports.Progress = Progress;

/***/ }),
/* 1153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RingProgress = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(298);

var _adaptor = __webpack_require__(1154);

var RingProgress =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RingProgress, _super);

  function RingProgress() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'ring-process';
    return _this;
  }

  RingProgress.prototype.getDefaultOptions = function () {
    return {
      percent: 0.2,
      innerRadius: 0.8,
      radius: 0.98,
      color: ['#FAAD14', '#E8EDF3'],
      statistic: {
        title: false,
        content: {
          style: {
            fontSize: '14px',
            fontWeight: 300,
            fill: '#4D4D4D',
            textAlign: 'center',
            textBaseline: 'middle'
          },
          formatter: function formatter(_a) {
            var percent = _a.percent;
            return (percent * 100).toFixed(2) + "%";
          }
        }
      },
      animation: true
    };
  };
  /**
   * 
   * @param percent
   */


  RingProgress.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.data((0, _utils.getProgressData)(percent)); // todo  G2  afterrender  annotations

    (0, _adaptor.statistic)({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   *   
   */


  RingProgress.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return RingProgress;
}(_plot.Plot);

exports.RingProgress = RingProgress;

/***/ }),
/* 1154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.statistic = statistic;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _common = __webpack_require__(25);

var _adaptor = __webpack_require__(529);

var _constant = __webpack_require__(196);

/**
 * coordinate 
 * @param params
 */
function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      radius = options.radius; // coordinate

  chart.coordinate('theta', {
    innerRadius: innerRadius,
    radius: radius
  });
  return params;
}
/**
 * statistic 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      statistic = options.statistic,
      percent = options.percent,
      meta = options.meta; // 

  chart.getController('annotation').clear(true);
  /**   */

  if (innerRadius && statistic) {
    var transformContent = statistic.content;

    if (transformContent && !transformContent.formatter) {
      // @ts-ignore
      transformContent.formatter = function (_a) {
        var percent = _a.percent;
        var metaFormatter = (0, _util.get)(meta, [_constant.PERCENT, 'formatter']);

        if (metaFormatter) {
          return metaFormatter(percent);
        }

        return percent;
      };
    }

    (0, _utils.renderStatistic)(chart, {
      statistic: (0, _tslib.__assign)((0, _tslib.__assign)({}, statistic), {
        content: transformContent
      }),
      plotType: 'ring-progress'
    }, {
      percent: percent
    });
  }

  if (updated) {
    chart.render(true);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(_adaptor.geometry, (0, _common.scale)({}), coordinate, statistic, _common.animation, _common.theme, (0, _common.annotation)())(params);
}

/***/ }),
/* 1155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Heatmap = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1156);

__webpack_require__(1157);

__webpack_require__(1158);

// registered shapes
var Heatmap =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Heatmap, _super);

  function Heatmap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'heatmap';
    return _this;
  }
  /**
   * 
   */


  Heatmap.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  Heatmap.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      type: 'polygon',
      legend: false,
      xAxis: {
        tickLine: null,
        line: null,
        grid: {
          alignTick: false,
          line: {
            style: {
              lineWidth: 1,
              lineDash: null,
              stroke: '#f0f0f0'
            }
          }
        }
      },
      yAxis: {
        grid: {
          alignTick: false,
          line: {
            style: {
              lineWidth: 1,
              lineDash: null,
              stroke: '#f0f0f0'
            }
          }
        }
      }
    });
  };

  return Heatmap;
}(_plot.Plot);

exports.Heatmap = Heatmap;

/***/ }),
/* 1156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(121);

var _common = __webpack_require__(25);

/**
 * 
 * @param params
 */
function field(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      type = options.type,
      reflect = options.reflect,
      xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      sizeField = options.sizeField,
      sizeRatio = options.sizeRatio,
      shape = options.shape,
      color = options.color;
  chart.data(data);
  var geometry;

  if (type === 'density') {
    geometry = chart.heatmap().position(xField + "*" + yField);
  } else {
    geometry = chart.polygon().position(xField + "*" + yField);
  }

  if (colorField) {
    geometry.color(colorField, color || _constant.DEFAULT_COLORS.GRADIENT.CONTINUOUS);
  }

  if (reflect) {
    chart.coordinate().reflect(reflect);
  }
  /**
   * The ratio between the actual size and the max available size, must be in range `[0,1]`.
   *
   * If the `sizeRatio` attribute is undefined or it exceeds the range,
   * `checkedSizeRatio` would be set to 1 as default.
   */


  var checkedSizeRatio = 1;

  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn('sizeRatio is not in effect: Must define shape or sizeField first');
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn('sizeRatio is not in effect: It must be a number in [0,1]');
    } else {
      checkedSizeRatio = sizeRatio;
    }
  } // when it has to change shape from original rect


  if (shape) {
    // just to change shape in cell
    if (!sizeField) {
      geometry.shape('', function () {
        return [shape, 1, checkedSizeRatio];
      });
    } // specific shape in different size


    if (sizeField) {
      var field_1 = data.map(function (row) {
        return row[sizeField];
      });
      var min_1 = Math.min.apply(Math, field_1);
      var max_1 = Math.max.apply(Math, field_1);
      geometry.shape(sizeField, function (v) {
        return [shape, (v - min_1) / (max_1 - min_1), checkedSizeRatio];
      });
    }
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      colorField = options.colorField;

  if (legend) {
    chart.legend(colorField, legend);
  } else {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function style(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      colorField = options.colorField,
      sizeField = options.sizeField,
      heatmapStyle = options.heatmapStyle;
  var geometry = chart.geometries[0];

  if (heatmapStyle && geometry) {
    if ((0, _util.isFunction)(heatmapStyle)) {
      geometry.style(xField + "*" + yField + "*" + colorField + "*" + sizeField, heatmapStyle);
    } else if ((0, _util.isObject)(heatmapStyle)) {
      geometry.style(heatmapStyle);
    }
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      colorField = options.colorField,
      type = options.type;
  var geometry = (0, _utils.findGeometry)(chart, type === 'density' ? 'heatmap' : 'polygon');

  if (!label) {
    geometry.label(false);
  } else if (colorField) {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [colorField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(field, meta, _common.theme, axis, legend, _common.tooltip, style, label, (0, _common.annotation)(), _common.interaction, _common.animation)(params);
}

/***/ }),
/* 1157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

(0, _g.registerShape)('polygon', 'circle', {
  draw: function draw(cfg, group) {
    var _a, _b;

    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value);
    var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon = group.addShape('circle', {
      attrs: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({
        x: cx,
        y: cy,
        r: radius
      }, cfg.defaultStyle), cfg.style), {
        fill: fill
      })
    });
    return polygon;
  }
});

/***/ }),
/* 1158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

(0, _g.registerShape)('polygon', 'square', {
  draw: function draw(cfg, group) {
    var _a, _b;

    var cx = cfg.x;
    var cy = cfg.y;
    var points = this.parsePoints(cfg.points);
    var width = Math.abs(points[2].x - points[1].x);
    var height = Math.abs(points[1].y - points[0].y);
    var maxSideLength = Math.min(width, height);
    var value = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value);
    var fill = ((_a = cfg.style) === null || _a === void 0 ? void 0 : _a.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon = group.addShape('rect', {
      attrs: (0, _tslib.__assign)((0, _tslib.__assign)((0, _tslib.__assign)({
        x: cx - sideLength / 2,
        y: cy - sideLength / 2,
        width: sideLength,
        height: sideLength
      }, cfg.defaultStyle), cfg.style), {
        fill: fill
      })
    });
    return polygon;
  }
});

/***/ }),
/* 1159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Box = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1160);

var _constant = __webpack_require__(531);

var Box =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Box, _super);

  function Box() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'box';
    return _this;
  }
  /**
   *   
   */


  Box.prototype.getDefaultOptions = function () {
    var _a;

    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      meta: (_a = {}, _a[_constant.BOX_RANGE] = {
        min: 0,
        alias: _constant.BOX_RANGE_ALIAS
      }, _a),
      // 
      interactions: [{
        type: 'active-region'
      }],
      //  tooltips  markers
      tooltip: {
        showMarkers: false,
        showCrosshairs: true,
        shared: true
      }
    });
  };
  /**
   *   
   */


  Box.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Box;
}(_plot.Plot);

exports.Box = Box;

/***/ }),
/* 1160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.legend = legend;
exports.tooltip = tooltip;
exports.adaptor = adaptor;

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(121);

var _constant2 = __webpack_require__(531);

/**
 * 
 * @param params
 */
function field(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      groupField = options.groupField,
      color = options.color;
  var yFieldName = Array.isArray(yField) ? _constant2.BOX_RANGE : yField;
  var geometry = chart.schema().position(xField + "*" + yFieldName).shape('box'); // set group field as color channel

  if (groupField) {
    geometry.color(groupField, color).adjust('dodge');
  } // formate data when `yField` is Array


  var data = options.data;

  if (Array.isArray(yField)) {
    var low_1 = yField[0],
        q1_1 = yField[1],
        median_1 = yField[2],
        q3_1 = yField[3],
        high_1 = yField[4];
    data = (0, _util.map)(data, function (obj) {
      obj[_constant2.BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }

  chart.data(data);
  return params;
}

function outliersPoint(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      data = options.data,
      outliersField = options.outliersField,
      outliersStyle = options.outliersStyle,
      padding = options.padding;
  if (!outliersField) return params;
  var outliersView = chart.createView({
    padding: padding
  });
  outliersView.data(data);
  outliersView.axis(false);
  var geometry = outliersView.point().position(xField + "*" + outliersField).shape('circle');
  /**
   * style 
   * g.style({ fill: 'red' });
   * g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
   */

  if ((0, _util.isFunction)(outliersStyle)) {
    geometry.style(xField + "*" + outliersField, function (_x, _outliers) {
      var _a;

      return outliersStyle((_a = {}, _a[xField] = _x, _a[outliersField] = _outliers, _a));
    });
  } else if ((0, _util.isObject)(outliersStyle)) {
    geometry.style(outliersStyle);
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var meta = options.meta,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      outliersField = options.outliersField;
  var yFieldName = Array.isArray(yField) ? _constant2.BOX_RANGE : yField;
  var baseMeta = {}; // make yField and outliersField share y mate

  if (outliersField) {
    var syncName = _constant2.BOX_SYNC_NAME;
    baseMeta = (_a = {}, _a[outliersField] = {
      sync: syncName
    }, _a[yFieldName] = {
      sync: syncName
    }, _a);
  }

  var scales = (0, _utils.deepAssign)(baseMeta, meta, (_b = {}, _b[xField] = (0, _utils.pick)(xAxis, _constant.AXIS_META_CONFIG_KEYS), _b[yFieldName] = (0, _utils.pick)(yAxis, _constant.AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  var yFieldName = Array.isArray(yField) ? _constant2.BOX_RANGE : yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(_constant2.BOX_RANGE, false);
  } else {
    chart.axis(yFieldName, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      groupField = options.groupField;

  if (groupField) {
    if (legend) {
      chart.legend(groupField, legend);
    } else {
      // Grouped Box Chart default has legend, and it's position is `bottom`
      chart.legend(groupField, {
        position: 'bottom'
      });
    }
  } else {
    chart.legend(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function style(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      boxStyle = options.boxStyle;
  var geometry = (0, _utils.findGeometry)(chart, 'schema');
  var yFieldName = Array.isArray(yField) ? _constant2.BOX_RANGE : yField;
  /**
   * style 
   * g.style({ fill: 'red' });
   * g.style('x*y*color', (x, y, color) => ({ fill: 'red' }));
   */

  if ((0, _util.isFunction)(boxStyle)) {
    geometry.style(xField + "*" + yFieldName, function (_x, _y) {
      var _a;

      return boxStyle((_a = {}, _a[xField] = _x, _a[yFieldName] = _y, _a));
    });
  } else if ((0, _util.isObject)(boxStyle)) {
    geometry.style(boxStyle);
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip;

  if (tooltip !== undefined) {
    chart.tooltip(tooltip);
  }

  return params;
}
/**
 * 
 * @param params
 */


function adaptor(params) {
  return (0, _utils.flow)(field, outliersPoint, meta, axis, style, legend, tooltip, _common.interaction, _common.animation, _common.theme)(params);
}

/***/ }),
/* 1161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Stock = void 0;

var _tslib = __webpack_require__(1);

var _utils = __webpack_require__(12);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1162);

var _utils2 = __webpack_require__(532);

var _constant = __webpack_require__(299);

var Stock =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Stock, _super);

  function Stock() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'stock';
    return _this;
  }
  /**
   * 
   *  g2/g2plot    -->         -->          -->      
   */


  Stock.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      //  tooltips
      tooltip: _constant.DEFAULT_TOOLTIP_OPTIONS,
      interactions: [{
        type: 'tooltip'
      }],
      legend: {
        position: 'top-left'
      }
    });
  };
  /**
   *   
   */


  Stock.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  /**
   * @override
   * @param data
   */


  Stock.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });
    var yField = this.options.yField;
    this.chart.changeData((0, _utils2.getStockData)(data, yField));
  };

  return Stock;
}(_plot.Plot);

exports.Stock = Stock;

/***/ }),
/* 1162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = meta;
exports.axis = axis;
exports.tooltip = tooltip;
exports.legend = legend;
exports.adaptor = adaptor;

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(121);

var _constant2 = __webpack_require__(299);

var _utils2 = __webpack_require__(532);

/**
 * 
 * @param params
 */
function field(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField;
  var data = options.data;
  chart.data((0, _utils2.getStockData)(data, yField));
  var geometry = chart.schema().position(xField + "*" + _constant2.Y_FIELD).shape('candle');
  geometry.color(_constant2.TREND_FIELD, _constant2.TREND_COLOR);
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var chart = params.chart,
      options = params.options;
  var meta = options.meta,
      xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField;
  var baseMeta = (_a = {}, _a[xField] = {
    type: 'timeCat',
    tickCount: 6
  }, _a[_constant2.TREND_FIELD] = {
    values: [_constant2.TREND_UP, _constant2.TREND_DOWN]
  }, _a);
  var scales = (0, _utils.deepAssign)(baseMeta, meta, (_b = {}, _b[xField] = (0, _utils.pick)(xAxis, _constant.AXIS_META_CONFIG_KEYS), _b[_constant2.Y_FIELD] = (0, _utils.pick)(yAxis, _constant.AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(_constant2.Y_FIELD, false);
  } else {
    chart.axis(_constant2.Y_FIELD, yAxis);
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      _a = options.meta,
      meta = _a === void 0 ? {} : _a,
      _b = options.tooltip,
      tooltip = _b === void 0 ? {} : _b;
  var geometry = (0, _utils.findGeometry)(chart, 'schema');
  var open = yField[0],
      close = yField[1],
      high = yField[2],
      low = yField[3];
  var openAlias = meta[open] ? meta[open].alias || open : open;
  var closeAlias = meta[close] ? meta[close].alias || open : close;
  var highAlias = meta[high] ? meta[high].alias || high : high;
  var lowAlias = meta[low] ? meta[low].alias || low : low; // geomtooltip

  var baseGeomTooltipOptions = {
    fields: [xField, open, close, high, low],
    callback: function callback(xFieldVal, openVal, closeVal, highVal, lowVal) {
      var tpl = {
        name: xFieldVal,
        value: "\n          <br><span data-label=\"" + openAlias + "\" style=\"padding-left: 16px\">" + openAlias + "\uFF1A" + openVal + "</span>\n          <br><span data-label=\"" + closeAlias + "\" style=\"padding-left: 16px\">" + closeAlias + "\uFF1A" + closeVal + "</span>\n          <br><span data-label=\"" + highAlias + "\" style=\"padding-left: 16px\">" + highAlias + "\uFF1A" + highVal + "</span>\n          <br><span data-label=\"" + lowAlias + "\" style=\"padding-left: 16px\">" + lowAlias + "\uFF1A" + lowVal + "</span>\n        "
      };
      return tpl;
    }
  }; // charttooltip text

  var baseTooltipOptions = {
    crosshairs: {
      text: function text(type, defaultContent, items) {
        var tooltipCrosshairsText = {
          position: 'end'
        };

        if (type === 'x') {
          var item = items[0];
          tooltipCrosshairsText['content'] = item ? item.data[xField] : defaultContent;
        } else {
          tooltipCrosshairsText['content'] = defaultContent;
        }

        return tooltipCrosshairsText;
      }
    }
  };

  if (tooltip) {
    if ((0, _util.isObject)(tooltip)) {
      var chartTooltip = (0, _utils.deepAssign)({}, baseTooltipOptions, tooltip);
      chart.tooltip(chartTooltip);
      geometry.tooltip(baseGeomTooltipOptions);
    }
  } else {
    chart.tooltip(false);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend;

  if (legend) {
    chart.legend(_constant2.TREND_FIELD, legend);
  } else if (legend === false) {
    chart.legend(false);
  }

  return params;
}
/**
 * K
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  (0, _utils.flow)(field, meta, _common.theme, axis, tooltip, legend, _common.interaction, _common.animation)(params);
}

/***/ }),
/* 1163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "FUNNEL_CONVERSATION_FIELD", {
  enumerable: true,
  get: function get() {
    return _constant.FUNNEL_CONVERSATION;
  }
});
exports.Funnel = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1164);

var _constant = __webpack_require__(124);

var Funnel =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Funnel, _super);

  function Funnel() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'funnel';
    return _this;
  }
  /**
   *   
   */


  Funnel.prototype.getDefaultOptions = function () {
    //  defaultOption  core.getDefaultOptions funnel  defaulOption  adaptor  defaultOption 
    return {
      appendPadding: [0, 80]
    };
  };
  /**
   *   
   */


  Funnel.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Funnel;
}(_plot.Plot);

exports.Funnel = Funnel;

/***/ }),
/* 1164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = meta;
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _conversion = __webpack_require__(520);

var _basic = __webpack_require__(533);

var _compare = __webpack_require__(1165);

var _facet = __webpack_require__(1166);

var _dynamicHeight = __webpack_require__(1167);

var _constant = __webpack_require__(124);

/**
 *
 * geometry,
 * 1. interval.shape('funnel')
 * 2. 
 * 3. polypon
 * 4.  + list 
* /

/**
 * options 
 * @param params
 */
function defaultOptions(params) {
  var _a;

  var options = params.options;
  var compareField = options.compareField,
      xField = options.xField,
      yField = options.yField;
  var defaultOption = {
    minSize: 0,
    maxSize: 1,
    meta: (_a = {}, _a[_constant.FUNNEL_MAPPING_VALUE] = {
      min: 0,
      max: 1,
      nice: false
    }, _a),
    label: compareField ? {
      fields: [xField, yField, compareField, _constant.FUNNEL_PERCENT, _constant.FUNNEL_CONVERSATION],
      style: {
        fill: '#fff',
        fontSize: 12
      },
      formatter: function formatter(datum) {
        return "" + datum[yField];
      }
    } : {
      fields: [xField, yField, _constant.FUNNEL_PERCENT, _constant.FUNNEL_CONVERSATION],
      offset: 0,
      position: 'middle',
      style: {
        fill: '#fff',
        fontSize: 12
      },
      formatter: function formatter(datum) {
        return datum[xField] + " " + datum[yField];
      }
    },
    tooltip: {
      showTitle: false,
      showMarkers: false,
      shared: false,
      title: xField,
      formatter: function formatter(datum) {
        return {
          name: datum[xField],
          value: datum[yField]
        };
      }
    },
    conversionTag: {
      offsetX: 10,
      offsetY: 0,
      style: {},
      // conversionTag 
      formatter: function formatter(datum) {
        return "\u8F6C\u5316\u7387: " + _conversion.conversionTagFormatter.apply(void 0, datum[_constant.FUNNEL_CONVERSATION]);
      }
    }
  };
  return (0, _utils.deepAssign)({
    options: defaultOption
  }, params);
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var options = params.options;
  var compareField = options.compareField,
      dynamicHeight = options.dynamicHeight,
      seriesField = options.seriesField;

  if (seriesField) {
    return (0, _facet.facetFunnel)(params);
  }

  if (compareField) {
    return (0, _compare.compareFunnel)(params);
  }

  if (dynamicHeight) {
    return (0, _dynamicHeight.dynamicHeightFunnel)(params);
  }

  return (0, _basic.basicFunnel)(params);
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a)))(params);
}
/**
 * 
 * @param params
 */


function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend;

  if (legend === false) {
    chart.legend(false);
  } else {
    chart.legend(legend); // TODO FIX: legend-click 
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(defaultOptions, geometry, meta, axis, _common.tooltip, _common.interaction, legend, _common.animation, _common.theme, (0, _common.annotation)())(params);
}

/***/ }),
/* 1165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compareFunnel = compareFunnel;

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _tooltip = __webpack_require__(90);

var _base = __webpack_require__(78);

var _constant = __webpack_require__(124);

var _common = __webpack_require__(300);

/**
 * 
 * @param params
 */
function field(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var _b = options.data,
      data = _b === void 0 ? [] : _b,
      yField = options.yField; // 

  chart.data(data);
  chart.scale((_a = {}, _a[yField] = {
    sync: true
  }, _a));
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xField = options.xField,
      yField = options.yField,
      color = options.color,
      compareField = options.compareField,
      isTransposed = options.isTransposed,
      tooltip = options.tooltip,
      maxSize = options.maxSize,
      minSize = options.minSize,
      label = options.label;
  chart.facet('mirror', {
    fields: [compareField],
    // 
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    eachView: function eachView(view, facet) {
      var index = isTransposed ? facet.rowIndex : facet.columnIndex;

      if (!isTransposed) {
        view.coordinate({
          type: 'rect',
          actions: [['transpose'], ['scale', index === 0 ? -1 : 1, -1]]
        });
      }

      var formatterData = (0, _common.transformData)(facet.data, data, {
        yField: yField,
        maxSize: maxSize,
        minSize: minSize
      });
      view.data(formatterData); // 

      var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField, compareField]),
          fields = _a.fields,
          formatter = _a.formatter;

      var defaultFacetLabel = isTransposed ? {
        offset: index === 0 ? 10 : -23,
        position: index === 0 ? 'bottom' : 'top'
      } : {
        offset: 10,
        position: 'left',
        style: {
          textAlign: index === 0 ? 'end' : 'start'
        }
      };
      (0, _base.geometry)({
        chart: view,
        options: {
          type: 'interval',
          xField: xField,
          yField: _constant.FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: (0, _util.isArray)(fields) && fields.concat([_constant.FUNNEL_PERCENT, _constant.FUNNEL_CONVERSATION]),
          mapping: {
            shape: 'funnel',
            tooltip: formatter,
            color: color,
            style: {
              lineWidth: 1,
              stroke: '#fff'
            }
          },
          label: label === false ? false : (0, _utils.deepAssign)({}, defaultFacetLabel, label)
        }
      });
    }
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var chart = params.chart,
      options = params.options;
  var conversionTag = options.conversionTag,
      isTransposed = options.isTransposed;
  chart.once('beforepaint', function () {
    chart.views.forEach(function (view, viewIndex) {
      var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
        var ratio = viewIndex === 0 ? -1 : 1;
        return (0, _utils.deepAssign)({}, initLineOption, {
          start: [datumIndex - 0.5, datum[_constant.FUNNEL_MAPPING_VALUE]],
          end: [datumIndex - 0.5, datum[_constant.FUNNEL_MAPPING_VALUE] + 0.05],
          text: isTransposed ? {
            style: {
              textAlign: 'start'
            }
          } : {
            offsetX: conversionTag !== false ? ratio * conversionTag.offsetX : 0,
            style: {
              textAlign: viewIndex === 0 ? 'end' : 'start'
            }
          }
        });
      };

      (0, _common.conversionTagComponent)(getLineCoordinate)((0, _utils.deepAssign)({}, {
        chart: view,
        options: options
      }));
    });
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function compareFunnel(params) {
  return (0, _utils.flow)(field, geometry, conversionTag)(params);
}

/***/ }),
/* 1166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.facetFunnel = facetFunnel;

var _utils = __webpack_require__(12);

var _basic = __webpack_require__(533);

/**
 * 
 * @param params
 */
function field(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var _b = options.data,
      data = _b === void 0 ? [] : _b,
      yField = options.yField; // 

  chart.data(data);
  chart.scale((_a = {}, _a[yField] = {
    sync: true
  }, _a));
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var seriesField = options.seriesField,
      isTransposed = options.isTransposed;
  chart.facet('rect', {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    eachView: function eachView(view, facet) {
      (0, _basic.basicFunnel)((0, _utils.deepAssign)({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function facetFunnel(params) {
  return (0, _utils.flow)(field, geometry)(params);
}

/***/ }),
/* 1167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dynamicHeightFunnel = dynamicHeightFunnel;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(124);

var _base = __webpack_require__(78);

var _tooltip = __webpack_require__(90);

var _common = __webpack_require__(300);

/**
 * 
 * @param params
 * :  yfield 2 2
 * :  g2 data ->  -> 
 *  -0.5 <= x <= 0.5, 0 <= y <= 1 
 * ,  x 
 *  data.length + 1  y = 4x - 1 [0.5, 1], [0.25, 0] data  y  y 
 */

/**
 * 
 * @param params
 */
function field(params) {
  var chart = params.chart,
      options = params.options;
  var _a = options.data,
      data = _a === void 0 ? [] : _a,
      yField = options.yField; // 

  var sum = (0, _util.reduce)(data, function (total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max = (0, _util.maxBy)(data, yField)[yField];
  var formatData = (0, _util.map)(data, function (row, index) {
    //  xy  [, ]
    var x = [];
    var y = [];
    row[_constant.FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum; // 

    if (index) {
      var preItemX = data[index - 1][_constant.PLOYGON_X];
      var preItemY = data[index - 1][_constant.PLOYGON_Y];
      x[0] = preItemX[3];
      y[0] = preItemY[3];
      x[1] = preItemX[2];
      y[1] = preItemY[2];
    } else {
      x[0] = -0.5;
      y[0] = 1;
      x[1] = 0.5;
      y[1] = 1;
    } // 


    y[2] = y[1] - row[_constant.FUNNEL_TOTAL_PERCENT];
    x[2] = (y[2] + 1) / 4;
    y[3] = y[2];
    x[3] = -x[2]; // 

    row[_constant.PLOYGON_X] = x;
    row[_constant.PLOYGON_Y] = y;
    row[_constant.FUNNEL_PERCENT] = (row[yField] || 0) / max;
    row[_constant.FUNNEL_CONVERSATION] = [(0, _util.get)(data, [index - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
/**
 * geometry
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      yField = options.yField,
      color = options.color,
      tooltip = options.tooltip,
      label = options.label;

  var _a = (0, _tooltip.getTooltipMapping)(tooltip, [xField, yField]),
      fields = _a.fields,
      formatter = _a.formatter; // 


  (0, _base.geometry)({
    chart: chart,
    options: {
      type: 'polygon',
      xField: _constant.PLOYGON_X,
      yField: _constant.PLOYGON_Y,
      colorField: xField,
      tooltipFields: (0, _util.isArray)(fields) && fields.concat([_constant.FUNNEL_PERCENT, _constant.FUNNEL_CONVERSATION]),
      label: label,
      mapping: {
        tooltip: formatter,
        color: color
      }
    }
  });
  return params;
}
/**
 * 
 * @param params
 */


function transpose(params) {
  var chart = params.chart,
      options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: 'rect',
    actions: isTransposed ? [['transpose'], ['reflect', 'x']] : []
  });
  return params;
}
/**
 * 
 * @param params
 */


function conversionTag(params) {
  var getLineCoordinate = function getLineCoordinate(datum, datumIndex, data, initLineOption) {
    return (0, _tslib.__assign)((0, _tslib.__assign)({}, initLineOption), {
      start: [datum[_constant.PLOYGON_X][1], datum[_constant.PLOYGON_Y][1]],
      end: [datum[_constant.PLOYGON_X][1] + 0.05, datum[_constant.PLOYGON_Y][1]]
    });
  };

  (0, _common.conversionTagComponent)(getLineCoordinate)(params);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function dynamicHeightFunnel(params) {
  return (0, _utils.flow)(field, geometry, transpose, conversionTag)(params);
}

/***/ }),
/* 1168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Liquid = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1169);

var _utils = __webpack_require__(534);

__webpack_require__(1170);

// register liquid shape

/**
 * 
 */
var Liquid =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Liquid, _super);

  function Liquid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'liquid';
    return _this;
  }

  Liquid.prototype.getDefaultOptions = function () {
    return {
      color: '#6a99f9',
      radius: 0.9,
      statistic: {
        title: false,
        content: {
          formatter: function formatter(_a) {
            var percent = _a.percent;
            return (percent * 100).toFixed(2) + "%";
          },
          style: {
            opacity: 0.75,
            fontSize: '30px',
            lineHeight: '30px',
            textAlign: 'center'
          }
        }
      },
      outline: {
        border: 2,
        distance: 0
      },
      wave: {
        count: 3,
        length: 192
      }
    };
  };
  /**
   * 
   * @param percent
   */


  Liquid.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    this.chart.data((0, _utils.getLiquidData)(percent));
    (0, _adaptor.statistic)({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   * 
   */


  Liquid.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Liquid;
}(_plot.Plot);

exports.Liquid = Liquid;

/***/ }),
/* 1169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.statistic = statistic;
exports.adaptor = adaptor;

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _utils2 = __webpack_require__(534);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      color = options.color,
      liquidStyle = options.liquidStyle,
      radius = options.radius,
      outline = options.outline,
      wave = options.wave;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data((0, _utils2.getLiquidData)(percent));
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: 'type',
      yField: 'percent',
      // radius  columnWidthRatio 
      //   redius 
      widthRatio: radius,
      interval: {
        color: color,
        style: liquidStyle,
        shape: 'liquid-fill-gauge'
      }
    }
  });
  var ext = (0, _geometries.interval)(p).ext;
  var geometry = ext.geometry; //  radius  shape 

  geometry.customInfo({
    radius: radius,
    outline: outline,
    wave: wave
  }); // 

  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
/**
 * 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var statistic = options.statistic,
      percent = options.percent,
      meta = options.meta; // 

  chart.getController('annotation').clear(true);

  if (statistic.content && !statistic.content.formatter) {
    var metaFormatter_1 = (0, _util.get)(meta, ['percent', 'formatter']); // @ts-ignore

    statistic.content.formatter = function (_a) {
      var percent = _a.percent;
      return metaFormatter_1 ? metaFormatter_1(percent) : (percent * 100).toFixed(2) + "%";
    };
  }

  (0, _utils.renderStatistic)(chart, {
    statistic: statistic,
    plotType: 'liquid'
  }, {
    percent: percent
  });

  if (updated) {
    chart.render(true);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, statistic, (0, _common.scale)({}), _common.animation, _common.theme, _common.interaction)(params);
}

/***/ }),
/* 1170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _matrix = __webpack_require__(523);

var DURATION = 5000;
/**
 * 
 * @param min
 * @param max
 * @param factor
 */

function lerp(min, max, factor) {
  return min + (max - min) * factor;
}
/**
 *  attrs
 * @param cfg
 */


function getFillAttrs(cfg) {
  var attrs = (0, _tslib.__assign)({
    opacity: 1
  }, cfg.style);

  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }

  return attrs;
}
/**
 *  attrs
 * @param cfg
 */


function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: '#fff',
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = (0, _util.mix)({}, defaultAttrs, cfg.style);

  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }

  if ((0, _util.isNumber)(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }

  return attrs;
}
/**
 * 
 * Using Bezier curves to fit sine wave.
 * There is 4 control points for each curve of wave,
 * which is at 1/4 wave length of the sine wave.
 *
 * The control points for a wave from (a) to (d) are a-b-c-d:
 *          c *----* d
 *     b *
 *       |
 * ... a * ..................
 *
 * whose positions are a: (0, 0), b: (0.5, 0.5), c: (1, 1), d: (PI / 2, 1)
 *
 * @param x          x position of the left-most point (a)
 * @param stage      0-3, stating which part of the wave it is
 * @param waveLength wave length of the sine wave
 * @param amplitude  wave amplitude
 * @return 
 */


function getWaterWavePositions(x, stage, waveLength, amplitude) {
  if (stage === 0) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, amplitude], [x + waveLength / 4, amplitude]];
  }

  if (stage === 1) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude / 2], [x + waveLength / 4, 0]];
  }

  if (stage === 2) {
    return [[x + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2], [x + 1 / 2 * waveLength / Math.PI, -amplitude], [x + waveLength / 4, -amplitude]];
  }

  return [[x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude], [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude / 2], [x + waveLength / 4, 0]];
}
/**
 * 
 * @param radius          
 * @param waterLevel      
 * @param waveLength      
 * @param phase           
 * @param amplitude       
 * @param cx              x
 * @param cy              y
 * @return path            
 * @reference http://gitlab.alipay-inc.com/datavis/g6/blob/1.2.0/src/graph/utils/path.js#L135
 */


function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path = [];
  var _phase = phase; // map phase to [-Math.PI * 2, 0]

  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }

  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }

  _phase = _phase / Math.PI / 2 * waveLength;
  var left = cx - radius + _phase - radius * 2;
  /**
   * top-left corner as start point
   *
   * draws this point
   *  |
   * \|/
   *  ~~~~~~~~
   *  |      |
   *  +------+
   */

  path.push(['M', left, waterLevel]);
  /**
   * top wave
   *
   * ~~~~~~~~ <- draws this sine wave
   * |      |
   * +------+
   */

  var waveRight = 0;

  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude);
    path.push(['C', pos[0][0] + left, -pos[0][1] + waterLevel, pos[1][0] + left, -pos[1][1] + waterLevel, pos[2][0] + left, -pos[2][1] + waterLevel]);

    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  /**
   * top-right corner
   *
   *                       ~~~~~~~~
   * 3. draws this line -> |      | <- 1. draws this line
   *                       +------+
   *                          ^
   *                          |
   *                  2. draws this line
   */


  path.push(['L', waveRight + left, cy + radius]);
  path.push(['L', left, cy + radius]);
  path.push(['Z']); // path.push(['L', left, waterLevel]);

  return path;
}
/**
 * 
 * @param x           x
 * @param y           y
 * @param level        01
 * @param waveCount   
 * @param waveAttrs      
 * @param group       
 * @param clip        
 * @param radius      
 * @param waveLength  
 */


function addWaterWave(x, y, level, waveCount, waveAttrs, group, clip, radius, waveLength) {
  var fill = waveAttrs.fill,
      opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;

  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 0 : idx / (waveCount - 1);
    var wave = group.addShape('path', {
      name: "waterwave-path",
      attrs: {
        path: getWaterWavePath(radius, bbox.minY + height * level, waveLength, 0, width / 32, // 
        x, y),
        fill: fill,
        opacity: lerp(0.2, 0.9, factor) * opacity
      }
    });

    try {
      var matrix = (0, _matrix.transform)([['t', waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({
        matrix: matrix
      }, {
        duration: lerp(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e) {
      // TODO off-screen canvas  canvas
      console.warn('off-screen group animate error!');
    }
  }
}

(0, _g.registerShape)('interval', 'liquid-fill-gauge', {
  draw: function draw(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var radio = customInfo.radius;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border,
        distance = outline.distance;
    var waveCount = wave.count,
        waveLength = wave.length; //  minX

    var minX = (0, _util.reduce)(cfg.points, function (r, p) {
      return Math.min(r, p.x);
    }, Infinity);
    var center = this.parsePoint({
      x: cx,
      y: cy
    });
    var minXPoint = this.parsePoint({
      x: minX,
      y: cy
    });
    var halfWidth = center.x - minXPoint.x; //   radius 

    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs(cfg);
    var circleAttrs = getLineAttrs(cfg); // 1. 

    container.addShape('circle', {
      name: 'wrap',
      attrs: (0, _util.mix)(circleAttrs, {
        x: center.x,
        y: center.y,
        r: radius,
        fill: 'transparent',
        lineWidth: border
      })
    }); // 2.  group

    var waves = container.addGroup({
      name: 'waves'
    }); // 3.  clip 

    var clipCircle = waves.setClip({
      type: 'circle',
      attrs: {
        x: center.x,
        y: center.y,
        r: radius - distance - border / 2
      }
    }); // 4. 

    addWaterWave(center.x, center.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipCircle, radius * 2, waveLength);
    return container;
  }
});

/***/ }),
/* 1171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Bullet = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1172);

var _utils2 = __webpack_require__(535);

var Bullet =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Bullet, _super);

  function Bullet() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'bullet';
    return _this;
  }

  Bullet.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    });

    var _a = (0, _utils2.transformData)(this.options),
        min = _a.min,
        max = _a.max,
        ds = _a.ds; // scale


    (0, _adaptor.meta)({
      options: this.options,
      ext: {
        data: {
          min: min,
          max: max
        }
      },
      chart: this.chart
    });
    this.chart.changeData(ds);
  };
  /**
   * 
   */


  Bullet.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  Bullet.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      layout: 'horizontal',
      size: {
        range: 30,
        measure: 20,
        target: 20
      },
      xAxis: {
        tickLine: false,
        line: null
      },
      bulletStyle: {
        range: {
          fillOpacity: 0.5
        }
      },
      label: {
        measure: {
          position: 'right'
        }
      },
      tooltip: {
        // 
        showMarkers: false
      }
    });
  };

  return Bullet;
}(_plot.Plot);

exports.Bullet = Bullet;

/***/ }),
/* 1172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = meta;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _utils2 = __webpack_require__(535);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var bulletStyle = options.bulletStyle,
      targetField = options.targetField,
      rangeField = options.rangeField,
      measureField = options.measureField,
      xField = options.xField,
      color = options.color,
      layout = options.layout,
      size = options.size,
      label = options.label; // 

  var _a = (0, _utils2.transformData)(options),
      min = _a.min,
      max = _a.max,
      ds = _a.ds;

  chart.data(ds); // rangeGeometry

  var r = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: xField,
      yField: rangeField,
      seriesField: 'rKey',
      isStack: true,
      label: (0, _util.get)(label, 'range'),
      interval: {
        color: (0, _util.get)(color, 'range'),
        style: (0, _util.get)(bulletStyle, 'range'),
        size: (0, _util.get)(size, 'range')
      }
    }
  });
  (0, _geometries.interval)(r); //  tooltip 

  chart.geometries[0].tooltip(false); // measureGeometry

  var m = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: xField,
      yField: measureField,
      seriesField: 'mKey',
      isStack: true,
      label: (0, _util.get)(label, 'measure'),
      interval: {
        color: (0, _util.get)(color, 'measure'),
        style: (0, _util.get)(bulletStyle, 'measure'),
        size: (0, _util.get)(size, 'measure')
      }
    }
  });
  (0, _geometries.interval)(m); // targetGeometry

  var t = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: xField,
      yField: targetField,
      seriesField: 'tKey',
      label: (0, _util.get)(label, 'target'),
      point: {
        color: (0, _util.get)(color, 'target'),
        style: (0, _util.get)(bulletStyle, 'target'),
        size: (0, _util.get)(size, 'target') / 2,
        shape: layout === 'horizontal' ? 'line' : 'hyphen'
      }
    }
  });
  (0, _geometries.point)(t); // 

  if (layout === 'horizontal') {
    chart.coordinate().transpose();
  }

  return (0, _tslib.__assign)((0, _tslib.__assign)({}, params), {
    ext: {
      data: {
        min: min,
        max: max
      }
    }
  });
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options,
      ext = params.ext;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      targetField = options.targetField,
      rangeField = options.rangeField,
      measureField = options.measureField,
      xField = options.xField;
  var extData = ext.data;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[measureField] = yAxis, _a), (_b = {}, _b[measureField] = {
    min: extData === null || extData === void 0 ? void 0 : extData.min,
    max: extData === null || extData === void 0 ? void 0 : extData.max
  }, _b[targetField] = {
    sync: "" + measureField
  }, _b[rangeField] = {
    sync: "" + measureField
  }, _b)))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      measureField = options.measureField,
      rangeField = options.rangeField,
      targetField = options.targetField;
  chart.axis("" + rangeField, false);
  chart.axis("" + targetField, false); //  false 

  if (xAxis === false) {
    chart.axis("" + xField, false);
  } else {
    chart.axis("" + xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis("" + measureField, false);
  } else {
    chart.axis("" + measureField, yAxis);
  }

  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend;
  chart.removeInteraction('legend-filter'); // @TODO  legend

  chart.legend(legend); //  color  legend, legend

  chart.legend('rKey', false);
  chart.legend('mKey', false);
  chart.legend('tKey', false);
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      measureField = options.measureField,
      targetField = options.targetField,
      rangeField = options.rangeField;
  var _a = chart.geometries,
      rangeGeometry = _a[0],
      measureGeometry = _a[1],
      targetGeometry = _a[2];

  if ((0, _util.get)(label, 'range')) {
    rangeGeometry.label("" + rangeField, (0, _tslib.__assign)({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, (0, _utils.transformLabel)(label.range)));
  } else {
    rangeGeometry.label(false);
  }

  if ((0, _util.get)(label, 'measure')) {
    measureGeometry.label("" + measureField, (0, _tslib.__assign)({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, (0, _utils.transformLabel)(label.measure)));
  } else {
    measureGeometry.label(false);
  }

  if ((0, _util.get)(label, 'target')) {
    targetGeometry.label("" + targetField, (0, _tslib.__assign)({
      layout: [{
        type: 'limit-in-plot'
      }]
    }, (0, _utils.transformLabel)(label.target)));
  } else {
    targetGeometry.label(false);
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  (0, _utils.flow)(geometry, meta, axis, legend, _common.theme, label, _common.tooltip, _common.interaction, _common.animation)(params);
}

/***/ }),
/* 1173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sunburst = void 0;

var _tslib = __webpack_require__(1);

var _utils = __webpack_require__(12);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1174);

var Sunburst =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Sunburst, _super);

  function Sunburst() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'sunburst';
    return _this;
  }
  /**
   * 
   */


  Sunburst.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      type: 'partition',
      innerRadius: 0,
      seriesField: 'value',
      tooltip: {
        shared: true,
        showMarkers: false,
        offset: 20,
        showTitle: false
      }
    });
  };
  /**
   * 
   */


  Sunburst.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Sunburst;
}(_plot.Plot);

exports.Sunburst = Sunburst;

/***/ }),
/* 1174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.axis = axis;
exports.legend = legend;
exports.tooltip = tooltip;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _geometries = __webpack_require__(32);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _utils2 = __webpack_require__(1175);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var color = options.color,
      colorField = options.colorField,
      sunburstStyle = options.sunburstStyle;
  var data = (0, _utils2.transformData)(options);
  chart.data(data); // geometry

  (0, _geometries.polygon)((0, _utils.deepAssign)({}, params, {
    options: {
      xField: 'x',
      yField: 'y',
      seriesField: colorField,
      polygon: {
        color: color,
        style: sunburstStyle
      }
    }
  }));
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * legend 
 * @param params
 */


function legend(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      seriesField = options.seriesField;
  var geometry = (0, _utils.findGeometry)(chart, 'polygon'); // label  false,   label

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: [seriesField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * coord 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var innerRadius = options.innerRadius,
      radius = options.radius,
      reflect = options.reflect;
  var coord = chart.coordinate({
    type: 'polar',
    cfg: {
      innerRadius: innerRadius,
      radius: radius
    }
  });

  if (reflect) {
    coord.reflect(reflect);
  }

  return params;
}
/**
 * scale 
 * @param params
 */


function scale(params) {
  var chart = params.chart,
      options = params.options;
  var meta = options.meta;

  if (meta) {
    // @ts-ignore
    chart.scale(meta);
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip,
      seriesField = options.seriesField,
      colorField = options.colorField;

  if (tooltip) {
    chart.tooltip((0, _tslib.__assign)((0, _tslib.__assign)({}, tooltip), {
      customContent: tooltip && tooltip.customContent ? tooltip.customContent : function (value, items) {
        return (0, _utils2.getTooltipTemplate)({
          value: value,
          items: items,
          formatter: tooltip && (tooltip === null || tooltip === void 0 ? void 0 : tooltip.formatter),
          fields: tooltip && tooltip.fields || [seriesField, colorField]
        });
      }
    }));
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, _common.theme, axis, scale, legend, coordinate, tooltip, label, _common.interaction, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformData = transformData;
exports.getTooltipTemplate = getTooltipTemplate;

var _tslib = __webpack_require__(1);

var _partition = __webpack_require__(1176);

var _treemap = __webpack_require__(537);

/**
 * sunburst 
 * @param options
 */
function transformData(options) {
  var data = options.data,
      type = options.type,
      seriesField = options.seriesField,
      colorField = options.colorField,
      hierarchyConfig = options.hierarchyConfig;
  var transform = {
    partition: _partition.partition,
    treemap: _treemap.treemap
  };
  var nodes = transform[type](data, (0, _tslib.__assign)((0, _tslib.__assign)({}, hierarchyConfig), {
    // @ts-ignore
    type: "hierarchy." + type,
    field: seriesField,
    as: ['x', 'y']
  }));
  var result = [];
  nodes.forEach(function (node) {
    var _a;

    var _b, _c, _d, _e;

    if (node.depth === 0) {
      return null;
    }

    var nodeInfo = (0, _tslib.__assign)((_a = {}, _a[seriesField] = node.data[seriesField] || ((_c = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c[seriesField]), _a[colorField] = node.data[colorField] || ((_e = (_d = node.parent) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e[colorField]), _a), node);
    nodeInfo.ext = hierarchyConfig;
    result.push(nodeInfo);
  });
  return result;
}
/**
 * customContent
 * @param {string} value
 * @param {any[]} items
 * @param {Function} formatter
 * @param {string} field
 * @returns HTMLElement
 */


function getTooltipTemplate(params) {
  var items = params.items,
      formatter = params.formatter,
      fields = params.fields;

  var _a = items[0] || {},
      color = _a.color,
      mappingData = _a.mappingData,
      data = _a.data; // 


  var container = document.createElement('ul');
  container.className = 'g2-tooltip';
  var listItem = '';

  var formatterItem = function formatterItem(item, field) {
    var _a;

    if (formatter) {
      return formatter((0, _tslib.__assign)((0, _tslib.__assign)({}, item), {
        field: field
      }));
    }

    return {
      name: field,
      value: (item === null || item === void 0 ? void 0 : item[field]) || ((_a = item === null || item === void 0 ? void 0 : item.data) === null || _a === void 0 ? void 0 : _a[field])
    };
  };

  fields.forEach(function (field) {
    var _a = formatterItem(data, field),
        name = _a.name,
        value = _a.value;

    listItem += "<li class=\"g2-tooltip-list-item\" data-index={index} style=\"margin-bottom:4px;display:flex;align-items: center;\">\n        <span style=\"background-color:" + ((mappingData === null || mappingData === void 0 ? void 0 : mappingData.color) || color) + ";\" class=\"g2-tooltip-marker\"></span>\n        <span style=\"display:inline-flex;flex:1;justify-content:space-between\">\n        <span style=\"margin-right: 16px;\">" + name + ":</span>\n        <span class=\"g2-tooltip-list-item-value\">" + value + "</span>\n        </span>\n    </li>";
  });
  container.innerHTML = listItem;
  return container;
}

/***/ }),
/* 1176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.partition = partition;

var d3Hierarchy = _interopRequireWildcard(__webpack_require__(292));

var _util = __webpack_require__(0);

var _util2 = __webpack_require__(536);

var DEFAULT_OPTIONS = {
  field: 'value',
  size: [1, 1],
  round: false,
  padding: 0,
  sort: true,
  as: ['x', 'y']
};

function partition(data, options) {
  options = (0, _util.assign)({}, DEFAULT_OPTIONS, options);
  var as = options.as;

  if (!(0, _util.isArray)(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }

  var field;

  try {
    field = (0, _util2.getField)(options);
  } catch (e) {
    console.warn(e);
  }

  var partition = function partition(data) {
    return d3Hierarchy.partition().size(options.size).round(options.round).padding(options.padding)(d3Hierarchy.hierarchy(data).sum(function (d) {
      return d[field];
    }));
  };

  var root = partition(data);
  /*
   * points:
   *   3  2
   *   0  1
   */

  var x = as[0];
  var y = as[1];
  root.each(function (node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return (0, _util2.getAllNodes)(root);
}

/***/ }),
/* 1177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Gauge = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1178);

var _constant = __webpack_require__(196);

var _utils = __webpack_require__(538);

__webpack_require__(1179);

__webpack_require__(1180);

//  shape

/**
 * 
 */
var Gauge =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Gauge, _super);

  function Gauge() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'gauge';
    return _this;
  }

  Gauge.prototype.getDefaultOptions = function () {
    var _a;

    return {
      percent: 0,
      range: {
        ticks: []
      },
      innerRadius: 0.9,
      radius: 0.95,
      startAngle: -7 / 6 * Math.PI,
      endAngle: 1 / 6 * Math.PI,
      syncViewPadding: true,
      axis: {
        line: null,
        label: {
          offset: -24,
          style: {
            textAlign: 'center',
            textBaseline: 'middle'
          }
        },
        subTickLine: {
          length: -8
        },
        tickLine: {
          length: -12
        },
        grid: null
      },
      indicator: {
        pointer: {
          style: {
            lineWidth: 5,
            lineCap: 'round'
          }
        },
        pin: {
          style: {
            r: 9.75,
            lineWidth: 4.5,
            fill: '#fff'
          }
        }
      },
      statistic: {
        title: false
      },
      meta: (_a = {}, //  view  scale  v 
      _a[_constant.RANGE_VALUE] = {
        sync: 'v'
      }, _a[_constant.PERCENT] = {
        sync: 'v',
        tickCount: 5,
        tickInterval: 0.2
      }, _a),
      animation: false
    };
  };
  /**
   * 
   * @param percent
   */


  Gauge.prototype.changeData = function (percent) {
    this.updateOption({
      percent: percent
    });
    var indicatorView = this.chart.views.find(function (v) {
      return v.id === _constant.INDICATEOR_VIEW_ID;
    });

    if (indicatorView) {
      indicatorView.data((0, _utils.getIndicatorData)(percent));
    }

    var rangeView = this.chart.views.find(function (v) {
      return v.id === _constant.RANGE_VIEW_ID;
    });

    if (rangeView) {
      rangeView.data((0, _utils.getRangeData)(percent, this.options.range));
    } // todo  G2  afterrender  annotations


    (0, _adaptor.statistic)({
      chart: this.chart,
      options: this.options
    }, true);
  };
  /**
   * 
   */


  Gauge.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Gauge;
}(_plot.Plot);

exports.Gauge = Gauge;

/***/ }),
/* 1178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.statistic = statistic;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _constant = __webpack_require__(121);

var _utils = __webpack_require__(12);

var _constant2 = __webpack_require__(196);

var _utils2 = __webpack_require__(538);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      range = options.range,
      radius = options.radius,
      innerRadius = options.innerRadius,
      startAngle = options.startAngle,
      endAngle = options.endAngle,
      axis = options.axis,
      indicator = options.indicator;
  var color = range.color; //  & 
  // 

  if (indicator) {
    var indicatorData = (0, _utils2.getIndicatorData)(percent);
    var v1 = chart.createView({
      id: _constant2.INDICATEOR_VIEW_ID
    });
    v1.data(indicatorData);
    v1.point().position(_constant2.PERCENT + "*1").shape('gauge-indicator') //  shape 
    .customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator: indicator
    });
    v1.coordinate('polar', {
      startAngle: startAngle,
      endAngle: endAngle,
      radius: innerRadius * radius
    });
    v1.axis(_constant2.PERCENT, axis); //  scale 

    v1.scale(_constant2.PERCENT, (0, _utils.pick)(axis, _constant.AXIS_META_CONFIG_KEYS));
  } //  range
  // [{ range: 1, type: '0' }]


  var rangeData = (0, _utils2.getRangeData)(percent, options.range);
  var v2 = chart.createView({
    id: _constant2.RANGE_VIEW_ID
  });
  v2.data(rangeData);
  var rangeColor = (0, _util.isString)(color) ? [color, _constant2.DEFAULT_COLOR] : color;
  v2.interval().position("1*" + _constant2.RANGE_VALUE).color(_constant2.RANGE_TYPE, rangeColor).adjust('stack');
  v2.coordinate('polar', {
    innerRadius: innerRadius,
    radius: radius,
    startAngle: startAngle,
    endAngle: endAngle
  }).transpose();
  return params;
}
/**
 * meter   mask
 * @param params
 */


function meterView(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var type = options.type,
      meter = options.meter;

  if (type === 'meter') {
    var innerRadius = options.innerRadius,
        radius = options.radius,
        startAngle = options.startAngle,
        endAngle = options.endAngle;
    var background = chart.getTheme().background;
    var color = background;

    if (!color || color === 'transparent') {
      color = '#fff';
    }

    var v3 = chart.createView({
      id: _constant2.MASK_VIEW_ID
    });
    v3.data([(_a = {}, _a[_constant2.RANGE_TYPE] = '1', _a[_constant2.RANGE_VALUE] = 1, _a)]);
    v3.interval().position("1*" + _constant2.RANGE_VALUE).color(color).adjust('stack').shape('meter-gauge').customInfo(meter || {});
    v3.coordinate('polar', {
      innerRadius: innerRadius,
      radius: radius,
      startAngle: startAngle,
      endAngle: endAngle
    }).transpose();
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  return (0, _utils.flow)((0, _common.scale)((_a = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a[_constant2.PERCENT] = {}, _a)))(params);
}
/**
 * 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var statistic = options.statistic,
      percent = options.percent; // 

  chart.getController('annotation').clear(true);

  if (statistic) {
    var content = statistic.content;
    var transformContent = void 0; //  content 

    if (content) {
      transformContent = (0, _utils.deepAssign)({}, {
        formatter: function formatter(_a) {
          var percent = _a.percent;
          return (percent * 100).toFixed(2) + "%";
        },
        style: {
          opacity: 0.75,
          fontSize: '30px',
          lineHeight: 1,
          textAlign: 'center',
          color: 'rgba(44,53,66,0.85)'
        }
      }, content);
    }

    (0, _utils.renderGaugeStatistic)(chart, {
      statistic: (0, _tslib.__assign)((0, _tslib.__assign)({}, statistic), {
        content: transformContent
      })
    }, {
      percent: percent
    });
  }

  if (updated) {
    chart.render(true);
  }

  return params;
}
/**
 * other 
 * @param params
 */


function other(params) {
  var chart = params.chart;
  chart.legend(false);
  chart.tooltip(false);
  return params;
}
/**
 *  adaptor
 */


/**
 * 
 * @param chart
 * @param options
 */
function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)( // animation  createView  View 
  _common.animation, geometry, meta, statistic, _common.interaction, _common.theme, // meterView 
  meterView, other // ...  adaptor flow
  )(params);
}

/***/ }),
/* 1179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

// Shape 
(0, _g.registerShape)('point', 'gauge-indicator', {
  draw: function draw(cfg, container) {
    //  customInfo 
    var _a = cfg.customInfo,
        indicator = _a.indicator,
        defaultColor = _a.defaultColor;
    var _b = indicator,
        pointer = _b.pointer,
        pin = _b.pin;
    var group = container.addGroup(); // 

    var center = this.parsePoint({
      x: 0,
      y: 0
    }); // 

    if (pointer) {
      // pointer
      group.addShape('line', {
        name: 'pointer',
        attrs: (0, _tslib.__assign)({
          x1: center.x,
          y1: center.y,
          x2: cfg.x,
          y2: cfg.y,
          stroke: defaultColor
        }, pointer.style)
      });
    } // pin


    if (pin) {
      group.addShape('circle', {
        name: 'pin',
        attrs: (0, _tslib.__assign)({
          x: center.x,
          y: center.y,
          stroke: defaultColor
        }, pin.style)
      });
    }

    return group;
  }
});

/***/ }),
/* 1180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

var _graphics = __webpack_require__(45);

// Shape 
(0, _g.registerShape)('interval', 'meter-gauge', {
  draw: function draw(cfg, container) {
    //  customInfo 
    var _a = cfg.customInfo,
        _b = _a.steps,
        STEP = _b === void 0 ? 50 : _b,
        _c = _a.stepRatio,
        stepRatio = _c === void 0 ? 0.5 : _c;
    var total = this.coordinate.endAngle - this.coordinate.startAngle;
    var interval = total / STEP;
    var gap = 0;
    /**
     * stepRatio : (0, 1]
     * 1: interval : gap = stepRatio : (1 - stepRatio)
     * 2: interval * STEP + stepRatio * (STEP - 1) = total
     */

    if (stepRatio > 0 && stepRatio <= 1) {
      interval = total / ((1 - stepRatio) / stepRatio * (STEP - 1) + STEP);
      gap = interval * (1 - stepRatio) / stepRatio;
    }

    var group = container.addGroup(); //  gap

    if (gap > 0) {
      var center = this.coordinate.getCenter();
      var radius = this.coordinate.getRadius();

      var _d = _g.Util.getAngle(cfg, this.coordinate),
          startAngle = _d.startAngle,
          endAngle = _d.endAngle;

      for (var i = startAngle, j = 0; i < endAngle && j < 2 * STEP - 1; j++) {
        var drawn = j % 2;

        if (drawn) {
          var path = (0, _graphics.getSectorPath)(center.x, center.y, radius, i, Math.min(i + gap, endAngle), radius * this.coordinate.innerRadius);
          group.addShape('path', {
            name: 'meter-gauge-mask',
            attrs: {
              path: path,
              fill: cfg.color,
              stroke: cfg.color,
              lineWidth: 0.5
            },
            // mask 
            capture: false
          });
        }

        i += drawn ? gap : interval;
      }
    }

    return group;
  }
});

/***/ }),
/* 1181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Waterfall = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1182);

var _utils = __webpack_require__(540);

/**
 * 
 */
var Waterfall =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Waterfall, _super);

  function Waterfall() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'waterfall';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  Waterfall.prototype.changeData = function (data) {
    var _a = this.options,
        xField = _a.xField,
        yField = _a.yField,
        total = _a.total;
    this.updateOption({
      data: data
    });
    this.chart.changeData((0, _utils.transformData)(data, xField, yField, total));
  };
  /**
   *   
   */


  Waterfall.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };
  /**
   *   
   */


  Waterfall.prototype.getDefaultOptions = function () {
    return {
      /** default: show label */
      label: {},

      /** default: show leaderLine */
      leaderLine: {
        style: {
          lineWidth: 1,
          stroke: '#8c8c8c',
          lineDash: [4, 2]
        }
      },

      /** default: show total */
      total: {
        label: '',
        style: {
          fill: 'rgba(0, 0, 0, 0.25)'
        }
      },
      interactions: [{
        type: 'element-active'
      }],
      risingFill: '#f4664a',
      fallingFill: '#30bf78',
      waterfallStyle: {
        fill: 'rgba(0, 0, 0, 0.25)'
      },
      yAxis: {
        grid: {
          line: {
            style: {
              lineDash: [4, 2]
            }
          }
        }
      }
    };
  };

  return Waterfall;
}(_plot.Plot);

exports.Waterfall = Waterfall;

/***/ }),
/* 1182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tooltip = tooltip;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _utils = __webpack_require__(12);

var _constants = __webpack_require__(539);

var _utils2 = __webpack_require__(540);

__webpack_require__(1183);

/**
 * 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xField = options.xField,
      yField = options.yField,
      total = options.total,
      leaderLine = options.leaderLine,
      columnWidthRatio = options.columnWidthRatio,
      waterfallStyle = options.waterfallStyle,
      risingFill = options.risingFill,
      fallingFill = options.fallingFill,
      color = options.color; // 

  chart.data((0, _utils2.transformData)(data, xField, yField, total)); //  colorMapping

  var colorMapping = color || function (datum) {
    if ((0, _util.get)(datum, [_constants.IS_TOTAL])) {
      return (0, _util.get)(total, ['style', 'fill'], '');
    }

    return (0, _util.get)(datum, [_constants.Y_FIELD, 1]) - (0, _util.get)(datum, [_constants.Y_FIELD, 0]) > 0 ? risingFill : fallingFill;
  };

  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      xField: xField,
      yField: _constants.Y_FIELD,
      seriesField: xField,
      rawFields: [yField, _constants.DIFF_FIELD, _constants.IS_TOTAL, _constants.Y_FIELD],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        shape: 'waterfall',
        color: colorMapping
      }
    }
  });
  var ext = (0, _geometries.interval)(p).ext;
  var geometry = ext.geometry; //  waterfall leaderLineCfg  shape 

  geometry.customInfo({
    leaderLine: leaderLine
  });
  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a, _b;

  var options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      meta = options.meta;
  var Y_FIELD_META = (0, _utils.deepAssign)({}, {
    alias: yField
  }, (0, _util.get)(meta, yField));
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[xField] = xAxis, _a[yField] = yAxis, _a[_constants.Y_FIELD] = yAxis, _a), (0, _utils.deepAssign)({}, meta, (_b = {}, _b[_constants.Y_FIELD] = Y_FIELD_META, _b[_constants.DIFF_FIELD] = Y_FIELD_META, _b[_constants.ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField; //  false 

  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }

  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(_constants.Y_FIELD, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(_constants.Y_FIELD, yAxis);
  }

  return params;
}
/**
 * legend  todo  hover 
 * @param params
 */


function legend(params) {
  var chart = params.chart,
      options = params.options;
  var legend = options.legend,
      total = options.total,
      risingFill = options.risingFill,
      fallingFill = options.fallingFill;

  if (legend === false) {
    chart.legend(false);
  } else {
    var items = [{
      name: '',
      value: 'increase',
      marker: {
        symbol: 'square',
        style: {
          r: 5,
          fill: risingFill
        }
      }
    }, {
      name: '',
      value: 'decrease',
      marker: {
        symbol: 'square',
        style: {
          r: 5,
          fill: fallingFill
        }
      }
    }];

    if (total) {
      items.push({
        name: total.label || '',
        value: 'total',
        marker: {
          symbol: 'square',
          style: (0, _utils.deepAssign)({}, {
            r: 5
          }, (0, _util.get)(total, 'style'))
        }
      });
    }

    chart.legend((0, _utils.deepAssign)({}, {
      custom: true,
      position: 'top',
      items: items
    }, legend));
    chart.removeInteraction('legend-filter');
  }

  return params;
}
/**
 * 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      labelMode = options.labelMode,
      xField = options.xField;
  var geometry = (0, _utils.findGeometry)(chart, 'interval');

  if (!label) {
    geometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    geometry.label({
      fields: labelMode === 'absolute' ? [_constants.ABSOLUTE_FIELD, xField] : [_constants.DIFF_FIELD, xField],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * tooltip 
 * @param params
 */


function tooltip(params) {
  var chart = params.chart,
      options = params.options;
  var tooltip = options.tooltip,
      xField = options.xField,
      yField = options.yField;

  if (tooltip !== false) {
    chart.tooltip((0, _tslib.__assign)({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      // tooltip  y 
      fields: [yField]
    }, tooltip)); //  yField  tooltip 

    var geometry_1 = chart.geometries[0];
    (tooltip === null || tooltip === void 0 ? void 0 : tooltip.formatter) ? geometry_1.tooltip(xField + "*" + yField, tooltip.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }

  return params;
}
/**
 * 
 * @param params
 */


function adaptor(params) {
  return (0, _utils.flow)(geometry, meta, axis, legend, tooltip, label, _common.state, _common.theme, _common.interaction, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(12);

/**
 *  path
 * @param points
 */
function getRectPath(points) {
  var path = [];

  for (var i = 0; i < points.length; i++) {
    var point = points[i];

    if (point) {
      var action = i === 0 ? 'M' : 'L';
      path.push([action, point.x, point.y]);
    }
  }

  var first = points[0];
  path.push(['L', first.x, first.y]);
  path.push(['z']);
  return path;
}
/**
 * 
 * @param cfg 
 */


function getFillAttrs(cfg) {
  return (0, _utils.deepAssign)({}, cfg.defaultStyle, cfg.style, {
    fill: cfg.color
  });
}

(0, _g.registerShape)('interval', 'waterfall', {
  draw: function draw(cfg, container) {
    var customInfo = cfg.customInfo,
        points = cfg.points,
        nextPoints = cfg.nextPoints;
    var group = container.addGroup(); //  

    var rectPath = this.parsePath(getRectPath(points));
    var fillAttrs = getFillAttrs(cfg);
    group.addShape('path', {
      attrs: (0, _tslib.__assign)((0, _tslib.__assign)({}, fillAttrs), {
        path: rectPath
      })
    }); //  

    var leaderLineCfg = (0, _util.get)(customInfo, 'leaderLine');

    if (leaderLineCfg && nextPoints) {
      var linkPath = [['M', points[2].x, points[2].y], ['L', nextPoints[0].x, nextPoints[0].y]];

      if (points[2].y === nextPoints[1].y) {
        linkPath[1] = ['L', nextPoints[1].x, nextPoints[1].y];
      }

      linkPath = this.parsePath(linkPath);
      group.addShape('path', {
        attrs: (0, _tslib.__assign)({
          path: linkPath
        }, leaderLineCfg.style || {})
      });
    }

    return group;
  }
});

/***/ }),
/* 1184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RadialBar = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1185);

/**
 * 
 */
var RadialBar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(RadialBar, _super);

  function RadialBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'radial-bar';
    return _this;
  }
  /**
   * @override
   * @param data
   */


  RadialBar.prototype.changeData = function (data) {
    this.updateOption({
      data: data
    }); // scale

    (0, _adaptor.meta)({
      chart: this.chart,
      options: this.options
    });
    this.chart.changeData(data);
  };
  /**
   * 
   */


  RadialBar.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      interactions: [{
        type: 'element-active'
      }],
      legend: false,
      tooltip: {
        showMarkers: false
      },
      xAxis: {
        grid: null,
        tickLine: null,
        line: null
      },
      maxAngle: 240
    });
  };
  /**
   * 
   */


  RadialBar.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return RadialBar;
}(_plot.Plot);

exports.RadialBar = RadialBar;

/***/ }),
/* 1185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.meta = meta;
exports.axis = axis;
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _utils2 = __webpack_require__(1186);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      style = options.barStyle,
      color = options.color,
      tooltip = options.tooltip,
      colorField = options.colorField,
      type = options.type,
      xField = options.xField,
      yField = options.yField;
  chart.data(data);
  var p = (0, _utils.deepAssign)({}, params, {
    options: {
      tooltip: tooltip,
      seriesField: colorField,
      interval: {
        style: style,
        color: color,
        shape: type === 'line' ? 'line' : 'intervel'
      },
      // 
      minColumnWidth: options.minBarWidth,
      maxColumnWidth: options.maxBarWidth,
      columnBackground: options.barBackground
    }
  });
  (0, _geometries.interval)(p);

  if (type === 'line') {
    (0, _geometries.point)({
      chart: chart,
      options: {
        xField: xField,
        yField: yField,
        seriesField: colorField,
        point: {
          shape: 'circle',
          color: color
        }
      }
    });
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  var options = params.options;
  var yField = options.yField,
      data = options.data,
      maxAngle = options.maxAngle;
  return (0, _utils.flow)((0, _common.scale)((_a = {}, _a[yField] = {
    min: 0,
    max: (0, _utils2.getScaleMax)(maxAngle, yField, data)
  }, _a)))(params);
}
/**
 * coordinate 
 * @param params
 */


function coordinate(params) {
  var chart = params.chart,
      options = params.options;
  var radius = options.radius,
      innerRadius = options.innerRadius,
      startAngle = options.startAngle,
      endAngle = options.endAngle;
  chart.coordinate({
    type: 'polar',
    cfg: {
      radius: radius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    }
  }).transpose();
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xField = options.xField,
      xAxis = options.xAxis;
  chart.axis(xField, xAxis);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(geometry, meta, axis, coordinate, _common.interaction, _common.animation, _common.theme, _common.tooltip, _common.legend, (0, _common.annotation)())(params);
}

/***/ }),
/* 1186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getScaleMax = getScaleMax;

function getScaleMax(maxAngle, yField, data) {
  var yData = data.map(function (item) {
    return item[yField];
  }).filter(function (v) {
    return v !== undefined;
  });
  var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
  var formatRadian = Math.abs(maxAngle) % 360;

  if (!formatRadian) {
    return maxValue;
  }

  return maxValue * 360 / formatRadian;
}

/***/ }),
/* 1187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BidirectionalBar = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _utils = __webpack_require__(12);

var _adaptor = __webpack_require__(1188);

var _utils2 = __webpack_require__(541);

var BidirectionalBar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(BidirectionalBar, _super);

  function BidirectionalBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'bidirectional-bar';
    return _this;
  }

  BidirectionalBar.prototype.getDefaultOptions = function () {
    return (0, _utils.deepAssign)({}, _super.prototype.getDefaultOptions.call(this), {
      syncViewPadding: _utils2.syncViewPadding
    });
  };
  /**
   * 
   */


  BidirectionalBar.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return BidirectionalBar;
}(_plot.Plot);

exports.BidirectionalBar = BidirectionalBar;

/***/ }),
/* 1188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interaction = interaction;
exports.limitInPlot = limitInPlot;
exports.theme = theme;
exports.animation = animation;
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _common = __webpack_require__(25);

var _geometries = __webpack_require__(32);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(1189);

var _utils2 = __webpack_require__(541);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      xField = options.xField,
      yField = options.yField,
      color = options.color,
      barStyle = options.barStyle,
      widthRatio = options.widthRatio,
      legend = options.legend,
      layout = options.layout; // 

  var groupData = (0, _utils2.transformData)(xField, yField, _constant.SERIES_FIELD_KEY, data, (0, _utils2.isHorizontal)(layout)); //  view  legend

  if (legend) {
    chart.legend(_constant.SERIES_FIELD_KEY, legend);
  } else if (legend === false) {
    chart.legend(false);
  } //  view


  var firstView;
  var secondView;
  var firstViewData = groupData[0],
      secondViewData = groupData[1]; // 

  if ((0, _utils2.isHorizontal)(layout)) {
    firstView = chart.createView({
      region: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 0.5,
          y: 1
        }
      },
      id: _constant.FIRST_AXES_VIEW
    });
    firstView.coordinate().transpose().reflect('x');
    secondView = chart.createView({
      region: {
        start: {
          x: 0.5,
          y: 0
        },
        end: {
          x: 1,
          y: 1
        }
      },
      id: _constant.SECOND_AXES_VIEW
    });
    secondView.coordinate().transpose(); // @: ( transform )

    firstView.data(firstViewData);
    secondView.data(secondViewData);
  } else {
    // 
    firstView = chart.createView({
      region: {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: 1,
          y: 0.5
        }
      },
      id: _constant.FIRST_AXES_VIEW
    });
    secondView = chart.createView({
      region: {
        start: {
          x: 0,
          y: 0.5
        },
        end: {
          x: 1,
          y: 1
        }
      },
      id: _constant.SECOND_AXES_VIEW
    });
    secondView.coordinate().reflect('y').rotate(Math.PI * 0); // 

    firstView.data(firstViewData);
    secondView.data(secondViewData);
  }

  var left = (0, _utils.deepAssign)({}, params, {
    chart: firstView,
    options: {
      widthRatio: widthRatio,
      xField: xField,
      yField: yField[0],
      seriesField: _constant.SERIES_FIELD_KEY,
      interval: {
        color: color,
        style: barStyle
      }
    }
  });
  (0, _geometries.interval)(left);
  var right = (0, _utils.deepAssign)({}, params, {
    chart: secondView,
    options: {
      xField: xField,
      yField: yField[1],
      seriesField: _constant.SERIES_FIELD_KEY,
      widthRatio: widthRatio,
      interval: {
        color: color,
        style: barStyle
      }
    }
  });
  (0, _geometries.interval)(right);
  return params;
}
/**
 * meta 
 * -  SERIES_FIELD_KEY  yField 
 * @param params
 */


function meta(params) {
  var _a, _b, _c;

  var options = params.options,
      chart = params.chart;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField;
  var firstView = (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW);
  var secondView = (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW);
  var aliasMap = {};
  (0, _util.keys)((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function (metaKey) {
    if ((0, _util.get)(options === null || options === void 0 ? void 0 : options.meta, [metaKey, 'alias'])) {
      aliasMap[metaKey] = options.meta[metaKey].alias;
    }
  });
  chart.scale((_a = {}, _a[_constant.SERIES_FIELD_KEY] = {
    sync: true,
    formatter: function formatter(v) {
      return (0, _util.get)(aliasMap, v, v);
    }
  }, _a));
  (0, _common.scale)((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))((0, _utils.deepAssign)({}, params, {
    chart: firstView
  }));
  (0, _common.scale)((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))((0, _utils.deepAssign)({}, params, {
    chart: secondView
  }));
  return params;
}
/**
 * axis 
 * @param params
 */


function axis(params) {
  var chart = params.chart,
      options = params.options;
  var xAxis = options.xAxis,
      yAxis = options.yAxis,
      xField = options.xField,
      yField = options.yField,
      layout = options.layout;
  var firstView = (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW);
  var secondView = (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW); //  view axis 

  secondView.axis(xField, false); //  false  firstView 

  if (xAxis === false) {
    firstView.axis(xField, false);
  } else {
    firstView.axis(xField, (0, _tslib.__assign)({
      //  firstView 
      position: (0, _utils2.isHorizontal)(layout) ? 'top' : 'bottom'
    }, xAxis));
  }

  if (yAxis === false) {
    firstView.axis(yField[0], false);
    secondView.axis(yField[1], false);
  } else {
    firstView.axis(yField[0], yAxis[yField[0]]);
    secondView.axis(yField[1], yAxis[yField[1]]);
  }
  /**
   *  syncViewPadding
   *  TODO  g2 View  setter 
   */
  //@ts-ignore


  chart.__axisPosition = {
    position: firstView.getOptions().axes[xField].position,
    layout: layout
  };
  return params;
}
/**
 * interaction 
 * @param params
 */


function interaction(params) {
  var chart = params.chart;
  (0, _common.interaction)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW)
  }));
  (0, _common.interaction)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW)
  }));
  return params;
}
/**
 * limitInPlot
 * @param params
 */


function limitInPlot(params) {
  var chart = params.chart,
      options = params.options;
  var yField = options.yField,
      yAxis = options.yAxis;
  (0, _common.limitInPlot)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[0]]
    }
  }));
  (0, _common.limitInPlot)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[1]]
    }
  }));
  return params;
}
/**
 * theme
 * @param params
 */


function theme(params) {
  var chart = params.chart;
  (0, _common.theme)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW)
  }));
  (0, _common.theme)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW)
  }));
  return params;
}
/**
 * animation
 * @param params
 */


function animation(params) {
  var chart = params.chart;
  (0, _common.animation)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW)
  }));
  (0, _common.animation)((0, _utils.deepAssign)({}, params, {
    chart: (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW)
  }));
  return params;
}
/**
 * label 
 * @param params
 */


function label(params) {
  var chart = params.chart,
      options = params.options;
  var label = options.label,
      yField = options.yField;
  var firstView = (0, _utils.findViewById)(chart, _constant.FIRST_AXES_VIEW);
  var secondView = (0, _utils.findViewById)(chart, _constant.SECOND_AXES_VIEW);
  var leftGeometry = (0, _utils.findGeometry)(firstView, 'interval');
  var rightGeometry = (0, _utils.findGeometry)(secondView, 'interval');

  if (!label) {
    leftGeometry.label(false);
    rightGeometry.label(false);
  } else {
    var callback = label.callback,
        cfg = (0, _tslib.__rest)(label, ["callback"]);
    leftGeometry.label({
      fields: [yField[0]],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
    rightGeometry.label({
      fields: [yField[1]],
      callback: callback,
      cfg: (0, _utils.transformLabel)(cfg)
    });
  }

  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, meta, axis, limitInPlot, theme, label, _common.tooltip, interaction, animation)(params);
}

/***/ }),
/* 1189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SERIES_FIELD_KEY = exports.SECOND_AXES_VIEW = exports.FIRST_AXES_VIEW = void 0;
var FIRST_AXES_VIEW = 'first-axes-view';
exports.FIRST_AXES_VIEW = FIRST_AXES_VIEW;
var SECOND_AXES_VIEW = 'second-axes-view';
/**  key  */

exports.SECOND_AXES_VIEW = SECOND_AXES_VIEW;
var SERIES_FIELD_KEY = 'series-field-key';
exports.SERIES_FIELD_KEY = SERIES_FIELD_KEY;

/***/ }),
/* 1190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Treemap = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1191);

__webpack_require__(1192);

__webpack_require__(525);

var Treemap =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Treemap, _super);

  function Treemap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'treemap';
    return _this;
  }

  Treemap.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Treemap;
}(_plot.Plot);

exports.Treemap = Treemap;

/***/ }),
/* 1191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interaction = interaction;
exports.adaptor = adaptor;

var _polygon = __webpack_require__(517);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _utils2 = __webpack_require__(542);

/**
 *  option
 * @param params
 */
function defaultOptions(params) {
  var options = params.options;
  var colorField = options.colorField;
  return (0, _utils.deepAssign)({
    options: {
      //  name 
      colorField: 'name',
      rectStyle: {
        lineWidth: 1,
        stroke: '#fff'
      },
      hierarchyConfig: {
        tile: 'treemapResquarify'
      },
      label: {
        fields: ['name'],
        layout: {
          type: 'limit-in-shape'
        }
      },
      tooltip: {
        showMarkers: false,
        showTitle: false,
        fields: ['name', 'value', colorField],
        formatter: function formatter(data) {
          return {
            name: data.name,
            value: data.value
          };
        }
      },
      interactions: [{
        type: 'view-zoom'
      }, {
        type: 'treemap-element-zoom'
      }]
    }
  }, params);
}
/**
 * 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var color = options.color,
      colorField = options.colorField,
      rectStyle = options.rectStyle;
  var data = (0, _utils2.transformData)({
    data: options.data,
    colorField: options.colorField,
    openDrillDown: (0, _utils2.isDrillDown)(options.interactions)
  });
  chart.data(data); // geometry

  (0, _polygon.polygon)((0, _utils.deepAssign)({}, params, {
    options: {
      xField: 'x',
      yField: 'y',
      seriesField: colorField,
      rawFields: ['value'],
      polygon: {
        color: color,
        style: rectStyle
      }
    }
  }));
  return params;
}
/**
 * 
 * @param params
 */


function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * Interaction 
 * @param params
 */


function interaction(params) {
  var chart = params.chart,
      options = params.options;
  var interactions = options.interactions,
      hierarchyConfig = options.hierarchyConfig;
  (0, _common.interaction)({
    chart: chart,
    options: {
      interactions: (0, _utils2.getFommatInteractions)(interactions, hierarchyConfig)
    }
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(defaultOptions, geometry, axis, _common.theme, _common.legend, _common.tooltip, interaction, _common.animation, (0, _common.annotation)())(params);
}

/***/ }),
/* 1192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _g = __webpack_require__(17);

var _treemapDrillDownAction = __webpack_require__(1193);

var _util = __webpack_require__(1194);

(0, _g.registerAction)('treemap-drill-down-action', _treemapDrillDownAction.TreemapDrillDownAction);
(0, _g.registerInteraction)('treemap-drill-down', {
  showEnable: [{
    trigger: 'plot:mouseenter',
    action: 'cursor:pointer'
  }, {
    trigger: 'plot:mouseleave',
    action: 'cursor:default'
  }],
  start: [{
    trigger: 'element:click',
    isEnable: _util.isTopParentNode,
    action: ['treemap-drill-down-action:click', 'reset-button:show']
  }],
  rollback: [{
    trigger: 'reset-button:click',
    action: ['treemap-drill-down-action:reset']
  }, {
    trigger: 'reset-button:click',
    action: ['reset-button:hide'],
    isEnable: function isEnable(context) {
      return !(0, _util.hasHistoryDrill)(context);
    }
  }]
});

/***/ }),
/* 1193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TreemapDrillDownAction = void 0;

var _tslib = __webpack_require__(1);

var _g = __webpack_require__(17);

var _util = __webpack_require__(0);

var _utils = __webpack_require__(542);

var TreemapDrillDownAction =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TreemapDrillDownAction, _super);

  function TreemapDrillDownAction() {
    var _this = _super !== null && _super.apply(this, arguments) || this; //  scale


    _this.cacheDataStack = [];
    return _this;
  }

  TreemapDrillDownAction.prototype.drill = function (data) {
    console.log(this.context);
    var view = this.context.view;
    var currentData = view.getData();
    var groupScales = view.getGroupScales();
    var hierarchyConfig = (0, _util.get)(view, ['interactions', 'treemap-drill-down', 'cfg', 'hierarchyConfig'], {}); //  update 

    var drillData = (0, _utils.transformData)({
      data: data,
      colorField: (0, _util.get)(groupScales, [0, 'field']),
      openDrillDown: true,
      hierarchyConfig: hierarchyConfig
    });
    view.changeData(drillData);
    this.cacheDataStack.push(currentData);
  };

  TreemapDrillDownAction.prototype.click = function () {
    var data = (0, _util.get)(this.context, ['event', 'data', 'data']);
    if (!data) return false;
    this.drill(data);
  };

  TreemapDrillDownAction.prototype.reset = function () {
    var view = this.context.view;

    if (!(0, _util.isArray)(this.cacheDataStack) || this.cacheDataStack.length <= 0) {
      return;
    }

    var cacheData = this.cacheDataStack.splice(this.cacheDataStack.length - 1, 1);
    view.changeData(cacheData[0]);
  };

  return TreemapDrillDownAction;
}(_g.Action);

exports.TreemapDrillDownAction = TreemapDrillDownAction;

/***/ }),
/* 1194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTopParentNode = isTopParentNode;
exports.hasHistoryDrill = hasHistoryDrill;

var _util = __webpack_require__(0);

/**
 * 
 */
function isTopParentNode(context) {
  var data = (0, _util.get)(context, ['event', 'data', 'data'], {});
  return (0, _util.isArray)(data.children) && data.children.length > 0 && data.depth === 1;
}
/**
 * 
 */


function hasHistoryDrill(context) {
  if (!context || !context.getAction) return false;
  var treemapElementDrillAction = context.getAction('treemap-drill-down-action');
  if (!treemapElementDrillAction) return false; // @ts-ignore

  var cacheDataStack = treemapElementDrillAction.cacheDataStack;
  return (0, _util.isArray)(cacheDataStack) && cacheDataStack.length > 0;
}

/***/ }),
/* 1195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sankey = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1196);

/**
 *   Sankey
 */
var Sankey =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Sankey, _super);

  function Sankey() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'sankey';
    return _this;
  }

  Sankey.prototype.getDefaultOptions = function () {
    return {
      appendPadding: 8,
      syncViewPadding: true,
      nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1
      },
      edgeStyle: {
        opacity: 0.3,
        lineWidth: 0
      },
      label: {
        fields: ['x', 'name'],
        callback: function callback(x, name) {
          var isLast = x[1] === 1; // 

          return {
            style: {
              fill: '#545454',
              textAlign: isLast ? 'end' : 'start'
            },
            offsetX: isLast ? -8 : 8,
            content: name
          };
        },
        layout: [{
          type: 'hide-overlap'
        }]
      },
      tooltip: {
        showTitle: false,
        showMarkers: false,
        fields: ['source', 'target', 'value'],
        formatter: function formatter(datum) {
          var source = datum.source,
              target = datum.target,
              value = datum.value;
          return {
            name: source + ' -> ' + target,
            value: value
          };
        }
      },
      nodeWidthRatio: 0.008,
      nodePaddingRatio: 0.01
    };
  };
  /**
   * 
   */


  Sankey.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Sankey;
}(_plot.Plot);

exports.Sankey = Sankey;

/***/ }),
/* 1196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _sankey = __webpack_require__(1197);

var _geometries = __webpack_require__(32);

var _data = __webpack_require__(106);

var _constant = __webpack_require__(1266);

var _circle = __webpack_require__(1267);

/**
 * geometry 
 * @param params
 */
function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var data = options.data,
      sourceField = options.sourceField,
      targetField = options.targetField,
      weightField = options.weightField,
      color = options.color,
      nodeStyle = options.nodeStyle,
      edgeStyle = options.edgeStyle,
      label = options.label,
      tooltip = options.tooltip,
      nodeAlign = options.nodeAlign,
      nodePaddingRatio = options.nodePaddingRatio,
      nodeWidthRatio = options.nodeWidthRatio,
      nodeSort = options.nodeSort; // 1.  view 

  chart.legend(false);
  chart.tooltip(tooltip);
  chart.axis(false); // 2.  layout 

  var sankeyLayoutInputData = (0, _data.transformDataToNodeLinkData)((0, _circle.cutoffCircle)(data, sourceField, targetField), sourceField, targetField, weightField); // 3. layout 

  var _a = (0, _sankey.sankeyLayout)({
    nodeAlign: nodeAlign,
    nodePadding: nodePaddingRatio,
    nodeWidth: nodeWidthRatio,
    nodeSort: nodeSort
  }, sankeyLayoutInputData),
      nodes = _a.nodes,
      links = _a.links; // 4. 


  var nodesData = nodes.map(function (node) {
    return {
      x: node.x,
      y: node.y,
      name: node.name
    };
  });
  var edgesData = links.map(function (link) {
    return {
      source: link.source.name,
      target: link.target.name,
      name: link.source.name || link.target.name,
      x: link.x,
      y: link.y,
      value: link.value
    };
  }); // 5. node edge views

  var nodeView = chart.createView();
  nodeView.data(nodesData);
  (0, _geometries.polygon)({
    chart: nodeView,
    options: {
      xField: _constant.X_FIELD,
      yField: _constant.Y_FIELD,
      seriesField: _constant.COLOR_FIELD,
      polygon: {
        color: color,
        style: nodeStyle
      },
      label: label,
      tooltip: false
    }
  }); // edge view

  var edgeView = chart.createView();
  edgeView.data(edgesData);
  (0, _geometries.edge)({
    chart: edgeView,
    // @ts-ignore
    options: {
      xField: _constant.X_FIELD,
      yField: _constant.Y_FIELD,
      seriesField: _constant.COLOR_FIELD,
      edge: {
        color: color,
        style: edgeStyle,
        shape: 'arc'
      },
      tooltip: tooltip,
      state: {
        active: {
          style: {
            opacity: 0.8,
            lineWidth: 0
          }
        }
      }
    }
  });
  chart.interaction('element-active'); // scale

  chart.scale({
    x: {
      sync: true,
      nice: true
    },
    y: {
      sync: true,
      nice: true
    },
    name: {
      sync: 'color'
    }
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(geometry, _common.interaction, _common.animation, _common.theme // ...  adaptor flow
  )(params);
}

/***/ }),
/* 1197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodeAlignFunction = getNodeAlignFunction;
exports.getDefaultOptions = getDefaultOptions;
exports.sankeyLayout = sankeyLayout;

var _util = __webpack_require__(0);

var _d3Sankey = __webpack_require__(1198);

var ALIGN_METHOD = {
  left: _d3Sankey.sankeyLeft,
  right: _d3Sankey.sankeyRight,
  center: _d3Sankey.sankeyCenter,
  justify: _d3Sankey.sankeyJustify
};
/**
 * 
 */

var DEFAULT_OPTIONS = {
  nodeId: function nodeId(node) {
    return node.index;
  },
  nodeAlign: 'justify',
  nodeWidth: 0.008,
  nodePadding: 0.03,
  nodeSort: undefined
};
/**
 *  align function
 * @param nodeAlign
 */

function getNodeAlignFunction(nodeAlign) {
  var func = (0, _util.isString)(nodeAlign) ? ALIGN_METHOD[nodeAlign] : (0, _util.isFunction)(nodeAlign) ? nodeAlign : null;
  return func || _d3Sankey.sankeyJustify;
}

function getDefaultOptions(sankeyLayoutOptions) {
  return (0, _util.assign)({}, DEFAULT_OPTIONS, sankeyLayoutOptions);
}
/**
 * 0 - 1 
 *  data 
 * @param sankeyLayoutOptions
 * @param data
 */


function sankeyLayout(sankeyLayoutOptions, data) {
  var options = getDefaultOptions(sankeyLayoutOptions);
  var nodeId = options.nodeId,
      nodeSort = options.nodeSort,
      nodeAlign = options.nodeAlign,
      nodeWidth = options.nodeWidth,
      nodePadding = options.nodePadding;
  var sankeyProcessor = (0, _d3Sankey.sankey)().nodeSort(nodeSort).links(function (d) {
    return d.links;
  }).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([[0, 0], [1, 1]]).nodeId(nodeId); // 

  var layoutData = sankeyProcessor(data); // post process (x, y), etc.

  layoutData.nodes.forEach(function (node) {
    var x0 = node.x0,
        x1 = node.x1,
        y0 = node.y0,
        y1 = node.y1;
    /* points
     * 3---2
     * |   |
     * 0---1
     */

    node.x = [x0, x1, x1, x0];
    node.y = [y0, y0, y1, y1];
  });
  layoutData.links.forEach(function (edge) {
    var source = edge.source,
        target = edge.target;
    var sx = source.x1;
    var tx = target.x0;
    edge.x = [sx, sx, tx, tx];
    var offset = edge.width / 2;
    edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];
  });
  return layoutData;
}

/***/ }),
/* 1198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "sankey", {
  enumerable: true,
  get: function get() {
    return _sankey.default;
  }
});
Object.defineProperty(exports, "sankeyCenter", {
  enumerable: true,
  get: function get() {
    return _align.center;
  }
});
Object.defineProperty(exports, "sankeyLeft", {
  enumerable: true,
  get: function get() {
    return _align.left;
  }
});
Object.defineProperty(exports, "sankeyRight", {
  enumerable: true,
  get: function get() {
    return _align.right;
  }
});
Object.defineProperty(exports, "sankeyJustify", {
  enumerable: true,
  get: function get() {
    return _align.justify;
  }
});
Object.defineProperty(exports, "sankeyLinkHorizontal", {
  enumerable: true,
  get: function get() {
    return _sankeyLinkHorizontal.default;
  }
});

var _sankey = _interopRequireDefault(__webpack_require__(1199));

var _align = __webpack_require__(564);

var _sankeyLinkHorizontal = _interopRequireDefault(__webpack_require__(1239));

/***/ }),
/* 1199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Sankey;

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _d3Array = __webpack_require__(543);

var _align = __webpack_require__(564);

var _constant = _interopRequireDefault(__webpack_require__(1238));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}

function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}

function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}

function value(d) {
  return d.value;
}

function defaultId(d) {
  return d.index;
}

function defaultNodes(graph) {
  return graph.nodes;
}

function defaultLinks(graph) {
  return graph.links;
}

function find(nodeById, id) {
  var node = nodeById.get(id);
  if (!node) throw new Error("missing: " + id);
  return node;
}

function computeLinkBreadths(_ref) {
  var nodes = _ref.nodes;

  var _iterator = _createForOfIteratorHelper(nodes),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;
      var y0 = node.y0;
      var y1 = y0;

      var _iterator2 = _createForOfIteratorHelper(node.sourceLinks),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var link = _step2.value;
          link.y0 = y0 + link.width / 2;
          y0 += link.width;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(node.targetLinks),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _link = _step3.value;
          _link.y1 = y1 + _link.width / 2;
          y1 += _link.width;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}

function Sankey() {
  var x0 = 0,
      y0 = 0,
      x1 = 1,
      y1 = 1; // extent

  var dx = 24; // nodeWidth

  var dy = 8,
      py; // nodePadding

  var id = defaultId;
  var align = _align.justify;
  var sort;
  var linkSort;
  var nodes = defaultNodes;
  var links = defaultLinks;
  var iterations = 6;

  function sankey() {
    var graph = {
      nodes: nodes.apply(null, arguments),
      links: links.apply(null, arguments)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }

  sankey.update = function (graph) {
    computeLinkBreadths(graph);
    return graph;
  };

  sankey.nodeId = function (_) {
    return arguments.length ? (id = typeof _ === "function" ? _ : (0, _constant.default)(_), sankey) : id;
  };

  sankey.nodeAlign = function (_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : (0, _constant.default)(_), sankey) : align;
  };

  sankey.nodeSort = function (_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };

  sankey.nodeWidth = function (_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };

  sankey.nodePadding = function (_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };

  sankey.nodes = function (_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : (0, _constant.default)(_), sankey) : nodes;
  };

  sankey.links = function (_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : (0, _constant.default)(_), sankey) : links;
  };

  sankey.linkSort = function (_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };

  sankey.size = function (_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };

  sankey.extent = function (_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
  };

  sankey.iterations = function (_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };

  function computeNodeLinks(_ref2) {
    var nodes = _ref2.nodes,
        links = _ref2.links;

    var _iterator4 = _createForOfIteratorHelper(nodes.entries()),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
            i = _step4$value[0],
            node = _step4$value[1];

        node.index = i;
        node.sourceLinks = [];
        node.targetLinks = [];
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var nodeById = new Map(nodes.map(function (d, i) {
      return [id(d, i, nodes), d];
    }));

    var _iterator5 = _createForOfIteratorHelper(links.entries()),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = (0, _slicedToArray2.default)(_step5.value, 2),
            _i = _step5$value[0],
            link = _step5$value[1];

        link.index = _i;
        var source = link.source,
            target = link.target;
        if ((0, _typeof2.default)(source) !== "object") source = link.source = find(nodeById, source);
        if ((0, _typeof2.default)(target) !== "object") target = link.target = find(nodeById, target);
        source.sourceLinks.push(link);
        target.targetLinks.push(link);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    if (linkSort != null) {
      var _iterator6 = _createForOfIteratorHelper(nodes),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _step6.value,
              sourceLinks = _step6$value.sourceLinks,
              targetLinks = _step6$value.targetLinks;
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
  }

  function computeNodeValues(_ref3) {
    var nodes = _ref3.nodes;

    var _iterator7 = _createForOfIteratorHelper(nodes),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var node = _step7.value;
        node.value = node.fixedValue === undefined ? Math.max((0, _d3Array.sum)(node.sourceLinks, value), (0, _d3Array.sum)(node.targetLinks, value)) : node.fixedValue;
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }

  function computeNodeDepths(_ref4) {
    var nodes = _ref4.nodes;
    var n = nodes.length;
    var current = new Set(nodes);
    var next = new Set();
    var x = 0;

    while (current.size) {
      var _iterator8 = _createForOfIteratorHelper(current),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var node = _step8.value;
          node.depth = x;

          var _iterator9 = _createForOfIteratorHelper(node.sourceLinks),
              _step9;

          try {
            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
              var target = _step9.value.target;
              next.add(target);
            }
          } catch (err) {
            _iterator9.e(err);
          } finally {
            _iterator9.f();
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      if (++x > n) throw new Error("circular link");
      current = next;
      next = new Set();
    }
  }

  function computeNodeHeights(_ref5) {
    var nodes = _ref5.nodes;
    var n = nodes.length;
    var current = new Set(nodes);
    var next = new Set();
    var x = 0;

    while (current.size) {
      var _iterator10 = _createForOfIteratorHelper(current),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var node = _step10.value;
          node.height = x;

          var _iterator11 = _createForOfIteratorHelper(node.targetLinks),
              _step11;

          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var source = _step11.value.source;
              next.add(source);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      if (++x > n) throw new Error("circular link");
      current = next;
      next = new Set();
    }
  }

  function computeNodeLayers(_ref6) {
    var nodes = _ref6.nodes;
    var x = (0, _d3Array.max)(nodes, function (d) {
      return d.depth;
    }) + 1;
    var kx = (x1 - x0 - dx) / (x - 1);
    var columns = new Array(x);

    var _iterator12 = _createForOfIteratorHelper(nodes),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var node = _step12.value;
        var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
        node.layer = i;
        node.x0 = x0 + i * kx;
        node.x1 = node.x0 + dx;
        if (columns[i]) columns[i].push(node);else columns[i] = [node];
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    if (sort) {
      var _iterator13 = _createForOfIteratorHelper(columns),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var column = _step13.value;
          column.sort(sort);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }

    return columns;
  }

  function initializeNodeBreadths(columns) {
    var ky = (0, _d3Array.min)(columns, function (c) {
      return (y1 - y0 - (c.length - 1) * py) / (0, _d3Array.sum)(c, value);
    });

    var _iterator14 = _createForOfIteratorHelper(columns),
        _step14;

    try {
      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
        var _nodes = _step14.value;
        var y = y0;

        var _iterator15 = _createForOfIteratorHelper(_nodes),
            _step15;

        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var _node = _step15.value;
            _node.y0 = y;
            _node.y1 = y + _node.value * ky;
            y = _node.y1 + py;

            var _iterator16 = _createForOfIteratorHelper(_node.sourceLinks),
                _step16;

            try {
              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                var link = _step16.value;
                link.width = link.value * ky;
              }
            } catch (err) {
              _iterator16.e(err);
            } finally {
              _iterator16.f();
            }
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }

        y = (y1 - y + py) / (_nodes.length + 1);

        for (var i = 0; i < _nodes.length; ++i) {
          var node = _nodes[i];
          node.y0 += y * (i + 1);
          node.y1 += y * (i + 1);
        }

        reorderLinks(_nodes);
      }
    } catch (err) {
      _iterator14.e(err);
    } finally {
      _iterator14.f();
    }
  }

  function computeNodeBreadths(graph) {
    var columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / ((0, _d3Array.max)(columns, function (c) {
      return c.length;
    }) - 1));
    initializeNodeBreadths(columns);

    for (var i = 0; i < iterations; ++i) {
      var alpha = Math.pow(0.99, i);
      var beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  } // Reposition each node based on its incoming (target) links.


  function relaxLeftToRight(columns, alpha, beta) {
    for (var i = 1, n = columns.length; i < n; ++i) {
      var column = columns[i];

      var _iterator17 = _createForOfIteratorHelper(column),
          _step17;

      try {
        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
          var target = _step17.value;
          var y = 0;
          var w = 0;

          var _iterator18 = _createForOfIteratorHelper(target.targetLinks),
              _step18;

          try {
            for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
              var _step18$value = _step18.value,
                  source = _step18$value.source,
                  _value = _step18$value.value;
              var v = _value * (target.layer - source.layer);
              y += targetTop(source, target) * v;
              w += v;
            }
          } catch (err) {
            _iterator18.e(err);
          } finally {
            _iterator18.f();
          }

          if (!(w > 0)) continue;

          var _dy = (y / w - target.y0) * alpha;

          target.y0 += _dy;
          target.y1 += _dy;
          reorderNodeLinks(target);
        }
      } catch (err) {
        _iterator17.e(err);
      } finally {
        _iterator17.f();
      }

      if (sort === undefined) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  } // Reposition each node based on its outgoing (source) links.


  function relaxRightToLeft(columns, alpha, beta) {
    for (var n = columns.length, i = n - 2; i >= 0; --i) {
      var column = columns[i];

      var _iterator19 = _createForOfIteratorHelper(column),
          _step19;

      try {
        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
          var source = _step19.value;
          var y = 0;
          var w = 0;

          var _iterator20 = _createForOfIteratorHelper(source.sourceLinks),
              _step20;

          try {
            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
              var _step20$value = _step20.value,
                  target = _step20$value.target,
                  _value2 = _step20$value.value;
              var v = _value2 * (target.layer - source.layer);
              y += sourceTop(source, target) * v;
              w += v;
            }
          } catch (err) {
            _iterator20.e(err);
          } finally {
            _iterator20.f();
          }

          if (!(w > 0)) continue;

          var _dy2 = (y / w - source.y0) * alpha;

          source.y0 += _dy2;
          source.y1 += _dy2;
          reorderNodeLinks(source);
        }
      } catch (err) {
        _iterator19.e(err);
      } finally {
        _iterator19.f();
      }

      if (sort === undefined) column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }

  function resolveCollisions(nodes, alpha) {
    var i = nodes.length >> 1;
    var subject = nodes[i];
    resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
  } // Push any overlapping nodes down.


  function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
    for (; i < nodes.length; ++i) {
      var node = nodes[i];

      var _dy3 = (y - node.y0) * alpha;

      if (_dy3 > 1e-6) node.y0 += _dy3, node.y1 += _dy3;
      y = node.y1 + py;
    }
  } // Push any overlapping nodes up.


  function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
    for (; i >= 0; --i) {
      var node = nodes[i];

      var _dy4 = (node.y1 - y) * alpha;

      if (_dy4 > 1e-6) node.y0 -= _dy4, node.y1 -= _dy4;
      y = node.y0 - py;
    }
  }

  function reorderNodeLinks(_ref7) {
    var sourceLinks = _ref7.sourceLinks,
        targetLinks = _ref7.targetLinks;

    if (linkSort === undefined) {
      var _iterator21 = _createForOfIteratorHelper(targetLinks),
          _step21;

      try {
        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
          var _sourceLinks = _step21.value.source.sourceLinks;

          _sourceLinks.sort(ascendingTargetBreadth);
        }
      } catch (err) {
        _iterator21.e(err);
      } finally {
        _iterator21.f();
      }

      var _iterator22 = _createForOfIteratorHelper(sourceLinks),
          _step22;

      try {
        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
          var _targetLinks = _step22.value.target.targetLinks;

          _targetLinks.sort(ascendingSourceBreadth);
        }
      } catch (err) {
        _iterator22.e(err);
      } finally {
        _iterator22.f();
      }
    }
  }

  function reorderLinks(nodes) {
    if (linkSort === undefined) {
      var _iterator23 = _createForOfIteratorHelper(nodes),
          _step23;

      try {
        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
          var _step23$value = _step23.value,
              sourceLinks = _step23$value.sourceLinks,
              targetLinks = _step23$value.targetLinks;
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      } catch (err) {
        _iterator23.e(err);
      } finally {
        _iterator23.f();
      }
    }
  } // Returns the target.y0 that would produce an ideal link from source to target.


  function targetTop(source, target) {
    var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;

    var _iterator24 = _createForOfIteratorHelper(source.sourceLinks),
        _step24;

    try {
      for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
        var _step24$value = _step24.value,
            node = _step24$value.target,
            width = _step24$value.width;
        if (node === target) break;
        y += width + py;
      }
    } catch (err) {
      _iterator24.e(err);
    } finally {
      _iterator24.f();
    }

    var _iterator25 = _createForOfIteratorHelper(target.targetLinks),
        _step25;

    try {
      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
        var _step25$value = _step25.value,
            _node2 = _step25$value.source,
            _width = _step25$value.width;
        if (_node2 === source) break;
        y -= _width;
      }
    } catch (err) {
      _iterator25.e(err);
    } finally {
      _iterator25.f();
    }

    return y;
  } // Returns the source.y0 that would produce an ideal link from source to target.


  function sourceTop(source, target) {
    var y = target.y0 - (target.targetLinks.length - 1) * py / 2;

    var _iterator26 = _createForOfIteratorHelper(target.targetLinks),
        _step26;

    try {
      for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
        var _step26$value = _step26.value,
            node = _step26$value.source,
            width = _step26$value.width;
        if (node === source) break;
        y += width + py;
      }
    } catch (err) {
      _iterator26.e(err);
    } finally {
      _iterator26.f();
    }

    var _iterator27 = _createForOfIteratorHelper(source.sourceLinks),
        _step27;

    try {
      for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
        var _step27$value = _step27.value,
            _node3 = _step27$value.target,
            _width2 = _step27$value.width;
        if (_node3 === target) break;
        y -= _width2;
      }
    } catch (err) {
      _iterator27.e(err);
    } finally {
      _iterator27.f();
    }

    return y;
  }

  return sankey;
}

/***/ }),
/* 1200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cross;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(46));

var _typeof2 = _interopRequireDefault(__webpack_require__(19));

function length(array) {
  return array.length | 0;
}

function empty(length) {
  return !(length > 0);
}

function arrayify(values) {
  return (0, _typeof2.default)(values) !== "object" || "length" in values ? values : Array.from(values);
}

function reducer(reduce) {
  return function (values) {
    return reduce.apply(void 0, (0, _toConsumableArray2.default)(values));
  };
}

function cross() {
  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
    values[_key] = arguments[_key];
  }

  var reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
  values = values.map(arrayify);
  var lengths = values.map(length);
  var j = values.length - 1;
  var index = new Array(j + 1).fill(0);
  var product = [];
  if (j < 0 || lengths.some(empty)) return product;

  while (true) {
    product.push(index.map(function (j, i) {
      return values[i][j];
    }));
    var i = j;

    while (++index[i] === lengths[i]) {
      if (i === 0) return reduce ? product.map(reduce) : product;
      index[i--] = 0;
    }
  }
}

/***/ }),
/* 1201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cumsum;

function cumsum(values, valueof) {
  var sum = 0,
      index = 0;
  return Float64Array.from(values, valueof === undefined ? function (v) {
    return sum += +v || 0;
  } : function (v) {
    return sum += +valueof(v, index++, values) || 0;
  });
}

/***/ }),
/* 1202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

/***/ }),
/* 1203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.Adder = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(7));

var _createClass2 = _interopRequireDefault(__webpack_require__(23));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
var Adder = /*#__PURE__*/function () {
  function Adder() {
    (0, _classCallCheck2.default)(this, Adder);
    this._partials = new Float64Array(32);
    this._n = 0;
  }

  (0, _createClass2.default)(Adder, [{
    key: "add",
    value: function add(x) {
      var p = this._partials;
      var i = 0;

      for (var j = 0; j < this._n && j < 32; j++) {
        var y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
        if (lo) p[i++] = lo;
        x = hi;
      }

      p[i] = x;
      this._n = i + 1;
      return this;
    }
  }, {
    key: "valueOf",
    value: function valueOf() {
      var p = this._partials;
      var n = this._n,
          x,
          y,
          lo,
          hi = 0;

      if (n > 0) {
        hi = p[--n];

        while (n > 0) {
          x = hi;
          y = p[--n];
          hi = x + y;
          lo = y - (hi - x);
          if (lo) break;
        }

        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y = lo * 2;
          x = hi + y;
          if (y == x - hi) hi = x;
        }
      }

      return hi;
    }
  }]);
  return Adder;
}();

exports.Adder = Adder;

function _default(values, valueof) {
  var adder = new Adder();

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value = +value) {
          adder.add(value);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if (_value = +valueof(_value, ++index, values)) {
          adder.add(_value);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return +adder;
}

/***/ }),
/* 1204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPrototypeOf = __webpack_require__(4);

var setPrototypeOf = __webpack_require__(238);

var isNativeFunction = __webpack_require__(1205);

var construct = __webpack_require__(1206);

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper;

/***/ }),
/* 1205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction;

/***/ }),
/* 1206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setPrototypeOf = __webpack_require__(238);

var isNativeReflectConstruct = __webpack_require__(1207);

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),
/* 1207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),
/* 1208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = groupSort;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _group = _interopRequireWildcard(__webpack_require__(550));

var _sort = _interopRequireDefault(__webpack_require__(553));

function groupSort(values, reduce, key) {
  return (reduce.length === 1 ? (0, _sort.default)((0, _group.rollup)(values, reduce, key), function (_ref, _ref2) {
    var _ref3 = (0, _slicedToArray2.default)(_ref, 2),
        ak = _ref3[0],
        av = _ref3[1];

    var _ref4 = (0, _slicedToArray2.default)(_ref2, 2),
        bk = _ref4[0],
        bv = _ref4[1];

    return (0, _ascending.default)(av, bv) || (0, _ascending.default)(ak, bk);
  }) : (0, _sort.default)((0, _group.default)(values, key), function (_ref5, _ref6) {
    var _ref7 = (0, _slicedToArray2.default)(_ref5, 2),
        ak = _ref7[0],
        av = _ref7[1];

    var _ref8 = (0, _slicedToArray2.default)(_ref6, 2),
        bk = _ref8[0],
        bv = _ref8[1];

    return reduce(av, bv) || (0, _ascending.default)(ak, bk);
  })).map(function (_ref9) {
    var _ref10 = (0, _slicedToArray2.default)(_ref9, 1),
        key = _ref10[0];

    return key;
  });
}

/***/ }),
/* 1209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _slicedToArray2 = _interopRequireDefault(__webpack_require__(41));

var _array = __webpack_require__(1210);

var _bisect = _interopRequireDefault(__webpack_require__(544));

var _constant = _interopRequireDefault(__webpack_require__(1211));

var _extent = _interopRequireDefault(__webpack_require__(549));

var _identity = _interopRequireDefault(__webpack_require__(552));

var _nice3 = _interopRequireDefault(__webpack_require__(555));

var _ticks = _interopRequireWildcard(__webpack_require__(301));

var _sturges = _interopRequireDefault(__webpack_require__(556));

function _default() {
  var value = _identity.default,
      domain = _extent.default,
      threshold = _sturges.default;

  function histogram(data) {
    if (!Array.isArray(data)) data = Array.from(data);
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds, and nice the
    // default domain accordingly.

    if (!Array.isArray(tz)) {
      var max = x1,
          tn = +tz;

      if (domain === _extent.default) {
        var _nice = (0, _nice3.default)(x0, x1, tn);

        var _nice2 = (0, _slicedToArray2.default)(_nice, 2);

        x0 = _nice2[0];
        x1 = _nice2[1];
      }

      tz = (0, _ticks.default)(x0, x1, tn); // If the last threshold is coincident with the domains upper bound, the
      // last bin will be zero-width. If the default domain is used, and this
      // last threshold is coincident with the maximum input value, we can
      // extend the niced upper bound by one tick to ensure uniform bin widths;
      // otherwise, we simply remove the last threshold. Note that we dont
      // coerce values or the domain to numbers, and thus must be careful to
      // compare order (>=) rather than strict equality (===)!

      if (tz[tz.length - 1] >= x1) {
        if (max >= x1 && domain === _extent.default) {
          var step = (0, _ticks.tickIncrement)(x0, x1, tn);

          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) {
      tz.shift(), --m;
    }

    while (tz[m - 1] > x1) {
      tz.pop(), --m;
    }

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[(0, _bisect.default)(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0, _constant.default)([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0, _constant.default)(_array.slice.call(_)) : (0, _constant.default)(_), histogram) : threshold;
  };

  return histogram;
}

/***/ }),
/* 1210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.slice = void 0;
var array = Array.prototype;
var slice = array.slice;
exports.slice = slice;
var map = array.map;
exports.map = map;

/***/ }),
/* 1211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function () {
    return x;
  };
}

/***/ }),
/* 1212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _count = _interopRequireDefault(__webpack_require__(197));

var _quantile = _interopRequireDefault(__webpack_require__(302));

function _default(values, min, max) {
  return Math.ceil((max - min) / (2 * ((0, _quantile.default)(values, 0.75) - (0, _quantile.default)(values, 0.25)) * Math.pow((0, _count.default)(values), -1 / 3)));
}

/***/ }),
/* 1213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _count = _interopRequireDefault(__webpack_require__(197));

var _deviation = _interopRequireDefault(__webpack_require__(547));

function _default(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0, _deviation.default)(values) * Math.pow((0, _count.default)(values), -1 / 3)));
}

/***/ }),
/* 1214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mean;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function mean(values, valueof) {
  var count = 0;
  var sum = 0;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value != null && (value = +value) >= value) {
          ++count, sum += value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if ((_value = valueof(_value, ++index, values)) != null && (_value = +_value) >= _value) {
          ++count, sum += _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  if (count) return sum / count;
}

/***/ }),
/* 1215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quantile = _interopRequireDefault(__webpack_require__(302));

function _default(values, valueof) {
  return (0, _quantile.default)(values, 0.5, valueof);
}

/***/ }),
/* 1216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _regeneratorRuntime2 = __webpack_require__(154);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = merge;

var _regenerator = _interopRequireDefault(__webpack_require__(154));

var _marked = /*#__PURE__*/_regeneratorRuntime2.mark(flatten);

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function flatten(arrays) {
  var _iterator, _step, array;

  return _regenerator.default.wrap(function flatten$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _iterator = _createForOfIteratorHelper(arrays);
          _context.prev = 1;

          _iterator.s();

        case 3:
          if ((_step = _iterator.n()).done) {
            _context.next = 8;
            break;
          }

          array = _step.value;
          return _context.delegateYield(array, "t0", 6);

        case 6:
          _context.next = 3;
          break;

        case 8:
          _context.next = 13;
          break;

        case 10:
          _context.prev = 10;
          _context.t1 = _context["catch"](1);

          _iterator.e(_context.t1);

        case 13:
          _context.prev = 13;

          _iterator.f();

          return _context.finish(13);

        case 16:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[1, 10, 13, 16]]);
}

function merge(arrays) {
  return Array.from(flatten(arrays));
}

/***/ }),
/* 1217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pairs;
exports.pair = pair;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function pairs(values) {
  var pairof = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : pair;
  var pairs = [];
  var previous;
  var first = false;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      if (first) pairs.push(pairof(previous, value));
      previous = value;
      first = true;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return pairs;
}

function pair(a, b) {
  return [a, b];
}

/***/ }),
/* 1218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

/***/ }),
/* 1219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = least;

var _ascending = _interopRequireDefault(__webpack_require__(79));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function least(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  var min;
  var defined = false;

  if (compare.length === 1) {
    var minValue;

    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;
        var value = compare(element);

        if (defined ? (0, _ascending.default)(value, minValue) < 0 : (0, _ascending.default)(value, value) === 0) {
          min = element;
          minValue = value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if (defined ? compare(_value, min) < 0 : compare(_value, _value) === 0) {
          min = _value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return min;
}

/***/ }),
/* 1220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = greatest;

var _ascending = _interopRequireDefault(__webpack_require__(79));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function greatest(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  var max;
  var defined = false;

  if (compare.length === 1) {
    var maxValue;

    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;
        var value = compare(element);

        if (defined ? (0, _ascending.default)(value, maxValue) > 0 : (0, _ascending.default)(value, value) === 0) {
          max = element;
          maxValue = value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if (defined ? compare(_value, max) > 0 : compare(_value, _value) === 0) {
          max = _value;
          defined = true;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return max;
}

/***/ }),
/* 1221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = greatestIndex;

var _ascending = _interopRequireDefault(__webpack_require__(79));

var _maxIndex = _interopRequireDefault(__webpack_require__(559));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function greatestIndex(values) {
  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _ascending.default;
  if (compare.length === 1) return (0, _maxIndex.default)(values, compare);
  var maxValue;
  var max = -1;
  var index = -1;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      ++index;

      if (max < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
        maxValue = value;
        max = index;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return max;
}

/***/ }),
/* 1222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scan;

var _leastIndex = _interopRequireDefault(__webpack_require__(561));

function scan(values, compare) {
  var index = (0, _leastIndex.default)(values, compare);
  return index < 0 ? undefined : index;
}

/***/ }),
/* 1223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffler = shuffler;
exports.default = void 0;

var _default = shuffler(Math.random);

exports.default = _default;

function shuffler(random) {
  return function shuffle(array) {
    var i0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var i1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : array.length;
    var m = i1 - (i0 = +i0);

    while (m) {
      var i = random() * m-- | 0,
          t = array[m + i0];
      array[m + i0] = array[i + i0];
      array[i + i0] = t;
    }

    return array;
  };
}

/***/ }),
/* 1224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sum;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function sum(values, valueof) {
  var sum = 0;

  if (valueof === undefined) {
    var _iterator = _createForOfIteratorHelper(values),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value = +value) {
          sum += value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var index = -1;

    var _iterator2 = _createForOfIteratorHelper(values),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _value = _step2.value;

        if (_value = +valueof(_value, ++index, values)) {
          sum += _value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return sum;
}

/***/ }),
/* 1225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _transpose = _interopRequireDefault(__webpack_require__(562));

function _default() {
  return (0, _transpose.default)(arguments);
}

/***/ }),
/* 1226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = every;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function every(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var index = -1;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;

      if (!test(value, ++index, values)) {
        return false;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}

/***/ }),
/* 1227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = some;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function some(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var index = -1;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;

      if (test(value, ++index, values)) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}

/***/ }),
/* 1228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = filter;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function filter(values, test) {
  if (typeof test !== "function") throw new TypeError("test is not a function");
  var array = [];
  var index = -1;

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;

      if (test(value, ++index, values)) {
        array.push(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return array;
}

/***/ }),
/* 1229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = map;

function map(values, mapper) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
  return Array.from(values, function (value, index) {
    return mapper(value, index, values);
  });
}

/***/ }),
/* 1230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduce;

function reduce(values, reducer, value) {
  if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
  var iterator = values[Symbol.iterator]();
  var done,
      next,
      index = -1;

  if (arguments.length < 3) {
    var _iterator$next = iterator.next();

    done = _iterator$next.done;
    value = _iterator$next.value;
    if (done) return;
    ++index;
  }

  while ((_iterator$next2 = iterator.next(), done = _iterator$next2.done, next = _iterator$next2.value, _iterator$next2), !done) {
    var _iterator$next2;

    value = reducer(value, next, ++index, values);
  }

  return value;
}

/***/ }),
/* 1231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reverse;

function reverse(values) {
  if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
  return Array.from(values).reverse();
}

/***/ }),
/* 1232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = difference;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function difference(values) {
  values = new Set(values);

  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];

    var _iterator = _createForOfIteratorHelper(other),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;
        values.delete(value);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return values;
}

/***/ }),
/* 1233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = disjoint;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function disjoint(values, other) {
  var iterator = other[Symbol.iterator](),
      set = new Set();

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var v = _step.value;
      if (set.has(v)) return false;
      var value = void 0,
          done = void 0;

      while (_iterator$next = iterator.next(), value = _iterator$next.value, done = _iterator$next.done, _iterator$next) {
        var _iterator$next;

        if (done) break;
        if (Object.is(v, value)) return false;
        set.add(value);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}

/***/ }),
/* 1234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = intersection;

var _set = _interopRequireDefault(__webpack_require__(1235));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function intersection(values) {
  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    others[_key - 1] = arguments[_key];
  }

  values = new Set(values);
  others = others.map(_set.default);

  var _iterator = _createForOfIteratorHelper(values),
      _step;

  try {
    out: for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;

      var _iterator2 = _createForOfIteratorHelper(others),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var other = _step2.value;

          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return values;
}

/***/ }),
/* 1235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = set;

function set(values) {
  return values instanceof Set ? values : new Set(values);
}

/***/ }),
/* 1236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subset;

var _superset = _interopRequireDefault(__webpack_require__(563));

function subset(values, other) {
  return (0, _superset.default)(other, values);
}

/***/ }),
/* 1237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = union;

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function union() {
  var set = new Set();

  for (var _len = arguments.length, others = new Array(_len), _key = 0; _key < _len; _key++) {
    others[_key] = arguments[_key];
  }

  for (var _i = 0, _others = others; _i < _others.length; _i++) {
    var other = _others[_i];

    var _iterator = _createForOfIteratorHelper(other),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var o = _step.value;
        set.add(o);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return set;
}

/***/ }),
/* 1238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = constant;

function constant(x) {
  return function () {
    return x;
  };
}

/***/ }),
/* 1239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Shape = __webpack_require__(1240);

function horizontalSource(d) {
  return [d.source.x1, d.y0];
}

function horizontalTarget(d) {
  return [d.target.x0, d.y1];
}

function _default() {
  return (0, _d3Shape.linkHorizontal)().source(horizontalSource).target(horizontalTarget);
}

/***/ }),
/* 1240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireWildcard = __webpack_require__(14);

var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "arc", {
  enumerable: true,
  get: function get() {
    return _arc.default;
  }
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function get() {
    return _area.default;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function get() {
    return _line.default;
  }
});
Object.defineProperty(exports, "pie", {
  enumerable: true,
  get: function get() {
    return _pie.default;
  }
});
Object.defineProperty(exports, "areaRadial", {
  enumerable: true,
  get: function get() {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "radialArea", {
  enumerable: true,
  get: function get() {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "lineRadial", {
  enumerable: true,
  get: function get() {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "radialLine", {
  enumerable: true,
  get: function get() {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "pointRadial", {
  enumerable: true,
  get: function get() {
    return _pointRadial.default;
  }
});
Object.defineProperty(exports, "linkHorizontal", {
  enumerable: true,
  get: function get() {
    return _index.linkHorizontal;
  }
});
Object.defineProperty(exports, "linkVertical", {
  enumerable: true,
  get: function get() {
    return _index.linkVertical;
  }
});
Object.defineProperty(exports, "linkRadial", {
  enumerable: true,
  get: function get() {
    return _index.linkRadial;
  }
});
Object.defineProperty(exports, "symbol", {
  enumerable: true,
  get: function get() {
    return _symbol.default;
  }
});
Object.defineProperty(exports, "symbols", {
  enumerable: true,
  get: function get() {
    return _symbol.symbols;
  }
});
Object.defineProperty(exports, "symbolCircle", {
  enumerable: true,
  get: function get() {
    return _circle.default;
  }
});
Object.defineProperty(exports, "symbolCross", {
  enumerable: true,
  get: function get() {
    return _cross.default;
  }
});
Object.defineProperty(exports, "symbolDiamond", {
  enumerable: true,
  get: function get() {
    return _diamond.default;
  }
});
Object.defineProperty(exports, "symbolSquare", {
  enumerable: true,
  get: function get() {
    return _square.default;
  }
});
Object.defineProperty(exports, "symbolStar", {
  enumerable: true,
  get: function get() {
    return _star.default;
  }
});
Object.defineProperty(exports, "symbolTriangle", {
  enumerable: true,
  get: function get() {
    return _triangle.default;
  }
});
Object.defineProperty(exports, "symbolWye", {
  enumerable: true,
  get: function get() {
    return _wye.default;
  }
});
Object.defineProperty(exports, "curveBasisClosed", {
  enumerable: true,
  get: function get() {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "curveBasisOpen", {
  enumerable: true,
  get: function get() {
    return _basisOpen.default;
  }
});
Object.defineProperty(exports, "curveBasis", {
  enumerable: true,
  get: function get() {
    return _basis.default;
  }
});
Object.defineProperty(exports, "curveBundle", {
  enumerable: true,
  get: function get() {
    return _bundle.default;
  }
});
Object.defineProperty(exports, "curveCardinalClosed", {
  enumerable: true,
  get: function get() {
    return _cardinalClosed.default;
  }
});
Object.defineProperty(exports, "curveCardinalOpen", {
  enumerable: true,
  get: function get() {
    return _cardinalOpen.default;
  }
});
Object.defineProperty(exports, "curveCardinal", {
  enumerable: true,
  get: function get() {
    return _cardinal.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomClosed", {
  enumerable: true,
  get: function get() {
    return _catmullRomClosed.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomOpen", {
  enumerable: true,
  get: function get() {
    return _catmullRomOpen.default;
  }
});
Object.defineProperty(exports, "curveCatmullRom", {
  enumerable: true,
  get: function get() {
    return _catmullRom.default;
  }
});
Object.defineProperty(exports, "curveLinearClosed", {
  enumerable: true,
  get: function get() {
    return _linearClosed.default;
  }
});
Object.defineProperty(exports, "curveLinear", {
  enumerable: true,
  get: function get() {
    return _linear.default;
  }
});
Object.defineProperty(exports, "curveMonotoneX", {
  enumerable: true,
  get: function get() {
    return _monotone.monotoneX;
  }
});
Object.defineProperty(exports, "curveMonotoneY", {
  enumerable: true,
  get: function get() {
    return _monotone.monotoneY;
  }
});
Object.defineProperty(exports, "curveNatural", {
  enumerable: true,
  get: function get() {
    return _natural.default;
  }
});
Object.defineProperty(exports, "curveStep", {
  enumerable: true,
  get: function get() {
    return _step.default;
  }
});
Object.defineProperty(exports, "curveStepAfter", {
  enumerable: true,
  get: function get() {
    return _step.stepAfter;
  }
});
Object.defineProperty(exports, "curveStepBefore", {
  enumerable: true,
  get: function get() {
    return _step.stepBefore;
  }
});
Object.defineProperty(exports, "stack", {
  enumerable: true,
  get: function get() {
    return _stack.default;
  }
});
Object.defineProperty(exports, "stackOffsetExpand", {
  enumerable: true,
  get: function get() {
    return _expand.default;
  }
});
Object.defineProperty(exports, "stackOffsetDiverging", {
  enumerable: true,
  get: function get() {
    return _diverging.default;
  }
});
Object.defineProperty(exports, "stackOffsetNone", {
  enumerable: true,
  get: function get() {
    return _none.default;
  }
});
Object.defineProperty(exports, "stackOffsetSilhouette", {
  enumerable: true,
  get: function get() {
    return _silhouette.default;
  }
});
Object.defineProperty(exports, "stackOffsetWiggle", {
  enumerable: true,
  get: function get() {
    return _wiggle.default;
  }
});
Object.defineProperty(exports, "stackOrderAppearance", {
  enumerable: true,
  get: function get() {
    return _appearance.default;
  }
});
Object.defineProperty(exports, "stackOrderAscending", {
  enumerable: true,
  get: function get() {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "stackOrderDescending", {
  enumerable: true,
  get: function get() {
    return _descending.default;
  }
});
Object.defineProperty(exports, "stackOrderInsideOut", {
  enumerable: true,
  get: function get() {
    return _insideOut.default;
  }
});
Object.defineProperty(exports, "stackOrderNone", {
  enumerable: true,
  get: function get() {
    return _none2.default;
  }
});
Object.defineProperty(exports, "stackOrderReverse", {
  enumerable: true,
  get: function get() {
    return _reverse.default;
  }
});

var _arc = _interopRequireDefault(__webpack_require__(1241));

var _area = _interopRequireDefault(__webpack_require__(565));

var _line = _interopRequireDefault(__webpack_require__(304));

var _pie = _interopRequireDefault(__webpack_require__(1243));

var _areaRadial = _interopRequireDefault(__webpack_require__(1246));

var _lineRadial = _interopRequireDefault(__webpack_require__(567));

var _pointRadial = _interopRequireDefault(__webpack_require__(568));

var _index = __webpack_require__(1247);

var _symbol = _interopRequireWildcard(__webpack_require__(1248));

var _circle = _interopRequireDefault(__webpack_require__(570));

var _cross = _interopRequireDefault(__webpack_require__(571));

var _diamond = _interopRequireDefault(__webpack_require__(572));

var _square = _interopRequireDefault(__webpack_require__(574));

var _star = _interopRequireDefault(__webpack_require__(573));

var _triangle = _interopRequireDefault(__webpack_require__(575));

var _wye = _interopRequireDefault(__webpack_require__(576));

var _basisClosed = _interopRequireDefault(__webpack_require__(1249));

var _basisOpen = _interopRequireDefault(__webpack_require__(1250));

var _basis = _interopRequireDefault(__webpack_require__(200));

var _bundle = _interopRequireDefault(__webpack_require__(1251));

var _cardinalClosed = _interopRequireDefault(__webpack_require__(577));

var _cardinalOpen = _interopRequireDefault(__webpack_require__(578));

var _cardinal = _interopRequireDefault(__webpack_require__(201));

var _catmullRomClosed = _interopRequireDefault(__webpack_require__(1252));

var _catmullRomOpen = _interopRequireDefault(__webpack_require__(1253));

var _catmullRom = _interopRequireDefault(__webpack_require__(306));

var _linearClosed = _interopRequireDefault(__webpack_require__(1254));

var _linear = _interopRequireDefault(__webpack_require__(198));

var _monotone = __webpack_require__(1255);

var _natural = _interopRequireDefault(__webpack_require__(1256));

var _step = _interopRequireWildcard(__webpack_require__(1257));

var _stack = _interopRequireDefault(__webpack_require__(1258));

var _expand = _interopRequireDefault(__webpack_require__(1259));

var _diverging = _interopRequireDefault(__webpack_require__(1260));

var _none = _interopRequireDefault(__webpack_require__(162));

var _silhouette = _interopRequireDefault(__webpack_require__(1261));

var _wiggle = _interopRequireDefault(__webpack_require__(1262));

var _appearance = _interopRequireDefault(__webpack_require__(579));

var _ascending = _interopRequireDefault(__webpack_require__(307));

var _descending = _interopRequireDefault(__webpack_require__(1263));

var _insideOut = _interopRequireDefault(__webpack_require__(1264));

var _none2 = _interopRequireDefault(__webpack_require__(163));

var _reverse = _interopRequireDefault(__webpack_require__(1265));

/***/ }),
/* 1241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = __webpack_require__(160);

var _constant = _interopRequireDefault(__webpack_require__(107));

var _math = __webpack_require__(161);

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = y32 * x10 - x32 * y10;
  if (t * t < _math.epsilon) return;
  t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
  return [x0 + t * x10, y0 + t * y10];
} // Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html


function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0, _math.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0, _math.sqrt)((0, _math.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00; // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?

  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function _default() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0, _constant.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math.halfPi,
        a1 = endAngle.apply(this, arguments) - _math.halfPi,
        da = (0, _math.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0, _d3Path.path)(); // Ensure that the outer radius is always larger than the inner radius.

    if (r1 < r0) r = r1, r1 = r0, r0 = r; // Is it a point?

    if (!(r1 > _math.epsilon)) context.moveTo(0, 0); // Or is it a circle or annulus?
    else if (da > _math.tau - _math.epsilon) {
        context.moveTo(r1 * (0, _math.cos)(a0), r1 * (0, _math.sin)(a0));
        context.arc(0, 0, r1, a0, a1, !cw);

        if (r0 > _math.epsilon) {
          context.moveTo(r0 * (0, _math.cos)(a1), r0 * (0, _math.sin)(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > _math.epsilon && (padRadius ? +padRadius.apply(this, arguments) : (0, _math.sqrt)(r0 * r0 + r1 * r1)),
              rc = (0, _math.min)((0, _math.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1; // Apply padding? Note that since r1  r0, da1  da0.

          if (rp > _math.epsilon) {
            var p0 = (0, _math.asin)(rp / r0 * (0, _math.sin)(ap)),
                p1 = (0, _math.asin)(rp / r1 * (0, _math.sin)(ap));
            if ((da0 -= p0 * 2) > _math.epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > _math.epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * (0, _math.cos)(a01),
              y01 = r1 * (0, _math.sin)(a01),
              x10 = r0 * (0, _math.cos)(a10),
              y10 = r0 * (0, _math.sin)(a10); // Apply rounded corners?

          if (rc > _math.epsilon) {
            var x11 = r1 * (0, _math.cos)(a11),
                y11 = r1 * (0, _math.sin)(a11),
                x00 = r0 * (0, _math.cos)(a00),
                y00 = r0 * (0, _math.sin)(a00),
                oc; // Restrict the corner radius according to the sector angle.

            if (da < _math.pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / (0, _math.sin)((0, _math.acos)((ax * bx + ay * by) / ((0, _math.sqrt)(ax * ax + ay * ay) * (0, _math.sqrt)(bx * bx + by * by))) / 2),
                  lc = (0, _math.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = (0, _math.min)(rc, (r0 - lc) / (kc - 1));
              rc1 = (0, _math.min)(rc, (r1 - lc) / (kc + 1));
            }
          } // Is the sector collapsed to a line?


          if (!(da1 > _math.epsilon)) context.moveTo(x01, y01); // Does the sectors outer ring have rounded corners?
          else if (rc1 > _math.epsilon) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
                }
            } // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw); // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?

          if (!(r0 > _math.epsilon) || !(da0 > _math.epsilon)) context.lineTo(x10, y10); // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > _math.epsilon) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
                }
            } // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math.pi / 2;
    return [(0, _math.cos)(a) * r, (0, _math.sin)(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
}

/***/ }),
/* 1242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath

  this._ = "";
}

function path() {
  return new Path();
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function moveTo(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function lineTo(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) ; // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Otherwise, draw an arc!
        else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

            if (Math.abs(t01 - 1) > epsilon) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }

            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
  },
  arc: function arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      } // Is this arc empty? Were done.


    if (!r) return; // Does the angle go the wrong way? Flip the direction.

    if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.

    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
  },
  rect: function rect(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function toString() {
    return this._;
  }
};
var _default = path;
exports.default = _default;

/***/ }),
/* 1243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(__webpack_require__(107));

var _descending = _interopRequireDefault(__webpack_require__(1244));

var _identity = _interopRequireDefault(__webpack_require__(1245));

var _math = __webpack_require__(161);

function _default() {
  var value = _identity.default,
      sortValues = _descending.default,
      sort = null,
      startAngle = (0, _constant.default)(0),
      endAngle = (0, _constant.default)(_math.tau),
      padAngle = (0, _constant.default)(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math.tau, Math.max(-_math.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    } // Optionally sort the arcs by previously-computed values or by data.


    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    }); // Compute the arcs! They are stored in the original data's order.

    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : padAngle;
  };

  return pie;
}

/***/ }),
/* 1244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

/***/ }),
/* 1245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(d) {
  return d;
}

/***/ }),
/* 1246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

var _interopRequireWildcard = __webpack_require__(14);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _radial = _interopRequireWildcard(__webpack_require__(566));

var _area = _interopRequireDefault(__webpack_require__(565));

var _lineRadial = __webpack_require__(567);

function _default() {
  var a = (0, _area.default)().curve(_radial.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;
  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return (0, _lineRadial.lineRadial)(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return (0, _lineRadial.lineRadial)(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return (0, _lineRadial.lineRadial)(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return (0, _lineRadial.lineRadial)(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return a;
}

/***/ }),
/* 1247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;

var _d3Path = __webpack_require__(160);

var _array = __webpack_require__(569);

var _constant = _interopRequireDefault(__webpack_require__(107));

var _point = __webpack_require__(305);

var _pointRadial = _interopRequireDefault(__webpack_require__(568));

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = _point.x,
      y = _point.y,
      context = null;

  function link() {
    var buffer,
        argv = _array.slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv);

    if (!context) context = buffer = (0, _d3Path.path)();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function (_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function (_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : x;
  };

  link.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : y;
  };

  link.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = (0, _pointRadial.default)(x0, y0),
      p1 = (0, _pointRadial.default)(x0, y0 = (y0 + y1) / 2),
      p2 = (0, _pointRadial.default)(x1, y0),
      p3 = (0, _pointRadial.default)(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

/***/ }),
/* 1248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.symbols = void 0;

var _d3Path = __webpack_require__(160);

var _circle = _interopRequireDefault(__webpack_require__(570));

var _cross = _interopRequireDefault(__webpack_require__(571));

var _diamond = _interopRequireDefault(__webpack_require__(572));

var _star = _interopRequireDefault(__webpack_require__(573));

var _square = _interopRequireDefault(__webpack_require__(574));

var _triangle = _interopRequireDefault(__webpack_require__(575));

var _wye = _interopRequireDefault(__webpack_require__(576));

var _constant = _interopRequireDefault(__webpack_require__(107));

var symbols = [_circle.default, _cross.default, _diamond.default, _square.default, _star.default, _triangle.default, _wye.default];
exports.symbols = symbols;

function _default() {
  var type = (0, _constant.default)(_circle.default),
      size = (0, _constant.default)(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0, _d3Path.path)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0, _constant.default)(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0, _constant.default)(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}

/***/ }),
/* 1249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(__webpack_require__(199));

var _basis = __webpack_require__(200);

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);

          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x, this._y2 = y;
        break;

      case 1:
        this._point = 2;
        this._x3 = x, this._y3 = y;
        break;

      case 2:
        this._point = 3;
        this._x4 = x, this._y4 = y;

        this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);

        break;

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisClosed(context);
}

/***/ }),
/* 1250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = __webpack_require__(200);

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisOpen(context);
}

/***/ }),
/* 1251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _basis = __webpack_require__(200);

function Bundle(context, beta) {
  this._basis = new _basis.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];

    this._basis.lineStart();
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;

        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;

    this._basis.lineEnd();
  },
  point: function point(x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
};

var _default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new _basis.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
}(0.85);

exports.default = _default;

/***/ }),
/* 1252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalClosed = __webpack_require__(577);

var _noop = _interopRequireDefault(__webpack_require__(199));

var _catmullRom = __webpack_require__(306);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

/***/ }),
/* 1253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalOpen = __webpack_require__(578);

var _catmullRom = __webpack_require__(306);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;

/***/ }),
/* 1254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(__webpack_require__(199));

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function lineStart() {
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (this._point) this._context.closePath();
  },
  point: function point(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

function _default(context) {
  return new LinearClosed(context);
}

/***/ }),
/* 1255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.monotoneX = monotoneX;
exports.monotoneY = monotoneY;

function sign(x) {
  return x < 0 ? -1 : 1;
} // Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.


function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
} // Calculate a one-sided slope.


function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
} // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


function _point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;

  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;

      case 3:
        _point(this, this._t0, slope2(this, this._t0));

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function point(x, y) {
    var t1 = NaN;
    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        _point(this, slope2(this, t1 = slope3(this, x, y)), t1);

        break;

      default:
        _point(this, this._t0, t1 = slope3(this, x, y));

        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function moveTo(x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function closePath() {
    this._context.closePath();
  },
  lineTo: function lineTo(x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

/***/ }),
/* 1256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function lineEnd() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);

      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);

        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function point(x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
}; // See https://www.particleincell.com/2012/bezier-splines/ for derivation.

function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];

  for (i = 1; i < n - 1; ++i) {
    a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  }

  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];

  for (i = 1; i < n; ++i) {
    m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  }

  a[n - 1] = r[n - 1] / b[n - 1];

  for (i = n - 2; i >= 0; --i) {
    a[i] = (r[i] - a[i + 1]) / b[i];
  }

  b[n - 1] = (x[n] + a[n - 1]) / 2;

  for (i = 0; i < n - 1; ++i) {
    b[i] = 2 * x[i + 1] - a[i + 1];
  }

  return [a, b];
}

function _default(context) {
  return new Natural(context);
}

/***/ }),
/* 1257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.stepBefore = stepBefore;
exports.stepAfter = stepAfter;

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function areaStart() {
    this._line = 0;
  },
  areaEnd: function areaEnd() {
    this._line = NaN;
  },
  lineStart: function lineStart() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function lineEnd() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function point(x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);

            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;

            this._context.lineTo(x1, this._y);

            this._context.lineTo(x1, y);
          }

          break;
        }
    }

    this._x = x, this._y = y;
  }
};

function _default(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

/***/ }),
/* 1258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = __webpack_require__(569);

var _constant = _interopRequireDefault(__webpack_require__(107));

var _none = _interopRequireDefault(__webpack_require__(162));

var _none2 = _interopRequireDefault(__webpack_require__(163));

function stackValue(d, key) {
  return d[key];
}

function _default() {
  var keys = (0, _constant.default)([]),
      order = _none2.default,
      offset = _none.default,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }

      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? _none2.default : typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? _none.default : _, stack) : offset;
  };

  return stack;
}

/***/ }),
/* 1259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(__webpack_require__(162));

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }

    if (y) for (i = 0; i < n; ++i) {
      series[i][j][1] /= y;
    }
  }

  (0, _none.default)(series, order);
}

/***/ }),
/* 1260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}

/***/ }),
/* 1261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(__webpack_require__(162));

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) {
      y += series[i][j][1] || 0;
    }

    s0[j][1] += s0[j][0] = -y / 2;
  }

  (0, _none.default)(series, order);
}

/***/ }),
/* 1262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(__webpack_require__(162));

function _default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;

  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;

      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }

      s1 += sij0, s2 += s3 * sij0;
    }

    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }

  s0[j - 1][1] += s0[j - 1][0] = y;
  (0, _none.default)(series, order);
}

/***/ }),
/* 1263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(__webpack_require__(307));

function _default(series) {
  return (0, _ascending.default)(series).reverse();
}

/***/ }),
/* 1264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _appearance = _interopRequireDefault(__webpack_require__(579));

var _ascending = __webpack_require__(307);

function _default(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending.sum),
      order = (0, _appearance.default)(series),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];

    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}

/***/ }),
/* 1265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(2);

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(__webpack_require__(163));

function _default(series) {
  return (0, _none.default)(series).reverse();
}

/***/ }),
/* 1266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COLOR_FIELD = exports.Y_FIELD = exports.X_FIELD = void 0;
var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var Y_FIELD = 'y';
exports.Y_FIELD = Y_FIELD;
var COLOR_FIELD = 'name';
exports.COLOR_FIELD = COLOR_FIELD;

/***/ }),
/* 1267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cutoffCircle = cutoffCircle;

var _util = __webpack_require__(0);

/**
 *  source  target  source 
 * @param circleCache
 * @param source
 * @param target
 */
function hasCircle(circleCache, source, target) {
  // 
  if ((0, _util.size)(source) === 0) return false; // target 

  if (source.includes(target)) return true; // 

  return source.some(function (s) {
    return hasCircle(circleCache, circleCache.get(s), target);
  });
}
/**
 * 
 * @param data
 * @param sourceField
 * @param targetField
 */


function cutoffCircle(data, sourceField, targetField) {
  var dataWithoutCircle = [];
  var removedData = [];
  /**   ->   */

  var circleCache = new Map();
  (0, _util.each)(data, function (d) {
    var source = d[sourceField];
    var target = d[targetField]; // 

    if (!hasCircle(circleCache, [source], target)) {
      // 
      dataWithoutCircle.push(d); // 

      if (!circleCache.has(target)) {
        circleCache.set(target, []);
      }

      circleCache.get(target).push(source);
    } else {
      //  log
      removedData.push(d);
    }
  });

  if (removedData.length !== 0) {
    console.warn("sankey data contains circle, " + removedData.length + " records removed.", removedData);
  }

  return dataWithoutCircle;
}

/***/ }),
/* 1268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chord = void 0;

var _tslib = __webpack_require__(1);

var _plot = __webpack_require__(21);

var _adaptor = __webpack_require__(1269);

/**
 *   Chord
 */
var Chord =
/** @class */
function (_super) {
  (0, _tslib.__extends)(Chord, _super);

  function Chord() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    /**  */


    _this.type = 'chord';
    return _this;
  }

  Chord.prototype.getDefaultOptions = function () {
    return {
      nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1
      },
      edgeStyle: {
        opacity: 0.5,
        lineWidth: 2
      },
      label: {
        fields: ['x', 'name'],
        callback: function callback(x, name) {
          var centerX = (x[0] + x[1]) / 2;
          var offsetX = centerX > 0.5 ? -4 : 4;
          return {
            labelEmit: true,
            style: {
              fill: '#8c8c8c'
            },
            offsetX: offsetX,
            content: name
          };
        }
      },
      tooltip: {
        fields: ['source', 'target', 'value'],
        formatter: function formatter(datum) {
          var source = datum.source,
              target = datum.target,
              value = datum.value;
          return {
            name: source + " -> " + target,
            value: value
          };
        }
      },
      interactions: [{
        type: 'element-active'
      }],
      weight: true,
      nodePaddingRatio: 0.1,
      nodeWidthRatio: 0.05
    };
  };
  /**
   * 
   */


  Chord.prototype.getSchemaAdaptor = function () {
    return _adaptor.adaptor;
  };

  return Chord;
}(_plot.Plot);

exports.Chord = Chord;

/***/ }),
/* 1269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _geometries = __webpack_require__(32);

var _chord = __webpack_require__(1270);

var _data = __webpack_require__(106);

var _constant = __webpack_require__(1271);

function transformData(params) {
  // extnodeGeometry edgeGeometry
  var options = params.options;
  var data = options.data,
      sourceField = options.sourceField,
      targetField = options.targetField,
      weightField = options.weightField,
      nodePaddingRatio = options.nodePaddingRatio,
      nodeWidthRatio = options.nodeWidthRatio; // node link

  var chordLayoutInputData = (0, _data.transformDataToNodeLinkData)(data, sourceField, targetField, weightField);

  var _a = (0, _chord.chordLayout)({
    weight: true,
    nodePaddingRatio: nodePaddingRatio,
    nodeWidthRatio: nodeWidthRatio
  }, chordLayoutInputData),
      nodes = _a.nodes,
      links = _a.links; // 1. node


  var nodesData = nodes.map(function (node) {
    return {
      id: node.id,
      x: node.x,
      y: node.y,
      name: node.name
    };
  }); // 2. edge
  // TODO: 

  var edgesData = links.map(function (link) {
    return {
      source: link.source.name,
      target: link.target.name,
      x: link.x,
      y: link.y,
      value: link.value
    };
  });
  return (0, _tslib.__assign)((0, _tslib.__assign)({}, params), {
    ext: (0, _tslib.__assign)((0, _tslib.__assign)({}, params.ext), {
      // chordDataextgeometry
      chordData: {
        nodesData: nodesData,
        edgesData: edgesData
      }
    })
  });
}
/**
 * scale
 * @param params 
 */


function scale(params) {
  var _a;

  var chart = params.chart;
  chart.scale((_a = {
    x: {
      sync: true,
      nice: true
    },
    y: {
      sync: true,
      nice: true,
      max: 1
    }
  }, _a[_constant.NODE_COLOR_FIELD] = {
    sync: 'color'
  }, _a[_constant.EDGE_COLOR_FIELD] = {
    sync: 'color'
  }, _a));
  return params;
}
/**
 * axis
 * @param params 
 */


function axis(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
/**
 * legend
 * @param params 
 */


function legend(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
/**
 * tooltip
 * @param params 
 */


function tooltip(params) {
  var chart = params.chart;
  chart.tooltip({
    showTitle: false,
    showMarkers: false
  });
  return params;
}
/**
 * coordinate
 * @param params 
 */


function coordinate(params) {
  var chart = params.chart;
  chart.coordinate('polar').reflect('y');
  return params;
}
/**
 * nodeGeometry
 * @param params 
 */


function nodeGeometry(params) {
  // node view
  var chart = params.chart,
      options = params.options;
  var nodesData = params.ext.chordData.nodesData;
  var nodeStyle = options.nodeStyle,
      label = options.label;
  var nodeView = chart.createView();
  nodeView.data(nodesData); // 

  (0, _geometries.polygon)({
    chart: nodeView,
    options: {
      xField: _constant.X_FIELD,
      yField: _constant.Y_FIELD,
      seriesField: _constant.NODE_COLOR_FIELD,
      polygon: {
        style: nodeStyle
      },
      label: label,
      tooltip: false
    }
  });
  return params;
}
/**
 * edgeGeometry
 * @param params 
 */


function edgeGeometry(params) {
  var chart = params.chart,
      options = params.options;
  var edgesData = params.ext.chordData.edgesData;
  var edgeStyle = options.edgeStyle,
      tooltip = options.tooltip;
  var edgeView = chart.createView();
  edgeView.data(edgesData); // edge

  var edgeOptions = {
    xField: _constant.X_FIELD,
    yField: _constant.Y_FIELD,
    seriesField: _constant.EDGE_COLOR_FIELD,
    edge: {
      style: edgeStyle,
      shape: 'arc'
    },
    tooltip: tooltip
  };
  (0, _geometries.edge)({
    chart: edgeView,
    options: edgeOptions
  });
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return (0, _utils.flow)(transformData, coordinate, scale, axis, legend, tooltip, edgeGeometry, nodeGeometry, _common.interaction, _common.animation, _common.theme)(params);
}

/***/ }),
/* 1270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultOptions = getDefaultOptions;
exports.chordLayout = chordLayout;

var _util = __webpack_require__(0);

/*
 * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)
 * graph data required (nodes, edges)
 */
var DEFAULT_OPTIONS = {
  y: 0,
  nodeWidthRatio: 0.05,
  weight: false,
  nodePaddingRatio: 0.1,
  id: function id(node) {
    return node.id;
  },
  source: function source(edge) {
    return edge.source;
  },
  target: function target(edge) {
    return edge.target;
  },
  sourceWeight: function sourceWeight(edge) {
    return edge.value || 1;
  },
  targetWeight: function targetWeight(edge) {
    return edge.value || 1;
  },
  sortBy: null
};
/**
 * valueedges
 * @param nodeById
 * @param edges
 * @param options
 */

function processGraph(nodeById, edges, options) {
  (0, _util.forIn)(nodeById, function (node, id) {
    // in edges, out edges
    node.inEdges = edges.filter(function (edge) {
      return "" + options.target(edge) === "" + id;
    });
    node.outEdges = edges.filter(function (edge) {
      return "" + options.source(edge) === "" + id;
    }); // frequency

    node.edges = node.outEdges.concat(node.inEdges);
    node.frequency = node.edges.length; // weight

    node.value = 0;
    node.inEdges.forEach(function (edge) {
      node.value += options.targetWeight(edge);
    });
    node.outEdges.forEach(function (edge) {
      node.value += options.sourceWeight(edge);
    });
  });
}
/**
 * 
 * @param nodes
 * @param options
 */


function sortNodes(nodes, options) {
  var sortMethods = {
    weight: function weight(a, b) {
      return b.value - a.value;
    },
    frequency: function frequency(a, b) {
      return b.frequency - a.frequency;
    },
    id: function id(a, b) {
      return ("" + options.id(a)).localeCompare("" + options.id(b));
    }
  };
  var method = sortMethods[options.sortBy];

  if (!method && (0, _util.isFunction)(options.sortBy)) {
    method = options.sortBy;
  }

  if (method) {
    nodes.sort(method);
  }
}

function layoutNodes(nodes, options) {
  var len = nodes.length;

  if (!len) {
    throw new TypeError("Invalid nodes: it's empty!");
  }

  if (options.weight) {
    var nodePaddingRatio_1 = options.nodePaddingRatio;

    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
      throw new TypeError('Invalid nodePaddingRatio: it must be in range [0, 1)!');
    }

    var margin_1 = nodePaddingRatio_1 / (2 * len);
    var nodeWidthRatio_1 = options.nodeWidthRatio;

    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
      throw new TypeError('Invalid nodeWidthRatio: it must be in range (0, 1)!');
    }

    var totalValue_1 = 0;
    nodes.forEach(function (node) {
      totalValue_1 += node.value;
    });
    nodes.forEach(function (node) {
      node.weight = node.value / totalValue_1;
      node.width = node.weight * (1 - nodePaddingRatio_1);
      node.height = nodeWidthRatio_1;
    });
    nodes.forEach(function (node, index) {
      // x
      var deltaX = 0;

      for (var i = index - 1; i >= 0; i--) {
        deltaX += nodes[i].width + 2 * margin_1;
      }

      var minX = node.minX = margin_1 + deltaX;
      var maxX = node.maxX = node.minX + node.width;
      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
      var maxY = node.maxY = minY + nodeWidthRatio_1;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY, maxY];
      /* points
       * 3---2
       * |   |
       * 0---1
       */
      // node.x = minX + 0.5 * node.width;
      // node.y = options.y;
    });
  } else {
    var deltaX_1 = 1 / len;
    nodes.forEach(function (node, index) {
      node.x = (index + 0.5) * deltaX_1;
      node.y = options.y;
    });
  }

  return nodes;
}

function locatingEdges(nodeById, edges, options) {
  if (options.weight) {
    var valueById_1 = {};
    (0, _util.forIn)(nodeById, function (node, id) {
      valueById_1[id] = node.value;
    });
    edges.forEach(function (edge) {
      var sId = options.source(edge);
      var tId = options.target(edge);
      var sNode = nodeById[sId];
      var tNode = nodeById[tId];

      if (sNode && tNode) {
        var sValue = valueById_1[sId];
        var currentSValue = options.sourceWeight(edge);
        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
        var sEnd = sStart + currentSValue / sNode.value * sNode.width;
        valueById_1[sId] -= currentSValue;
        var tValue = valueById_1[tId];
        var currentTValue = options.targetWeight(edge);
        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
        var tEnd = tStart + currentTValue / tNode.value * tNode.width;
        valueById_1[tId] -= currentTValue;
        var y = options.y;
        edge.x = [sStart, sEnd, tStart, tEnd];
        edge.y = [y, y, y, y]; // edgesourcetargetid sourceNodetargetNode

        edge.source = sNode;
        edge.target = tNode;
      }
    });
  } else {
    edges.forEach(function (edge) {
      var sNode = nodeById[options.source(edge)];
      var tNode = nodeById[options.target(edge)];

      if (sNode && tNode) {
        edge.x = [sNode.x, tNode.x];
        edge.y = [sNode.y, tNode.y]; // edgesourcetargetid sourceNodetargetNode

        edge.source = sNode;
        edge.target = tNode;
      }
    });
  }

  return edges;
}

function getDefaultOptions(options) {
  return (0, _util.assign)({}, DEFAULT_OPTIONS, options);
}

function chordLayout(chordLayoutOptions, chordLayoutInputData) {
  var options = getDefaultOptions(chordLayoutOptions);
  var nodeById = {};
  var nodes = chordLayoutInputData.nodes;
  var links = chordLayoutInputData.links;
  nodes.forEach(function (node) {
    var id = options.id(node);
    nodeById[id] = node;
  });
  processGraph(nodeById, links, options);
  sortNodes(nodes, options);
  var outputNodes = layoutNodes(nodes, options);
  var outputLinks = locatingEdges(nodeById, links, options);
  return {
    nodes: outputNodes,
    links: outputLinks
  };
}

/***/ }),
/* 1271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EDGE_COLOR_FIELD = exports.NODE_COLOR_FIELD = exports.Y_FIELD = exports.X_FIELD = void 0;
var X_FIELD = 'x';
exports.X_FIELD = X_FIELD;
var Y_FIELD = 'y';
exports.Y_FIELD = Y_FIELD;
var NODE_COLOR_FIELD = 'name';
exports.NODE_COLOR_FIELD = NODE_COLOR_FIELD;
var EDGE_COLOR_FIELD = 'source';
exports.EDGE_COLOR_FIELD = EDGE_COLOR_FIELD;

/***/ }),
/* 1272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.P = void 0;

var _tslib = __webpack_require__(1);

var _utils = __webpack_require__(12);

var _plot = __webpack_require__(21);

/**
 *  G2Plot  G2Plot 
 * 1. 
 * 2. 
 * 3. 
 * 
 *
 * 
 *
 * ```ts
 * import { P } from '@antv/g2plot';
 * import { GeoWorldMap, GeoWorldMapOptions } from 'g2plot-geo-world-map';
 *
 * const plot = new P('container', {
 *   geoJson: '',
 *   longitude: '',
 *   latitude: '',
 * }, GeoWorldMap, defaultOptions);
 *
 * plot.render();
 * ```
 */
var P =
/** @class */
function (_super) {
  (0, _tslib.__extends)(P, _super);
  /**
   *  adaptor 
   * @param container
   * @param options
   * @param adaptor
   * @param defaultOptions
   */

  function P(container, options, adaptor, defaultOptions) {
    var _this = _super.call(this, container, (0, _utils.deepAssign)({}, defaultOptions, options)) || this;
    /**  any plot */


    _this.type = 'g2-plot';
    _this.defaultOptions = defaultOptions;
    _this.adaptor = adaptor;
    return _this;
  }
  /**
   * 
   */


  P.prototype.getDefaultOptions = function () {
    return this.defaultOptions;
  };
  /**
   * 
   */


  P.prototype.getSchemaAdaptor = function () {
    return this.adaptor;
  };

  return P;
}(_plot.Plot);

exports.P = P;

/***/ }),
/* 1273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = adaptor;

var _tslib = __webpack_require__(1);

var _util = __webpack_require__(0);

var _base = __webpack_require__(78);

var _common = __webpack_require__(25);

var _utils = __webpack_require__(12);

var _constant = __webpack_require__(121);

/**
 * geometry 
 * @param params
 */
function multiView(params) {
  var chart = params.chart,
      options = params.options;
  var views = options.views,
      legend = options.legend,
      tooltip = options.tooltip;
  (0, _util.each)(views, function (v) {
    var region = v.region,
        data = v.data,
        meta = v.meta,
        axes = v.axes,
        coordinate = v.coordinate,
        interactions = v.interactions,
        annotations = v.annotations,
        geometries = v.geometries; // 1.  view

    var viewOfG2 = chart.createView({
      region: region
    }); // 2. data

    viewOfG2.data(data); // 3. meta

    var scales = {};

    if (axes) {
      (0, _util.each)(axes, function (axis, field) {
        scales[field] = (0, _utils.pick)(axis, _constant.AXIS_META_CONFIG_KEYS);
      });
    }

    scales = (0, _utils.deepAssign)({}, meta, scales);
    viewOfG2.scale(scales); // 4. x y axis

    if (!axes) {
      viewOfG2.axis(false);
    } else {
      (0, _util.each)(axes, function (axis, field) {
        viewOfG2.axis(field, axis);
      });
    } // 5. coordinate


    viewOfG2.coordinate(coordinate); // 6. geometry

    (0, _util.each)(geometries, function (geometry) {
      var ext = (0, _base.geometry)({
        chart: viewOfG2,
        options: geometry
      }).ext; // adjust

      var adjust = geometry.adjust;

      if (adjust) {
        ext.geometry.adjust(adjust);
      }
    }); // 7. interactions

    (0, _util.each)(interactions, function (interaction) {
      if (interaction.enable === false) {
        viewOfG2.removeInteraction(interaction.type);
      } else {
        viewOfG2.interaction(interaction.type, interaction.cfg);
      }
    }); // 8. annotations

    (0, _util.each)(annotations, function (annotation) {
      viewOfG2.annotation()[annotation.type]((0, _tslib.__assign)({}, annotation));
    });
  }); // legend

  if (!legend) {
    chart.legend(false);
  } else {
    (0, _util.each)(legend, function (l, field) {
      chart.legend(field, l);
    });
  } // tooltip


  chart.tooltip(tooltip);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  return (0, _utils.flow)(_common.animation, //  view 
  multiView, _common.interaction, _common.animation, _common.theme, _common.tooltip // ...  adaptor flow
  )(params);
}

/***/ }),
/* 1274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.notice = notice;
exports.Lab = exports.Stage = void 0;

var _multiView = __webpack_require__(580);

/**  */
var Stage;
exports.Stage = Stage;

(function (Stage) {
  Stage["DEV"] = "DEV";
  Stage["BETA"] = "BETA";
  Stage["STABLE"] = "STABLE";
})(Stage || (exports.Stage = Stage = {}));
/**
 * 
 * @param stage
 */


function notice(stage, plotType) {
  console.warn(stage === Stage.DEV ? "Plot '" + plotType + "' is in DEV stage, just give us issues." : stage === Stage.BETA ? "Plot '" + plotType + "' is in BETA stage, DO NOT use it in production env." : stage === Stage.STABLE ? "Plot '" + plotType + "' is in STABLE stage, import it by \"import { " + plotType + " } from '@antv/g2plot'\"." : 'invalid Stage type.');
}
/**
 * 
 */


var Lab =
/** @class */
function () {
  function Lab() {}

  Object.defineProperty(Lab, "MultiView", {
    get: function get() {
      notice(Stage.STABLE, 'MultiView');
      return _multiView.MultiView;
    },
    enumerable: false,
    configurable: true
  });
  return Lab;
}();

exports.Lab = Lab;

/***/ }),
/* 1275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.adaptor = exports.statistic = void 0;

var tslib_1 = __webpack_require__(1);

var util_1 = __webpack_require__(0);

var common_1 = __webpack_require__(34);

var constant_1 = __webpack_require__(290);

var utils_1 = __webpack_require__(16);

var constant_2 = __webpack_require__(194);

var utils_2 = __webpack_require__(581);
/**
 * geometry 
 * @param params
 */


function geometry(params) {
  var chart = params.chart,
      options = params.options;
  var percent = options.percent,
      range = options.range,
      radius = options.radius,
      innerRadius = options.innerRadius,
      startAngle = options.startAngle,
      endAngle = options.endAngle,
      axis = options.axis,
      indicator = options.indicator;
  var color = range.color; //  & 
  // 

  if (indicator) {
    var indicatorData = utils_2.getIndicatorData(percent);
    var v1 = chart.createView({
      id: constant_2.INDICATEOR_VIEW_ID
    });
    v1.data(indicatorData);
    v1.point().position(constant_2.PERCENT + "*1").shape('gauge-indicator') //  shape 
    .customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator: indicator
    });
    v1.coordinate('polar', {
      startAngle: startAngle,
      endAngle: endAngle,
      radius: innerRadius * radius
    });
    v1.axis(constant_2.PERCENT, axis); //  scale 

    v1.scale(constant_2.PERCENT, utils_1.pick(axis, constant_1.AXIS_META_CONFIG_KEYS));
  } //  range
  // [{ range: 1, type: '0' }]


  var rangeData = utils_2.getRangeData(percent, options.range);
  var v2 = chart.createView({
    id: constant_2.RANGE_VIEW_ID
  });
  v2.data(rangeData);
  var rangeColor = util_1.isString(color) ? [color, constant_2.DEFAULT_COLOR] : color;
  v2.interval().position("1*" + constant_2.RANGE_VALUE).color(constant_2.RANGE_TYPE, rangeColor).adjust('stack');
  v2.coordinate('polar', {
    innerRadius: innerRadius,
    radius: radius,
    startAngle: startAngle,
    endAngle: endAngle
  }).transpose();
  return params;
}
/**
 * meter   mask
 * @param params
 */


function meterView(params) {
  var _a;

  var chart = params.chart,
      options = params.options;
  var type = options.type,
      meter = options.meter;

  if (type === 'meter') {
    var innerRadius = options.innerRadius,
        radius = options.radius,
        startAngle = options.startAngle,
        endAngle = options.endAngle;
    var background = chart.getTheme().background;
    var color = background;

    if (!color || color === 'transparent') {
      color = '#fff';
    }

    var v3 = chart.createView({
      id: constant_2.MASK_VIEW_ID
    });
    v3.data([(_a = {}, _a[constant_2.RANGE_TYPE] = '1', _a[constant_2.RANGE_VALUE] = 1, _a)]);
    v3.interval().position("1*" + constant_2.RANGE_VALUE).color(color).adjust('stack').shape('meter-gauge').customInfo(meter || {});
    v3.coordinate('polar', {
      innerRadius: innerRadius,
      radius: radius,
      startAngle: startAngle,
      endAngle: endAngle
    }).transpose();
  }

  return params;
}
/**
 * meta 
 * @param params
 */


function meta(params) {
  var _a;

  return utils_1.flow(common_1.scale((_a = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a[constant_2.PERCENT] = {}, _a)))(params);
}
/**
 * 
 * @param params
 */


function statistic(params, updated) {
  var chart = params.chart,
      options = params.options;
  var statistic = options.statistic,
      percent = options.percent; // 

  chart.getController('annotation').clear(true);

  if (statistic) {
    var content = statistic.content;
    var transformContent = void 0; //  content 

    if (content) {
      transformContent = utils_1.deepAssign({}, {
        formatter: function formatter(_a) {
          var percent = _a.percent;
          return (percent * 100).toFixed(2) + "%";
        },
        style: {
          opacity: 0.75,
          fontSize: '30px',
          lineHeight: 1,
          textAlign: 'center',
          color: 'rgba(44,53,66,0.85)'
        }
      }, content);
    }

    utils_1.renderGaugeStatistic(chart, {
      statistic: tslib_1.__assign(tslib_1.__assign({}, statistic), {
        content: transformContent
      })
    }, {
      percent: percent
    });
  }

  if (updated) {
    chart.render(true);
  }

  return params;
}

exports.statistic = statistic;
/**
 * other 
 * @param params
 */

function other(params) {
  var chart = params.chart;
  chart.legend(false);
  chart.tooltip(false);
  return params;
}
/**
 * 
 * @param chart
 * @param options
 */


function adaptor(params) {
  // flow  G2 API
  return utils_1.flow( // animation  createView  View 
  common_1.animation, geometry, meta, statistic, common_1.interaction, common_1.theme, // meterView 
  meterView, other // ...  adaptor flow
  )(params);
}

exports.adaptor = adaptor;

/***/ }),
/* 1276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var tslib_1 = __webpack_require__(1);

var g2_1 = __webpack_require__(17); // Shape 


g2_1.registerShape('point', 'gauge-indicator', {
  draw: function draw(cfg, container) {
    //  customInfo 
    var _a = cfg.customInfo,
        indicator = _a.indicator,
        defaultColor = _a.defaultColor;
    var _b = indicator,
        pointer = _b.pointer,
        pin = _b.pin;
    var group = container.addGroup(); // 

    var center = this.parsePoint({
      x: 0,
      y: 0
    }); // 

    if (pointer) {
      // pointer
      group.addShape('line', {
        name: 'pointer',
        attrs: tslib_1.__assign({
          x1: center.x,
          y1: center.y,
          x2: cfg.x,
          y2: cfg.y,
          stroke: defaultColor
        }, pointer.style)
      });
    } // pin


    if (pin) {
      group.addShape('circle', {
        name: 'pin',
        attrs: tslib_1.__assign({
          x: center.x,
          y: center.y,
          stroke: defaultColor
        }, pin.style)
      });
    }

    return group;
  }
});

/***/ }),
/* 1277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var g2_1 = __webpack_require__(17);

var graphics_1 = __webpack_require__(45); // Shape 


g2_1.registerShape('interval', 'meter-gauge', {
  draw: function draw(cfg, container) {
    //  customInfo 
    var _a = cfg.customInfo,
        _b = _a.steps,
        STEP = _b === void 0 ? 50 : _b,
        _c = _a.stepRatio,
        stepRatio = _c === void 0 ? 0.5 : _c;
    var total = this.coordinate.endAngle - this.coordinate.startAngle;
    var interval = total / STEP;
    var gap = 0;
    /**
     * stepRatio : (0, 1]
     * 1: interval : gap = stepRatio : (1 - stepRatio)
     * 2: interval * STEP + stepRatio * (STEP - 1) = total
     */

    if (stepRatio > 0 && stepRatio <= 1) {
      interval = total / ((1 - stepRatio) / stepRatio * (STEP - 1) + STEP);
      gap = interval * (1 - stepRatio) / stepRatio;
    }

    var group = container.addGroup(); //  gap

    if (gap > 0) {
      var center = this.coordinate.getCenter();
      var radius = this.coordinate.getRadius();

      var _d = g2_1.Util.getAngle(cfg, this.coordinate),
          startAngle = _d.startAngle,
          endAngle = _d.endAngle;

      for (var i = startAngle, j = 0; i < endAngle && j < 2 * STEP - 1; j++) {
        var drawn = j % 2;

        if (drawn) {
          var path = graphics_1.getSectorPath(center.x, center.y, radius, i, Math.min(i + gap, endAngle), radius * this.coordinate.innerRadius);
          group.addShape('path', {
            name: 'meter-gauge-mask',
            attrs: {
              path: path,
              fill: cfg.color,
              stroke: cfg.color,
              lineWidth: 0.5
            },
            // mask 
            capture: false
          });
        }

        i += drawn ? gap : interval;
      }
    }

    return group;
  }
});

/***/ }),
/* 1278 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/classCallCheck.js
var classCallCheck = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/createClass.js
var createClass = __webpack_require__(23);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/get.js
var get = __webpack_require__(219);
var get_default = /*#__PURE__*/__webpack_require__.n(get);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/inherits.js
var inherits = __webpack_require__(8);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/possibleConstructorReturn.js
var possibleConstructorReturn = __webpack_require__(9);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn);

// EXTERNAL MODULE: ./node_modules/_@babel_runtime@7.12.5@@babel/runtime/helpers/getPrototypeOf.js
var getPrototypeOf = __webpack_require__(4);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf);

// EXTERNAL MODULE: ./node_modules/_@antv_scale@0.3.7@@antv/scale/esm/index.js
var esm = __webpack_require__(108);

// CONCATENATED MODULE: ./src/extend/scale/linear-tick.ts
// nice
var SNAP_COUNT_ARRAY = [1, 1.2, 1.5, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];
var DEFAULT_COUNT = 5; // 

/* harmony default export */ var linear_tick = (function (cfg) {
  var _ref = cfg || {},
      tickCount = _ref.tickCount,
      tickInterval = _ref.tickInterval;

  var _ref2 = cfg || {},
      min = _ref2.min,
      max = _ref2.max;

  min = isNaN(min) ? 0 : min;
  max = isNaN(max) ? 0 : max;
  var count = tickCount && tickCount >= 2 ? tickCount : DEFAULT_COUNT; // interval tickInterval

  var interval = tickInterval || getBestInterval({
    tickCount: count,
    max: max,
    min: min
  }); // intervaltick

  var minTick = Math.floor(min / interval) * interval; // tickInterval, count tickInterval

  if (tickInterval) {
    var intervalCount = Math.abs(Math.ceil((max - minTick) / tickInterval)) + 1; // tickCount  count 

    count = Math.max(count, intervalCount);
  }

  var ticks = [];
  var tickLength = 0;
  var fixedLength = getFixedLength(interval);

  while (tickLength < count) {
    ticks.push(toFixed(minTick + tickLength * interval, fixedLength));
    tickLength++;
  }

  return ticks;
});
var DECIMAL_LENGTH = 12;

function getFactor(number) {
  // 
  number = Math.abs(number);
  var factor = 1;

  if (number === 0) {
    return factor;
  } // 1,


  if (number < 1) {
    var count = 0;

    while (number < 1) {
      factor = factor / 10;
      number = number * 10;
      count++;
    } // 


    if (factor.toString().length > DECIMAL_LENGTH) {
      factor = parseFloat(factor.toFixed(count));
    }

    return factor;
  } // 10


  while (number > 10) {
    factor = factor * 10;
    number = number / 10;
  }

  return factor;
} // 


function getBestInterval(_ref3) {
  var tickCount = _ref3.tickCount,
      min = _ref3.min,
      max = _ref3.max;

  // 1
  if (min === max) {
    return 1 * getFactor(max);
  } // 1.


  var avgInterval = (max - min) / (tickCount - 1); // 2. [1-10]

  var factor = getFactor(avgInterval);
  var calInterval = avgInterval / factor;
  var calMax = max / factor;
  var calMin = min / factor; // 

  var similarityIndex = 0;

  for (var index = 0; index < SNAP_COUNT_ARRAY.length; index++) {
    var item = SNAP_COUNT_ARRAY[index];

    if (calInterval <= item) {
      similarityIndex = index;
      break;
    }
  }

  var similarityInterval = getInterval(similarityIndex, tickCount, calMin, calMax); // , similarityIndexsimilarityIndex

  var fixedLength = getFixedLength(similarityInterval) + getFixedLength(factor);
  return toFixed(similarityInterval * factor, fixedLength);
}

function getInterval(startIndex, tickCount, min, max) {
  var verify = false;
  var interval = SNAP_COUNT_ARRAY[startIndex]; // 

  for (var i = startIndex; i < SNAP_COUNT_ARRAY.length; i++) {
    if (intervalIsVerify({
      interval: SNAP_COUNT_ARRAY[i],
      tickCount: tickCount,
      max: max,
      min: min
    })) {
      // interval
      interval = SNAP_COUNT_ARRAY[i];
      verify = true;
      break;
    }
  } // , 10


  if (!verify) {
    return 10 * getInterval(0, tickCount, min / 10, max / 10);
  }

  return interval;
} // 


function intervalIsVerify(_ref4) {
  var interval = _ref4.interval,
      tickCount = _ref4.tickCount,
      max = _ref4.max,
      min = _ref4.min;
  var minTick = Math.floor(min / interval) * interval;

  if (minTick + (tickCount - 1) * interval >= max) {
    return true;
  }

  return false;
} // 


function getFixedLength(num) {
  var str = num.toString();
  var index = str.indexOf('.');
  var indexOfExp = str.indexOf('e-');
  var length = indexOfExp >= 0 ? parseInt(str.substr(indexOfExp + 2), 10) : str.substr(index + 1).length;

  if (length > 20) {
    // 20
    length = 20;
  }

  return length;
} // @antv/util fixedbasemr


function toFixed(v, length) {
  return parseFloat(v.toFixed(length));
}
// CONCATENATED MODULE: ./src/extend/scale/scale.ts







function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }



Object(esm["registerTickMethod"])('linear-strict-tick-method', linear_tick);
/**
 * 
 * @class
 */

var scale_LinearStrict = /*#__PURE__*/function (_Linear) {
  inherits_default()(LinearStrict, _Linear);

  var _super = _createSuper(LinearStrict);

  function LinearStrict(props) {
    var _this;

    classCallCheck_default()(this, LinearStrict);

    _this = _super.call(this, props);
    _this.type = 'linear-strict';
    return _this;
  }

  createClass_default()(LinearStrict, [{
    key: "initCfg",
    value: function initCfg() {
      get_default()(getPrototypeOf_default()(LinearStrict.prototype), "initCfg", this).call(this);

      this.tickMethod = 'linear-strict-tick-method';
    }
  }, {
    key: "calculateTicks",
    value: function calculateTicks() {
      var preNice = this.nice; // ticksnicetrue

      this.nice = true;

      var ticks = get_default()(getPrototypeOf_default()(LinearStrict.prototype), "calculateTicks", this).call(this);

      this.nice = preNice; // ticks

      if (ticks.length) {
        this.min = ticks[0];
        this.max = ticks[ticks.length - 1];
      }

      return ticks;
    }
  }]);

  return LinearStrict;
}(esm["Linear"]);

/* harmony default export */ var scale = (scale_LinearStrict);
Object(esm["registerScale"])('linear-strict', scale_LinearStrict);

/***/ })
/******/ ]);
});

/***/ })

}]);